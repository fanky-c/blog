<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <!--  禁止百度引擎抓取 -->
    <meta name="Baiduspider" content="noarchive">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="js、nodejs、css、nginx、vue、react">
    <meta name="keyword" content="网易">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        Linux系统命令及Shell脚本实践指南 - fanky_c的博客 | fanky_c&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>fanky_c</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#linux简介"><span class="toc-text">linux简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#linux的特点"><span class="toc-text">linux的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux启动流程"><span class="toc-text">linux启动流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux帮助命令"><span class="toc-text">linux帮助命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用man-page"><span class="toc-text">使用man page</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用info-page"><span class="toc-text">使用info page</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux用户管理"><span class="toc-text">linux用户管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#linux用户和用户组"><span class="toc-text">linux用户和用户组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#uid和gid"><span class="toc-text">uid和gid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#etc-passwd-和-etc-shadow"><span class="toc-text">/etc/passwd 和 /etc/shadow</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux账号管理"><span class="toc-text">linux账号管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#新增和删除用户"><span class="toc-text">新增和删除用户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#新增和删除用户组"><span class="toc-text">新增和删除用户组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#检查用户信息"><span class="toc-text">检查用户信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux切换用户"><span class="toc-text">linux切换用户</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#切换其他用户"><span class="toc-text">切换其他用户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用其他用户的身份执行命令：sudo"><span class="toc-text">用其他用户的身份执行命令：sudo</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux例行任务管理"><span class="toc-text">linux例行任务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单一时刻执行一次任务：at"><span class="toc-text">单一时刻执行一次任务：at</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#周期性执行任务：cron"><span class="toc-text">周期性执行任务：cron</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#etc-crontab管理"><span class="toc-text">/etc/crontab管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux文件管理"><span class="toc-text">linux文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件和目录管理"><span class="toc-text">文件和目录管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#文件的相关操作"><span class="toc-text">文件的相关操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#目录的相关操作"><span class="toc-text">目录的相关操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文件时间戳"><span class="toc-text">文件时间戳</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件和目录权限"><span class="toc-text">文件和目录权限</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#查看文件或者目录权限-ls-al"><span class="toc-text">查看文件或者目录权限: ls -al</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#改变文件权限：chmod"><span class="toc-text">改变文件权限：chmod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#改变文件的拥有者：chown"><span class="toc-text">改变文件的拥有者：chown</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#改变文件的拥有者：chown-1"><span class="toc-text">改变文件的拥有者：chown</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查看文件类型：file"><span class="toc-text">查看文件类型：file</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找文件"><span class="toc-text">查找文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一般查找-find"><span class="toc-text">一般查找 find</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库查找-locate"><span class="toc-text">数据库查找 locate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查找执行文件-which-whereis"><span class="toc-text">查找执行文件 which/whereis</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件压缩和打包"><span class="toc-text">文件压缩和打包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gzip-gunzip"><span class="toc-text">gzip/gunzip</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tar"><span class="toc-text">tar</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux文件系统"><span class="toc-text">linux文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件系统"><span class="toc-text">文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#磁盘分区、创建文件系统、挂载"><span class="toc-text">磁盘分区、创建文件系统、挂载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建文件系统：fdisk"><span class="toc-text">创建文件系统：fdisk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#磁盘挂载：mount"><span class="toc-text">磁盘挂载：mount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#磁盘检查：fsck、badblocks"><span class="toc-text">磁盘检查：fsck、badblocks</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#硬链接和软连接"><span class="toc-text">硬链接和软连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#硬链接"><span class="toc-text">硬链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#软连接"><span class="toc-text">软连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符处理"><span class="toc-text">字符处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#管道"><span class="toc-text">管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用grep搜索文本"><span class="toc-text">使用grep搜索文本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用sort排序"><span class="toc-text">使用sort排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用uniq删除重复内容"><span class="toc-text">使用uniq删除重复内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用cut截取文本"><span class="toc-text">使用cut截取文本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用tr做文本转换"><span class="toc-text">使用tr做文本转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用paste做文本合并"><span class="toc-text">使用paste做文本合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用split分割大文件"><span class="toc-text">使用split分割大文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络管理"><span class="toc-text">网络管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#网络接口"><span class="toc-text">网络接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ifconfig检查和配置网卡"><span class="toc-text">ifconfig检查和配置网卡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将ip配置信息写入配置文件"><span class="toc-text">将ip配置信息写入配置文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路由和网关"><span class="toc-text">路由和网关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS客户端配置"><span class="toc-text">DNS客户端配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#etc-hosts"><span class="toc-text">/etc/hosts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#etc-resolv-conf"><span class="toc-text">/etc/resolv.conf</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络测试工具"><span class="toc-text">网络测试工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ping"><span class="toc-text">ping</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#host"><span class="toc-text">host</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#网络故障排查"><span class="toc-text">网络故障排查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程管理"><span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是进程"><span class="toc-text">什么是进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程、线程、程序区别"><span class="toc-text">进程、线程、程序区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#进程-VS-程序"><span class="toc-text">进程 VS 程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程-VS-线程"><span class="toc-text">进程 VS 线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程观察：-ps、top"><span class="toc-text">进程观察： ps、top</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程的终止：-kill、killall"><span class="toc-text">进程的终止： kill、killall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查询进程打开文件：lsof"><span class="toc-text">查询进程打开文件：lsof</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#查看进程"><span class="toc-text">查看进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查看什么进程使用该文件"><span class="toc-text">查看什么进程使用该文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#恢复被删除的文件，-此文件必须正在被某个进程使用"><span class="toc-text">恢复被删除的文件， 此文件必须正在被某个进程使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程优先级调整：nice、renice"><span class="toc-text">进程优先级调整：nice、renice</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vi和vim编辑器"><span class="toc-text">vi和vim编辑器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vim编辑器使用"><span class="toc-text">vim编辑器使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正则表达式"><span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#正则基础"><span class="toc-text">正则基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#正则表达式示例"><span class="toc-text">正则表达式示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#grep"><span class="toc-text">grep</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文本处理工具sed"><span class="toc-text">文本处理工具sed</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sed介绍"><span class="toc-text">sed介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除"><span class="toc-text">删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查找替换"><span class="toc-text">查找替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符转换"><span class="toc-text">字符转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插入文本"><span class="toc-text">插入文本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读入文本"><span class="toc-text">读入文本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#打印"><span class="toc-text">打印</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sed脚本"><span class="toc-text">sed脚本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文本处理工具awk"><span class="toc-text">文本处理工具awk</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#介绍"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#打印指定域"><span class="toc-text">打印指定域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指定打印分隔符"><span class="toc-text">指定打印分隔符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#截取字符串"><span class="toc-text">截取字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#确定字符串的长度"><span class="toc-text">确定字符串的长度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shell编程概述和编程基础"><span class="toc-text">shell编程概述和编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shell介绍"><span class="toc-text">shell介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell脚本"><span class="toc-text">shell脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#编写第一个shell脚本"><span class="toc-text">编写第一个shell脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行脚本"><span class="toc-text">运行脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shell脚本排错"><span class="toc-text">shell脚本排错</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell内置命令"><span class="toc-text">shell内置命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何确定内建命令：type"><span class="toc-text">如何确定内建命令：type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#执行程序：“-”（点号）"><span class="toc-text">执行程序：“.”（点号）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#别名：alias"><span class="toc-text">别名：alias</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#任务前后台切换：bg、fg、jobs"><span class="toc-text">任务前后台切换：bg、fg、jobs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#声明变量：declare、typeset"><span class="toc-text">声明变量：declare、typeset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#打印字符：echo"><span class="toc-text">打印字符：echo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#跳出循环：break"><span class="toc-text">跳出循环：break</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#循环控制：continue"><span class="toc-text">循环控制：continue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#退出Shell：exit"><span class="toc-text">退出Shell：exit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#发送信号给指定PID或进程：kill"><span class="toc-text">发送信号给指定PID或进程：kill</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#声明局部变量：local"><span class="toc-text">声明局部变量：local</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从标准输入读取一行到变量：read"><span class="toc-text">从标准输入读取一行到变量：read</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义函数返回值：return"><span class="toc-text">定义函数返回值：return</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量"><span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#局部变量"><span class="toc-text">局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#环境变量"><span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量命名"><span class="toc-text">变量命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量赋值和取值"><span class="toc-text">变量赋值和取值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#取消变量"><span class="toc-text">取消变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#特殊变量"><span class="toc-text">特殊变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量的作用域"><span class="toc-text">变量的作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转义和引用"><span class="toc-text">转义和引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#转义"><span class="toc-text">转义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引用"><span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#部分引用"><span class="toc-text">部分引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#全引用"><span class="toc-text">全引用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命令替换"><span class="toc-text">命令替换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运算符"><span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#算术运算符"><span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自增自减"><span class="toc-text">自增自减</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他运算符"><span class="toc-text">其他运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用-做运算"><span class="toc-text">使用$[]做运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内建运算命令declare"><span class="toc-text">内建运算命令declare</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#算术扩展"><span class="toc-text">算术扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特殊字符"><span class="toc-text">特殊字符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#通配符"><span class="toc-text">通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引号"><span class="toc-text">引号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注释符"><span class="toc-text">注释符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#大括号"><span class="toc-text">大括号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#杂项"><span class="toc-text">杂项</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#反引号"><span class="toc-text">反引号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#位置参数"><span class="toc-text">位置参数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试和判断"><span class="toc-text">测试和判断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#测试"><span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#测试结构"><span class="toc-text">测试结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文件测试"><span class="toc-text">文件测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串测试"><span class="toc-text">字符串测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#整数比较"><span class="toc-text">整数比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#逻辑测试符和逻辑运算符"><span class="toc-text">逻辑测试符和逻辑运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断"><span class="toc-text">判断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#if判断结构"><span class="toc-text">if判断结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#if-else判断结构"><span class="toc-text">if/else判断结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#if-elif-else判断结构"><span class="toc-text">if/elif/else判断结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case判断结构"><span class="toc-text">case判断结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环"><span class="toc-text">循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for循环"><span class="toc-text">for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#带列表的for循环"><span class="toc-text">带列表的for循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不带列表的for循环"><span class="toc-text">不带列表的for循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类C的for循环"><span class="toc-text">类C的for循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for的无限循环"><span class="toc-text">for的无限循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while循环"><span class="toc-text">while循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#while循环的语法"><span class="toc-text">while循环的语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用while按行读取文件"><span class="toc-text">使用while按行读取文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while的无限循环"><span class="toc-text">while的无限循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#until循环"><span class="toc-text">until循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select循环"><span class="toc-text">select循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套循环"><span class="toc-text">嵌套循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环控制"><span class="toc-text">循环控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#break语句"><span class="toc-text">break语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#continue语句"><span class="toc-text">continue语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数基本使用"><span class="toc-text">函数基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#带参数的函数-1-2-N…"><span class="toc-text">带参数的函数($1, $2, $N…)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数库"><span class="toc-text">函数库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义函数库"><span class="toc-text">自定义函数库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数库-etc-init-d-functions"><span class="toc-text">函数库/etc/init.d/functions</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重定向"><span class="toc-text">重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#io重定向符号和用法"><span class="toc-text">io重定向符号和用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-标准输出覆盖重定向：-gt"><span class="toc-text">1.标准输出覆盖重定向：&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-标准输出追加重定向：-gt-gt"><span class="toc-text">2.标准输出追加重定向：&gt;&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-标识输出重定向：-gt-amp"><span class="toc-text">3.标识输出重定向：&gt;&amp;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-标准输入重定向：-lt"><span class="toc-text">4.标准输入重定向：&lt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-管道："><span class="toc-text">5.管道：|</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用exec"><span class="toc-text">使用exec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Here-Document"><span class="toc-text">Here Document</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shell脚本范例"><span class="toc-text">shell脚本范例</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Linux系统命令及Shell脚本实践指南
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2022-04-25 14:28:05</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#读书笔记" title="读书笔记">读书笔记</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#linux系统" title="linux系统">linux系统</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#shell脚本" title="shell脚本">shell脚本</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h2 id="linux简介"><a href="#linux简介" class="headerlink" title="linux简介"></a>linux简介</h2><h3 id="linux的特点"><a href="#linux的特点" class="headerlink" title="linux的特点"></a>linux的特点</h3><ol>
<li><strong>免费开源。</strong>Linux是一款完全免费的操作系统，任何人都可以从网络上下载到它的源代码，并可以根据自己的需求进行定制化的开发，而且没有版权限制。</li>
<li><strong>模块化程度高。</strong>Linux的内核设计分成进程管理、内存管理、进程间通信、虚拟文件系统、网络5部分，其采用的模块机制使得用户可以根据实际需要，在内核中插入或移走模块，这使得内核可以被高度的剪裁定制，以方便在不同的场景下使用。</li>
<li><strong>广泛的硬件支持。</strong>得益于其免费开源的特点，有大批程序员不断地向Linux社区提供代码，使得Linux有着异常丰富的设备驱动资源，对主流硬件的支持极好，而且几乎能运行在所有流行的处理器上。</li>
<li><strong>安全稳定。</strong>Linux采取了很多安全技术措施，包括读写权限控制、带保护的子系统、审计跟踪、核心授权等，这为网络环境中的用户提供了安全保障。实际上有很多运行Linux的服务器可以持续运行长达数年而无须重启，依然可以性能良好地提供服务，其安全稳定性已经在各个领域得到了广泛的证实。</li>
<li><strong>多用户，多任务。</strong>多用户是指系统资源可以同时被不同的用户使用，每个用户对自己的资源有特定的权限，互不影响。多任务是现代化计算机的主要特点，指的是计算机能同时运行多个程序，且程序之间彼此独立，Linux内核负责调度每个进程，使之平等地访问处理器。由于CPU处理速度极快，从用户的角度来看所有的进程好像在并行运行。</li>
<li><strong>良好的可移植性。</strong>Linux中95%以上的代码都是用C语言编写的，由于C语言是一种机器无关的高级语言，是可移植的，因此Linux系统也是可移植的。</li>
</ol>
<h3 id="linux启动流程"><a href="#linux启动流程" class="headerlink" title="linux启动流程"></a>linux启动流程</h3><ol>
<li>首先，计算机会加载BIOS，这是计算机上最接近硬件的软件，各家主板制造商都会开发适合自己主板的BIOS，而BIOS中一项很重要的功能就是对自身的硬件做一次健康检查，只有硬件没有问题，才能运行软件，记住，操作系统也是一种软件</li>
<li>机器自检通过后，下面就要引导系统了。这个动作是BIOS设定的，BIOS默认会从硬盘上的第0柱面、第0磁道、第一个扇区中读取被称为MBR的东西，即主引导记录</li>
<li>第三步就是顺理成章地运行Grub了。Grub最重要的功能就是根据其配置文件加载kernel镜像，并运行内核加载后的第一个程序/sbin/init，这个程序会根据/etc/inittab来进行初始化的工作</li>
<li>Linux将根据/etc/inittab中定义的系统初始化配置si::sysinit:/etc/rc.d/rc.sysinit执行/etc/rc.sysinit脚本，该脚本将会设置系统变量、网络配置，并启动swap、设定/proc、加载用户自定义模块、加载内核设置等。</li>
<li>根据第三步读到的runlevel值来启动对应的服务，如果值为3，就会运行/etc/rc3.d/下的所有脚本，如果值为5，就会运行/etc/rc5.d/下的所有脚本。</li>
<li>将运行/etc/rc.local</li>
<li>会生成终端或X Window来等待用户登录</li>
</ol>
<h3 id="linux帮助命令"><a href="#linux帮助命令" class="headerlink" title="linux帮助命令"></a>linux帮助命令</h3><h4 id="使用man-page"><a href="#使用man-page" class="headerlink" title="使用man page"></a>使用man page</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ls</span><br></pre></td></tr></table></figure>
<h4 id="使用info-page"><a href="#使用info-page" class="headerlink" title="使用info page"></a>使用info page</h4><p>可以在命令行中输入info ls来显示ls命令的说明文<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info ls</span><br></pre></td></tr></table></figure></p>
<h2 id="linux用户管理"><a href="#linux用户管理" class="headerlink" title="linux用户管理"></a>linux用户管理</h2><h3 id="linux用户和用户组"><a href="#linux用户和用户组" class="headerlink" title="linux用户和用户组"></a>linux用户和用户组</h3><h4 id="uid和gid"><a href="#uid和gid" class="headerlink" title="uid和gid"></a>uid和gid</h4><p>Linux系统中的用户分为3类，<strong>即普通用户、根用户、系统用户。</strong></p>
<ol>
<li>普通用户: 通常普通用户的UID大于500，因为在添加普通用户时，系统默认用户ID从500开始编号。</li>
<li>根用户: 根用户也就是root用户，它的ID是0，也被称为超级用户，root账户拥有对系统的完全控制权：可以修改、删除任何文件，运行任何命令。所以root用户也是系统里面最具危险性的用户，root用户甚至可以在系统正常运行时删除所有文件系统，造成无法挽回的灾难。</li>
<li>系统用户：系统用户是指系统运行时必须有的用户，但并不是指真实的使用者。系统用户的ID范围是1~499</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#要确认自己的UID，可以使用以下id命令来获得：</span></span><br><span class="line">id</span><br><span class="line"></span><br><span class="line"><span class="comment">#要确认自己所属的用户组，可以使用以下groups命令来获得</span></span><br><span class="line">groups</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果要查询当前在线用户，可在用户登录以后，使用命令who看到目前登录在系统中的所有用户</span></span><br><span class="line">who</span><br></pre></td></tr></table></figure>
<h4 id="etc-passwd-和-etc-shadow"><a href="#etc-passwd-和-etc-shadow" class="headerlink" title="/etc/passwd 和 /etc/shadow"></a>/etc/passwd 和 /etc/shadow</h4><p>在登录Linux时必须要输入用户名和密码。而系统用来记录用户名、密码最重要的两个文件就是/etc/passwd 和 /etc/shadow(而且默认只有root用户才有读的权限，其他人完全没有读取这个文件的可能)</p>
<h3 id="linux账号管理"><a href="#linux账号管理" class="headerlink" title="linux账号管理"></a>linux账号管理</h3><h4 id="新增和删除用户"><a href="#新增和删除用户" class="headerlink" title="新增和删除用户"></a>新增和删除用户</h4><ol>
<li>新增用户： useradd</li>
<li>修改密码： passwd</li>
<li>修改用户： usermod</li>
<li>删除用户： userdel</li>
</ol>
<h4 id="新增和删除用户组"><a href="#新增和删除用户组" class="headerlink" title="新增和删除用户组"></a>新增和删除用户组</h4><ol>
<li>新增用户组： groupadd</li>
<li>删除用户组： groupdel</li>
</ol>
<h4 id="检查用户信息"><a href="#检查用户信息" class="headerlink" title="检查用户信息"></a>检查用户信息</h4><ol>
<li><p>查看用户： users、who、w</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用命令users可以查看当前系统有哪些用户。比如，在当前的系统中运行users命令，就会发现有两个root在当前机器上登录。</span></span><br><span class="line">users</span><br><span class="line"></span><br><span class="line"><span class="comment">#第一列是登录用户的用户名，第二列是用户登录的终端，第三列是用户登录的时间。</span></span><br><span class="line">who</span><br><span class="line"></span><br><span class="line"><span class="comment">#w命令的第一行会显示当前时间、系统运行时间、已登录的用户数量和系统负载。下面显示的信息分为8列</span></span><br><span class="line">w</span><br></pre></td></tr></table></figure>
</li>
<li><p>调查用户：finger</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果在finger后跟上某个用户名，则显示该用户更详细的信息，</span></span><br><span class="line">finger user1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="linux切换用户"><a href="#linux切换用户" class="headerlink" title="linux切换用户"></a>linux切换用户</h3><h4 id="切换其他用户"><a href="#切换其他用户" class="headerlink" title="切换其他用户"></a>切换其他用户</h4><p>假如说我以普通用户john登录到系统中，这时候想使用useradd添加一个用户，怎么办？普通用户是没有添加用户的权限的，只有root用户才能创建用户。当然我们可以使用exit命令退出当前用户，然后使用root用户登录，再使用useradd添加用户。但是也有一种更方便的方式，那就是使用su命令，su是切换用户的意思。在不加参数的情况下，su命令默认表示切换到root用户，之后只要输入root密码就可以切换身份为root了，完成操作后，使用exit命令可以退出root切换到原先的用户。如下所示：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#su命令默认表示切换到root用户，之后只要输入root密码就可以切换身份为root了，</span></span><br><span class="line"><span class="comment">#完成操作后，使用exit命令可以退出root切换到原先的用户</span></span><br><span class="line">su</span><br><span class="line"></span><br><span class="line"><span class="comment">#加上-这个参数后，切换成root用户时，不但身份变成了root，而且还能应用root的用户环境</span></span><br><span class="line">su -</span><br></pre></td></tr></table></figure></p>
<p><strong>使用su命令切换用户之后，当前的用户环境并没有发生变化，而使用su-命令切换用户后，用户环境变成root的了</strong></p>
<h4 id="用其他用户的身份执行命令：sudo"><a href="#用其他用户的身份执行命令：sudo" class="headerlink" title="用其他用户的身份执行命令：sudo"></a>用其他用户的身份执行命令：sudo</h4><p>sudo并不是真的切换了用户，而是使用其他用户的身份和权限执行了命令。</p>
<h3 id="linux例行任务管理"><a href="#linux例行任务管理" class="headerlink" title="linux例行任务管理"></a>linux例行任务管理</h3><blockquote>
<p>在Linux中也有处理这两种任务的方法。如果任务是周期性执行的，其命令为cron；如果只是在某一个特定的时间执行一次，其命令为at。</p>
</blockquote>
<h4 id="单一时刻执行一次任务：at"><a href="#单一时刻执行一次任务：at" class="headerlink" title="单一时刻执行一次任务：at"></a>单一时刻执行一次任务：at</h4><p><em>默认情况下，所有用户都可以使用at命令来调度自己的任务，如果由于特殊的原因需要禁止某些用户使用这个功能，可以将该用户的用户名添加至/etc/at.deny</em></p>
<h4 id="周期性执行任务：cron"><a href="#周期性执行任务：cron" class="headerlink" title="周期性执行任务：cron"></a>周期性执行任务：cron</h4><p><em>有一些任务是需要周期性执行的，比如说每天早晨的闹钟会在设定的时间准时响起</em></p>
<ol>
<li><p>启动crond进程</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service crond start</span><br><span class="line"></span><br><span class="line">service crond status</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑任务crontab -e</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* * * * * <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#前面5个*可以用来定义时间，</span></span><br><span class="line"><span class="comment">#第一个*表示分钟，可以使用的值是1~59，每分钟可以使用*和*/1表示；</span></span><br><span class="line"><span class="comment">#第二个*表示小时，可以使用的值是0~23；</span></span><br><span class="line"><span class="comment">#第三个*表示日期，可以使用的值是1~31；</span></span><br><span class="line"><span class="comment">#第四个*表示月份，可以使用的值是1~12；</span></span><br><span class="line"><span class="comment">#第五个*表示星期几，可以使用的值是0~6，0代表星期日；</span></span><br><span class="line"><span class="comment">#最后是执行的命令</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">*  *  *  *  * service httpd restart</span><br><span class="line">*/1  *  *  *  * service httpd restart</span><br><span class="line"><span class="comment">#这两种写法其实是一致的，都是每分钟重启httpd进程。请注意，这只是一个例子，除非你有确定的目的，否则不要在实际生产环境中这么设置</span></span><br><span class="line"></span><br><span class="line">*  */1  *  *  * service httpd restart</span><br><span class="line"><span class="comment">#每小时重启httpd 进程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*  23-3/1  *  *  * service httpd restart</span><br><span class="line"><span class="comment">#从23点开始到3点，每小时重启httpd 进程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">30 23 *  *  * service httpd restart</span><br><span class="line"><span class="comment">#每天晚上23点30分重启httpd进程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">30 23 1  *  * service httpd restart</span><br><span class="line"><span class="comment">#每月的第一天晚上23点30分重启httpd进程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">30 23 1  1  * service httpd restart</span><br><span class="line"><span class="comment">#每年1月1日的晚上23点30分重启httpd进程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">30 23 *  *  0 service httpd restart</span><br><span class="line"><span class="comment">#每周日晚上23点30分重启httpd进程</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看定时任务 crontab -l</p>
</li>
</ol>
<p><em>如果由于特殊的原因需要禁止某些用户使用这个功能，可以将该用户的用户名添加至/etc/cron.deny中</em></p>
<h4 id="etc-crontab管理"><a href="#etc-crontab管理" class="headerlink" title="/etc/crontab管理"></a>/etc/crontab管理</h4><p>我们知道用户可以通过crontab-e命令来编辑定义自己的任务，事实上，系统也有自己的例行任务，而其配置文件是/etc/crontab。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/crontab</span></span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line">HOME=/</span><br><span class="line"></span><br><span class="line"><span class="comment"># run-parts</span></span><br><span class="line">01 * * * * root run-parts /etc/cron.hourly</span><br><span class="line">02 4 * * * root run-parts /etc/cron.daily</span><br><span class="line">22 4 * * 0 root run-parts /etc/cron.weekly</span><br><span class="line">42 4 1 * * root run-parts /etc/cron.monthly</span><br></pre></td></tr></table></figure></p>
<h2 id="linux文件管理"><a href="#linux文件管理" class="headerlink" title="linux文件管理"></a>linux文件管理</h2><h3 id="文件和目录管理"><a href="#文件和目录管理" class="headerlink" title="文件和目录管理"></a>文件和目录管理</h3><h4 id="文件的相关操作"><a href="#文件的相关操作" class="headerlink" title="文件的相关操作"></a>文件的相关操作</h4><p>Linux遵循一切皆文件的规则，对Linux进行配置时，在很大程度上就是处理文件的过程，所以掌握文件的相关操作是非常有必要的</p>
<ol>
<li>创建文件：touch</li>
<li>删除文件：rm</li>
<li><p>移动或重命名文件： mv，后面需要跟两个参数，<strong>第一个参数是要被移动的文件，第二个参数是移动到的目录</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把test.log文件移动到/mnt中</span></span><br><span class="line">mv test.log /mnt/</span><br><span class="line"><span class="comment"># 把test.log重命名为test1.log</span></span><br><span class="line">mv test.log test1.log</span><br><span class="line"><span class="comment"># 移动文件的同时重命名文件</span></span><br><span class="line">mv test.log /mnt/test2.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看文件：cat</p>
</li>
<li><p>查看文件头： head</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况下，head将显示该文件前10行的内容;也可以使用-n参数指定显示的行数</span></span><br><span class="line">head -n 20 /text.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看文件尾: tail</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要动态地查看文件，使用-f参数就可以做到</span></span><br><span class="line">tail -f /text.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件格式转换：dos2unix, 当把Windows下的文本文件移动到Linux下时，会由于系统之间文本文件的换行符不同而造成文件在Linux下的读写操作有问题</p>
</li>
</ol>
<h4 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h4><ol>
<li><p>创建目录：mkdir</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以使用-p参数一次性创建所有目录，这样就不用费力地一个个创建了，命令如下所示</span></span><br><span class="line">mkdir -p dir2/dir3</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除目录：rmdir和rm</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rmdir 用来删除目录。但是需要注意的是，它只能删除空目录，如果目录不为空（存在文件或者子目录），那么该命令将拒绝删除指定的目录</span></span><br><span class="line">rmdir dir1 <span class="comment">#提示dir1为非空目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rm</span></span><br><span class="line">rm -rf dir1</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件和目录复制：cp</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制文件且重命名</span></span><br><span class="line">cp a.txt /tmp/b.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制文件不重命名</span></span><br><span class="line">cp a.txt /tmp/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制目录所有文件</span></span><br><span class="line">cp -rf /dir1/* /dir2/</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="文件时间戳"><a href="#文件时间戳" class="headerlink" title="文件时间戳"></a>文件时间戳</h4><p>通过touch可以创建新文件。如果文件已经存在，那么touch命令仅仅会更新文件的创建时间而不会修改文件内容。请记住，在Linux下目录也是一种文件，所以如果touch一个目录，这个目录的创建时间也会被更新</p>
<h3 id="文件和目录权限"><a href="#文件和目录权限" class="headerlink" title="文件和目录权限"></a>文件和目录权限</h3><h4 id="查看文件或者目录权限-ls-al"><a href="#查看文件或者目录权限-ls-al" class="headerlink" title="查看文件或者目录权限: ls -al"></a>查看文件或者目录权限: ls -al</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -l参数表示要求ls命令列出每个文件的详细信息，</span></span><br><span class="line"><span class="comment"># -a参数则要求ls命令还要同时列出隐藏文件</span></span><br><span class="line">ls -al</span><br><span class="line">[root@localhost ~]<span class="comment"># ls -al</span></span><br><span class="line">total 112</span><br><span class="line">drwxr-x---  3 root root  4096 Oct  1 10:43 .</span><br><span class="line">drwxr-xr-x 24 root root  4096 Oct  1 07:42 ..</span><br><span class="line">-rw-------  1 root root  5659 Sep 24 02:07 .bash_history</span><br><span class="line">-rw-r--r--  1 root root    24 Jan  6  2007 .bash_logout</span><br><span class="line">-rw-------  1 root root    72 Oct  1 08:45 .lesshst</span><br><span class="line">drwx------  2 root root  4096 Oct  1 08:48 .ssh</span><br><span class="line"></span><br><span class="line"><span class="comment">#第一列：是文件类别和权限，这列由10个字符组成，第一个字符表明该文件的类型</span></span><br><span class="line"><span class="comment">#第二列：代表“连接数”，除了目录文件之外，其他所有文件的连接数都是1，目录文件的连接数是该目录中包含其他目录的总个数+2，也就是说，如果目录A中包含目录B和C，则目录A的连接数为4</span></span><br><span class="line"><span class="comment">#第三列：代表该文件的所有人</span></span><br><span class="line"><span class="comment">#第四列：代表该文件的所有组</span></span><br><span class="line"><span class="comment">#第五列：是该文件的大小</span></span><br><span class="line"><span class="comment">#第六列：是该文件的创建时间或最近的修改时间</span></span><br><span class="line"><span class="comment">#第七列：是文件名</span></span><br></pre></td></tr></table></figure>
<p>第一列含义：<br><img src="/img/linux1.jpeg" style="max-width:95%"></p>
<h4 id="改变文件权限：chmod"><a href="#改变文件权限：chmod" class="headerlink" title="改变文件权限：chmod"></a>改变文件权限：chmod</h4><p>Linux下的每个文件都定义了文件拥有者（user）、拥有组（group）、其他人（others）的权限，我们使用字母u、g、o来分别代表拥有者、拥有组、其他人，而对应的具体权限则使用rwx的组合来定义，增加权限使用+号，删除权限使用-号，详细权限使用=号。图中用一些例子说明了如何使用chmod来改变文件的权限。<br><img src="/img/linux2.jpeg" style="max-width:95%"><br>如果要给用户组或其他人添加或删除相关权限，只需要将上面的u相应地更换成g或o即可。但是正如大家看到的，这种方式同一时刻只能给文件拥有者、文件拥有组或是其他所有人设置权限，如果要想同时设置所有人的权限就需要使用数字表示法了，我们定义r=4，w=2，x=1，如果权限是rwx，则数字表示为7，如果权限是r-x，则数字表示为5。假设想设置一个文件的权限是：拥有者的权限是读、写、执行（rwx），拥有组的权限是读、执行（r-x），其他人的权限是只读（r–），那么可以使用命令chmod 754 somefile来设置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改某个目录权限</span></span><br><span class="line">chmod -R 754 somedir</span><br></pre></td></tr></table></figure>
<h4 id="改变文件的拥有者：chown"><a href="#改变文件的拥有者：chown" class="headerlink" title="改变文件的拥有者：chown"></a>改变文件的拥有者：chown</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改文件拥有者</span></span><br><span class="line">chown chao a.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件拥有组</span></span><br><span class="line">chown :chao a.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时修改文件拥有者和拥有组</span></span><br><span class="line">chown chao:chao a.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时修改目录拥有者和拥有组</span></span><br><span class="line">chown -R chao:chao somedir</span><br></pre></td></tr></table></figure>
<h4 id="改变文件的拥有者：chown-1"><a href="#改变文件的拥有者：chown-1" class="headerlink" title="改变文件的拥有者：chown"></a>改变文件的拥有者：chown</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp -R chao somedir</span><br></pre></td></tr></table></figure>
<h4 id="查看文件类型：file"><a href="#查看文件类型：file" class="headerlink" title="查看文件类型：file"></a>查看文件类型：file</h4><p>使用ls-l令可以通过查看第一个字符判断文件类型。字母d代表目录、字母l代表连接文件，字母b代表块文件，字母c代表字符文件，字母s代表socket文件，字符-代表普通文件，字母p代表管道文件</p>
<h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><h4 id="一般查找-find"><a href="#一般查找-find" class="headerlink" title="一般查找 find"></a>一般查找 find</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从根目录开始寻找名为httpd.conf的文件</span></span><br><span class="line">find / -name httpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从etc目录开始寻找名为httpd.conf的文件</span></span><br><span class="line">find /etc -name httpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找系统所有以conf结尾的文件</span></span><br><span class="line">find / -name *.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找系统所有以http开头文件</span></span><br><span class="line">find / -name httpd*</span><br></pre></td></tr></table></figure>
<p><img src="/img/linux3.jpeg" style="max-width:95%"></p>
<h4 id="数据库查找-locate"><a href="#数据库查找-locate" class="headerlink" title="数据库查找 locate"></a>数据库查找 locate</h4><p>与find不同，locate命令依赖于一个数据库文件，Linux系统默认每天会检索一下系统中的所有文件，然后将检索到的文件记录到数据库中，所以使用locate命令要比find命令反馈更为迅速。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新数据库 --&gt; 查找文件</span></span><br><span class="line">updatedb</span><br><span class="line">find /etc -name httpd.conf</span><br></pre></td></tr></table></figure></p>
<h4 id="查找执行文件-which-whereis"><a href="#查找执行文件-which-whereis" class="headerlink" title="查找执行文件 which/whereis"></a>查找执行文件 which/whereis</h4><p>which用于从系统的PATH变量所定义的目录中查找可执行文件的绝对路径。比如说想查找node这个命令在系统中的绝对路径<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用whereis也能查到其路径，但是和which不同的是，</span></span><br><span class="line"><span class="comment"># 它不但能找出其二进制文件，还能找出相关的man文件：</span></span><br><span class="line">whereis node</span><br></pre></td></tr></table></figure></p>
<h3 id="文件压缩和打包"><a href="#文件压缩和打包" class="headerlink" title="文件压缩和打包"></a>文件压缩和打包</h3><h4 id="gzip-gunzip"><a href="#gzip-gunzip" class="headerlink" title="gzip/gunzip"></a>gzip/gunzip</h4><p>gzip/gunzip是用来压缩和解压缩单个文件的工具<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩install.log文件</span></span><br><span class="line">gzip install.log  <span class="comment"># 最终压缩的文件名：install.log.gz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压 install.log.gz</span></span><br><span class="line">gunzip install.log.gz</span><br></pre></td></tr></table></figure></p>
<h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>tar不但可以打包文件，还可以将整个目录中的全部文件整合成一个包，整合包的同时还能使用gzip的功能进行压缩，比如说把整个/boot目录整合并压缩成一个文件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩命令: 压缩/boot目录成bott.tgz</span></span><br><span class="line"><span class="comment"># -z的含义是使用gzip压缩</span></span><br><span class="line"><span class="comment"># -c是创建压缩文件（create）</span></span><br><span class="line"><span class="comment"># -v是显示当前被压缩的文件</span></span><br><span class="line"><span class="comment"># -f是指使用文件名，也就是这里的boot.tgz文件</span></span><br><span class="line">tar -zcvf boot.tgz /boot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩命令 讲zain目录 压缩为dist.tar.gz</span></span><br><span class="line">tar -czf dist.tar.gz zain/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压命令: 直接将boot.tgz在当前目录中解压成boot目录</span></span><br><span class="line">tar -zxvf boot.tgz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压命令：使用-c参数指定压缩后的目录存放位置。比如说将boot目录解压到/tmp目录中</span></span><br><span class="line">tar -zxvf boot.tgz -c /tmp</span><br></pre></td></tr></table></figure></p>
<h2 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>大家已经知道Linux使用了树形文件存储结构，在磁盘上存储文件的时候，使用的则是目录加文件的形式。但实际上对于磁盘等各种存储设备来说，无论是什么数据，都只有0和1的概念。而对用户来说，0和1同样毫无意义，那怎么办呢？这就需要一种类似于“翻译”的机制存在于用户和磁盘之间了，在Linux中采用的是文件系统+虚拟文件系统（Virtual File System，VFS）的解决方案。</p>
<h3 id="磁盘分区、创建文件系统、挂载"><a href="#磁盘分区、创建文件系统、挂载" class="headerlink" title="磁盘分区、创建文件系统、挂载"></a>磁盘分区、创建文件系统、挂载</h3><h4 id="创建文件系统：fdisk"><a href="#创建文件系统：fdisk" class="headerlink" title="创建文件系统：fdisk"></a>创建文件系统：fdisk</h4><h4 id="磁盘挂载：mount"><a href="#磁盘挂载：mount" class="headerlink" title="磁盘挂载：mount"></a>磁盘挂载：mount</h4><p>创建了文件系统的分区后，在Linux系统下还需要经过挂载才能使用，挂载设备的命令是mount，</p>
<h4 id="磁盘检查：fsck、badblocks"><a href="#磁盘检查：fsck、badblocks" class="headerlink" title="磁盘检查：fsck、badblocks"></a>磁盘检查：fsck、badblocks</h4><p>当磁盘出现逻辑错误时，可以使用fsck来尝试修复。出现此类错误比较典型的情况是当机器突然掉电时可能引发。</p>
<h3 id="硬链接和软连接"><a href="#硬链接和软连接" class="headerlink" title="硬链接和软连接"></a>硬链接和软连接</h3><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>硬链接（hard link）又称实际链接，是指通过索引节点来进行链接。在Linux文件系统中，所有的文件都会有一个编号，称为inode，多个文件名指向同一索引节点是被允许的，这种链接就是硬链接。硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接指向同一文件，删除一个链接并不会影响索引节点本身和其他的链接，只有当最后一个链接被删除时，文件的数据块及目录的链接才会被释放。也就是说，文件真正删除的前提条件是与之相关的所有硬链接均被删除。<strong>硬链接有两个限制：</strong></p>
<ol>
<li>不允许给目录创建硬链接；</li>
<li>只有在同一文件系统中的文件之间才能创建链接，即不同分区上的两个文件之间不能够建立硬链接。</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">mkdir -p hard</span><br><span class="line"><span class="built_in">cd</span> hard</span><br><span class="line">touch hard01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看inode</span></span><br><span class="line">ls -li</span><br><span class="line">3834061-rw-r--r-- 1 root root 0 Jan 15 10:50 hard01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建hard01的硬链接hard01_hlink</span></span><br><span class="line"><span class="comment"># 硬链接hard01_hlink指向的inode和hard01指向inode是一致的</span></span><br><span class="line">ln hard01 hard01_hlink</span><br><span class="line"></span><br><span class="line"><span class="comment"># ls -li 查看文件inode</span></span><br><span class="line"><span class="comment"># 文件创建之初该值为1，该文件每增加一个硬链接该值将增1(变成2)，</span></span><br><span class="line"><span class="comment"># 当此数为0的时候该文件才能真正被文件系统删除</span></span><br><span class="line">ls -li</span><br><span class="line">3834061-rw-r--r-- 2 root root 0 Jan 15 10:50 hard01</span><br><span class="line">3834061-rw-r--r-- 2 root root 0 Jan 15 10:50 hard01_hlink</span><br></pre></td></tr></table></figure>
<h4 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h4><p>软链接（soft link）又称符号链接（symbolic link），是一个包含了另一个文件路径名的文件，可以指向任意文件或目录，也可以跨不同的文件系统。软链接和Windows下的“快捷方式”十分类似，删除软链接并不会删除其所指向的源文件，如果删除了源文件则软链接会出现“断链”。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">mkdir -p soft</span><br><span class="line"><span class="built_in">cd</span> soft</span><br><span class="line">touch soft01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建软连接使用-s，</span></span><br><span class="line"><span class="comment"># 创建 soft01_slink 指向 soft01 (当你访问soft01_slink， 实际是访问soft01_slink)</span></span><br><span class="line">ln -s soft01 soft01_slink</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 /home/user/ 目录下创建一个名为 bin_link 的符号链接，指向 /usr/local/bin 目录。</span></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/bin /home/user/bin_link</span><br><span class="line"></span><br><span class="line">ls -li</span><br><span class="line">3834063-rw-r--r-- 1 root root 0 Jan 15 10:50 soft01</span><br><span class="line">3834064-rw-r--r-- 1 root root 0 Jan 15 10:50 soft01_slink</span><br></pre></td></tr></table></figure></p>
<p>另外还请注意，在创建软链接的前后分别使用ls -li命令，会发现软链接的inode和源文件的inode不一样，这说明软链接本身就是一个文件。<br>读者可以尝试删除软链接的源文件，然后可以在终端中看到对应的软链接将会以闪烁的方式标记其已是一个断链。</p>
<h2 id="字符处理"><a href="#字符处理" class="headerlink" title="字符处理"></a>字符处理</h2><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>在Linux中也存在着管道，它是一个固定大小的缓冲区，该缓冲区的大小为1页，即4K字节。管道是一种使用非常频繁的通信机制，我们可以用管道符“|”来连接进程，由管道连接起来的进程可以自动运行，如同有一个数据流一样，所以管道表现为输入输出重定向的一种方法，它可以把一个命令的输出内容当作下一个命令的输入内容，两个命令之间只需要使用管道符连接即可。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果想要看一下/etc/init.d目录下文件的详细信息，</span></span><br><span class="line"><span class="comment"># 可以使用ls-l/etc/init.d命令，不过这可能会出现因输出内容过多而造成翻屏的情况，</span></span><br><span class="line"><span class="comment"># 这样一来，先输出的内容在屏幕上就看不到了。</span></span><br><span class="line"><span class="comment"># 其实这里就可以利用管道功能，将命令的输出使用more程序一页一页地显示出来</span></span><br><span class="line">ls -l /etc/init.d | more</span><br></pre></td></tr></table></figure></p>
<h3 id="使用grep搜索文本"><a href="#使用grep搜索文本" class="headerlink" title="使用grep搜索文本"></a>使用grep搜索文本</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep [-ivnc] <span class="string">'需要匹配字符'</span> 文件名</span><br><span class="line"><span class="comment"># -i 不区分大小写</span></span><br><span class="line"><span class="comment"># -c 统计包括匹配的行数</span></span><br><span class="line"><span class="comment"># -n 输出行号</span></span><br><span class="line"><span class="comment"># -v 反向匹配</span></span><br></pre></td></tr></table></figure>
<p>案例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找含有name的行</span></span><br><span class="line">grep <span class="string">'name'</span> txt1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找含有name的行编号</span></span><br><span class="line">grep -n <span class="string">'name'</span> txt1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找含有name的行编号， 忽略大小写</span></span><br><span class="line">grep -ni <span class="string">'name'</span> txt1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 管道</span></span><br><span class="line">cat txt1.txt | grep -ni <span class="string">'name'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="使用sort排序"><a href="#使用sort排序" class="headerlink" title="使用sort排序"></a>使用sort排序</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sort [-ntkr] 文件名</span><br><span class="line"><span class="comment"># -n 采用数字排序</span></span><br><span class="line"><span class="comment"># -t 指定分隔符</span></span><br><span class="line"><span class="comment"># -k 指定第几行</span></span><br><span class="line"><span class="comment"># -r 反向排序</span></span><br></pre></td></tr></table></figure>
<p>案例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat sort.txt</span></span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">d:1</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat sort.txt | sort</span></span><br><span class="line">a:4</span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">d:1</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"><span class="comment">#对输出内容直接排序时，默认按照每行的第一个字符进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cat sort.txt | sort -t ":" -k 2-n</span></span><br><span class="line">d:1</span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br></pre></td></tr></table></figure></p>
<h3 id="使用uniq删除重复内容"><a href="#使用uniq删除重复内容" class="headerlink" title="使用uniq删除重复内容"></a>使用uniq删除重复内容</h3><p>如果文件（或标准输出）中有多行完全相同的内容，我们很自然希望能删除重复的行，同时还可以统计出完全相同的行出现的总次数，uniq命令就能帮助解决这个问题。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uniq [-ic]</span><br><span class="line"><span class="comment"># -i 忽略大小写</span></span><br><span class="line"><span class="comment"># -c 计算重复行数</span></span><br></pre></td></tr></table></figure></p>
<p>案例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat uniq.txt | uniq</span></span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat uniq.txt | sort | uniq</span></span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用-c参数就会在每行前面打印出该行重复的次数</span></span><br><span class="line"><span class="comment"># cat uniq.txt | sort | uniq -c</span></span><br><span class="line">2 123</span><br><span class="line">2 abc</span><br></pre></td></tr></table></figure></p>
<h3 id="使用cut截取文本"><a href="#使用cut截取文本" class="headerlink" title="使用cut截取文本"></a>使用cut截取文本</h3><p>顾名思义，cut就是截取的意思，它能处理的对象是“一行”文本，可从中选取出用户所需要的部分。在有特定的分隔符时，可以指定分隔符，然后打印出以分隔符隔开的具体某一列或某几列<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cut -f指定行 -d<span class="string">'分隔符'</span></span><br><span class="line">cut -c指定列的字符</span><br></pre></td></tr></table></figure></p>
<p>案例<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比如说我们需要打印出系统中的所有用户</span></span><br><span class="line">cat /ect/passwd | cut -f1 -d<span class="string">':'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时打印出用户和这个用户的家目录</span></span><br><span class="line">cat /ect/passwd | cuf -f1,6 -d<span class="string">':'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时打印出每位用户的登录shell</span></span><br><span class="line">cat /ect/passwd | cuf -f1,6-7 -d<span class="string">':'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设想要打印出每行第1～5个字符，以及第7～10个字符的内容</span></span><br><span class="line">cat /ect/passwd | cuf -c1-5,7-10</span><br></pre></td></tr></table></figure></p>
<h3 id="使用tr做文本转换"><a href="#使用tr做文本转换" class="headerlink" title="使用tr做文本转换"></a>使用tr做文本转换</h3><p>tr命令比较简单，其主要作用在于文本转换或删除。这里假设要把文件/etc/passwd中的小写字母转换为大写字母，然后再尝试删除文本中的冒号<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | tr <span class="string">'[a-z]'</span> <span class="string">'[A-Z]'</span></span><br><span class="line"></span><br><span class="line">cat /etc/passwd | tr -d <span class="string">':'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="使用paste做文本合并"><a href="#使用paste做文本合并" class="headerlink" title="使用paste做文本合并"></a>使用paste做文本合并</h3><p>paste的作用在于将文件按照行进行合并，中间使用tab隔开。假设有两个文件分别为a.txt、b.txt，下面使用paste命令来合并文件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat a.txt</span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat b.txt</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line"></span><br><span class="line"><span class="comment"># past a.txt b.txt</span></span><br><span class="line">1 a</span><br><span class="line">2 b</span><br><span class="line">3 c</span><br><span class="line"></span><br><span class="line"><span class="comment"># past -d: a.txt b.txt</span></span><br><span class="line">1:a</span><br><span class="line">2:b</span><br><span class="line">3:c</span><br></pre></td></tr></table></figure></p>
<h3 id="使用split分割大文件"><a href="#使用split分割大文件" class="headerlink" title="使用split分割大文件"></a>使用split分割大文件</h3><p>在Linux下使用split命令来实现文件的分割，支持按照行数分割和按照大小分割这两种模式。要说明的是，二进制文件因为没有“行”的概念，所以二进制文件无法使用行分割，而只能按照文件大小进行分割。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -l参数：指定每500行为一个文件</span></span><br><span class="line"><span class="comment"># 分割完成后，当前目录下会产生很多小文件</span></span><br><span class="line">split -l 500 big_file.txt small_file_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是二进制文件， 只能按照文件大小分割</span></span><br><span class="line"><span class="comment"># 分割完成后，当前目录下会产生很多大小为6m的小文件</span></span><br><span class="line">split -b 64m big_bin small_bin_</span><br></pre></td></tr></table></figure></p>
<h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><h3 id="网络接口"><a href="#网络接口" class="headerlink" title="网络接口"></a>网络接口</h3><h4 id="ifconfig检查和配置网卡"><a href="#ifconfig检查和配置网卡" class="headerlink" title="ifconfig检查和配置网卡"></a>ifconfig检查和配置网卡</h4><p>如果不使用任何参数，输入ifconfig命令时将会输出当前系统中所有处于活动状态的网络接口。<br><img src="/img/linux4.jpeg" style="max-width:95%"><br>图中的eth0表示的是以太网的第一块网卡。其中eth是Ethernet的前三个字母，代表以太网，0代表是第一块网卡，第二块以太网网卡则是eth1，以此类推。Linkencap是指封装方式为以太网；HWaddr是指网卡的硬件地址（MAC地址）；inetaddr是指该网卡当前的IP地址；Broadcast是广播地址（这部分是由系统根据IP和掩码算出来的，一般不需要手工设置）；Mask是指掩码；UP说明了该网卡目前处于活动状态；MTU代表最大存储单元，即此网卡一次所能传输的最大分包；RX和TX分别代表接收和发送的包；collision代表发生的冲突数，如果发现值不为0则很可能网络存在故障；txqueuelen代表传输缓冲区长度大小；第二个设备是lo，表示主机的环回地址，这个地址是用于本地通信的。</p>
<p><strong>手动设置etho的ip地址</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifconfig etho 192.168.159.130 netmask 255.255.255.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有时候需要手工断开/启用网卡，以eth0为例，使用方法如下：</span></span><br><span class="line">ifconfig eth0 down <span class="comment">#断开</span></span><br><span class="line">ifconfig etho up <span class="comment">#启用</span></span><br></pre></td></tr></table></figure></p>
<h4 id="将ip配置信息写入配置文件"><a href="#将ip配置信息写入配置文件" class="headerlink" title="将ip配置信息写入配置文件"></a>将ip配置信息写入配置文件</h4><p>上一小节讲到的ifconfig命令可以直接配置网卡IP，但是这属于一种动态的配置，所配置的信息只是保存在当前运行的内核中。一旦系统重启，这些信息将丢失。为了能在重启后依然生效，可以在相关的配置文件中保存这些信息，这样，系统重启后将从这些配置文件中读取出来。RedHat和CentOS系统的网络配置文件所处的目录为/etc/sysconfig/network-scripts/，eth0的配置文件为ifcfg-eth0，如果有第二块物理网卡，则配置文件为ifcfg-eth1，以此类推<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat ifcfg-eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Advanced Micro Devices [AMD] 79c970 [PCnet32 LANCE]</span></span><br><span class="line">DEVICE=eth0 <span class="comment"># DEVICE变量定义了设备的名称</span></span><br><span class="line">BOOTPROTO=static <span class="comment"># 系统在启用这块网卡时，IP将会通过dhcp的方式获得；还有个可选的值是static，表示静态设置的IP</span></span><br><span class="line">ONBOOT=yes <span class="comment"># ONBOOT变量定义了启动时是否激活使用该设备，yes表示激活，no表示不激活</span></span><br><span class="line">IPADDR=192.168.159.129</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生效操作</span></span><br><span class="line">ifconfig eth0 down</span><br><span class="line">ifconfig eth0 up</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">service network restart</span><br></pre></td></tr></table></figure></p>
<h3 id="路由和网关"><a href="#路由和网关" class="headerlink" title="路由和网关"></a>路由和网关</h3><p>Linux主机之间是使用IP进行通信的，假设A主机和B主机同在一个网段内且网卡都处于激活状态，则A具备和B直接通信的能力（通过交换机或简易HUB）。但是如果A主机和B主机处于两个不同的网段，则A必须通过路由器才能和B通信。一般来说，路由器属于IT设备的基础设施，每一个网段都应该有至少一个网关。在Linux中可使用route命令添加默认网关。假设添加的网关是192.168.159.2，添加方式如下<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加</span></span><br><span class="line">route add default gw 192.168.159.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">route del default gw 192.168.159.2</span><br></pre></td></tr></table></figure></p>
<p>如果只使用route命令添加网关，一旦系统重启，配置信息就不存在了，必须将这种配置信息写到相关的配置文件中才能永久保存。可以在网卡配置文件中使用GATEWAY变量来定义网关，只需要添加如下部分到ifcfg-eth0中即可，当然别忘了重启网络服务使配置生效<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GATEWAY=192.168.159.2</span><br></pre></td></tr></table></figure></p>
<p>另外，在配置文件/etc/sysconfig/network中添加这段配置也能达到同样的效果。</p>
<h3 id="DNS客户端配置"><a href="#DNS客户端配置" class="headerlink" title="DNS客户端配置"></a>DNS客户端配置</h3><h4 id="etc-hosts"><a href="#etc-hosts" class="headerlink" title="/etc/hosts"></a>/etc/hosts</h4><p>们使用hosts文件来记录主机名和IP的对应关系，这样访问对方的主机时，就不需要使用IP了，只需要使用主机名。这个文件在Linux下就是/etc/hosts，这种方式确实“可以工作”，但是当主机数量增长到一定数量级的时候仍然无法适用。为了彻底解决这个问题，人们发明了DNS系统。经过几十年的发展，虽然系统、网络技术都发生了翻天覆地的变化，但是这个文件还是被当作传统保留了下来。hosts文件的作用主要如下：</p>
<ul>
<li>加快域名解析。当访问网站时，系统会首先查看hosts文件中是否有记录，如果记录存在则直接解析出对应的IP，这时则不需要请求DNS服务器</li>
<li>方便小型局域网用户使用的内部设备。很多单位的局域网中都存在着不少内部应用系统（比如办公自动化OA、公司论坛等），平时在工作中也都需要访问，但是由于这些局域网太小而不必为此专门设置DNS服务器，那么此时使用hosts文件则能简单地解决这个问题。</li>
</ul>
<h4 id="etc-resolv-conf"><a href="#etc-resolv-conf" class="headerlink" title="/etc/resolv.conf"></a>/etc/resolv.conf</h4><p>从技术上来说，DNS就是全互联网上主机名及其IP地址对应关系的数据库。设置主机为DNS客户端的配置文件就是/etc/resolv.conf，其中包含nameserver、search、domain这3个关键字<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># search关键字后紧跟的是一个域名。</span></span><br><span class="line"><span class="comment"># 每个主机严格来说都应该有一个FQDN（全限定域名），所以往往域名就很长，</span></span><br><span class="line"><span class="comment"># 如果这里写成search google.com，那么www就代表www.google. com了，</span></span><br><span class="line"><span class="comment"># 这个关键字后可以跟多个域名。</span></span><br><span class="line">search bigo.local</span><br><span class="line">nameserver 172.24.8.15 <span class="comment"># 172.24.8.15为DNS主机的IP地址</span></span><br><span class="line">nameserver 172.24.8.16</span><br></pre></td></tr></table></figure></p>
<h3 id="网络测试工具"><a href="#网络测试工具" class="headerlink" title="网络测试工具"></a>网络测试工具</h3><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>ping程序的目的在于测试另一台主机是否可达，一般来说，如果ping不到某台主机，就说明对方主机已经出现了问题，但是不排除由于链路中防火墙的因素、ping包被丢弃等原因而造成ping不通的情况<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 10.0.1.1.145</span><br></pre></td></tr></table></figure></p>
<h4 id="host"><a href="#host" class="headerlink" title="host"></a>host</h4><p>host命令是用来查询DNS记录的，如果使用域名作为host的参数，命令返回该域名的IP<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># host baidu.com</span></span><br><span class="line">baidu.com has address 220.181.38.148</span><br><span class="line">baidu.com has address 220.181.38.251</span><br><span class="line">baidu.com mail is handled by 10 mx.maillb.baidu.com.</span><br><span class="line">baidu.com mail is handled by 20 mx1.baidu.com.</span><br><span class="line">baidu.com mail is handled by 20 jpmx.baidu.com.</span><br><span class="line">baidu.com mail is handled by 20 mx50.baidu.com.</span><br><span class="line">baidu.com mail is handled by 20 usmx01.baidu.com.</span><br><span class="line">baidu.com mail is handled by 15 mx.n.shifen.com.</span><br></pre></td></tr></table></figure></p>
<h4 id="网络故障排查"><a href="#网络故障排查" class="headerlink" title="网络故障排查"></a>网络故障排查</h4><ol>
<li>硬件故障又主要分为网卡物理损坏、链路故障等原因。</li>
<li>软件主要表现为网卡驱动故障，也就是操作系统对网卡驱动的不兼容，这个问题往往需要通过安装对应的网卡设备驱动来解决<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步:确认网卡本身是否能正常工作?</span></span><br><span class="line">ping 127.0.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步确认网卡是否出现了物理或驱动故障，使用ping本机IP地址的方式，如果能ping通则说明本地设备和驱动都正常</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步要确认是否能ping通同网段的其他主机</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四步要确认是否能ping通网关IP</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第五步确认是否能ping通公网上的IP</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第六步确认是否能ping通公网上的某个域名，如果能ping通则说明DNS部分设置正确</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p>进程表示程序的一次执行过程，它是应用程序的运行实例，是一个动态的过程。或者可以更简单地描述为：进程是操作系统当前运行的程序。当一个进程开始运行时，就是启动了这个过程。</p>
<p>所有的进程都可能存在3种状态：运行态、就绪态、阻塞态。运行态表示程序当前实际占用着CPU等资源；就绪态是指程序除CPU之外的一切运行资源都已经就绪，等待操作系统分配CPU资源，只要分配了CPU资源，即可立即运行；而阻塞态是指程序在运行的过程中由于需要请求外部资源（例如I/O资源、打印机等低速的或同一时刻只能独享的资源）而当前无法继续执行，从而主动放弃当前CPU资源转而等待所请求资源。</p>
<p>而进程同步指的是进程间通过某种通信机制实现信息交互。现代计算机使用信号量机制来实现进程间的互斥和同步，它的基本原理是：两个或者多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一位置停止，直到它接收到一个特定的信号。</p>
<h3 id="进程、线程、程序区别"><a href="#进程、线程、程序区别" class="headerlink" title="进程、线程、程序区别"></a>进程、线程、程序区别</h3><h4 id="进程-VS-程序"><a href="#进程-VS-程序" class="headerlink" title="进程 VS 程序"></a>进程 VS 程序</h4><p>进程是动态的，而程序是静态的，进程是程序以及数据在计算机上的一次执行，没有静态的程序也就没有动态的执行。程序是可以以某种形式保存在存储介质上的，而进程只能在运行时存在于计算机的内存中。<br><em>如果说做一件事情需要经过若干既定的步骤，这些步骤可以被写成清单静态地列在纸上，那么它们就是广义上的“程序”，而只有真正开始将计划的步骤付诸实施的过程才是“进程”</em></p>
<h4 id="进程-VS-线程"><a href="#进程-VS-线程" class="headerlink" title="进程 VS 线程"></a>进程 VS 线程</h4><p>进程是资源分配的最小单位，线程是CPU调度的最小单位。做个简单的比喻：进程=火车，线程=车厢。</p>
<ol>
<li>线程在进程下行进（单纯的车厢无法运行）</li>
<li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li>
<li>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</li>
<li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li>
</ol>
<h3 id="进程观察：-ps、top"><a href="#进程观察：-ps、top" class="headerlink" title="进程观察： ps、top"></a>进程观察： ps、top</h3><ol>
<li>命令ps输出的只是当前查询状态下进程瞬间的状态信息，如果要想及时动态地查看进程就需要使用top命令了。</li>
<li>top命令提供了实时的系统状态监控，可以按照CPU使用、内存使用、执行时间等指标对进程进行排序</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ps [-Aawu]</span><br><span class="line"><span class="comment"># -A 列出所有进程</span></span><br><span class="line"><span class="comment"># -a 显示和本终端不相关的所有进程</span></span><br><span class="line"><span class="comment"># -w 显示加宽可以显示更多信息</span></span><br><span class="line"><span class="comment"># -u 显示有效使用者相关进程</span></span><br><span class="line"></span><br><span class="line">top</span><br></pre></td></tr></table></figure>
<h3 id="进程的终止：-kill、killall"><a href="#进程的终止：-kill、killall" class="headerlink" title="进程的终止： kill、killall"></a>进程的终止： kill、killall</h3><p>kill这些命令的原理都是向内核发送一个系统操作信号以及某个进程的标识号，使得内核对指定标识号的进程进行相应的操作。 典型用法是使用ps查出进程的PID，然后使用kill将其终止<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步</span></span><br><span class="line">ps -ef | grep dhcp <span class="comment"># 2899</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">pidof dhcp  <span class="comment"># 2899</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步</span></span><br><span class="line"><span class="built_in">kill</span> 2899</span><br></pre></td></tr></table></figure></p>
<p>命令kill后可以跟的信号代码一共有64种，使用kill-l就可以看到具体有哪些，如图所示。但是常用的一般只有3个，即HUP（1）、KILL（9）、TERM（15），分别代表重启、强行杀掉、正常结束。<br><img src="/img/linux5.jpeg" style="max-width:95%"></p>
<p>使用kill-1重启进程的时候实际上是不会改变主进程的PID的，也就是说只是发生了原地重启，或者说“软重启”<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 软重启</span></span><br><span class="line"><span class="built_in">kill</span> -1 2899</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要停止系统中所有的httpd进程，</span></span><br><span class="line"><span class="comment"># 那么只要按照以下方法操作</span></span><br><span class="line">killall httpd</span><br></pre></td></tr></table></figure></p>
<h3 id="查询进程打开文件：lsof"><a href="#查询进程打开文件：lsof" class="headerlink" title="查询进程打开文件：lsof"></a>查询进程打开文件：lsof</h3><p>Linux中一切皆文件，所以在系统中，被打开的文件可以是普通文件、目录、网络文件系统中的文件、字符设备、管道、socket等。那么如何知晓现在系统打开的是哪些文件呢，这时lsof命令就有用武之地了。</p>
<h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><p>使用lsof还可以查找使用了某个端口的进程，比如说如果系统中运行了sshd进程（基本上都是默认运行的），则该进程默认会绑定22端口，让我们来确认一下<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:22</span><br></pre></td></tr></table></figure></p>
<h4 id="查看什么进程使用该文件"><a href="#查看什么进程使用该文件" class="headerlink" title="查看什么进程使用该文件"></a>查看什么进程使用该文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></table></figure>
<h4 id="恢复被删除的文件，-此文件必须正在被某个进程使用"><a href="#恢复被删除的文件，-此文件必须正在被某个进程使用" class="headerlink" title="恢复被删除的文件， 此文件必须正在被某个进程使用"></a>恢复被删除的文件， 此文件必须正在被某个进程使用</h4><p><em>此文件必须正在被某个进程使用，也就是依然拥有打开文件的句柄能力。</em></p>
<p>现假设文件/var/log/messages不小心被删除了，首先来确认一下当前是否有进程正在使用这个文件，如果有则可以继续，如果没有就无法使用该方法继续了。本例中看到有个PID为2449的进程正在使用该文件，那么接下来只要找到对应/proc目录下的文件就可以了<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lsof | grep message</span></span><br><span class="line">syslogd   2449      root    1w      REG      253,0   149423    4161767 /var/<span class="built_in">log</span>/messages</span><br><span class="line"><span class="comment"># cat /proc/2449/fd/2 &gt; /var/log/messages</span></span><br><span class="line"><span class="comment"># Service syslogd restart</span></span><br></pre></td></tr></table></figure></p>
<h3 id="进程优先级调整：nice、renice"><a href="#进程优先级调整：nice、renice" class="headerlink" title="进程优先级调整：nice、renice"></a>进程优先级调整：nice、renice</h3><h2 id="vi和vim编辑器"><a href="#vi和vim编辑器" class="headerlink" title="vi和vim编辑器"></a>vi和vim编辑器</h2><p>vim编辑器是vi的加强版，在简单的文本操作上与vi几乎完全一致，所以习惯使用vi的人可以完全无缝地切换使用vim编辑器。同时vim还增加了很多新功能，包括代码补全、错误跳转等，可方便编程</p>
<h3 id="vim编辑器使用"><a href="#vim编辑器使用" class="headerlink" title="vim编辑器使用"></a>vim编辑器使用</h3><ol>
<li><p>搜索关键词</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/keyword <span class="comment"># 搜索keyword关键词</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>替换关键词</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:s/keyword/kw/g <span class="comment">#将本行的keyword替换成kw</span></span><br><span class="line"></span><br><span class="line">:1,<span class="variable">$s</span>/keyword/kw/g <span class="comment">#将1行到最后一行所有的keyword替换成kw</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="正则基础"><a href="#正则基础" class="headerlink" title="正则基础"></a>正则基础</h3><ol>
<li><p>“ .”（一个点）符号<br>点符号用于匹配除换行符之外的任意一个字符。例如：r.t可以匹配rot、rut</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">'r..t'</span> /etc/passwd</span><br></pre></td></tr></table></figure>
</li>
<li><p>“ *”符号<br>“<em>“符号用于匹配前一个字符 0次 或 任意多次，比如ab</em>，可以匹配a、ab、abb等。“*”号经常和“.”符号加在一起使用</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找包含字母r，后面紧跟任意长度的字符，再跟一个字母t的行</span></span><br><span class="line">grep <span class="string">'r.*t'</span> /etc/passwd</span><br></pre></td></tr></table></figure>
</li>
<li><p>“ \{n,m\}”符号</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># \&#123;n\&#125; 匹配前面的字符n次</span></span><br><span class="line">grep <span class="string">'ro\&#123;2\&#125;t'</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># \&#123;n,\&#125; 匹配前面的字符至少n次以上（含n次)</span></span><br><span class="line">grep <span class="string">'ro\&#123;2,\&#125;t'</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># \&#123;n,m\&#125; 匹配前面的字符n到m次</span></span><br><span class="line">grep <span class="string">'ro\&#123;2,3\&#125;t'</span> /etc/passwd</span><br></pre></td></tr></table></figure>
</li>
<li><p>“ ^”符号</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个符号用于匹配开头的字符。比如说“^root”匹配的是以字母root开始的行</span></span><br><span class="line">grep <span class="string">'^root'</span> /etc/passwd</span><br></pre></td></tr></table></figure>
</li>
<li><p>“ $”符号</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># “$”用于匹配尾部，比如说“abc$”代表的是以abc结尾的行。</span></span><br><span class="line"><span class="comment"># 如果是“^$”则代表该行为空，因为^和$间什么都没有</span></span><br><span class="line">grep <span class="string">'r.*t$'</span> /etc/passwd</span><br></pre></td></tr></table></figure>
</li>
<li><p>“ []”符号<br>这是一对方括号，用于匹配方括号内出现的任一字符</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配abc任意字符</span></span><br><span class="line">[abc]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比如说要匹配任意一个大写字母，就需要使用“-”号做范围限定，写成[A-Z]，</span></span><br><span class="line"><span class="comment"># 要匹配所有字母则写成[A-Za-z]。</span></span><br><span class="line"><span class="comment"># 一定要注意，这里“-”的作用不是充当一个字符。</span></span><br><span class="line">[a-zA-Z]</span><br><span class="line"></span><br><span class="line"><span class="comment"># “^”符号出现在[]中，则代表取反</span></span><br><span class="line">[^a-z]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手机号码 （3移动8联调）</span></span><br><span class="line">^1[38][0-9]\&#123;9\&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>“ \”转义符号</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\\"</span>  <span class="comment"># 对\符号进行转义</span></span><br><span class="line"><span class="string">"\.*"</span> <span class="comment"># 匹配任意长度的点号</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>“\&lt;”符号和“>”符号<br>界定单词的左边界和右边界</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello"</span> | grep <span class="string">'\&lt;hello\&gt;'</span>  <span class="comment">#匹配成功</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hellod"</span> | grep <span class="string">'\&lt;hello\&gt;'</span> <span class="comment"># 没有输出， 匹配失败</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>“ \d”符号</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 123 | grep [0-9] <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 123 | grep <span class="string">'\d'</span> <span class="comment"># 匹配不成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># '\d'是一种perf兼容模式表达式， 要想使用这种模式得加上-P参数</span></span><br><span class="line"><span class="built_in">echo</span> 123 | grep -P <span class="string">'\d'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>“ \b”符号<br>匹配单词的边界，比如“\bhello\b”可精确匹配“hello”单词</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'hello world'</span> | grep <span class="string">'\bhello\b'</span> <span class="comment"># hello world</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'helloworld'</span> | grep <span class="string">'\bhello\b'</span> <span class="comment"># 无匹配</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>“ \B”符号<br>匹配非单词的边界，比如hello\B可以匹配“helloworld”中的“hello”。</p>
</li>
<li><p>“ \w”符号<br>匹配字母、数字和下划线，等价于[A-Za-z0-9]。</p>
</li>
<li><p>“ \W”符号<br>匹配非字母、非数字、非下划线，等价于[^A-Za-z0-9]。</p>
</li>
<li><p>“ \s”符号<br>匹配任何空白字符</p>
</li>
<li><p>“ \S”符号<br>匹配任何非空白字符</p>
</li>
<li><p>“ \n”符号<br>匹配一个换行符（就是另起一新行，光标在新行的开头）。<br><em>我们平时编写文件的回车符(即：回车键 )应该确切来说叫做回车式的换行符。</em></p>
</li>
<li><p>“ \r”符号<br>匹配一个回车符（就是光标回到一旧行的开头，即光标目前所在的行为旧行）。</p>
</li>
<li><p>“ \t”符号<br>匹配一个制表符。</p>
</li>
<li><p>扩展正则表达式（需要使用egrep命令）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># “?”符号用于匹配前一个字符0次或1次，所以“ro?t”仅能匹配rot或rt。</span></span><br><span class="line"><span class="comment"># “+”符号用于匹配前一个字符1次以上，所以“ro+t”就可以匹配rot、root等。</span></span><br><span class="line"><span class="comment"># “|”符号是“或”的意思，即多种可能的罗列，彼此间是一种分支关系</span></span><br><span class="line"><span class="comment"># “()”符号通常需要和“|”符号联合使用，用于枚举一系列可替换的字符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通配符</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># * 符号: 这里的“*”就是提到的第一个通配符，代表0个或多个字符。那么之前的*.doc就是指所有以.doc结尾的文件</span></span><br><span class="line">ls -l *.doc</span><br><span class="line">ls -l A*.doc <span class="comment"># 找doc文档是以字母A开头</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ？符号： 如果要列出以字母A开头、但是只有两个字母的文件名、以.doc结尾的文件，就需要使用“?”了</span></span><br><span class="line">ls -l A?.doc</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#125; 符号: “&#123;&#125;”可拥有匹配所有括号内包含的以逗号隔开的字符</span></span><br><span class="line">ls -l &#123;A, B, C&#125;.doc  <span class="comment"># 相等于 ls -l [A-C].doc</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ^和！符号： 这两个符号往往和“[]”一起使用，当出现在“[]”中的时候，代表取反。所以[^A]（或[!A]）代表不是A。</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="正则表达式示例"><a href="#正则表达式示例" class="headerlink" title="正则表达式示例"></a>正则表达式示例</h3><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>grep的英文是Global search Regular Expression and print out the line，即全面搜索正则表达式并打印出匹配行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用“^”匹配行首</span></span><br><span class="line">grep <span class="string">'^good'</span> regexp.txt <span class="comment"># good morning teacher</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用“^$”组合，匹配空行</span></span><br><span class="line">grep -c <span class="string">'^$'</span> regexp.txt <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用“.”号匹配任意字符</span></span><br><span class="line">grep <span class="string">'g..d'</span> regexp.txt <span class="comment"># good gold golden</span></span><br><span class="line">grep <span class="string">'[Gg]..d'</span> regexp.txt <span class="comment"># good Good g12d</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用精确匹配</span></span><br><span class="line">grep <span class="string">'gold'</span> regexp.txt <span class="comment"># gold golden</span></span><br><span class="line">grep <span class="string">'\&lt;gold\&gt;'</span> regexp.txt <span class="comment"># gold</span></span><br><span class="line">grep <span class="string">'\bgold\b'</span> regexp.txt <span class="comment"># gold</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用“-”号</span></span><br><span class="line">grep <span class="string">'g[1-9]d'</span> regexp.txt <span class="comment"># g1d g2d</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用“*”号</span></span><br><span class="line">grep <span class="string">'go*d'</span> regexp.txt <span class="comment"># gd god good goood</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用“.*”号</span></span><br><span class="line">grep <span class="string">'g.*d'</span> regexp.txt <span class="comment"># gd gad good goood</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用“\”做字符转义, 下面.符号解析成正则任意字符</span></span><br><span class="line">grep <span class="string">'www.helloworld.com'</span> regexp.txt</span><br><span class="line">grep <span class="string">'www\.helloworld\.com'</span> regexp.txt</span><br></pre></td></tr></table></figure></p>
<h3 id="文本处理工具sed"><a href="#文本处理工具sed" class="headerlink" title="文本处理工具sed"></a>文本处理工具sed</h3><h4 id="sed介绍"><a href="#sed介绍" class="headerlink" title="sed介绍"></a>sed介绍</h4><p>sed（stream editor）是一种非交互式的流编辑器，通过多种转换修改流经它的文本。但是请注意，默认情况下，sed并不会改变原文件本身，而只是对流经sed命令的文本进行修改，并将修改后的结果打印到标准输出中（也就是屏幕）。所以本节讲的所有的sed操作都只是对“流”的操作，并不会改变原文件。sed处理文本时是以行为单位的，每处理完一行就立即打印出来，然后再处理下一行，直至全文处理结束。sed可做的编辑动作包括删除、查找替换、添加、插入、从其他文件中读入数据等。<br><strong>使用场景：常规编辑器编辑困难的文本；sed默认不更改源文件，如果想直接修改源文件本身则需要使用“-i”参数</strong></p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除第一行然后输出到屏幕</span></span><br><span class="line">sed <span class="string">'1d'</span> sed.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除第一行, 保存修改后的文件</span></span><br><span class="line">sed <span class="string">'1d'</span> sed.txt &gt; save_file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除第一行. 直接修改文件使用i参数；这里不会有任何输出， 而是直接修改了源文件</span></span><br><span class="line">sed -i <span class="string">'1d'</span> sed.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定范围的行</span></span><br><span class="line">sed <span class="string">'1, 3d'</span> sed.txt</span><br><span class="line">sed <span class="string">'1, $d'</span> sed.txt <span class="comment"># 删除1到最后一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除空行</span></span><br><span class="line">sed <span class="string">'/^$/d'</span> sed.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除包含empty的行</span></span><br><span class="line">sed <span class="string">'/empty/d'</span> sed.txt</span><br></pre></td></tr></table></figure>
<h4 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h4><p>使用s命令可将查找到的匹配文本内容替换为新的文本<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况下每行只替换第一个line</span></span><br><span class="line">sed <span class="string">'s/line/LINE/'</span> sed.txt <span class="comment"># this is LINE 1, this is First line, line</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 想要每行替换2个line</span></span><br><span class="line">sed <span class="string">'s/line/LINE/2'</span> sed.txt <span class="comment"># this is LINE 1, this is First LINE, line</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用g选项， 完成所欲匹配值的替换</span></span><br><span class="line">sed <span class="string">'s/line/LINE/g'</span> sed.txt <span class="comment"># this is LINE 1, this is First LINE, LINE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只替换开头的this为that</span></span><br><span class="line">sed <span class="string">'s/^this/that/'</span> sed.txt <span class="comment"># that is line 1, this is First line, line</span></span><br></pre></td></tr></table></figure></p>
<h4 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h4><p>使用y命令可进行字符转换，其作用为将一系列字符逐个地变换为另外一系列字符<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将file文件的O替换N, L替换E, D替换成W</span></span><br><span class="line">sed <span class="string">'y/OLD/NEW'</span> file</span><br><span class="line"></span><br><span class="line">sed <span class="string">'y/12345/ABCD'</span> sed.txt</span><br><span class="line"><span class="comment"># this is line A, this is First line</span></span><br><span class="line"><span class="comment"># this is line N, this is Second line</span></span><br><span class="line"><span class="comment"># this is line C, this is Third line</span></span><br></pre></td></tr></table></figure></p>
<h4 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h4><p>使用i或a命令插入文本，其中i代表在匹配行之前插入，而a代表在匹配行之后插入<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用i在第二行前插入文本</span></span><br><span class="line">sed <span class="string">'2 i Insert'</span> sed.txt</span><br><span class="line"><span class="comment"># this is line 1, this is First line</span></span><br><span class="line"><span class="comment"># Insert</span></span><br><span class="line"><span class="comment"># this is line 2, this is Second line</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用a在第二行后插入文本</span></span><br><span class="line">sed <span class="string">'2 a Insert'</span> sed.txt</span><br><span class="line"><span class="comment"># this is line 1, this is First line</span></span><br><span class="line"><span class="comment"># this is line 2, this is Second line</span></span><br><span class="line"><span class="comment"># Insert</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在匹配行的上一行插入文本</span></span><br><span class="line">sed <span class="string">'/Second/i\Insert'</span> sed.txt</span><br><span class="line"><span class="comment"># this is line 1, this is First line</span></span><br><span class="line"><span class="comment"># Insert</span></span><br><span class="line"><span class="comment"># this is line 2, this is Second line</span></span><br></pre></td></tr></table></figure></p>
<h4 id="读入文本"><a href="#读入文本" class="headerlink" title="读入文本"></a>读入文本</h4><p>使用r命令可从其他文件中读取文本，并插入匹配行之后<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将/etc/passwd中的内容读出来放到sed.txt空行之后</span></span><br><span class="line">sed <span class="string">'/^$/r /etc/passwd'</span> sed.txt</span><br></pre></td></tr></table></figure></p>
<h4 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h4><p>使用p命令可进行打印，这里使用sed命令时一定要加-n参数，表示不打印没关系的行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用p命令， 则只打印实际处理过的行，简化了输出（-n）</span></span><br><span class="line">sed -n <span class="string">'s/the/THE/p'</span> sed.txt</span><br></pre></td></tr></table></figure></p>
<h4 id="sed脚本"><a href="#sed脚本" class="headerlink" title="sed脚本"></a>sed脚本</h4><p>工作往往有一定“标准化”的操作，比如说先去除文件中所有的空行，然后再全部替换某些字符等，这种过程类似于生产线上程式化的流水作业；可以把这些动作静态化地写到某个文件中，然后调用sed命令并使用-f参数指定该文件，这样就可以将这一系列动作“装载”并应用于指定文件中，这无疑加快了工作效率，这种文件就是sed脚本。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># this替换THAT, 然后删除空行</span></span><br><span class="line"><span class="comment"># cat sed.rules</span></span><br><span class="line">s/this/THAT/g</span><br><span class="line">/^$/d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-f参数指定该脚本并应用到sed.txt</span></span><br><span class="line">sed -f sed.rules sed.txt</span><br></pre></td></tr></table></figure></p>
<h3 id="文本处理工具awk"><a href="#文本处理工具awk" class="headerlink" title="文本处理工具awk"></a>文本处理工具awk</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>sed其实是以行为单位的文本处理工具，而awk则是基于列的文本处理工具，它的工作方式是按行读取文本并视为一条记录，每条记录以字段分割成若干字段，然后输出各字段的值。</p>
<h4 id="打印指定域"><a href="#打印指定域" class="headerlink" title="打印指定域"></a>打印指定域</h4><p>awk使用$1、$2代表不同的域，则可以打印指定域<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只打印部分</span></span><br><span class="line">awk <span class="string">'&#123;print $1, $4&#125;'</span> awk.txt</span><br><span class="line"><span class="comment"># zhao 021-1111111</span></span><br><span class="line"><span class="comment"># liu  021-2222222</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印全部</span></span><br><span class="line">awk <span class="string">'&#123;print $0&#125;'</span> awk.txt</span><br><span class="line"><span class="comment"># zhao male   30 021-1111111</span></span><br><span class="line"><span class="comment"># liu  female 31 021-2222222</span></span><br><span class="line"><span class="comment"># hu   female 31 021-3333333 shanghai</span></span><br></pre></td></tr></table></figure></p>
<h4 id="指定打印分隔符"><a href="#指定打印分隔符" class="headerlink" title="指定打印分隔符"></a>指定打印分隔符</h4><p>默认情况下awk是使用空白字符作为分隔符的，但是也可以通过-F参数指定分隔符，来区分不同的域（有点像之前学过的cut命令）<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用.作为分隔符，这样每一行$1就是.之前的字符， $2就是.之后的字符</span></span><br><span class="line">awk -F. <span class="string">'&#123;print $1, $2&#125;'</span> awk.txt</span><br></pre></td></tr></table></figure></p>
<h4 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h4><p>可以使用substr()函数对指定域截取字符串。substr(指定域,第一个开始字符的位置,第二个结束的位置)</p>
<p>#其中第二个结束的位置可以为空，这样默认输出到该域的最后一个字符。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat awk.txt | awk <span class="string">'&#123;print substr($1, 6)&#125;'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="确定字符串的长度"><a href="#确定字符串的长度" class="headerlink" title="确定字符串的长度"></a>确定字符串的长度</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat awk.txt | awk <span class="string">'&#123;print length&#125;'</span></span><br></pre></td></tr></table></figure>
<h2 id="shell编程概述和编程基础"><a href="#shell编程概述和编程基础" class="headerlink" title="shell编程概述和编程基础"></a>shell编程概述和编程基础</h2><h3 id="shell介绍"><a href="#shell介绍" class="headerlink" title="shell介绍"></a>shell介绍</h3><blockquote>
<p>shell是指一种命令行解释器，是为用户和操作系统之间通信提供的一种接口<br>脚本语言又被称作解释型语言，这种语言经过编写后不需要做任何编译就可以运行。<br>计算机不能理解高级语言，只能理解机器语言，所以必须把高级语言翻译为机器码。而这种翻译的方式有两类，一类是编译，一类是解释，不同之处在于翻译的时间不同。编译型语言是运行前翻译，一般是使用编译工具将程序源码处理成机器认识的可执行文件（比如说Windows下的exe文件，Linux下的二进制可执行性文件），这种文件一旦产生，以后运行时将不需要再次翻译，所以一般来说，编译型语言的效率较高；而解释型语言是运行时翻译，执行一条语句就立即翻译一条，而且每次执行程序都需要进行解释，相对来说效率较低。但是也不能简单地认为编译型语言就一定比解释型效率高，随着解释器的发展，部分解释器能在运行程序时动态优化代码，因此这种效率差距也在一定程度上不断减小。</p>
</blockquote>
<h3 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h3><h4 id="编写第一个shell脚本"><a href="#编写第一个shell脚本" class="headerlink" title="编写第一个shell脚本"></a>编写第一个shell脚本</h4><p>一个Shell脚本永远是以“#!”开头的，这是一个脚本开始的标记，它是在告诉系统执行这个文件需要使用某个解释器，后面的/bin/bash就是指明了解释器的具体位置<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h4><ol>
<li><p>第一种就是在该脚本所在的目录中直接bash这个脚本。实际上，如果使用这种方式来运行脚本，该脚本中的第一行“#!/bin/bash”就可以不需要了，因为直接bash一个文件就是指定了使用BashShell来解释脚本内容。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash test.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种方式是给该脚本加上可执行权限，然后使用“./”来运行，它代表运行的是当前目录下的HelloWorld.sh脚本，如果采用这种方式而脚本没有可执行权限则会报错。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x test.sh</span><br><span class="line">./test.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果希望该脚本能成为默认的系统命令，简单地将该脚本复制到任一系统$PATH变量所包含的目录中，同时赋予可执行权限，下次运行的时候只需要直接输入该命令即可</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x text.sh</span><br><span class="line">mv test.sh /bin/</span><br><span class="line">test.sh</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="shell脚本排错"><a href="#shell脚本排错" class="headerlink" title="shell脚本排错"></a>shell脚本排错</h4><p>为了更清晰地看到脚本运行的过程，还可以借助-x参数来观察脚本的运行情况。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -x test.sh</span><br></pre></td></tr></table></figure></p>
<h3 id="shell内置命令"><a href="#shell内置命令" class="headerlink" title="shell内置命令"></a>shell内置命令</h3><blockquote>
<p>所谓Shell内建命令，就是由Bash自身提供的命令，而不是文件系统中的某个可执行文件。<br>通常来说，内建命令会比外部命令执行得更快，执行外部命令时不但会触发磁盘I/O，还需要fork出一个单独的进程来执行，执行完成后再退出。而执行内建命令相当于调用当前Shell进程的一个函数。</p>
</blockquote>
<h4 id="如何确定内建命令：type"><a href="#如何确定内建命令：type" class="headerlink" title="如何确定内建命令：type"></a>如何确定内建命令：type</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> <span class="built_in">cd</span></span><br><span class="line"><span class="comment"># cd is shell builtin</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> ifconfig</span><br><span class="line"><span class="comment"># ifconfig is /sbin/ifconfig</span></span><br></pre></td></tr></table></figure>
<h4 id="执行程序：“-”（点号）"><a href="#执行程序：“-”（点号）" class="headerlink" title="执行程序：“.”（点号）"></a>执行程序：“.”（点号）</h4><p>点号用于执行某个脚本，甚至脚本没有可执行权限也可以运行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">./test.sh</span><br><span class="line"><span class="comment"># 提示无权限</span></span><br><span class="line"></span><br><span class="line">. ./test.sh</span><br><span class="line"><span class="comment"># 执行成功</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> test.sh</span><br><span class="line"><span class="comment"># 执行成功， 同时返回脚本中最后一个命令的返回状态；</span></span><br><span class="line"><span class="comment"># 如果没有返回值则返回0，代表执行成功；</span></span><br><span class="line"><span class="comment"># 如果未找到指定的脚本则返回false</span></span><br></pre></td></tr></table></figure></p>
<h4 id="别名：alias"><a href="#别名：alias" class="headerlink" title="别名：alias"></a>别名：alias</h4><p>alias可用于创建命令的别名，若直接输入该命令且不带任何参数，则列出当前用户使用了别名的命令。现在你应该能理解类似ll这样的命令为什么与ls-l的效果是一样的吧<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样定义alias只能在当前Shell环境中有效，</span></span><br><span class="line"><span class="comment"># 换句话说，重新登录后这个别名就消失了。</span></span><br><span class="line"><span class="comment"># 为了确保永远生效，可以将该条目写到用户家目录中的.bashrc文件中</span></span><br><span class="line"><span class="built_in">alias</span> myShutdown=<span class="string">'shutdown -h now'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="任务前后台切换：bg、fg、jobs"><a href="#任务前后台切换：bg、fg、jobs" class="headerlink" title="任务前后台切换：bg、fg、jobs"></a>任务前后台切换：bg、fg、jobs</h4><p>该命令用于将任务放置后台运行，一般会与Ctrl+z、fg、&amp;符号联合使用。典型的使用场景是运行比较耗时的任务。比如打包某个占用较大空间的目录，若在前台执行，在任务完成前将会一直占用当前的终端，而导致无法执行其他任务，此时就应该将这类任务放置后台<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tar -zcf user.tgz /user</span><br><span class="line"><span class="comment"># 发现压缩很耗时， ctrl+z组合键暂停任务， jobs命令查看暂停任务为编号1</span></span><br><span class="line"><span class="built_in">bg</span> 1 <span class="comment"># 把tar任务放置后台</span></span><br><span class="line"><span class="built_in">fg</span> 1 <span class="comment"># 把后台tar任务调至前台</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果已知某个任务非常耗时，可以在一开始就在命令行后面加上 &amp;</span></span><br><span class="line">tar -zcf user.tgz /user &amp;</span><br></pre></td></tr></table></figure></p>
<h4 id="声明变量：declare、typeset"><a href="#声明变量：declare、typeset" class="headerlink" title="声明变量：declare、typeset"></a>声明变量：declare、typeset</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># i_num的值为1</span></span><br><span class="line">i_num=1</span><br><span class="line"><span class="comment"># str的值为helloworld</span></span><br><span class="line">str=<span class="string">"helloworld"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用declare声明只读变量</span></span><br><span class="line"><span class="built_in">declare</span> -r <span class="built_in">readonly</span>=10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用declare声明整型i_num1</span></span><br><span class="line"><span class="built_in">declare</span> -i i_num1=1</span><br></pre></td></tr></table></figure>
<h4 id="打印字符：echo"><a href="#打印字符：echo" class="headerlink" title="打印字符：echo"></a>打印字符：echo</h4><p>echo用于打印字符，典型用法是使用echo命令并跟上使用双引号括起的内容<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"hello world"</span> <span class="comment"># 不换行</span></span><br></pre></td></tr></table></figure></p>
<h4 id="跳出循环：break"><a href="#跳出循环：break" class="headerlink" title="跳出循环：break"></a>跳出循环：break</h4><p>从一个循环（for、while、until或者select）中退出。break后可以跟一个数字n，代表跳出n层循环，n必须大于1，如果n比当前循环层数还要大，则跳出所有循环。</p>
<h4 id="循环控制：continue"><a href="#循环控制：continue" class="headerlink" title="循环控制：continue"></a>循环控制：continue</h4><p>停止当前循环，并执行外层循环（for、while、until或者select）的下一次循环。continue后可以跟上一个数字n，代表跳至外部第n层循环。n必须大于1，如果n比当前循环层数还要大，将跳至最外层的循环</p>
<h4 id="退出Shell：exit"><a href="#退出Shell：exit" class="headerlink" title="退出Shell：exit"></a>退出Shell：exit</h4><p>在Shell脚本中使用exit代表退出当前脚本。该命令可以接受的参数是一个状态值n，代表退出的状态，下面的脚本什么都不会做，一旦运行就以状态值为5退出。如果不指定，默认状态值是0。</p>
<h4 id="发送信号给指定PID或进程：kill"><a href="#发送信号给指定PID或进程：kill" class="headerlink" title="发送信号给指定PID或进程：kill"></a>发送信号给指定PID或进程：kill</h4><blockquote>
<p>Linux操作系统包括3种不同类型的进程，第一种是交互进程，这是由一个Shell启动的进程，既可以在前台运行，也可以在后台运行；第二种是批处理进程，与终端没有联系，是一个进程序列；第三种是监控进程，也称系统守护进程，它们往往在系统启动时启动，并保持在后台运行</p>
</blockquote>
<p>kill命令用来终止进程，其工作的原理是向系统的内核发送一个系统操作信号和某个程序的进程标识号，然后系统内核就可以对进程标识号指定的进程进行操作。</p>
<h4 id="声明局部变量：local"><a href="#声明局部变量：local" class="headerlink" title="声明局部变量：local"></a>声明局部变量：local</h4><p>该命令用于在脚本中声明局部变量，典型的用法是用于函数体内，其作用域也在声明该变量的函数体中</p>
<h4 id="从标准输入读取一行到变量：read"><a href="#从标准输入读取一行到变量：read" class="headerlink" title="从标准输入读取一行到变量：read"></a>从标准输入读取一行到变量：read</h4><p>有时候我们开发的脚本必须具有交互性，也就是在运行过程中依赖人工输入才能继续<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据输入的箱数计算一共有多少瓶啤酒</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat read.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">declare</span> N</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"12 bottles of beer in a box"</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"How many box do you want:"</span></span><br><span class="line"><span class="built_in">read</span> N</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$((N*12)</span>) bottle in total"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行效果</span></span><br><span class="line">[root@localhost ~]<span class="comment"># bash read.sh</span></span><br><span class="line">12 bottles of beer <span class="keyword">in</span> a box</span><br><span class="line">How many box <span class="keyword">do</span> you want:10  <span class="comment">#这里输入数字</span></span><br><span class="line">120 bottle <span class="keyword">in</span> total</span><br></pre></td></tr></table></figure></p>
<p>如果不指定变量，read命令会将读取到的值放入环境变量REPLY中。另外要记住，read是按行读取的，用回车符区分一行，你可以输入任意文字，它们都会保存在变量REPLY中。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span></span><br><span class="line"><span class="comment"># 输入read命令 helloworld</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$REPLY</span></span><br><span class="line"><span class="comment"># 输出 helloworld</span></span><br></pre></td></tr></table></figure></p>
<h4 id="定义函数返回值：return"><a href="#定义函数返回值：return" class="headerlink" title="定义函数返回值：return"></a>定义函数返回值：return</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat return.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#定义了一个函数fun_01，该函数简单地返回1</span></span><br><span class="line"><span class="keyword">function</span> fun_01 &#123;</span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#调用该函数</span></span><br><span class="line">fun_01</span><br><span class="line"><span class="comment">#查看之前函数的返回值</span></span><br><span class="line"><span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>所谓局部变量就是指在某个Shell中生效的变量，对其他Shell来说无效，而且会随着当前Shell的消失而消失，局部变量的作用域被限定在声明它们的Shell中，可以使用local内建命令来“显式”的声明局部变量，但仅限于函数内使用。换言之，每个Shell都有自己的变量空间，彼此互不影响。而环境变量不仅仅是对于该Shell生效，对其子Shell也同样生效。</p>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>环境变量通常又称“全局变量”，以区别于局部变量。在Shell脚本中，变量默认就是全局的，无论在脚本的任何位置声明，但是为了让子Shell继承当前Shell的变量，则可以使用export内建命令将其导出为环境变量。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># VAR是变量的名字，value为值，使用等号相连，注意等号两端没有空格</span></span><br><span class="line"><span class="built_in">export</span> VAR=value</span><br></pre></td></tr></table></figure></p>
<p><strong>bash中默认包含有几十个预设的环境变量，这里挑选常见的一些予以介绍</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. bash shell的全路径</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 记录当前用户的UID。</span></span><br><span class="line"><span class="comment"># 当前的用户是root，所以该值应该为0。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$EUID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 变量：FUNCNAME</span></span><br><span class="line">cat funcname.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">funcname</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$FUNCNAME</span> <span class="comment"># 打印内容：funcname</span></span><br><span class="line">&#125;</span><br><span class="line">funcname</span><br><span class="line"></span><br><span class="line">bash funcname</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 变量：HOSTNAME 展示主机名</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$HOSTNAME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 变量：LANG</span></span><br><span class="line"><span class="comment"># 设置当前系统的语言环境，其实就是language的意思</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LANG</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 变量：PWD</span></span><br><span class="line"><span class="comment"># 记录当前目录</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PWD</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 变量：OLDPWD</span></span><br><span class="line"><span class="comment"># 记录之前目录，这个值是什么由之前所在的那个目录决定</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$OLDPWD</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 变量：PATH</span></span><br><span class="line"><span class="comment"># PATH 代表命令的搜索路径，非常重要</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span> <span class="comment"># 查看当前PATH的值</span></span><br></pre></td></tr></table></figure></p>
<h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>Shell中的变量必须以字母或者下划线开头，后面可以跟数字、字母和下划线，变量长度没有限制</p>
<h4 id="变量赋值和取值"><a href="#变量赋值和取值" class="headerlink" title="变量赋值和取值"></a>变量赋值和取值</h4><p><strong>赋值</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义变量：变量名=变量值</span></span><br><span class="line"><span class="comment">#注意点：变量名和变量值没有空格，之间没任何空格</span></span><br><span class="line">name=cc</span><br><span class="line">name=<span class="string">"c c"</span> <span class="comment">#其中引号可以爽双引号也可以是单引号</span></span><br></pre></td></tr></table></figure></p>
<p><strong>取值</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;name&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用$&#123;&#125;获取变量值是一种相对比较保守的方式</span></span><br><span class="line">name=<span class="string">"sue "</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$nameHello</span> <span class="comment"># 报错</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;name&#125;</span>Hello <span class="comment"># sue Hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果变量值引用的是其他变量，则必须使用双引号。</span></span><br><span class="line"><span class="comment">#单引号会阻止shell解释特殊字符$</span></span><br><span class="line">name=john</span><br><span class="line">name1=<span class="string">"<span class="variable">$name</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name1</span> <span class="comment"># john</span></span><br><span class="line">name1=<span class="string">'$name'</span> <span class="comment"># 单引号会阻止shell解释特殊字符$</span></span><br><span class="line"><span class="built_in">echo</span> name1</span><br><span class="line"><span class="variable">$name</span></span><br></pre></td></tr></table></figure></p>
<h4 id="取消变量"><a href="#取消变量" class="headerlink" title="取消变量"></a>取消变量</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name=john</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br><span class="line"><span class="built_in">unset</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span> <span class="comment">#变量中已经没有内容了</span></span><br></pre></td></tr></table></figure>
<h4 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h4><p><strong>1. 位置参数</strong><br>Shell中还有一些预先定义的特殊只读变量，它们的值只有在脚本运行时才能确定。首先是“位置参数”，位置参数的命名简单直接， 比如：脚本本身为$0，第一个参数为$1，第二个参数为$2，第三个为$3，以此类推。当位置参数的个数大于9时，需要用${}括起来标识，比如说第10个位置参数应该记为${10}。另外，$#表示脚本参数的个数总和，$@或$*表示脚本的所有参数</p>
<p><strong>2. 脚本或命令返回值：$?</strong><br>Linux中规定正常退出的命令和脚本应该以0作为其返回值，任何非0的返回值都表示命令未正确退出或未正常执行。<br>在自动化脚本中，也可以通过$?变量的值判断之前命令的执行状态，从而采取不同的动作。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尝试ping主机ping不通时的返回值</span></span><br><span class="line">ping 192.234.41.100 -c 1</span><br><span class="line"><span class="comment"># 返回非0， 代表命令执行不成功</span></span><br></pre></td></tr></table></figure></p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>Shell中的数组对元素个数没有限制，但只支持一维数组，这一点和很多语言不同。</p>
<p><strong>1. 数组定义</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法一</span></span><br><span class="line"><span class="built_in">declare</span> -a Array</span><br><span class="line">Array[0]=0</span><br><span class="line">Array[1]=1</span><br><span class="line">Array[2]=<span class="string">"Helloworld"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#方法二</span></span><br><span class="line"><span class="built_in">declare</span> -a Name=(<span class="string">'john'</span> <span class="string">'sue'</span>)</span><br><span class="line">Name[2]=<span class="string">'wang'</span> <span class="comment">#增加元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#方法三: 不使用declare的关键字</span></span><br><span class="line">Name=(<span class="string">'john'</span> <span class="string">'sue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法四: 调号赋值</span></span><br><span class="line">Score=([3]=3 [5]=5 [7]=7)</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 数组操作</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.取某个值</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;Array[0]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.取出所有的值</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;Array[@]&#125;</span></span><br><span class="line">0 1 Helloworld</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;Array[*]&#125;</span></span><br><span class="line">0 1 Helloworld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.数组长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#Array[@]&#125;</span></span><br><span class="line">3</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#Arraty[*]&#125;</span></span><br><span class="line">3</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#Array[2]&#125;</span> <span class="comment"># 查找某个元素的长度</span></span><br><span class="line">10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.数组截取</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;Array[@]:1:2&#125;</span> <span class="comment"># 取出数组的第一、第二元素</span></span><br><span class="line">1 Helloworld</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;Array[2]:0:5&#125;</span> <span class="comment"># 取出第二个元素从弟0个字符开始联系5个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.连接数组</span></span><br><span class="line">Conn=(<span class="variable">$&#123;Array[@]&#125;</span> <span class="variable">$&#123;Name[@]&#125;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;Conn[@]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.替换元素</span></span><br><span class="line">Arr=(<span class="variable">$&#123;Array[@]/Helloworld/HelloJohn&#125;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;Array[@]&#125;</span></span><br><span class="line">0 1 HelloJohn</span><br></pre></td></tr></table></figure></p>
<h4 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h4><p>变量的作用域又叫“命名空间”，表示变量（identifier，标识符）的上下文。相同的变量可以在多个命名空间中定义，并且彼此之间互不干涉，所以在一个新的命名空间中可以自定义任何变量，因为所定义的变量都只在各自的命名空间中。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在函数体内使用local关键字声明了和全局变量同名的局部变量后，</span></span><br><span class="line"><span class="comment"># 对该变量的操作只会影响局部变量，而不会影响与之同名的全局变量。</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat Namespace03.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">VAR_02=100</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ch_var</span></span>() &#123;</span><br><span class="line">        <span class="built_in">local</span> VAR_02=200 <span class="comment">#此处使用local声明变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Before function VAR_02:<span class="variable">$VAR_02</span>"</span></span><br><span class="line">ch_var</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"After function VAR_02:<span class="variable">$VAR_02</span>"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改后的Namespace03.sh执行结果</span></span><br><span class="line">[root@localhost ~]<span class="comment"># bash Namespace03.sh</span></span><br><span class="line">Before <span class="keyword">function</span> VAR_02:100</span><br><span class="line">After <span class="keyword">function</span> VAR_02:100</span><br></pre></td></tr></table></figure></p>
<h3 id="转义和引用"><a href="#转义和引用" class="headerlink" title="转义和引用"></a>转义和引用</h3><p>Shell中有两类字符，一类是普通字符，在Shell中除了本身的字面意思外没有其他特殊意义，即普通纯文本（literal）；另一类即元字符（meta），是Shell的保留字符，在Shell中有着特殊意义。这在很多时候会造成麻烦：比如说想要在程序中用美元符打印商品的价格，但是这个符号一般被解析成提取变量的值。为了消除这些特殊字符的功能，就必须对其进行转义和引用。</p>
<h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>要使用“\”来转义“$”字符，让“$”失去其特殊含义，而只作为一个符号出现。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo $Dollar 报错</span></span><br><span class="line"><span class="comment"># echo \$Dollar</span></span><br><span class="line"><span class="variable">$Dollar</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/linux7.jpeg" style="max-width:95%"></p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>引用是指将字符串用某种符号括起来，以防止特殊字符被解析为其他意思。比如说上一小节中的转义符就是一种引用。Shell中一共有4种引用符，分别是双引号、单引号、反引号和转义符。其中双引号又叫“部分引用”或“弱引用”，可以引用除$符、反引号、转义符之外的所有字符；单引号又叫“全引用”或“强引用”，可以引用所有字符；反引号则会将反引号括起的内容解释为系统命令。</p>
<h5 id="部分引用"><a href="#部分引用" class="headerlink" title="部分引用"></a>部分引用</h5><p>部分引用是指用双引号括起来的引用。在这种引用方式中，$符、反引号（`）、转义符（\）这3种特殊字符依然会被解析为特殊意义<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VAR03=100</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$VAR03</span>"</span> <span class="comment"># 100</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$VAR03</span> <span class="comment"># 100</span></span><br><span class="line"></span><br><span class="line">VAR04=<span class="string">"A  B  C"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$VAR04</span> <span class="comment"># A B C  (每个字母间隔只保留一个空格)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$VAR04</span>"</span> <span class="comment"># A  B  C</span></span><br></pre></td></tr></table></figure></p>
<h5 id="全引用"><a href="#全引用" class="headerlink" title="全引用"></a>全引用</h5><p>全引用是指用单引号括起来的引用。单引号中的任何字符都只当作是普通字符（除了单引号本身，也就是说单引号中间无法再包含单引号，即便用转义符转义单引号也不行）。所有在单引号中的字符都只能代表其作为字符的字面意义。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'$VAR03'</span></span><br><span class="line"><span class="comment"># $VAR03</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$VAR04'</span></span><br><span class="line"><span class="comment"># $VAR04</span></span><br></pre></td></tr></table></figure></p>
<p><strong>单引号和双引号在很多时候是一样的，只是要记住，在双引号中的$符、反引号、转义符还是会被解析成其特殊含义，而在单引号中所有的字符都只是字面意思</strong></p>
<h4 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h4><p>命令替换是指将命令的标准输出作为值赋给某个变量。比如，在某个目录中输入ls命令可查看当前目录中所有的文件，但如何将输出存入某个变量中呢？这就需要使用命令替换了，这也是Shell编程中使用非常频繁的功能。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">`命令`  <span class="comment"># DATE_01=`data`</span></span><br><span class="line">$(命令) <span class="comment"># DATE_02=$(data)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是有些情景是必须使用$()的：$()支持嵌套，而反引号不行</span></span><br><span class="line"><span class="comment"># $()仅在Bash Shell中有效，而反引号可在多种UNIX Shell中使用</span></span><br><span class="line">Fir_File_Lines=$(wc -l $(ls -l | sed -n <span class="string">'lp'</span>))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$Fir_File_Lines</span></span><br><span class="line">36 anaconda-ks.cfg</span><br></pre></td></tr></table></figure></p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>Shell只支持整数计算，也就是所有可能产生小数的运算都会舍去小数部分</p>
<h4 id="自增自减"><a href="#自增自减" class="headerlink" title="自增自减"></a>自增自减</h4><p>前置自增或前置自减操作会首先修改变量的值，然后再将变量的值传递出去；后置自增或后置自减则会首先将变量的值传递出去，然后再修改变量的值</p>
<h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><h4 id="使用-做运算"><a href="#使用-做运算" class="headerlink" title="使用$[]做运算"></a>使用$[]做运算</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $[]和$(())类似，可用于简单的算术运算</span></span><br><span class="line"><span class="built_in">echo</span> $[1+2]</span><br><span class="line"><span class="built_in">echo</span> $[5/2] <span class="comment"># 2 舍去小数</span></span><br></pre></td></tr></table></figure>
<h4 id="内建运算命令declare"><a href="#内建运算命令declare" class="headerlink" title="内建运算命令declare"></a>内建运算命令declare</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i=1+1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span> <span class="comment">#1+1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">declare</span> -i j</span><br><span class="line">j=1+1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$j</span> <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<h4 id="算术扩展"><a href="#算术扩展" class="headerlink" title="算术扩展"></a>算术扩展</h4><p>$((算术表达式))<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i=2</span><br><span class="line"><span class="built_in">echo</span> $((2*i+1)) <span class="comment">#5 这里i前面没有$</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#变量赋值</span></span><br><span class="line">var=$((算术表达式))</span><br><span class="line">var=$((2*i+1))</span><br><span class="line"><span class="built_in">echo</span> var <span class="comment"># 5</span></span><br></pre></td></tr></table></figure></p>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>通配符用于模式匹配，常见的通配符有<em>、?和用[]括起来的字符序列。其中</em>代表任意长度的字符串。例如：a<em>可以匹配以a开头的任意长度的字符串，但是不包括点号和斜线号。也就是说a</em>不能匹配abc.txt。问号（?）可用于匹配任一单个字符。方括号[]代表匹配其中的任意一个字符，比如[abc]代表匹配a或者b或者c，[]中可以用-表明起止，比如[a-c]等同于[abc]，但是要注意-字符在[]外只是一个普通字符，没有任何特殊作用；*和?在[]中则变成了普通字符，没有通配的功效</p>
<h4 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h4><p>引号包括单引号和双引号，单引号又叫称“全引用”或“强引用”；双引号又称“部分引用”或“弱引用”，所有用双引号括起来的字符除了美元符（$）、反斜线（\）、反引号（`）依然保留其特殊用途外，其余字符都作为普通字符处理；而所有用单引号括起的部分都作为普通字符处理，但是要注意单引号中间不能再出现单引号，否则会Shell无法判断到底哪里是单引号的起止位置。</p>
<h4 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h4><p>如果出现#后连着!，也就是“#!”不会被理解成注释，因此，其后跟着的部分必须是某个解释器的路径，而且“#!”必须出现在整个脚本的第一行</p>
<h4 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h4><p>大括号{}在Shell中的用法很多，最常见的用法就是引用变量原型，又叫变量扩展。例如变量VAR，可以使用${VAR}引用，这是推荐的引用变量的方法。</p>
<h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><h5 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h5><p>反引号用于命令替换，和$()的作用相同，表示返回当前命令的执行结果并赋值给变量。</p>
<h5 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$0</span>：脚本名本身。</span><br><span class="line"><span class="variable">$1</span>、<span class="variable">$2</span>……<span class="variable">$&#123;10&#125;</span>：脚本的第一个参数、第二个参数……第十个参数。</span><br><span class="line"><span class="variable">$#</span>：变量总数。</span><br><span class="line">$*、<span class="variable">$@</span>：显示所有参数。</span><br><span class="line">$?：前一个命令的退出的返回值。</span><br><span class="line">$!：最后一个后台进程的ID号。</span><br></pre></td></tr></table></figure>
<h2 id="测试和判断"><a href="#测试和判断" class="headerlink" title="测试和判断"></a>测试和判断</h2><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls一个存在的文件</span></span><br><span class="line">ls /var/<span class="built_in">log</span>/messages</span><br><span class="line"><span class="built_in">echo</span> $? <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ls一个不存在的文件</span></span><br><span class="line">ls /var/<span class="built_in">log</span>/messages11</span><br><span class="line"><span class="built_in">echo</span> $? <span class="comment"># 2 非0代表文件不存在</span></span><br></pre></td></tr></table></figure>
<p><strong>判断为真则返回0，为假则返回非0值。这种判断行为被称作“测试”</strong></p>
<h4 id="测试结构"><a href="#测试结构" class="headerlink" title="测试结构"></a>测试结构</h4><p>测试方式是使用“[”启动一个测试，再写expression，再以“]”结束测试。需要注意的是，左边的括号“[”后有个空格，右括号“]”前面也有个空格，如果任意一边少了空格都会造成Shell报错<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ expression ]</span><br></pre></td></tr></table></figure></p>
<h4 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h4><p>其中file_operator是文件测试符（具体参考下表），FILE是文件、目录（可以是文件或目录的全路径）<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件测试写法一</span></span><br><span class="line"><span class="built_in">test</span> file_operator FILE</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> -e /var/<span class="built_in">log</span>/messages</span><br><span class="line"><span class="built_in">echo</span> $?  <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件测试写法二</span></span><br><span class="line">[ file_operator FILE ]</span><br><span class="line"></span><br><span class="line">[-e /var/<span class="built_in">log</span>/messages ]</span><br><span class="line"><span class="built_in">echo</span> $? <span class="comment"># 1</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/linux8.jpeg" style="max-width:95%"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"What file do you want to test?"</span> filename</span><br><span class="line"><span class="keyword">if</span> [ !-e <span class="string">"<span class="variable">$filename</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"The file does not exist."</span></span><br><span class="line">   <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -r <span class="string">"<span class="variable">$filename</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$filename</span> is readable."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -w <span class="string">"<span class="variable">$filename</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$filename</span> is writeable"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -x <span class="string">"<span class="variable">$filename</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$filename</span> is executable"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串测试"><a href="#字符串测试" class="headerlink" title="字符串测试"></a>字符串测试</h4><p>Shell中的字符串比较主要有等于、不等于、大于、小于、是否为空等测试<br><img src="/img/linux9.jpeg" style="max-width:95%"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义空字符串str1</span></span><br><span class="line">[root@localhost ~]<span class="comment"># str1=""</span></span><br><span class="line"><span class="comment">#测试str1是否为空，为空则返回0</span></span><br><span class="line">[root@localhost ~]<span class="comment"># test-z "$str1"</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br><span class="line"><span class="comment">#测试str1是否非空，非空则返回0，为空返回非0，此处返回1</span></span><br><span class="line">[root@localhost ~]<span class="comment"># test-n "$str1"</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义非空字符串str2，值为hello</span></span><br><span class="line">[root@localhost ~]<span class="comment"># str2="hello"</span></span><br><span class="line"><span class="comment">#测试str2是否为空，为空返回0，不为空返回非0，此处返回1</span></span><br><span class="line">[root@localhost ~]<span class="comment"># [ -z "$str2" ]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">1</span><br><span class="line"><span class="comment">#测试str2是否非空，非空返回0</span></span><br><span class="line">[root@localhost ~]<span class="comment"># [ -n "$str2" ]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#比较str1和str2是否相同，相同则返回0，否则返回非0，此处返回1</span></span><br><span class="line">[root@localhost ~]<span class="comment"># [ "$str1" = "$str2" ]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">1</span><br><span class="line"><span class="comment">#比较str1和str2是否不同，不同则返回0</span></span><br><span class="line">[root@localhost ~]<span class="comment"># [ "$str1" != "$str2" ]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#比较str1和str1的大小，需要注意的是，&gt;和&lt;都需要进行转义</span></span><br><span class="line">[root@localhost ~]<span class="comment"># [ "$str1" \&gt; "$str2" ]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">1</span><br><span class="line">[root@localhost ~]<span class="comment"># [ "$str1" \&lt; "$str2" ]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果不想用转义符，则可以用[[]]括起表达式</span></span><br><span class="line">[root@localhost ~]<span class="comment"># [[ "$str1" &gt; "$str2" ]]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">1</span><br><span class="line">[root@localhost ~]<span class="comment"># [[ "$str1" &lt; "$str2" ]]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h4 id="整数比较"><a href="#整数比较" class="headerlink" title="整数比较"></a>整数比较</h4><p>整数测试是一种简单的算术运算，作用在于比较两个整数的大小关系，测试成立则返回0，否则返回非0值<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># num1=10</span></span><br><span class="line">[root@localhost ~]<span class="comment"># num2=10</span></span><br><span class="line">[root@localhost ~]<span class="comment"># num3=9</span></span><br><span class="line">[root@localhost ~]<span class="comment"># num4=11</span></span><br><span class="line">[root@localhost ~]<span class="comment"># [ "$num1" -eq "$num2" ]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br><span class="line">[root@localhost ~]<span class="comment"># [ "$num1" -gt "$num3" ]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br><span class="line">[root@localhost ~]<span class="comment"># [ "$num1" -lt "$num4" ]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br><span class="line">[root@localhost ~]<span class="comment"># [ "$num1" -ge "$num2" ]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br><span class="line">[root@localhost ~]<span class="comment"># [ "$num1" -le "$num2" ]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br><span class="line">[root@localhost ~]<span class="comment"># [ "$num1" -ne "$num3" ]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<h4 id="逻辑测试符和逻辑运算符"><a href="#逻辑测试符和逻辑运算符" class="headerlink" title="逻辑测试符和逻辑运算符"></a>逻辑测试符和逻辑运算符</h4><p>逻辑测试用于连接多个测试条件，并返回整个表达式的值。逻辑测试主要有逻辑非、逻辑与、逻辑或3种<br><img src="/img/linux10.jpeg" style="max-width:95%"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例一：逻辑非的使用</span></span><br><span class="line"><span class="comment">#测试值为真的表达式在使用逻辑非后，表达式变为假，反之亦然</span></span><br><span class="line">[root@localhost ~]<span class="comment"># [ !-e /var/log/messages ]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#例二：逻辑与的使用</span></span><br><span class="line"><span class="comment">#表达式都为真，整个表达式才返回真，否则返回假</span></span><br><span class="line">[root@localhost ~]<span class="comment"># [ -e /var/log/messages -a -e /var/log/messages01 ]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#例三：逻辑或的使用</span></span><br><span class="line"><span class="comment">#测试表达式中只要有真，则整个表达式返回真</span></span><br><span class="line">[root@localhost ~]<span class="comment"># [ -e /var/log/messages -o -e /var/log/messages01 ]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p><strong>如果读者曾经学过其他的编程语言，一定知道“逻辑运算符”也有逻辑非、逻辑与、逻辑或3种判断符号(! &amp;&amp; || )</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ! [ -e /var/log/messages ]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">1</span><br><span class="line">[root@localhost ~]<span class="comment"># [ -e /var/log/messages ] &amp;&amp; [ -e /var/log/messages01 ]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">1</span><br><span class="line">[root@localhost ~]<span class="comment"># [ -e /var/log/messages ] || [ -e /var/log/messages01 ]</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p>在Shell中，流程控制分为两大类，一类是“循环”，一类是“判断选择”。属于“循环”的有for、while、until，这将会在下一章中介绍，本节介绍“判断选择”，关键字是if、case。</p>
<h4 id="if判断结构"><a href="#if判断结构" class="headerlink" title="if判断结构"></a>if判断结构</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果expression测试返回真，则执行command</span></span><br><span class="line"><span class="keyword">if</span> expression; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>例子：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"Please input a score:"</span></span><br><span class="line"><span class="built_in">read</span> SCORE</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$SCORE</span>"</span> -lt 60 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"C"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$SCORE</span>"</span> -lt 80 -a <span class="string">"<span class="variable">$SCORE</span>"</span> -ge 60 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"B"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$SCORE</span>"</span> -ge 80 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"A"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#脚本运行结果，依次输入95、75、45时，脚本分别打印了正确的成绩等级</span></span><br><span class="line">[root@localhost ~]<span class="comment"># bash score01.sh</span></span><br><span class="line">Please input a score:95</span><br><span class="line">A</span><br><span class="line">[root@localhost ~]<span class="comment"># bash score01.sh</span></span><br><span class="line">Please input a score:75</span><br><span class="line">B</span><br><span class="line">[root@localhost ~]<span class="comment"># bash score01.sh</span></span><br><span class="line">Please input a score:45</span><br><span class="line">C</span><br></pre></td></tr></table></figure></p>
<h4 id="if-else判断结构"><a href="#if-else判断结构" class="headerlink" title="if/else判断结构"></a>if/else判断结构</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expression; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">command</span></span><br><span class="line"><span class="keyword">elif</span></span><br><span class="line">   <span class="built_in">command</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h4 id="if-elif-else判断结构"><a href="#if-elif-else判断结构" class="headerlink" title="if/elif/else判断结构"></a>if/elif/else判断结构</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expression; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">command</span></span><br><span class="line"><span class="keyword">elif</span></span><br><span class="line">   <span class="keyword">if</span> expression2; <span class="keyword">then</span></span><br><span class="line">      command2</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      command3</span><br><span class="line">   <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h4 id="case判断结构"><a href="#case判断结构" class="headerlink" title="case判断结构"></a>case判断结构</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># case判断结构中的var1、var2、var3等这些值只能是常量或正则表达式</span></span><br><span class="line"><span class="keyword">case</span> VAR <span class="keyword">in</span></span><br><span class="line">var1) command1 ;;</span><br><span class="line">var2) command2 ;;</span><br><span class="line">var3) command3 ;;</span><br><span class="line">...</span><br><span class="line">*) <span class="built_in">command</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p>例子：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">OS=<span class="string">'uname-s'</span></span><br><span class="line"><span class="keyword">case</span> “<span class="variable">$OS</span>” <span class="keyword">in</span></span><br><span class="line">FreeBSD) <span class="built_in">echo</span> <span class="string">"This is FreeBSD"</span> ;;</span><br><span class="line">CYGWIN_NT-5.1) <span class="built_in">echo</span> <span class="string">"This is Cygwin"</span> ;;</span><br><span class="line">SunOS) <span class="built_in">echo</span> <span class="string">"This is Solaris"</span> ;;</span><br><span class="line">Darwin) <span class="built_in">echo</span> <span class="string">"This is Mac OSX"</span> ;;</span><br><span class="line">AIX) <span class="built_in">echo</span> <span class="string">"This is AIX"</span> ;;</span><br><span class="line">Minix) <span class="built_in">echo</span> <span class="string">"This is Minix"</span> ;;</span><br><span class="line">Linux) <span class="built_in">echo</span> <span class="string">"This is Linux"</span> ;;</span><br><span class="line">*) <span class="built_in">echo</span> <span class="string">"Failed to identify this OS"</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><h4 id="带列表的for循环"><a href="#带列表的for循环" class="headerlink" title="带列表的for循环"></a>带列表的for循环</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fruits=<span class="string">"apple orange banana pear"</span></span><br><span class="line"><span class="keyword">for</span> FRUITS <span class="keyword">in</span> <span class="variable">$&#123;fruits&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"#&#123;FRUITS&#125; is franky's favorite"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Shell提供了用于计数的方式，比如说上例中1到5可以用&#123;1..5&#125;表示</span></span><br><span class="line"><span class="keyword">for</span> VAR <span class="keyword">in</span> &#123;1..5&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"Loop <span class="variable">$VAR</span> times"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是利用seq命令的“步长”计算1到100内的奇数和</span></span><br><span class="line">sum=0</span><br><span class="line"><span class="keyword">for</span> VAR <span class="keyword">in</span> $(seq 1 2 100)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">let</span> <span class="string">"sum+VAR"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Total: <span class="variable">$sum</span>"</span> <span class="comment"># 2500</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表for循环中in后面的内容可以是任意命令的标准输出</span></span><br><span class="line"><span class="keyword">for</span> VAR <span class="keyword">in</span> $(ls)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  ls -l <span class="variable">$VAR</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h4 id="不带列表的for循环"><a href="#不带列表的for循环" class="headerlink" title="不带列表的for循环"></a>不带列表的for循环</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> VARIBLE <span class="keyword">in</span> <span class="variable">$@</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="variable">$VARIBLE</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">bash test.sh 1 2 3 4 <span class="comment"># 1 2 3 4</span></span><br></pre></td></tr></table></figure>
<h4 id="类C的for循环"><a href="#类C的for循环" class="headerlink" title="类C的for循环"></a>类C的for循环</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类C的for循环语法结果</span></span><br><span class="line"><span class="keyword">for</span> ((expression1; expression2; expression3))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">       <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>例子<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>((i=0; i&lt;=10; i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$i</span> "</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在该示例中同时计算了1到100的和以及1到100的奇数和</span></span><br><span class="line">sum01=0</span><br><span class="line">sum02=0</span><br><span class="line"><span class="keyword">for</span> ((i=1,j=1; i&lt;=100; i++,j+=2))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> <span class="built_in">let</span> <span class="string">"sum01+=i"</span></span><br><span class="line"> <span class="keyword">if</span> [ <span class="variable">$j</span> -lt 100 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">"sum02+=j"</span></span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"sum01=<span class="variable">$sum01</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"sum02=<span class="variable">$sum02</span>"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="for的无限循环"><a href="#for的无限循环" class="headerlink" title="for的无限循环"></a>for的无限循环</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>((;1;))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">"infinite loop"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><h4 id="while循环的语法"><a href="#while循环的语法" class="headerlink" title="while循环的语法"></a>while循环的语法</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CONTER=5</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$CONTER</span> -gt 0 ]]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> echi -n <span class="string">"<span class="variable">$CONTER</span>"</span></span><br><span class="line"> <span class="built_in">let</span> <span class="string">"CONTER-=1"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是利用while做猜数字游戏，</span></span><br><span class="line"><span class="comment"># 只有当输入的数字和预设的数字一致时，才会停止循环</span></span><br><span class="line">PRE_SET_NUM=8</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Input a number between 1 and 10"</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> GUESS</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="variable">$GUESS</span> -eg <span class="variable">$PRE_SET_NUM</span> ]]; <span class="keyword">then</span></span><br><span class="line">     <span class="built_in">echo</span> <span class="string">"You get the right number"</span></span><br><span class="line">     <span class="built_in">exit</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     <span class="built_in">echo</span> <span class="string">"Wrong, Try again"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h4 id="使用while按行读取文件"><a href="#使用while按行读取文件" class="headerlink" title="使用while按行读取文件"></a>使用while按行读取文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat while04.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> LINE</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        NAME=`<span class="built_in">echo</span> <span class="variable">$LINE</span> | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">        AGE=`<span class="built_in">echo</span> <span class="variable">$LINE</span> | awk <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">        Sex=`<span class="built_in">echo</span> <span class="variable">$LINE</span> | awk <span class="string">'&#123;print $3&#125;'</span>`</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"My name is <span class="variable">$NAME</span>,I'm <span class="variable">$AGE</span> years old,I'm a <span class="variable">$Sex</span>"</span></span><br><span class="line"><span class="keyword">done</span> &lt; student_info.txt</span><br><span class="line"><span class="comment">#运行结果</span></span><br><span class="line">[root@localhost ~]<span class="comment"># bash while04.sh</span></span><br><span class="line">My name is John,I<span class="string">'m 30 years old,I'</span>m a Boy</span><br><span class="line">My name is Sue,I<span class="string">'m 28 years old,I'</span>m a Girl</span><br><span class="line">My name is Wang,I<span class="string">'m 25 years old,I'</span>m a Boy</span><br><span class="line">My name is Xu,I<span class="string">'m 23 years old,I'</span>m a Girl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#while使用管道的按行读取</span></span><br><span class="line"><span class="comment">#cat while04.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">cat student_info.txt | <span class="keyword">while</span> <span class="built_in">read</span> LINE</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">       NAME=`<span class="built_in">echo</span> <span class="variable">$LINE</span> | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">       AGE=`<span class="built_in">echo</span> <span class="variable">$LINE</span> | awk <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">       Sex=`<span class="built_in">echo</span> <span class="variable">$LINE</span> | awk <span class="string">'&#123;print $3&#125;'</span>`</span><br><span class="line">       <span class="built_in">echo</span> <span class="string">"My name is <span class="variable">$NAME</span>,I'm <span class="variable">$AGE</span> years old,I'm a <span class="variable">$Sex</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h4 id="while的无限循环"><a href="#while的无限循环" class="headerlink" title="while的无限循环"></a>while的无限循环</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们可以利用while的无限循环实时的监测系统进程，</span></span><br><span class="line"><span class="comment"># 以保证系统中的关键应用一直处于运行状态。</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    HTTPD_STATUS=`service httpd status | grep running`</span><br><span class="line">    <span class="keyword">if</span> [-z <span class="string">"<span class="variable">$HTTPD_STATUS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">           <span class="built_in">echo</span> <span class="string">"HTTPD is stopped,try to restart"</span></span><br><span class="line">           service httpd restart</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">           <span class="built_in">echo</span> <span class="string">"HTTPD is running,wait 5 sec until next check"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    sleep 5</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h3><p>待续…</p>
<h3 id="select循环"><a href="#select循环" class="headerlink" title="select循环"></a>select循环</h3><p>select是一种菜单扩展循环方式，其语法和带列表的for循环非常类似，基本结构如下<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select MENU <span class="keyword">in</span> (list)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>例子：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat select01.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Which car do you prefer?"</span></span><br><span class="line">select CAR <span class="keyword">in</span> Benz Audi VolksWagen</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="built_in">break</span> <span class="comment">#这里用到了没有讲过的break语句</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"You chose <span class="variable">$CAR</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果</span></span><br><span class="line"><span class="comment"># bash select01.sh</span></span><br><span class="line">Which car <span class="keyword">do</span> you prefer?</span><br><span class="line">1) Benz</span><br><span class="line">2) Audi</span><br><span class="line">3) VolksWagen</span><br><span class="line"><span class="comment">#?  #此处尝试直接回车，结果select再次生成了列表等待输入</span></span><br><span class="line">1) Benz</span><br><span class="line">2) Audi</span><br><span class="line">3) VolksWagen</span><br><span class="line"><span class="comment">#? 2#此处选择2，程序会退出select并继续执行后面的语句</span></span><br><span class="line">You chose Audi</span><br></pre></td></tr></table></figure></p>
<h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for循环嵌套</span></span><br><span class="line"><span class="keyword">for</span> ((i=1; i&lt;9; i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">for</span> ((j=1; j&lt;=9; j++))</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">"multi=<span class="variable">$i</span>*<span class="variable">$j</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$i</span>*<span class="variable">$j</span>=<span class="variable">$multi</span> "</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># while循环嵌套</span></span><br><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [[ <span class="string">"<span class="variable">$i</span>"</span> -le <span class="string">"9"</span> ]]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> j=1</span><br><span class="line"> <span class="keyword">while</span> [[ <span class="string">"<span class="variable">$j</span>"</span> -le <span class="string">"9"</span> ]]</span><br><span class="line"> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">"multi=<span class="variable">$i</span>*<span class="variable">$j</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$i</span>*<span class="variable">$j</span>=<span class="variable">$multi</span> "</span></span><br><span class="line">    <span class="built_in">let</span> <span class="string">"j+=1"</span></span><br><span class="line"> <span class="keyword">done</span></span><br><span class="line"> <span class="built_in">echo</span></span><br><span class="line"> <span class="built_in">let</span> <span class="string">"i+=1"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><h4 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h4><p>break用于终止当前整个循环体。一般情况下，break都是和if判断语句一起使用的，当if条件满足时使用break终止循环。</p>
<h4 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h4><p>continue并不会终止当前的整个循环体，它只是提前结束本次循环，而循环体还将继续执行；而break则会结束整个循环体。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数基本使用"><a href="#函数基本使用" class="headerlink" title="函数基本使用"></a>函数基本使用</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat checkFileExist.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">FILE=/etc/notExistFile  <span class="comment">#定义一个不存在的文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">checkFileExist</span></span>()&#123;              <span class="comment">#定义checkFileExist函数</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="variable">$FILE</span> ]; <span class="keyword">then</span></span><br><span class="line">           <span class="built_in">return</span> 0</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">           <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Call function checkFileExist"</span>     <span class="comment">#提示函数调用</span></span><br><span class="line">checkFileExist                          <span class="comment">#调用函数</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">       <span class="built_in">echo</span> <span class="string">"<span class="variable">$FILE</span> exist"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">       <span class="built_in">echo</span> <span class="string">"<span class="variable">$FILE</span> not exist"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行结果</span></span><br><span class="line"><span class="comment"># bash checkFileExist.sh</span></span><br><span class="line">Call <span class="keyword">function</span> checkFileExist</span><br><span class="line">/etc/notExistFile not exist             <span class="comment">#这里是调用函数的输出内容</span></span><br></pre></td></tr></table></figure>
<h3 id="带参数的函数-1-2-N…"><a href="#带参数的函数-1-2-N…" class="headerlink" title="带参数的函数($1, $2, $N…)"></a>带参数的函数($1, $2, $N…)</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat power.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">power</span></span>()&#123;</span><br><span class="line">    RESULT=1</span><br><span class="line">    LOOP=0</span><br><span class="line">    <span class="keyword">while</span> [[ <span class="string">"<span class="variable">$LOOP</span>"</span> -lt <span class="variable">$2</span> ]]</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">           <span class="built_in">let</span> <span class="string">"RESULT=RESULT*<span class="variable">$1</span>"</span></span><br><span class="line">           <span class="built_in">let</span> <span class="string">"LOOP=LOOP+1"</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$RESULT</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Call function power with parameters"</span></span><br><span class="line">power <span class="variable">$1</span> <span class="variable">$2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算2的2次方</span></span><br><span class="line"><span class="comment"># bash power.sh 2 2</span></span><br><span class="line">Call <span class="keyword">function</span> power with parameters</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算3的3次方</span></span><br><span class="line"><span class="comment"># bash power.sh 3 3</span></span><br><span class="line">Call <span class="keyword">function</span> power with parameters</span><br><span class="line">27</span><br></pre></td></tr></table></figure>
<h3 id="函数库"><a href="#函数库" class="headerlink" title="函数库"></a>函数库</h3><h4 id="自定义函数库"><a href="#自定义函数库" class="headerlink" title="自定义函数库"></a>自定义函数库</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat lib01.sh</span></span><br><span class="line"><span class="function"><span class="title">checkFileExists</span></span>()&#123;</span><br><span class="line">   <span class="keyword">if</span> [ -f <span class="variable">$1</span> ]; <span class="keyword">then</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="string">"File:<span class="variable">$1</span> exists"</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="string">"File:<span class="variable">$1</span> not exist"</span></span><br><span class="line">   <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat callLib01.sh （函数库）</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">source</span> ./lib01.sh    <span class="comment">#引用当前目录下的lib01.sh函数库</span></span><br><span class="line">_checkFileExists /etc/notExistFile <span class="comment">#调用函数库中的函数</span></span><br><span class="line">_checkFileExists /etc/passwd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行结果</span></span><br><span class="line"><span class="comment"># bash callLib01.sh</span></span><br><span class="line">File:/etc/notExistFile not exist</span><br><span class="line">File:/etc/passwd exists</span><br></pre></td></tr></table></figure>
<h4 id="函数库-etc-init-d-functions"><a href="#函数库-etc-init-d-functions" class="headerlink" title="函数库/etc/init.d/functions"></a>函数库/etc/init.d/functions</h4><p>很多Linux发行版中都有/etc/init.d目录，这是系统中放置所有开机启动脚本的目录，这些开机脚本在脚本开始运行时都会加载/etc/init.d/functions或/etc/rc.d/init.d/functions函数库（实际上这两个函数库的内容是完全一样的）<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat callFunctions01.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">source</span> /etc/init.d/<span class="built_in">functions</span></span><br><span class="line">confirm ITEM</span><br><span class="line"><span class="keyword">if</span> [[ $? -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">       <span class="built_in">echo</span> <span class="string">"ITEM confirmed"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">       <span class="built_in">echo</span> <span class="string">"ITEM not confirmed"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果</span></span><br><span class="line"><span class="comment"># bash callFunctions01.sh</span></span><br><span class="line">Start service ITEM (Y)es/(N)o/(C)ontinue? [Y] Y</span><br><span class="line">ITEM confirmed</span><br><span class="line"></span><br><span class="line"><span class="comment"># bash callFunctions01.sh</span></span><br><span class="line">Start service ITEM (Y)es/(N)o/(C)ontinue? [Y] N</span><br><span class="line">ITEM not confirmed</span><br></pre></td></tr></table></figure></p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>I/O重定向是重定向中的一个重要部分，在Shell编程中会有很多机会用到这个功能。简单来说，I/O重定向可以将任何文件、命令、脚本、程序或脚本的输出重定向到另外一个文件、命令、程序或脚本。</p>
<h3 id="io重定向符号和用法"><a href="#io重定向符号和用法" class="headerlink" title="io重定向符号和用法"></a>io重定向符号和用法</h3><p><img src="/img/linux6.jpeg" style="max-width:95%"></p>
<h4 id="1-标准输出覆盖重定向：-gt"><a href="#1-标准输出覆盖重定向：-gt" class="headerlink" title="1.标准输出覆盖重定向：&gt;"></a>1.标准输出覆盖重定向：&gt;</h4><p>使用标准输出覆盖重定向符号可以将原本输出到显示器上的内容重定向到一个文件中<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比如使用ls-l可以列出指定目录中文件的详细信息，</span></span><br><span class="line"><span class="comment"># 但是如果想把结果保存到文件中以便日后查看，</span></span><br><span class="line"><span class="comment"># 则可以使用标准输出覆盖重定向符</span></span><br><span class="line">ls -l /usr/&gt; ls_usr.txt</span><br></pre></td></tr></table></figure></p>
<p><em>如果指定的重定向文件不存在，则命令会先创建这个文件，如果文件存在且内容不为空，则原文件内容将被全部清空。所以有时候需要先判断该文件是否存在，以避免不小心破坏了原有文件内容</em></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果某命令的输出既有标准输出，又有标准错误输出，</span></span><br><span class="line"><span class="comment"># 则可以分别指定不同标识符的内容输出到不同的文件中</span></span><br><span class="line">COMMAND 1&gt;stdout.txt 2&gt;stderr.txt</span><br></pre></td></tr></table></figure>
<h4 id="2-标准输出追加重定向：-gt-gt"><a href="#2-标准输出追加重定向：-gt-gt" class="headerlink" title="2.标准输出追加重定向：&gt;&gt;"></a>2.标准输出追加重定向：&gt;&gt;</h4><p>该符号用法和&gt;完全一致，不同的只是如果指定的重定向文件存在且内容不为空，重定向并不会清空原文件内容，而是将命令的输出新增到原文件的尾部<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l /usr/&gt;&gt;append.txt</span><br><span class="line">ls -l /tmp/&gt;&gt;append.txt</span><br></pre></td></tr></table></figure></p>
<h4 id="3-标识输出重定向：-gt-amp"><a href="#3-标识输出重定向：-gt-amp" class="headerlink" title="3.标识输出重定向：&gt;&amp;"></a>3.标识输出重定向：&gt;&amp;</h4><p>标识输出重定向的作用是将一个标识的输出重定向到另一个标识的输入。比如想要将标准输出和标准错误同时定向到同一个文件中。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行COMMAND命令，将标准输出的内容重定向到stdout_stderr.txt中，</span></span><br><span class="line"><span class="comment"># 如果有标准错误输出也同时重定向到该文件中</span></span><br><span class="line">COMMAND &gt; stdout_stderr.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<p>很多时候大家并不会在意错误输出，特别是一些系统后台任务可能在每天凌晨运行，这时出现的错误输出可能并不是系统管理员所关心的，所以也没有必要将错误输出保存到任何文件中。这时可以利用系统中的一个特殊设备/dev/null，将所有错误输出重定向到该设备中—系统会将任何输入到该设备的内容全部删除（就像一个宇宙黑洞）<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMAND &gt; stdout.txt 2&gt; /dev/null</span><br></pre></td></tr></table></figure></p>
<h4 id="4-标准输入重定向：-lt"><a href="#4-标准输入重定向：-lt" class="headerlink" title="4.标准输入重定向：&lt;"></a>4.标准输入重定向：&lt;</h4><p>标准输入重定向可以将原本应由从标准输入设备中读取的内容转由文件内容输入，也就是将文件内容写入标准输入中<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例二：给sort的标准输入重定向</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat fruit01.txt</span></span><br><span class="line">banana</span><br><span class="line">apple</span><br><span class="line">carrot</span><br><span class="line">[root@localhost ~]<span class="comment"># sort &lt; fruit01.txt</span></span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">carrot</span><br></pre></td></tr></table></figure></p>
<h4 id="5-管道："><a href="#5-管道：" class="headerlink" title="5.管道：|"></a>5.管道：|</h4><p>简单地说管道就是将一个命令的输出作为另一个命令的输入，借此方式可通过多个简单命令的共同协作来完成较为复杂的工作</p>
<h3 id="使用exec"><a href="#使用exec" class="headerlink" title="使用exec"></a>使用exec</h3><p>exec是Shell的内建命令，执行这个命令时系统不会启动新的Shell，而是用要被执行的命令替换当前的Shell进程。因此假设在一个Shell中执行exec ls，则在列出当前目录后该Shell进程将会主动退出。如果使用ssh进行远程连接，则当前连接也会在执行完这个命令后断开</p>
<h3 id="Here-Document"><a href="#Here-Document" class="headerlink" title="Here Document"></a>Here Document</h3><p>Here Document又称此处文档，用于在命令或脚本中按行输入文本。HereDocument的格式为&lt;&lt;delimiter，其中delimiter是一个用于标注的“分隔符”，该分隔符后所有的输入都被当作是输入的文本，直到出现下一个分隔符为止<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sort &lt;&lt; END</span><br><span class="line">&gt; banner</span><br><span class="line">&gt; apple</span><br><span class="line">&gt; carrot</span><br><span class="line">&gt; END</span><br><span class="line">apple</span><br><span class="line">banner</span><br><span class="line">carrot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再以cat命令为例，要将输入的内容保存到HelloWorld02.txt中</span></span><br><span class="line">cat &gt;&gt; HelloWorld02.txt &lt;&lt; END</span><br><span class="line">&gt; Hello</span><br><span class="line">&gt; World</span><br><span class="line">&gt; END</span><br><span class="line">cat HelloWorld02.txt</span><br><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure></p>
<h2 id="shell脚本范例"><a href="#shell脚本范例" class="headerlink" title="shell脚本范例"></a>shell脚本范例</h2>
        
        <div id="comment-container">
        </div>
    </div>

    <div style="position:fixed;right:10px;bottom:15px;color: #999;cursor: pointer;" onclick="window.scrollTo(0,0)">回到顶部</div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/fanky-c">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p style="padding-top:10px;">
        <span>/</span>
        
            
               <span><a href="http://www.fankyc.cn">fanky_c</a></span>
            
        <span>/</span>
        
            
               <span><a href="https://beian.miit.gov.cn" target="_blank">粤ICP备19149804号</a></span>
            
        <span>/</span>
        
            
               <span><a href="#">It helps SEO</a></span>
            
        <span>/</span>
        
    </p>
    
    <p style="padding-top:5px;">
        <!--<span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>-->
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a>
    </p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<!-- <script async src="//cdn.jsdelivr.net/gh/sukkaw/busuanzi@2.3/bsz.pure.mini.js"></script> -->

</html>
