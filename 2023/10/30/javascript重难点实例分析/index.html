<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <!--  禁止百度引擎抓取 -->
    <meta name="Baiduspider" content="noarchive">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="js、nodejs、css、nginx、vue、react">
    <meta name="keyword" content="网易">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        javascript重难点实例分析 - fanky_c的博客 | fanky_c&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>fanky_c</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、javascript重点概念"><span class="toc-text">1、javascript重点概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-javascript的基本数据类型介绍"><span class="toc-text">1.1 javascript的基本数据类型介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-Undefined类型"><span class="toc-text">1.1.1 Undefined类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-Null类型"><span class="toc-text">1.1.2 Null类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-Undefined和Null两种类型的异同"><span class="toc-text">1.1.3  Undefined和Null两种类型的异同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-Boolean类型"><span class="toc-text">1.1.4 Boolean类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Number类型"><span class="toc-text">1.2 Number类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-Number类型转换"><span class="toc-text">1.2.1  Number类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-1-Number-函数"><span class="toc-text">1.2.1.1 Number()函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-2-parseInt-函数"><span class="toc-text">1.2.1.2 parseInt()函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-3-parseFloat-函数"><span class="toc-text">1.2.1.3 parseFloat()函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-4-结论"><span class="toc-text">1.2.1.4  结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-isNaN-函数与Number-isNaN-函数对比"><span class="toc-text">1.2.2 isNaN()函数与Number.isNaN()函数对比</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-1-isNaN-函数"><span class="toc-text">1.2.2.1 isNaN()函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-2-Number-isNaN-函数"><span class="toc-text">1.2.2.2 Number.isNaN()函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-3-总结"><span class="toc-text">1.2.2.3 总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-浮点型运算"><span class="toc-text">1.2.3 浮点型运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-1-浮点运算不准确原因"><span class="toc-text">1.2.3.1 浮点运算不准确原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-2-浮点运算计算过程"><span class="toc-text">1.2.3.2 浮点运算计算过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-3-解决方案"><span class="toc-text">1.2.3.3  解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-String类型"><span class="toc-text">1.3 String类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-String类型的定义与调用"><span class="toc-text">1.3.1 String类型的定义与调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-String类型常见算法"><span class="toc-text">1.3.2 String类型常见算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-1-字符串逆序输出"><span class="toc-text">1.3.2.1  字符串逆序输出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-2-统计字符串中出现次数最多的字符及出现的次数"><span class="toc-text">1.3.2.2 统计字符串中出现次数最多的字符及出现的次数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-3-去除字符串中重复的字符"><span class="toc-text">1.3.2.3 去除字符串中重复的字符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-4-判断一个字符串是否为回文字符串"><span class="toc-text">1.3.2.4  判断一个字符串是否为回文字符串</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-运算符"><span class="toc-text">1.4 运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、引用数据类型"><span class="toc-text">2、引用数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、函数"><span class="toc-text">3、函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、对象"><span class="toc-text">4、对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、DOM与事件"><span class="toc-text">5、DOM与事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、Ajax"><span class="toc-text">6、Ajax</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、ES6"><span class="toc-text">7、ES6</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        javascript重难点实例分析
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2023-10-30 20:09:46</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#js难点" title="js难点">js难点</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#js重点" title="js重点">js重点</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h2 id="1、javascript重点概念"><a href="#1、javascript重点概念" class="headerlink" title="1、javascript重点概念"></a>1、javascript重点概念</h2><h3 id="1-1-javascript的基本数据类型介绍"><a href="#1-1-javascript的基本数据类型介绍" class="headerlink" title="1.1 javascript的基本数据类型介绍"></a>1.1 javascript的基本数据类型介绍</h3><p><strong>基本数据类型：Undefined、Null、Boolean、Number、String、Symbol</strong></p>
<p><strong>引用数据类型：Object、Function、Array、Date等类型</strong></p>
<h4 id="1-1-1-Undefined类型"><a href="#1-1-1-Undefined类型" class="headerlink" title="1.1.1 Undefined类型"></a>1.1.1 Undefined类型</h4><p>Undefined类型只有一个唯一的字面值undefined，表示的是一个变量不存在。</p>
<p>下面是4种常见的出现undefined的场景：</p>
<ol>
<li>使用只声明而未初始化的变量时，会返回“undefined”。</li>
<li>获取一个对象的某个不存在的属性（自身属性和原型链继承属性）时，会返回“undefined”。</li>
<li>函数没有明确的返回值时，却在其他地方使用了返回值，会返回“undefined”。</li>
<li>函数定义时使用了多个形式参数（后文简称为形参），而在调用时传递的参数的数量少于形参数量，那么未匹配上的参数就为“undefined”</li>
</ol>
<h4 id="1-1-2-Null类型"><a href="#1-1-2-Null类型" class="headerlink" title="1.1.2 Null类型"></a>1.1.2 Null类型</h4><p>Null类型只有一个唯一的字面值null，表示一个空指针对象，这也是在使用typeof运算符检测null值时会返回“object”的原因.</p>
<p>下面是3种常见的出现null的场景:</p>
<ol>
<li>一般情况下，如果声明的变量是为了以后保存某个值，则应该在声明时就将其赋值为“null”。</li>
<li>JavaScript在获取DOM元素时，如果没有获取到指定的元素对象，就会返回“null”。</li>
<li>在使用正则表达式进行捕获时，如果没有捕获结果，就会返回“null”。</li>
</ol>
<h4 id="1-1-3-Undefined和Null两种类型的异同"><a href="#1-1-3-Undefined和Null两种类型的异同" class="headerlink" title="1.1.3  Undefined和Null两种类型的异同"></a>1.1.3  Undefined和Null两种类型的异同</h4><p>相同点：</p>
<ol>
<li>Undefined和Null两种数据类型都只有一个字面值，分别是undefined和null。</li>
<li>Undefined类型和Null类型在转换为Boolean类型的值时，都会转换为false。所以通过非运算符（！）获取结果为true的变量时，无法判断其值为undefined还是null。</li>
<li>在需要将两者转换成对象时，都会抛出一个TypeError的异常，也就是平时最常见的引用异常。</li>
<li>Undefined类型派生自Null类型，所以在非严格相等的情况下，两者是相等的，如下面代码所示。</li>
</ol>
<p>不同点：</p>
<ol>
<li>null是JavaScript中的关键字，而undefined是JavaScript中的一个全局变量，即挂载在window对象上的一个变量，并不是关键字。</li>
<li>在使用typeof运算符检测时，Undefined类型的值会返回“undefined”，而Null类型的值会返回“object”。</li>
<li>在通过call调用toString()函数时，Undefined类型的值会返回“[object Undefined]”，而Null类型的值会返回“[object Null]”。</li>
<li>在需要进行数值类型的转换时，undefined会转换为NaN，无法参与计算；null会转换为0，可以参与计算。</li>
<li>无论在什么情况下都没有必要将一个变量显式设置为undefined。如果需要定义某个变量来保存将来要使用的对象，应该将其初始化为null。这样不仅能将null作为空对象指针的惯例，还有助于区分null和undefined。</li>
</ol>
<h4 id="1-1-4-Boolean类型"><a href="#1-1-4-Boolean类型" class="headerlink" title="1.1.4 Boolean类型"></a>1.1.4 Boolean类型</h4><p>（1）String类型转换为Boolean类型</p>
<ol>
<li>空字符串””或者’’都会转换为false。</li>
<li>任何非空字符串都会转换为true，包括只有空格的字符串” “。</li>
</ol>
<p>（2）Object类型转换为Boolean类型</p>
<ol>
<li>当object为null时，会转换为false。</li>
<li>如果object不为null，则都会转换为true，包括空对象{}。</li>
</ol>
<h3 id="1-2-Number类型"><a href="#1-2-Number类型" class="headerlink" title="1.2 Number类型"></a>1.2 Number类型</h3><p>在JavaScript中，Number类型的数据既包括了整型数据，也包括了浮点型数据。</p>
<p>① 八进制：如果想要用八进制表示一个数值，那么首位必须是0，其他位必须是0～7的八进制序列。如果后面位数的字面值大于7，则破坏了八进制数据表示规则，前面的0会被忽略，当作十进制数据处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">024</span>; <span class="comment">// 20  2*8+4*1</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">079</span>; <span class="comment">// 79  最后一位9超出了八进制字面值，所以不属于八进制数据，最终按照十进制处理，结果为79。</span></span><br></pre></td></tr></table></figure>
<p>② 十六进制: 如果想要用十六进制表示一个数值，那么前两位必须是0x，其他位必须是十六进制序列（0～9，a～f或者A～F）。如果超过了十六进制序列，则会抛出异常。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num3 = <span class="number">0x3f</span>;  <span class="comment">// 63  3×16+15</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="number">0x2</span>g;  <span class="comment">// SyntaxError: Invalid or unexpected token 最后一位g超出了十六进制所能表示的字面值区间，所以不满足十六进制数据表示规则</span></span><br></pre></td></tr></table></figure>
<p><strong>Null类型转换为Number类型</strong></p>
<p>Null类型只有一个字面值null，直接转换为0。</p>
<p><strong>Undefined类型转换为Number类型</strong></p>
<p>Undefined类型只有一个字面值undefined，直接转换为NaN。</p>
<p><strong>Object类型转换为Number类型</strong></p>
<p>Object类型在转换为Number类型时，会优先调用valueOf()函数，然后通过valueOf()函数的返回值按照上述规则进行转换。如果转换的结果是NaN，则调用toString()函数，通过toString()函数的返回值重新按照上述规则进行转换；如果有确定的Number类型返回值，则结束，否则返回“NaN”。</p>
<h4 id="1-2-1-Number类型转换"><a href="#1-2-1-Number类型转换" class="headerlink" title="1.2.1  Number类型转换"></a>1.2.1  Number类型转换</h4><h5 id="1-2-1-1-Number-函数"><a href="#1-2-1-1-Number-函数" class="headerlink" title="1.2.1.1 Number()函数"></a>1.2.1.1 Number()函数</h5><p>Number()函数可以用于将任何类型转换为Number类型，它在转换时遵循下列规则。</p>
<p>① 如果是数字，会按照对应的进制数据格式，统一转换为十进制并返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="number">10</span>);    <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">010</span>);   <span class="comment">// 8，010是八进制的数据，转换成十进制是8</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">0x10</span>);  <span class="comment">// 16，0x10是十六进制数据，转换成十进制是16</span></span><br></pre></td></tr></table></figure>
<p>② 如果是Boolean类型的值，true将返回为“1”，false将返回为“0”。</p>
<p>③ 如果值为null，则返回“0”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>④ 如果值为undefined，则返回“NaN”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(undeﬁned); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>⑤ 如果值为字符串类型，则遵循下列规则。</p>
<p>· 如果该字符串只包含数字，则会直接转换成十进制数；如果数字前面有0，则会直接忽略这个0。</p>
<p>· 如果字符串是有效的浮点数形式，则会直接转换成对应的浮点数，前置的多个重复的0会被清空，只保留一个。</p>
<p>· 如果字符串是有效的十六进制形式，则会转换为对应的十进制数值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'0x12'</span>); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'0x21'</span>); <span class="comment">// 33</span></span><br></pre></td></tr></table></figure>
<p>· 如果字符串是有效的八进制形式，则不会按照八进制转换，而是直接按照十进制转换并输出，因为前置的0会被直接忽略。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'010'</span>);   <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'0020'</span>);  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>⑥ 如果值为对象类型，则会先调用对象的valueOf()函数获取返回值，并将返回值按照上述步骤重新判断能否转换为Number类型。如果都不满足，则会调用对象的toString()函数获取返回值，并将返回值重新按照步骤判断能否转换成Number类型。如果也不满足，则返回“NaN”。</p>
<p><strong>以下是通过valueOf()函数将对象正确转换成Number类型的示例。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">   age: <span class="number">21</span>,</span><br><span class="line">   valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">   &#125;,</span><br><span class="line">   toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'good'</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(obj);  <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>
<p><strong>以下是通过toString()函数将对象正确转换成Number类型的示例。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ar obj = &#123;</span><br><span class="line">   age: <span class="string">'21'</span>,</span><br><span class="line">   valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> [];</span><br><span class="line">   &#125;,</span><br><span class="line">   toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(obj);  <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>
<p><strong>以下示例是通过valueOf()函数和toString()函数都无法将对象转换成Number类型的示例（最后返回“NaN”）。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">   age: <span class="string">'21'</span>,</span><br><span class="line">   valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">'a'</span>;</span><br><span class="line">   &#125;,</span><br><span class="line">   toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">'b'</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(obj);  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p><strong>如果toString()函数和valueOf()函数返回的都是对象类型而无法转换成基本数据类型，则会抛出类型转换的异常。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">   age: <span class="string">'21'</span>,</span><br><span class="line">   valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> [];</span><br><span class="line">   &#125;,</span><br><span class="line">   toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> [];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(obj);  <span class="comment">// 抛出异常TypeError: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure>
<h5 id="1-2-1-2-parseInt-函数"><a href="#1-2-1-2-parseInt-函数" class="headerlink" title="1.2.1.2 parseInt()函数"></a>1.2.1.2 parseInt()函数</h5><p>在使用parseInt()函数将字符串转换成整数时，需要注意以下5点。</p>
<ul>
<li>（1）非字符串类型转换为字符串类型</li>
</ul>
<p>如果遇到传入的参数是非字符串类型的情况，则需要将其优先转换成字符串类型，即使传入的是整型数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0x12'</span>, <span class="number">16</span>);  <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x12</span>, <span class="number">16</span>);    <span class="comment">// 24</span></span><br></pre></td></tr></table></figure>
<p>第一条语句直接将字符串”0x12”转换为十六进制数，得到的结果为1×16+2=18；</p>
<p>第二条语句由于传入的是十六进制数，所以会先转换成十进制数18，然后转换成字符串”18”，再将字符串”18”转换成十六进制数，得到的结果为1×16+8=24。</p>
<ul>
<li>（2）数据截取的前置匹配原则</li>
</ul>
<p>parseInt()函数在做转换时，对于传入的字符串会采用前置匹配的原则。即从字符串的第一个字符开始匹配，如果处于基数指定的范围，则保留并继续往后匹配满足条件的字符，直到某个字符不满足基数指定的数据范围，则从该字符开始，舍弃后面的全部字符。在获取到满足条件的字符后，将这些字符转换为整数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">"fg123"</span>, <span class="number">16</span>);  <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>对于字符串’fg123’，首先从第一个字符开始，’f’是满足十六进制的数据，因为十六进制数据范围是0～9，a～f(A～F)，所以保留’f’；然后是第二个字符’g’，它不满足十六进制数据范围，因此从第二个字符至最后一个字符全部舍弃，最终字符串只保留字符’f’；然后将字符’f’转换成十六进制的数据，为15，因此最后返回的结果为“15”。</p>
<p>如果遇到的字符串是以”0x”开头的，那么在按照十六进制处理时，会计算后面满足条件的字符串；如果按照十进制处理，则会直接返回“0”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0x12'</span>,<span class="number">16</span>);   <span class="comment">// 18 = 16 + 2</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0x12'</span>,<span class="number">10</span>);   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>需要注意的一点是，如果传入的字符串中涉及算术运算，则不执行，算术符号会被当作字符处理；如果传入的参数是算术运算表达式，则会先运算完成得到结果，再参与parseInt()函数的计算。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">15</span> * <span class="number">3</span>, <span class="number">10</span>);   <span class="comment">// 45，先运算完成得到45，再进行parseInt(45, 10)的运算</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'15 * 3'</span>, <span class="number">10</span>); <span class="comment">// 15，直接当作字符串处理，并不会进行乘法运算</span></span><br></pre></td></tr></table></figure>
<ul>
<li>（3）对包含字符e的不同数据的处理差异</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">6e3</span>, <span class="number">10</span>);     <span class="comment">// 6000</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">6e3</span>, <span class="number">16</span>);      <span class="comment">// 24576</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'6e3'</span>, <span class="number">10</span>);    <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'6e3'</span>, <span class="number">16</span>);     <span class="comment">// 1763</span></span><br></pre></td></tr></table></figure>
<p>第一条语句parseInt(6e3, 10)，首先会执行6e3=6000，然后转换为字符串”6000”，实际执行的语句是parseInt(‘6000’, 10)，表示的是将字符串”6000”转换为十进制的整数，得到的结果为6000。</p>
<p>第二条语句parseInt(6e3, 16)，首先会执行6e3=6000，然后转换为字符串”6000”，实际执行的语句是parseInt(‘6000’, 16)，表示的是将字符串”6000”转换为十六进制的数，得到的结果是6×163 = 24576。</p>
<p>第三条语句parseInt(‘6e3’, 10)，表示的是将字符串’6e3’转换为十进制的整数，因为字符’e’不在十进制所能表达的范围内，所以会直接省略，实际处理的字符串只有”6”，得到的结果为6。</p>
<p>第四条语句parseInt(‘6e3’, 16)，表示的是将字符串’6e3’转换为十六进制的整数，因为字符’e’在十六进制所能表达的范围内，所以会转换为14进行计算，最后得到的结果为6×162 +14×16 + 3 = 1763。</p>
<ul>
<li>（4）对浮点型数的处理</li>
</ul>
<p>如果传入的值是浮点型数，则会忽略小数点及后面的数，直接取整。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'6.01'</span>, <span class="number">10</span>); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'6.99'</span>, <span class="number">10</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>经过上面的详细分析，我们再来看看以下语句的执行结果。以下语句都会返回“15”，这是为什么呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">"0xF"</span>, <span class="number">16</span>);    <span class="comment">// 十六进制的F为15，返回“15”</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"F"</span>, <span class="number">16</span>);      <span class="comment">// 十六进制的F为15，返回“15”</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"17"</span>, <span class="number">8</span>);      <span class="comment">// 八进制的"17"，返回结果为1×8 + 7 = 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">021</span>, <span class="number">8</span>);      <span class="comment">// 021先转换成十进制得到17，然后转换成字符串"17"，再转换成八进制，返回结果为1×8 + 7 = 15</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"015"</span>, <span class="number">10</span>);   <span class="comment">// 前面的0忽略，返回“15”</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">15.99</span>, <span class="number">10</span>);   <span class="comment">// 直接取整，返回“15”</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"15,123"</span>, <span class="number">10</span>); <span class="comment">// 字符串"15,123"一一匹配，得到"15"，转换成十进制后返回“15”</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"FXX123"</span>, <span class="number">16</span>); <span class="comment">// 字符串"FXX123"一一匹配，得到"F"，转换成十六进制后返回“15”</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"1111"</span>, <span class="number">2</span>);    <span class="comment">// 1×23 + 1×22 + 1×2 + 1 = 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"15 * 3"</span>, <span class="number">10</span>); <span class="comment">// 字符串中并不会进行算术运算，实际按照"15"进行计算，返回“15”</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"15e2"</span>, <span class="number">10</span>);   <span class="comment">// 实际按照字符串"15"运算，返回“15”</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"15px"</span>, <span class="number">10</span>);   <span class="comment">// 实际按照字符串"15"运算，返回“15”</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"12"</span>, <span class="number">13</span>);     <span class="comment">// 按照十三进制计算，返回结果为1×13 + 2 = 15</span></span><br></pre></td></tr></table></figure>
<ul>
<li>（5）map()函数与parseInt()函数的隐形坑</li>
</ul>
<p>设想这样一个场景，存在一个数组，数组中的每个元素都是Number类型的字符串[‘1’,’2’, ‘3’, ‘4’]，如果我们想要将数组中的元素全部转换为整数，我们该怎么做呢？</p>
<p>我们可能会想到在Array的map()函数中调用parseInt()函数，代码如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = arr.map(<span class="built_in">parseInt</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p>但是在运行后，得到的结果是[1, NaN, NaN, NaN]，与我们期望的结果[1, 2, 3, 4]差别很大，这是为什么呢？</p>
<p>上面的代码实际与下面的代码等效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">val, index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(val, index);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>);  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>);  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'4'</span>, <span class="number">3</span>);  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>任何整数以0为基数取整时，都会返回本身，所以第一行代码会返回“1”。</p>
<h5 id="1-2-1-3-parseFloat-函数"><a href="#1-2-1-3-parseFloat-函数" class="headerlink" title="1.2.1.3 parseFloat()函数"></a>1.2.1.3 parseFloat()函数</h5><p>① 如果在解析过程中遇到了正负号（+ / -）、数字0～9、小数点或者科学计数法（e / E）以外的字符，则会忽略从该字符开始至结束的所有字符，然后返回当前已经解析的字符的浮点数形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'+1.2'</span>);   <span class="comment">// 1.2</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'-1.2'</span>);   <span class="comment">// -1.2</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'++1.2'</span>);  <span class="comment">// NaN，符号不能连续出现</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'--1.2'</span>);  <span class="comment">// NaN，符号不能连续出现</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'1+1.2'</span>);  <span class="comment">// 1，'+'出现在第二位，不会当作符号位处理</span></span><br></pre></td></tr></table></figure>
<p>② 字符串前面的空白符会直接忽略，如果第一个字符就无法解析，则会直接返回“NaN”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'  1.2'</span>); <span class="comment">// 1.2</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'f1.2'</span>);  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>③ 对于字符串中出现的合法科学运算符e，进行运算处理后会转换成浮点型数，这点与parseInt()函数的处理有很大的不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'4e3'</span>);   <span class="comment">// 4000</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'4e3'</span>, <span class="number">10</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>④ 对于小数点，只能正确匹配第一个，第二个小数点是无效的，它后面的字符也都将被忽略。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'11.20'</span>);  <span class="comment">// 11.2</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'11.2.1'</span>); <span class="comment">// 11.2</span></span><br></pre></td></tr></table></figure>
<p>下面是使用parseFloat()函数的综合实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">"123AF"</span>);   <span class="comment">// 123，匹配字符串'123'</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">"0xA"</span>);     <span class="comment">// 0，匹配字符串'0'</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">"22.5"</span>);    <span class="comment">// 22.5，匹配字符串'22.5'</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">"22.3.56"</span>); <span class="comment">// 22.3，匹配字符串'22.3'</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">"0908.5"</span>);  <span class="comment">// 908.5，匹配字符串'908.5'</span></span><br></pre></td></tr></table></figure>
<h5 id="1-2-1-4-结论"><a href="#1-2-1-4-结论" class="headerlink" title="1.2.1.4  结论"></a>1.2.1.4  结论</h5><p>· Number()函数转换的是传入的整个值，并不是像parseInt()函数和parseFloat()函数一样会从首位开始匹配符合条件的值。如果整个值不能被完整转换，则会返回“NaN”。</p>
<p>· parseFloat()函数在解析小数点时，会将第一个小数点当作有效字符，而parseInt()函数在解析时如果遇到小数点会直接停止，因为小数点不是整数的一部分。</p>
<p>· parseFloat()函数在解析时没有进制的概念，而parseInt()函数在解析时会依赖于传入的基数做数值转换。</p>
<h4 id="1-2-2-isNaN-函数与Number-isNaN-函数对比"><a href="#1-2-2-isNaN-函数与Number-isNaN-函数对比" class="headerlink" title="1.2.2 isNaN()函数与Number.isNaN()函数对比"></a>1.2.2 isNaN()函数与Number.isNaN()函数对比</h4><p>Number类型数据中存在一个比较特殊的数值NaN（Not a Number），它表示应该返回数值却并未返回数值的情况。</p>
<p>NaN存在的目的是在某些异常情况下保证程序的正常执行。例如0/0，在其他语言中，程序会直接抛出异常，而在JavaScript中会返回“NaN”，程序可以正常执行。</p>
<p><strong>NaN有两个很明显的特点，第一个是任何涉及NaN的操作都会返回“NaN”，第二个是NaN与任何值都不相等，即使是与NaN本身相比。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>;  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>在判断NaN时，ES5提供了isNaN()函数，ECMAScript 6（后续简称ES6）为Number类型增加了静态函数isNaN()。</p>
<h5 id="1-2-2-1-isNaN-函数"><a href="#1-2-2-1-isNaN-函数" class="headerlink" title="1.2.2.1 isNaN()函数"></a>1.2.2.1 isNaN()函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>);            <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(undeﬁned);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;);             <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">true</span>);           <span class="comment">// false，Number(true)会转换成数字1</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">null</span>);           <span class="comment">// false，Number(null)会转换成数字0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">1</span>);              <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">''</span>);             <span class="comment">// false，Number('')会转换为成数字0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">"1"</span>);            <span class="comment">// false，字符串"1"可以转换成数字1</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">"JavaScript"</span>);   <span class="comment">// true，字符串"JavaScript"无法转换成数字Date类型</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="built_in">Date</span>());     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().toString());  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="1-2-2-2-Number-isNaN-函数"><a href="#1-2-2-2-Number-isNaN-函数" class="headerlink" title="1.2.2.2 Number.isNaN()函数"></a>1.2.2.2 Number.isNaN()函数</h5><p>既然在全局环境中有isNaN()函数，为什么在ES6中会专门针对Number类型增加一个isNaN()函数呢？</p>
<p>这是因为isNaN()函数本身存在误导性，而ES6中的Number.isNaN()函数会在真正意义上去判断变量是否为NaN，不会做数据类型转换。只有在传入的值为NaN时，才会返回“true”，传入其他任何类型的值时会返回“false”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>);        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(undeﬁned);   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">null</span>);       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>);       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">''</span>);         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">123</span>);        <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码运行后，除了传入NaN会返回“true”以外，传入其他的值都会返回“false”。如果在非ES6环境中想用ES6中的isNaN()函数，该怎么办呢？我们有以下兼容性处理方案。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 兼容性处理</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">Number</span>.isNaN) &#123;</span><br><span class="line">    <span class="built_in">Number</span>.isNaN = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> n !== n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-2-2-3-总结"><a href="#1-2-2-3-总结" class="headerlink" title="1.2.2.3 总结"></a>1.2.2.3 总结</h5><p>· isNaN()函数在判断是否为NaN时，需要先进行数据类型转换，只有在无法转换为数字时才会返回“true”；</p>
<p>· Number.isNaN()函数在判断是否为NaN时，只需要判断传入的值是否为NaN，并不会进行数据类型转换。</p>
<h4 id="1-2-3-浮点型运算"><a href="#1-2-3-浮点型运算" class="headerlink" title="1.2.3 浮点型运算"></a>1.2.3 浮点型运算</h4><p><strong>在JavaScript中，整数和浮点数都属于Number类型，它们都统一采用64位浮点数进行存储</strong></p>
<p>虽然它们存储数据的方式是一致的，但是在进行数值运算时，却会表现出明显的差异性。整数参与运算时，得到的结果往往会和我们所想的一样，而对于浮点型运算，有时却会出现一些意想不到的结果，如下面的代码所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加法</span></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> = <span class="number">0.30000000000000004</span></span><br><span class="line"><span class="number">0.7</span> + <span class="number">0.1</span> = <span class="number">0.7999999999999999</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 减法</span></span><br><span class="line"><span class="number">1.5</span> - <span class="number">1.2</span> = <span class="number">0.30000000000000004</span></span><br><span class="line"><span class="number">0.3</span> - <span class="number">0.2</span> = <span class="number">0.09999999999999998</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘法</span></span><br><span class="line"><span class="number">0.7</span> * <span class="number">180</span> = <span class="number">125.99999999999999</span></span><br><span class="line"><span class="number">9.7</span> * <span class="number">100</span> = <span class="number">969.9999999999999</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除法</span></span><br><span class="line"><span class="number">0.3</span> / <span class="number">0.1</span> = <span class="number">2.9999999999999996</span></span><br><span class="line"><span class="number">0.69</span> / <span class="number">10</span> = <span class="number">0.06899999999999999</span></span><br></pre></td></tr></table></figure>
<p>得到这样的结果，大家是不是觉得很奇怪呢？0.1 + 0.2为什么不是等于0.3，而是等于0.30000000000000004呢？接下来我们一探究竟。</p>
<h5 id="1-2-3-1-浮点运算不准确原因"><a href="#1-2-3-1-浮点运算不准确原因" class="headerlink" title="1.2.3.1 浮点运算不准确原因"></a>1.2.3.1 浮点运算不准确原因</h5><p>首先我们来看看一个浮点型数在计算机中的表示，它总共长度是64位，其中最高位为符号位，接下来的11位为指数位，最后的52位为小数位，即有效数字的部分。</p>
<p>· 第0位：符号位sign表示数的正负，0表示正数，1表示负数。</p>
<p>· 第1位到第11位：存储指数部分，用e表示。</p>
<p>· 第12位到第63位：存储小数部分（即有效数字），用f表示，如图1-1所示。<br><br><br>  <img src="/img/float.jpeg" alt="浮点运算" height="auto"><br><br><br><strong>因为浮点型数使用64位存储时，最多只能存储52位的小数位，对于一些存在无限循环的小数位浮点数，会截取前52位，从而丢失精度，所以会出现上面实例中的结果。</strong></p>
<h5 id="1-2-3-2-浮点运算计算过程"><a href="#1-2-3-2-浮点运算计算过程" class="headerlink" title="1.2.3.2 浮点运算计算过程"></a>1.2.3.2 浮点运算计算过程</h5><p>接下来以0.1 + 0.2 = 0.30000000000000004的运算为例，看看为什么会得到这个计算结果。</p>
<p>首先将各个浮点数的小数位按照“乘2取整，顺序排列”的方法转换成二进制表示。</p>
<p>具体做法是用2乘以十进制小数，得到积，将积的整数部分取出；然后再用2乘以余下的小数部分，又得到一个积；再将积的整数部分取出，如此推进，直到积中的小数部分为零为止。</p>
<p>然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位，得到最终结果。</p>
<p>0.1转换为二进制表示的计算过程如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> * <span class="number">2</span> = <span class="number">0.2</span> <span class="comment">//取出整数部分0</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> <span class="comment">//取出整数部分0</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> <span class="comment">//取出整数部分0</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> <span class="comment">//取出整数部分1</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> <span class="comment">//取出整数部分1</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> <span class="comment">//取出整数部分0</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> <span class="comment">//取出整数部分0</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> <span class="comment">//取出整数部分1</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> <span class="comment">//取出整数部分1</span></span><br></pre></td></tr></table></figure>
<p>1.2取出整数部分1后，剩余小数为0.2，与这一轮运算的第一位相同，表示这将是一个无限循环的计算过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> <span class="comment">//取出整数部分0</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> <span class="comment">//取出整数部分0</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> <span class="comment">//取出整数部分1</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> <span class="comment">//取出整数部分1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>因此0.1转换成二进制表示为0.0 0011 0011 0011 0011 0011 0011……（无限循环）。</p>
<p>同理对0.2进行二进制的转换，计算过程与上面类似，直接从0.2开始，相比于0.1，少了第一位的0，其余位数完全相同，结果为0.0011 0011 0011 0011 0011 0011……（无限循环）。</p>
<p>将0.1与0.2相加，然后转换成52位精度的浮点型表示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0.0001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span>  <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span>   (<span class="number">0.1</span>)</span><br><span class="line">+ <span class="number">0.0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span>   (<span class="number">0.2</span>)</span><br><span class="line">= <span class="number">0.0100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span> <span class="number">1100</span></span><br></pre></td></tr></table></figure>
<h5 id="1-2-3-3-解决方案"><a href="#1-2-3-3-解决方案" class="headerlink" title="1.2.3.3  解决方案"></a>1.2.3.3  解决方案</h5><p>这里提供一种方法，主要思路是将浮点数先乘以一定的数值转换为整数，通过整数进行运算，然后将结果除以相同的数值转换成浮点数后返回。</p>
<p>下面提供一套用于做浮点数加减乘除运算的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> operationObj = &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 处理传入的参数，不管传入的是数组还是以逗号分隔的参数都处理为数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="variable">args</span></span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@returns <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   getParam(args) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.concat.apply([], args);</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取每个数的乘数因子，根据小数位数计算</span></span><br><span class="line"><span class="comment">    * 1.首先判断是否有小数点，如果没有，则返回1；</span></span><br><span class="line"><span class="comment">    * 2.有小数点时，将小数位数的长度作为Math.pow()函数的参数进行计算</span></span><br><span class="line"><span class="comment">    * 例如2的乘数因子为1，2.01的乘数因子为100</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@returns <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   multiplier(x) &#123;</span><br><span class="line">      <span class="keyword">let</span> parts = x.toString().split(<span class="string">'.'</span>);</span><br><span class="line">      <span class="keyword">return</span> parts.length &lt; <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">Math</span>.pow(<span class="number">10</span>, parts[<span class="number">1</span>].length);</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取多个数据中最大的乘数因子</span></span><br><span class="line"><span class="comment">    * 例如1.3的乘数因子为10，2.13的乘数因子为100</span></span><br><span class="line"><span class="comment">    * 则1.3和2.13的最大乘数因子为100</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@returns <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   correctionFactor() &#123;</span><br><span class="line">       <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">       <span class="keyword">let</span> argArr = <span class="keyword">this</span>.getParam(args);</span><br><span class="line">       <span class="keyword">return</span> argArr.reduce(<span class="function">(<span class="params">accum, next</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">let</span> num = <span class="keyword">this</span>.multiplier(next);</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">Math</span>.max(accum, num);</span><br><span class="line">       &#125;, <span class="number">1</span>);</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 加法运算</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="variable">args</span></span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@returns <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   add(...args) &#123;</span><br><span class="line">       <span class="keyword">let</span> calArr = <span class="keyword">this</span>.getParam(args);</span><br><span class="line">       <span class="comment">// 获取参与运算值的最大乘数因子</span></span><br><span class="line">       <span class="keyword">let</span> corrFactor = <span class="keyword">this</span>.correctionFactor(calArr);</span><br><span class="line">       <span class="keyword">let</span> sum = calArr.reduce(<span class="function">(<span class="params">accum, curr</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="comment">// 将浮点数乘以最大乘数因子，转换为整数参与运算</span></span><br><span class="line">           <span class="keyword">return</span> accum + <span class="built_in">Math</span>.round(curr * corrFactor);</span><br><span class="line">       &#125;, <span class="number">0</span>);</span><br><span class="line">       <span class="comment">// 除以最大乘数因子</span></span><br><span class="line">       <span class="keyword">return</span> sum / corrFactor;</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 减法运算</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="variable">args</span></span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@returns <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   subtract(...args) &#123;</span><br><span class="line">       <span class="keyword">let</span> calArr = <span class="keyword">this</span>.getParam(args);</span><br><span class="line">       <span class="keyword">let</span> corrFactor = <span class="keyword">this</span>.correctionFactor(calArr);</span><br><span class="line">       <span class="keyword">let</span> diﬀ = calArr.reduce(<span class="function">(<span class="params">accum, curr, curIndex</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// reduce()函数在未传入初始值时，curIndex从1开始，第一位参与运算的值需要</span></span><br><span class="line">          <span class="comment">// 乘以最大乘数因子</span></span><br><span class="line">          <span class="keyword">if</span> (curIndex === <span class="number">1</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">Math</span>.round(accum * corrFactor) - <span class="built_in">Math</span>.round(curr * corrFactor);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// accum作为上一次运算的结果，就无须再乘以最大因子</span></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Math</span>.round(accum) - <span class="built_in">Math</span>.round(curr * corrFactor);</span><br><span class="line">       &#125;);</span><br><span class="line">     <span class="comment">// 除以最大乘数因子</span></span><br><span class="line">       <span class="keyword">return</span> diﬀ / corrFactor;</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 乘法运算</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="variable">args</span></span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@returns <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   multiply(...args) &#123;</span><br><span class="line">      <span class="keyword">let</span> calArr = <span class="keyword">this</span>.getParam(args);</span><br><span class="line">      <span class="keyword">let</span> corrFactor = <span class="keyword">this</span>.correctionFactor(calArr);</span><br><span class="line">      calArr = calArr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 乘以最大乘数因子</span></span><br><span class="line">          <span class="keyword">return</span> item * corrFactor;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">let</span> multi = calArr.reduce(<span class="function">(<span class="params">accum, curr</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Math</span>.round(accum) * <span class="built_in">Math</span>.round(curr);</span><br><span class="line">      &#125;, <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 除以最大乘数因子</span></span><br><span class="line">      <span class="keyword">return</span> multi / <span class="built_in">Math</span>.pow(corrFactor, calArr.length);</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 除法运算</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="variable">args</span></span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@returns <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   divide(...args) &#123;</span><br><span class="line">       <span class="keyword">let</span> calArr = <span class="keyword">this</span>.getParam(args);</span><br><span class="line">       <span class="keyword">let</span> quotient = calArr.reduce(<span class="function">(<span class="params">accum, curr</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">let</span> corrFactor = <span class="keyword">this</span>.correctionFactor(accum, curr);</span><br><span class="line">           <span class="comment">// 同时转换为整数参与运算</span></span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">Math</span>.round(accum * corrFactor) / <span class="built_in">Math</span>.round(curr * corrFactor);</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">return</span> quotient;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-String类型"><a href="#1-3-String类型" class="headerlink" title="1.3 String类型"></a>1.3 String类型</h3><p>JavaScript中的String类型（字符串类型）既可以通过双引号””表示，也可以通过单引号’’表示，而且是完全等效的，这点与Java、PHP等语言在字符串的处理上是不同的。</p>
<p><strong>如果是引用类型的数据，则在转换时总是会调用toString()函数，得到不同类型值的字符串表示；如果是基本数据类型，则会直接将字面值转换为字符串表示形式。例如null值和undefined值转换为字符串时，会直接返回字面值，分别是”null”和”undefined”。</strong></p>
<h4 id="1-3-1-String类型的定义与调用"><a href="#1-3-1-String类型的定义与调用" class="headerlink" title="1.3.1 String类型的定义与调用"></a>1.3.1 String类型的定义与调用</h4><p>在JavaScript中，有3种定义字符串的方式，分别是字符串字面量，直接调用String()函数与new String()构造函数。</p>
<ol>
<li>字符串字面量</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello JavaScript'</span>;  <span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">"hello html"</span>;       <span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello css";         // 错误写法，首尾符号不一样</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>直接调用String()函数</li>
</ol>
<p>① 如果是Number类型的值，则直接转换成对应的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="number">123</span>);     <span class="comment">// '123'</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">123.12</span>);  <span class="comment">// '123.12'</span></span><br></pre></td></tr></table></figure>
<p>② 如果是Boolean类型的值，则直接转换成’true’或者’false’。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="literal">true</span>);  <span class="comment">// 'true'</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">false</span>); <span class="comment">// 'false'</span></span><br></pre></td></tr></table></figure>
<p>③ 如果值为null，则返回字符串’null’；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="literal">null</span>);  <span class="comment">// 'null'</span></span><br></pre></td></tr></table></figure>
<p>④ 如果值为undefined，则返回字符串’undefined’；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(undeﬁned); <span class="comment">// 'undeﬁned'</span></span><br></pre></td></tr></table></figure>
<p>⑤ 如果值为字符串，则直接返回字符串本身；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="string">'this is a string'</span>);  <span class="comment">// 'this is a string'</span></span><br></pre></td></tr></table></figure>
<p>⑥ 如果值为引用类型，则会先调用toString()函数获取返回值，将返回值按照上述步骤①～⑤判断能否转换字符串类型，如果都不满足，则会调用对象的valueOf()函数获取返回值，并将返回值重新按照步骤①～⑤判断能否转换成字符串类型，如果也不满足，则会抛出类型转换的异常。</p>
<p>以下是通过toString()函数将对象正确转换成String类型的示例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">   age: <span class="number">21</span>,</span><br><span class="line">   valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">   &#125;,</span><br><span class="line">   toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">'good'</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">String</span>(obj);  <span class="comment">// 'good'</span></span><br></pre></td></tr></table></figure>
<p>以下是通过valueOf()函数将对象正确转换成String类型的示例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">   age: <span class="string">'21'</span>,</span><br><span class="line">   valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">   &#125;,</span><br><span class="line">   toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> [];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">String</span>(obj);  <span class="comment">// '21'</span></span><br></pre></td></tr></table></figure>
<p>如果toString()函数和valueOf()函数返回的都是对象类型而无法转换成原生类型时，则会抛出类型转换的异常:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">   age: <span class="string">'21'</span>,</span><br><span class="line">   valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> [];</span><br><span class="line">   &#125;,</span><br><span class="line">   toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> [];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">String</span>(obj);  <span class="comment">// 抛出异常TypeError: Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>new String()构造函数</li>
</ol>
<p>new String()构造函数使用new运算符生成String类型的实例，对于传入的参数同样采用和上述String()函数一样的类型转换策略，最后的返回值是一个String类型对象的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello JavaScript'</span>); <span class="comment">// String &#123;"hello JavaScript"&#125;</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>三者在作比较时的区别</li>
</ol>
<p>基本字符串在作比较时，只需要比较字符串的值即可；而在比较字符串对象时，比较的是对象所在的地址。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="built_in">String</span>(str);</span><br><span class="line"><span class="keyword">var</span> str3 = <span class="built_in">String</span>(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">var</span> str4 = <span class="keyword">new</span> <span class="built_in">String</span>(str);</span><br><span class="line"><span class="keyword">var</span> str5 = <span class="keyword">new</span> <span class="built_in">String</span>(str);</span><br><span class="line"><span class="keyword">var</span> str6 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line">str === str2;   <span class="comment">// true</span></span><br><span class="line">str2 === str3;  <span class="comment">// true</span></span><br><span class="line">str3 === str4;  <span class="comment">// false</span></span><br><span class="line">str4 === str5;  <span class="comment">// false</span></span><br><span class="line">str5 === str6;  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>对于str4、str5和str6，因为是使用new运算符生成的String类型的实例，所以在比较时需要判断变量是否指向同一个对象，即内存地址是否相同，很明显str4、str5、str6都是在内存中新生成的地址，彼此各不相同。</p>
<ol start="5">
<li>函数的调用</li>
</ol>
<p>在String对象的原型链上有一系列的函数，例如indexOf()函数、substring()函数、slice()函数等，通过String对象的实例可以调用这些函数做字符串的处理。</p>
<p>但是我们发现，采用字面量方式定义的字符串没有通过new运算符生成String对象的实例也能够直接调用原型链上的函数。</p>
<p>这是为什么呢？</p>
<p><strong>实际上基本字符串本身是没有字符串对象的函数，而在基本字符串调用字符串对象才有的函数时，JavaScript会自动将基本字符串转换为字符串对象，形成一种包装类型，这样基本字符串就可以正常调用字符串对象的方法了。</strong></p>
<h4 id="1-3-2-String类型常见算法"><a href="#1-3-2-String类型常见算法" class="headerlink" title="1.3.2 String类型常见算法"></a>1.3.2 String类型常见算法</h4><h5 id="1-3-2-1-字符串逆序输出"><a href="#1-3-2-1-字符串逆序输出" class="headerlink" title="1.3.2.1  字符串逆序输出"></a>1.3.2.1  字符串逆序输出</h5><p>给定一个字符串’abcdefg’，执行一定的算法后，输出的结果为’gfedcba’。</p>
<ol>
<li>算法1</li>
</ol>
<p>算法1的主要思想是借助数组的reverse()函数。</p>
<p>首先将字符串转换为字符数组，然后通过调用数组原生的reverse()函数进行逆序，得到逆序数组后再通过调用join()函数得到逆序字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法1：借助数组的reverse()函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseString1</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>算法2</li>
</ol>
<p>算法2的主要思想是利用字符串本身的charAt()函数。</p>
<p>从尾部开始遍历字符串，然后利用charAt()函数获取字符并逐个拼接，得到最终的结果。charAt()函数接收一个索引数字，返回该索引位置对应的字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法2：利用charAt()函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseString2</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> result = <span class="string">''</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i = str.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">       result += str.charAt(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>算法3</li>
</ol>
<p>算法3的主要思想是通过递归实现逆序输出，与算法2的处理类似。</p>
<p>递归从字符串最后一个位置索引开始，通过charAt()函数获取一个字符，并拼接到结果字符串中，递归结束的条件是位置索引小于0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法3：递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseString3</span>(<span class="params">strIn,pos,strOut</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(pos&lt;<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> strOut;</span><br><span class="line">   strOut += strIn.charAt(pos--);</span><br><span class="line">   <span class="keyword">return</span> reverseString3(strIn,pos,strOut);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abcdefg'</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reverseString3(str, str.length - <span class="number">1</span>, result));</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>算法4</li>
</ol>
<p>算法4的主要思想是通过call()函数来改变slice()函数的执行主体。</p>
<p>调用call()函数后，可以让字符串具有数组的特性，在调用未传入参数的slice()函数后，得到的是一个与自身相等的数组，从而可以直接调用reverse()函数，最后再通过调用join()函数，得到逆序字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法4: 利用call()函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseString4</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 改变slice()函数的执行主体，得到一个数组</span></span><br><span class="line">   <span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(str);</span><br><span class="line">   <span class="comment">// 调用reverse()函数逆序数组</span></span><br><span class="line">   <span class="keyword">return</span> arr.reverse().join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>算法5</li>
</ol>
<p>算法5的主要思想是借助栈的先进后出原则</p>
<p>由于JavaScript并未提供栈的实现，我们首先需要实现一个栈的数据结构，然后在栈中添加插入和弹出的函数，利用插入和弹出方法的函数字符串逆序。</p>
<p>首先，我们来看下基本数据结构——栈的实现。通过一个数组进行数据存储，通过一个top变量记录栈顶的位置，随着数据的插入和弹出，栈顶位置动态变化。</p>
<p>栈的操作包括两种，分别是出栈和入栈。出栈时，返回栈顶元素，即数组中索引值最大的元素，然后top变量减1；入栈时，往栈顶追加元素，然后top变量加1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.data = []; <span class="comment">// 保存栈内元素</span></span><br><span class="line">   <span class="keyword">this</span>.top = <span class="number">0</span>;   <span class="comment">// 记录栈顶位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链增加出栈、入栈方法</span></span><br><span class="line">Stack.prototype = &#123;</span><br><span class="line">   <span class="comment">// 入栈:先在栈顶添加元素，然后元素个数加1</span></span><br><span class="line">   push: <span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.data[<span class="keyword">this</span>.top++] = element;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="comment">// 出栈：先返回栈顶元素，然后元素个数减1</span></span><br><span class="line">   pop: <span class="function"><span class="keyword">function</span> <span class="title">pop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.data[--<span class="keyword">this</span>.top];</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="comment">// 返回栈内的元素个数，即长度</span></span><br><span class="line">   length: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.top;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法5：自定义栈实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseString5</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//创建一个栈的实例</span></span><br><span class="line">   <span class="keyword">var</span> s = <span class="keyword">new</span> Stack();</span><br><span class="line">   <span class="comment">//将字符串转成数组</span></span><br><span class="line">   <span class="keyword">var</span> arr = str.split(<span class="string">''</span>);</span><br><span class="line">   <span class="keyword">var</span> len = arr.length;</span><br><span class="line">   <span class="keyword">var</span> result = <span class="string">''</span>;</span><br><span class="line">   <span class="comment">//将元素压入栈内</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">      s.push(arr[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//输出栈内元素</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">      result += s.pop(j);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abcdefg'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reverseString5(str));</span><br></pre></td></tr></table></figure>
<h5 id="1-3-2-2-统计字符串中出现次数最多的字符及出现的次数"><a href="#1-3-2-2-统计字符串中出现次数最多的字符及出现的次数" class="headerlink" title="1.3.2.2 统计字符串中出现次数最多的字符及出现的次数"></a>1.3.2.2 统计字符串中出现次数最多的字符及出现的次数</h5><p>假如存在一个字符串’helloJavascripthellohtmlhellocss’，其中出现次数最多的字符是l，出现的次数是7次。</p>
<ol>
<li>算法1</li>
</ol>
<p>算法1的主要思想是通过key-value形式的对象来存储字符串以及字符串出现的次数，然后逐个判断出现次数最大值，同时获取对应的字符，具体实现如下。</p>
<p>· 首先通过key-value形式的对象来存储数据，key表示不重复出现的字符，value表示该字符出现的次数。</p>
<p>· 然后遍历字符串的每个字符，判断是否出现在key中。如果在，直接将对应的value值加1；如果不在，则直接新增一组key-value，value值为1</p>
<p>· 得到key-value对象后，遍历该对象，逐个比较value值的大小，找出其中最大的值并记录key-value，即获得最终想要的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxCount</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> json = &#123;&#125;;</span><br><span class="line">   <span class="comment">// 遍历str的每一个字符得到key-value形式的对象</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">       <span class="comment">// 判断json中是否有当前str的值</span></span><br><span class="line">       <span class="keyword">if</span> (!json[str.charAt(i)]) &#123;</span><br><span class="line">           <span class="comment">// 如果不存在，就将当前值添加到json中去</span></span><br><span class="line">           json[str.charAt(i)] = <span class="number">1</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 如果存在，则让value值加1</span></span><br><span class="line">           json[str.charAt(i)]++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 存储出现次数最多的值和出现次数</span></span><br><span class="line">   <span class="keyword">var</span> maxCountChar = <span class="string">''</span>;</span><br><span class="line">   <span class="keyword">var</span> maxCount = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 遍历json对象，找出出现次数最大的值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> json) &#123;</span><br><span class="line">      <span class="comment">// 如果当前项大于下一项</span></span><br><span class="line">      <span class="keyword">if</span> (json[key] &gt; maxCount) &#123;</span><br><span class="line">          <span class="comment">// 就让当前值更改为出现最多次数的值</span></span><br><span class="line">          maxCount = json[key];</span><br><span class="line">          maxCountChar = key;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//最终返回出现最多的值以及出现次数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="string">'出现最多的值是'</span> + maxCountChar + <span class="string">'，出现次数为'</span> + maxCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'helloJavaScripthellohtmlhellocss'</span>;</span><br><span class="line">getMaxCount(str); <span class="comment">// '出现最多的值是l，出现次数为7'</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>算法2</li>
</ol>
<p>算法2同样会借助于key-value形式的对象来存储字符与字符出现的次数，但是在运算上有所差别。</p>
<p>· 首先通过key-value形式的对象来存储数据，key表示不重复出现的字符，value表示该字符出现的次数。</p>
<p>· 然后将字符串处理成数组，通过forEach()函数遍历每个字符。在处理之前需要先判断当前处理的字符是否已经在key-value对象中，如果已经存在则表示已经处理过相同的字符，则无须处理；如果不存在，则会处理该字符item。</p>
<p>· 通过split()函数传入待处理字符，可以得到一个数组，该数组长度减1即为该字符出现的次数。</p>
<p>· 获取字符出现的次数后，立即与表示出现最大次数和最大次数对应的字符变量maxCount和maxCountChar相比，如果比maxCount大，则将值写入key-value对象中，并动态更新maxCount和maxCountChar的值，直到最后一个字符处理完成。</p>
<p>· 最后得到的结果即maxCount和maxCountChar两个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxCount2</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> json = &#123;&#125;;</span><br><span class="line">   <span class="keyword">var</span> maxCount = <span class="number">0</span>, maxCountChar = <span class="string">''</span>;</span><br><span class="line">   str.split(<span class="string">''</span>).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">       <span class="comment">// 判断json对象中是否有对应的key</span></span><br><span class="line">       <span class="keyword">if</span> (!json.hasOwnProperty(item)) &#123;</span><br><span class="line">           <span class="comment">// 当前字符出现的次数</span></span><br><span class="line">           <span class="keyword">var</span> number = str.split(item).length - <span class="number">1</span>;</span><br><span class="line">           <span class="comment">// 直接与出现次数最大值比较，并进行更新</span></span><br><span class="line">           <span class="keyword">if</span>(number &gt; maxCount) &#123;</span><br><span class="line">               <span class="comment">// 写入json对象</span></span><br><span class="line">               json[item] = number;</span><br><span class="line">               <span class="comment">// 更新maxCount与maxCountChar的值</span></span><br><span class="line">               maxCount = number;</span><br><span class="line">               maxCountChar = item;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="string">'出现最多的值是'</span> + maxCountChar + <span class="string">'，出现次数为'</span> + maxCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'helloJavaScripthellohtmlhellocss'</span>;</span><br><span class="line">getMaxCount2(str); <span class="comment">// '出现最多的值是l，出现次数为7'</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>算法3</li>
</ol>
<p>算法3的主要思想是对字符串进行排序，然后通过lastIndexOf()函数获取索引值后，判断索引值的大小以获取出现的最大次数。</p>
<p>· 首先将字符串处理成数组，调用sort()函数进行排序，处理成字符串。</p>
<p>· 然后遍历每个字符，通过调用lastIndexOf()函数，确定每个字符出现的最后位置，然后减去当前遍历的索引，就可以确定该字符出现的次数。</p>
<p>· 确定字符出现的次数后，直接与次数最大值变量maxCount进行比较，如果比maxCount大，则直接更新maxCount的值，并同步更新maxCountChar的值；如果比maxCount小，则不做任何处理。</p>
<p>· 计算完成后，将索引值设置为字符串出现的最后位置，进行下一轮计算，直到处理完所有字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxCount3</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 定义两个变量，分别表示出现最大次数和对应的字符</span></span><br><span class="line">   <span class="keyword">var</span> maxCount = <span class="number">0</span>, maxCountChar = <span class="string">''</span>;</span><br><span class="line">   <span class="comment">// 先处理成数组，调用sort()函数排序,再处理成字符串</span></span><br><span class="line">   str = str.split(<span class="string">''</span>).sort().join(<span class="string">''</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = str.length; i &lt; j; i++) &#123;</span><br><span class="line">       <span class="keyword">var</span> char = str[i];</span><br><span class="line">       <span class="comment">// 计算每个字符串出现的次数</span></span><br><span class="line">       <span class="keyword">var</span> charCount = str.lastIndexOf(char) - i + <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 与次数最大值作比较</span></span><br><span class="line">       <span class="keyword">if</span> (charCount &gt; maxCount) &#123;</span><br><span class="line">           <span class="comment">// 更新maxCount和maxCountChar的值</span></span><br><span class="line">           maxCount = charCount;</span><br><span class="line">           maxCountChar = char;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 变更索引为字符出现的最后位置</span></span><br><span class="line">       i = str.lastIndexOf(char);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">'出现最多的值是'</span> + maxCountChar + <span class="string">'，出现次数为'</span> + maxCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'helloJavaScripthellohtmlhellocss'</span>;</span><br><span class="line">getMaxCount3(str);  <span class="comment">// '出现最多的值是l，出现次数为7'</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>算法4</li>
</ol>
<p>算法4的主要思想是将字符串进行排序，然后通过正则表达式将字符串进行匹配拆分，将相同字符组合在一起，最后判断字符出现的次数。</p>
<p>· 首先将字符串处理成数组，调用sort()函数进行排序，处理成字符串。</p>
<p>· 然后设置正则表达式reg，对字符串使用match()函数进行匹配，得到一个数组，数组中的每个成员是相同的字符构成的字符串。</p>
<p>· 遍历数组，依次将成员字符串长度值与maxCount值进行比较，动态更新maxCount与maxCountChar的值，直到数组所有元素处理完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxCount4</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 定义两个变量，分别表示出现最大次数和对应的字符</span></span><br><span class="line">   <span class="keyword">var</span> maxCount = <span class="number">0</span>, maxCountChar = <span class="string">''</span>;</span><br><span class="line">   <span class="comment">// 先处理成数组，调用sort()函数排序,再处理成字符串</span></span><br><span class="line">   str = str.split(<span class="string">''</span>).sort().join(<span class="string">''</span>);</span><br><span class="line">   <span class="comment">// 通过正则表达式将字符串处理成数组(数组每个元素为相同字符构成的字符串)</span></span><br><span class="line">   <span class="keyword">var</span> arr = str.match(<span class="regexp">/(\w)\1+/g</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">       <span class="comment">// length表示字符串出现的次数</span></span><br><span class="line">       <span class="keyword">var</span> length = arr[i].length;</span><br><span class="line">       <span class="comment">// 与次数最大值作比较</span></span><br><span class="line">       <span class="keyword">if</span> (length &gt; maxCount) &#123;</span><br><span class="line">           <span class="comment">// 更新maxCount和maxCountChar</span></span><br><span class="line">           maxCount = length;</span><br><span class="line">           maxCountChar = arr[i][<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">'出现最多的值是'</span> + maxCountChar + <span class="string">'，出现次数为'</span> + maxCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'helloJavaScripthellohtmlhellocss'</span>;</span><br><span class="line">getMaxCount4(str);  <span class="comment">// '出现最多的值是l，出现次数为7'</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>算法5</li>
</ol>
<p>算法5的主要思想是借助replace()函数，主要实现方式如下。</p>
<p>· 通过while循环处理，跳出while循环的条件是字符串长度为0。</p>
<p>· 在while循环中，记录原始字符串的长度originCount，用于后面做长度计算处理。</p>
<p>· 获取字符串第一个字符char，通过replace()函数将char替换为空字符串’’，得到一个新的字符串，它的长度remainCount相比于originCount会小，其中的差值originCount - remainCount即为该字符出现的次数。</p>
<p>· 确定字符出现的次数后，直接与maxCount进行比较，如果比maxCount大，则直接更新maxCount的值，并同步更新maxCountChar的值；如果比maxCount小，则不做任何处理。</p>
<p>· 处理至跳出while循环，得到最终结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxCount5</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 定义两个变量，分别表示出现最大次数和对应的字符</span></span><br><span class="line">   <span class="keyword">var</span> maxCount = <span class="number">0</span>, maxCountChar = <span class="string">''</span>;</span><br><span class="line">   <span class="keyword">while</span> (str) &#123;</span><br><span class="line">       <span class="comment">// 记录原始字符串的长度</span></span><br><span class="line">       <span class="keyword">var</span> originCount = str.length;</span><br><span class="line">       <span class="comment">// 当前处理的字符</span></span><br><span class="line">       <span class="keyword">var</span> char = str[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(char, <span class="string">'g'</span>);</span><br><span class="line">       <span class="comment">// 使用replace()函数替换处理的字符为空字符串</span></span><br><span class="line">       str = str.replace(reg, <span class="string">''</span>);</span><br><span class="line">       <span class="keyword">var</span> remainCount = str.length;</span><br><span class="line">       <span class="comment">// 当前字符出现的次数</span></span><br><span class="line">       <span class="keyword">var</span> charCount = originCount - remainCount;</span><br><span class="line">       <span class="comment">// 与次数最大值作比较</span></span><br><span class="line">       <span class="keyword">if</span> (charCount &gt; maxCount) &#123;</span><br><span class="line">          <span class="comment">// 更新maxCount和maxCountChar的值</span></span><br><span class="line">          maxCount = charCount;</span><br><span class="line">          maxCountChar = char;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">'出现最多的值是'</span> + maxCountChar + <span class="string">'，出现次数为'</span> + maxCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'helloJavaScripthellohtmlhellocss'</span>;</span><br><span class="line">getMaxCount5(str);  <span class="comment">// '出现最多的值是l，出现次数为7'</span></span><br></pre></td></tr></table></figure>
<h5 id="1-3-2-3-去除字符串中重复的字符"><a href="#1-3-2-3-去除字符串中重复的字符" class="headerlink" title="1.3.2.3 去除字符串中重复的字符"></a>1.3.2.3 去除字符串中重复的字符</h5><p>假如存在一个字符串’helloJavaScripthellohtmlhellocss’，其中存在大量的重复字符，例如h、e、l等，去除重复的字符，只保留一个，得到的结果应该是’heloJavscriptm’。</p>
<ol>
<li>算法1</li>
</ol>
<p>算法1的主要思想是使用key-value类型的对象存储，key表示唯一的字符，处理完后将所有的key拼接在一起即可得到去重后的结果。</p>
<p>· 首先通过key-value形式的对象来存储数据，key表示不重复出现的字符，value为boolean类型的值，为true则表示字符出现过。</p>
<p>· 然后遍历字符串，判断当前处理的字符是否在对象中，如果在，则不处理；如果不在，则将该字符添加到结果数组中。</p>
<p>· 处理完字符串后，得到一个数组，转换为字符串后即可获得最终需要的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeDuplicateChar1</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 结果数组</span></span><br><span class="line">   <span class="keyword">var</span> result = [];</span><br><span class="line">   <span class="comment">// key-value形式的对象</span></span><br><span class="line">   <span class="keyword">var</span> json = &#123;&#125;;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">       <span class="comment">// 当前处理的字符</span></span><br><span class="line">       <span class="keyword">var</span> char = str[i];</span><br><span class="line">       <span class="comment">// 判断是否在对象中</span></span><br><span class="line">       <span class="keyword">if</span>(!json[char]) &#123;</span><br><span class="line">           <span class="comment">// value值设置为false</span></span><br><span class="line">           json[char] = <span class="literal">true</span>;</span><br><span class="line">           <span class="comment">// 添加至结果数组中</span></span><br><span class="line">           result.push(char);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'helloJavaScripthellohtmlhellocss'</span>;</span><br><span class="line">removeDuplicateChar1(str);  <span class="comment">// 'heloJavscriptm'</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>算法2</li>
</ol>
<p>算法2的主要思想是借助数组的filter()函数，然后在filter()函数中使用indexOf()函数判断。</p>
<p>· 通过call()函数改变filter()函数的执行体，让字符串可以直接执行filter()函数。</p>
<p>· 在自定义的filter()函数回调中，通过indexOf()函数判断其第一次出现的索引位置，如果与filter()函数中的index一样，则表示第一次出现，符合条件则return出去。这就表示只有第一次出现的字符会被成功过滤出来，而其他重复出现的字符会被忽略掉。</p>
<p>· filter()函数返回的结果便是已经去重的字符数组，将其转换为字符串输出即为最终需要的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeDuplicateChar2</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 使用call()函数改变ﬁlter函数的执行主体</span></span><br><span class="line">   <span class="keyword">let</span> result = <span class="built_in">Array</span>.prototype.ﬁlter.call(str, <span class="function"><span class="keyword">function</span> (<span class="params">char, index, arr</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 通过indexOf()函数与index的比较，判断是否是第一次出现的字符</span></span><br><span class="line">      <span class="keyword">return</span> arr.indexOf(char) === index;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="keyword">return</span> result.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'helloJavaScripthellohtmlhellocss'</span>;</span><br><span class="line">removeDuplicateChar2(str);  <span class="comment">// 'heloJavscriptm'</span></span><br></pre></td></tr></table></figure>
<p>借助于ES6的语法，以上方法体的执行代码还可以简写成一行的形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Array</span>.prototype.filter.call(str, (char, index, arr) =&gt; arr.indexOf</span><br><span class="line">(char) === index).join(<span class="string">''</span>);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>算法3</li>
</ol>
<p>算法3的主要思想是借助ES6中的Set数据结构，Set具有自动去重的特性，可以直接将数组元素去重。</p>
<p>· 将字符串处理成数组，然后作为参数传递给Set的构造函数，通过new运算符生成一个Set的实例。</p>
<p>· 将Set通过扩展运算符（…）转换成数组形式，最终转换成字符串获得需要的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeDuplicateChar3</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 字符串转换的数组作为参数，生成Set的实例</span></span><br><span class="line">   <span class="keyword">let</span> <span class="keyword">set</span> = new Set(str.split(''));</span><br><span class="line">    // 将<span class="keyword">set</span>重新处理为数组，然后转换成字符串</span><br><span class="line">   return [...<span class="keyword">set</span>].join('');</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var str = 'helloJavaScripthellohtmlhellocss';</span><br><span class="line">removeDuplicateChar3(str);  // 'heloJavscriptm'</span><br></pre></td></tr></table></figure>
<h5 id="1-3-2-4-判断一个字符串是否为回文字符串"><a href="#1-3-2-4-判断一个字符串是否为回文字符串" class="headerlink" title="1.3.2.4  判断一个字符串是否为回文字符串"></a>1.3.2.4  判断一个字符串是否为回文字符串</h5><p>回文字符串是指一个字符串正序和倒序是相同的，例如字符串’abcdcba’是一个回文字符串，而字符串’abcedba’则不是一个回文字符串。</p>
<p>需要注意的是，这里不区分字符大小写，即a与A在判断时是相等的。</p>
<p>给定两个字符串’abcdcba’和’abcedba’，经过一定的算法处理，分别会返回“true”和“false”。</p>
<ol>
<li>算法1</li>
</ol>
<p>算法1的主要思想是将字符串按从前往后顺序的字符与按从后往前顺序的字符逐个进行比较，如果遇到不一样的值则直接返回“false”，否则返回“true”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindromicStr1</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 空字符则直接返回“true”</span></span><br><span class="line">   <span class="keyword">if</span> (!str.length) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 统一转换成小写，同时转换成数组</span></span><br><span class="line">   str = str.toLowerCase().split(<span class="string">''</span>);</span><br><span class="line">   <span class="keyword">var</span> start = <span class="number">0</span>, end = str.length - <span class="number">1</span>;</span><br><span class="line">   <span class="comment">// 通过while循环判断正序和倒序的字母</span></span><br><span class="line">   <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">      <span class="comment">// 如果相等则更改比较的索引</span></span><br><span class="line">      <span class="keyword">if</span>(str[start] === str[end]) &#123;</span><br><span class="line">          start++;</span><br><span class="line">          end--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">'abcdcba'</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'abcedba'</span>;</span><br><span class="line"></span><br><span class="line">isPalindromicStr1(str1);  <span class="comment">// true</span></span><br><span class="line">isPalindromicStr1(str2);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>算法2</li>
</ol>
<p>算法2与算法1的主要思想相同，将正序和倒序的字符逐个进行比较，与算法1不同的是，算法2采用递归的形式实现。</p>
<p>递归结束的条件有两种情况，一个是当字符串全部处理完成，此时返回“true”；另一个是当遇到首字符与尾字符不同，此时返回“false”。而其他情况会依次进行递归处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindromicStr2</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 字符串处理完成，则返回“true”</span></span><br><span class="line">   <span class="keyword">if</span>(!str.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 字符串统一转换成小写</span></span><br><span class="line">   str = str.toLowerCase();</span><br><span class="line">   <span class="keyword">let</span> end = str.length - <span class="number">1</span>;</span><br><span class="line">   <span class="comment">// 当首字符和尾字符不同，直接返回“false”</span></span><br><span class="line">   <span class="keyword">if</span>(str[<span class="number">0</span>] !== str[end]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 删掉字符串首尾字符，进行递归处理</span></span><br><span class="line">   <span class="keyword">return</span> isPalindromicStr2(str.slice(<span class="number">1</span>, end));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">'abcdcba'</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'abcedba'</span>;</span><br><span class="line"></span><br><span class="line">isPalindromicStr2(str1);  <span class="comment">// true</span></span><br><span class="line">isPalindromicStr2(str2);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>算法3</li>
</ol>
<p>算法3的主要思想是将字符串进行逆序处理，然后与原来的字符串进行比较，如果相等则表示是回文字符串，否则不是回文字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindromicStr3</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 字符串统一转换成小写</span></span><br><span class="line">   str = str.toLowerCase();</span><br><span class="line">   <span class="comment">// 将字符串转换成数组</span></span><br><span class="line">   <span class="keyword">var</span> arr = str.split(<span class="string">''</span>);</span><br><span class="line">   <span class="comment">// 将数组逆序并转换成字符串</span></span><br><span class="line">    <span class="keyword">var</span> reverseStr = arr.reverse().join(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">return</span> str === reverseStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">'abcdcba'</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">'abcedba'</span>;</span><br><span class="line"></span><br><span class="line">isPalindromicStr3(str1);  <span class="comment">// true</span></span><br><span class="line">isPalindromicStr3(str2);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="1-4-运算符"><a href="#1-4-运算符" class="headerlink" title="1.4 运算符"></a>1.4 运算符</h3><h2 id="2、引用数据类型"><a href="#2、引用数据类型" class="headerlink" title="2、引用数据类型"></a>2、引用数据类型</h2><h2 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h2><h2 id="4、对象"><a href="#4、对象" class="headerlink" title="4、对象"></a>4、对象</h2><h2 id="5、DOM与事件"><a href="#5、DOM与事件" class="headerlink" title="5、DOM与事件"></a>5、DOM与事件</h2><h2 id="6、Ajax"><a href="#6、Ajax" class="headerlink" title="6、Ajax"></a>6、Ajax</h2><h2 id="7、ES6"><a href="#7、ES6" class="headerlink" title="7、ES6"></a>7、ES6</h2>
        
        <div id="comment-container">
        </div>
    </div>

    <div style="position:fixed;right:10px;bottom:15px;color: #999;cursor: pointer;" onclick="window.scrollTo(0,0)">回到顶部</div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/fanky-c">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p style="padding-top:10px;">
        <span>/</span>
        
            
               <span><a href="http://www.fankyc.cn">fanky_c</a></span>
            
        <span>/</span>
        
            
               <span><a href="https://beian.miit.gov.cn" target="_blank">粤ICP备19149804号</a></span>
            
        <span>/</span>
        
            
               <span><a href="#">It helps SEO</a></span>
            
        <span>/</span>
        
    </p>
    
    <p style="padding-top:5px;">
        <!--<span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>-->
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a>
    </p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<!-- <script async src="//cdn.jsdelivr.net/gh/sukkaw/busuanzi@2.3/bsz.pure.mini.js"></script> -->

</html>
