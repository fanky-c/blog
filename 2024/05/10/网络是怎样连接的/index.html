<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <!--  禁止百度引擎抓取 -->
    <meta name="Baiduspider" content="noarchive">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="js、nodejs、css、nginx、vue、react">
    <meta name="keyword" content="网易">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        网络是怎样连接的 - fanky_c的博客 | fanky_c&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>fanky_c</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、浏览器生成消息-—-探索浏览器内部"><span class="toc-text">1、浏览器生成消息 — 探索浏览器内部</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-生成HTTP请求消息"><span class="toc-text">1.1 生成HTTP请求消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-探索之旅从输入网址开始"><span class="toc-text">1.1.1 探索之旅从输入网址开始</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-浏览器先要解析URL"><span class="toc-text">1.1.2 浏览器先要解析URL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-省略文件名的情况"><span class="toc-text">1.1.3 省略文件名的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-HTTP的基本思路"><span class="toc-text">1.1.4 HTTP的基本思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-5-生成HTTP请求消息"><span class="toc-text">1.1.5 生成HTTP请求消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-6-发送请求后收到响应"><span class="toc-text">1.1.6 发送请求后收到响应</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-向DNS服务器查询Web服务器IP地址"><span class="toc-text">1.2 向DNS服务器查询Web服务器IP地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-IP地址的基本知识"><span class="toc-text">1.2.1 IP地址的基本知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-域名和IP地址并用的理由"><span class="toc-text">1.2.2 域名和IP地址并用的理由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-Socket库提供查询IP地址的功能"><span class="toc-text">1.2.3 Socket库提供查询IP地址的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-通过解析器向DNS服务器发出查询"><span class="toc-text">1.2.4 通过解析器向DNS服务器发出查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-解析器的内部原理"><span class="toc-text">1.2.5 解析器的内部原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-全世界DNS服务器的大接力"><span class="toc-text">1.3 全世界DNS服务器的大接力</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-DNS服务器的基本工作"><span class="toc-text">1.3.1 DNS服务器的基本工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-域名的层次结构"><span class="toc-text">1.3.2 域名的层次结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-寻找相应的DNS服务器并获取IP地址"><span class="toc-text">1.3.3 寻找相应的DNS服务器并获取IP地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-通过缓存加快DNS服务器的响应"><span class="toc-text">1.3.4 通过缓存加快DNS服务器的响应</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-委托协议栈发送消息"><span class="toc-text">1.4 委托协议栈发送消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-数据收发操作概览"><span class="toc-text">1.4.1 数据收发操作概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-创建套接字阶段"><span class="toc-text">1.4.2 创建套接字阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-连接阶段：把管道接上去"><span class="toc-text">1.4.3 连接阶段：把管道接上去</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4-通信阶段：传递消息"><span class="toc-text">1.4.4 通信阶段：传递消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-5-断开阶段：收发数据结束"><span class="toc-text">1.4.5 断开阶段：收发数据结束</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、用电信号传输TCP-IP-—-探索协议栈和网卡"><span class="toc-text">2、用电信号传输TCP/IP — 探索协议栈和网卡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-创建套接字"><span class="toc-text">2.1 创建套接字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、从网络到网络设备-—-探索集线器、交换机和路由器"><span class="toc-text">3、从网络到网络设备 — 探索集线器、交换机和路由器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、通过接入网进入互联网内部-—-探索接入网和网络运营商"><span class="toc-text">4、通过接入网进入互联网内部 — 探索接入网和网络运营商</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、服务器端的局域网中有什么玄机"><span class="toc-text">5、服务器端的局域网中有什么玄机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、请求到达web服务器，响应返回浏览器-—-短短几秒“漫长旅程”迎来终点"><span class="toc-text">6、请求到达web服务器，响应返回浏览器 — 短短几秒“漫长旅程”迎来终点</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        网络是怎样连接的
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2024-05-10 20:52:24</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#网络是怎样连接" title="网络是怎样连接">网络是怎样连接</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h2 id="1、浏览器生成消息-—-探索浏览器内部"><a href="#1、浏览器生成消息-—-探索浏览器内部" class="headerlink" title="1、浏览器生成消息 — 探索浏览器内部"></a>1、浏览器生成消息 — 探索浏览器内部</h2><h3 id="1-1-生成HTTP请求消息"><a href="#1-1-生成HTTP请求消息" class="headerlink" title="1.1 生成HTTP请求消息"></a>1.1 生成HTTP请求消息</h3><h4 id="1-1-1-探索之旅从输入网址开始"><a href="#1-1-1-探索之旅从输入网址开始" class="headerlink" title="1.1.1 探索之旅从输入网址开始"></a>1.1.1 探索之旅从输入网址开始</h4><p>我们的探索之旅从在浏览器中输入网址开始，在介绍浏览器的工作方式之前，让我们先来介绍一下网址。网址，准确来说应该叫URL，如果我说它就是以http://开头的那一串东西，恐怕大家一下子就明白了，但实际上除了“http:”，网址还可以以其他一些文字开头，例如“ftp:”“file:”“mailto:”等。</p>
<p>现在互联网中常见的几种URL，根据访问目标的不同，URL的写法也会不同。例如在访问Web服务器和FTP服务器时，URL中会包含服务器的域名和要访问的文件的路径名等，而发邮件的URL则包含收件人的邮件地址。此外，根据需要，URL中还会包含用户名、密码、服务器端口号等信息。</p>
<p><img src="/img/network1.jpg"></p>
<p>尽管URL有各种不同的写法，但它们有一个共同点，那就是URL开头的文字，即“http:”“ftp:”“file:”“mailto:”这部分文字都表示浏览器应当使用的访问方法。比如当访问Web服务器时应该使用HTTP协议，而访问FTP服务器时则应该使用FTP协议。因此，我们可以把这部分理解为访问时使用的协议类型。尽管后面部分的写法各不相同，但开头部分的内容决定了后面部分的写法，因此并不会造成混乱。</p>
<h4 id="1-1-2-浏览器先要解析URL"><a href="#1-1-2-浏览器先要解析URL" class="headerlink" title="1.1.2 浏览器先要解析URL"></a>1.1.2 浏览器先要解析URL</h4><p>浏览器要做的第一步工作就是对URL进行解析，从而生成发送给Web服务器的请求消息。刚才我们已经讲过，URL的格式会随着协议的不同而不同，因此下面我们以访问Web服务器的情况为例来进行讲解。</p>
<p><img src="/img/network2.jpg"></p>
<h4 id="1-1-3-省略文件名的情况"><a href="#1-1-3-省略文件名的情况" class="headerlink" title="1.1.3 省略文件名的情况"></a>1.1.3 省略文件名的情况</h4><p>没有文件名，服务器怎么知道要访问哪个文件呢？其实，我们会在服务器上事先设置好文件名省略时要访问的默认文件名。这个设置根据服务器不同而不同，大多数情况下是index.html或者default.htm之类的文件名。因此，像前面这样省略文件名时，服务器就会访问/dir/index.html或者/dir/default.htm。</p>
<h4 id="1-1-4-HTTP的基本思路"><a href="#1-1-4-HTTP的基本思路" class="headerlink" title="1.1.4 HTTP的基本思路"></a>1.1.4 HTTP的基本思路</h4><p><img src="/img/network3.jpg"></p>
<p>HTTP协议定义了客户端和服务器之间交互的消息内容和步骤，其基本思路非常简单。</p>
<p>首先，客户端会向服务器发送请求消息。请求消息中包含的内容是“对什么”和“进行怎样的操作”两个部分。其中相当于“对什么”的部分称为URI。换句话说就是，这里可以写各种访问目标，而这些访问目标统称为URI。</p>
<p>接下来“进行怎样的操作”的部分称为方法，方法表示需要让Web服务器完成怎样的工作，其中典型的例子包括读取URI表示的数据、将客户端输入的数据发送给URI表示的程序等。</p>
<p><img src="/img/network4.jpg"></p>
<h4 id="1-1-5-生成HTTP请求消息"><a href="#1-1-5-生成HTTP请求消息" class="headerlink" title="1.1.5 生成HTTP请求消息"></a>1.1.5 生成HTTP请求消息</h4><p>理解了HTTP的基本知识之后，让我们回到对浏览器本身的探索中来。</p>
<p>对URL进行解析之后，浏览器确定了Web服务器和文件名，接下来就是根据这些信息来生成HTTP请求消息了。实际上，HTTP消息在格式上是有严格规定的，因此浏览器会按照规定的格式来生成请求消息。</p>
<p>首先，请求消息的第一行称为请求行。这里的重点是最开头的方法，方法可以告诉Web服务器它应该进行怎样的操作。</p>
<p>HTTP消息的格式如下：</p>
<p><img src="/img/network5.jpg"></p>
<p>HTTP中主要头字段如下：</p>
<p><img src="/img/network6.jpg"></p>
<p><img src="/img/network7.jpg"></p>
<h4 id="1-1-6-发送请求后收到响应"><a href="#1-1-6-发送请求后收到响应" class="headerlink" title="1.1.6 发送请求后收到响应"></a>1.1.6 发送请求后收到响应</h4><p>当我们将上述请求消息发送出去之后，Web服务器会返回响应消息。</p>
<p>在响应消息中，第一行的内容为状态码和响应短语，用来表示请求的执行结果是成功还是出错。状态码和响应短语表示的内容一致，但它们的用途不同。状态码是一个数字，它主要用来向程序告知执行的结果；相对地，响应短语则是一段文字，用来向人们告知执行的结果。</p>
<p><img src="/img/network8.jpg"></p>
<p>HTTP消息示例如下：</p>
<p><img src="/img/network9.jpg"></p>
<p><img src="/img/network10.jpg"></p>
<p><img src="/img/network11.jpg"></p>
<h3 id="1-2-向DNS服务器查询Web服务器IP地址"><a href="#1-2-向DNS服务器查询Web服务器IP地址" class="headerlink" title="1.2 向DNS服务器查询Web服务器IP地址"></a>1.2 向DNS服务器查询Web服务器IP地址</h3><h4 id="1-2-1-IP地址的基本知识"><a href="#1-2-1-IP地址的基本知识" class="headerlink" title="1.2.1 IP地址的基本知识"></a>1.2.1 IP地址的基本知识</h4><p>生成HTTP消息之后，接下来我们需要委托操作系统将消息发送给Web服务器。尽管浏览器能够解析网址并生成HTTP消息，但它本身并不具备将消息发送到网络中的功能，因此这一功能需要委托操作系统来实现。在进行这一操作时，我们还有一个工作需要完成，那就是查询网址中服务器域名对应的IP地址。在委托操作系统发送消息时，必须要提供的不是通信对象的域名，而是它的IP地址。因此，在生成HTTP消息之后，下一个步骤就是根据域名查询IP地址。在讲解这一操作之前，让我们先来简单了解一下IP地址。</p>
<p>互联网和公司内部的局域网都是基于TCP/IP的思路来设计的，所以我们先来了解TCP/IP的基本思路。TCP/IP的结构如图1.8所示，就是由一些小的子网，通过路由器连接起来组成一个大的网络。这里的子网可以理解为用集线器连接起来的几台计算机，我们将它看作一个单位，称为子网。将子网通过路由器连接起来，就形成了一个网络。在网络中，所有的设备都会被分配一个地址。这个地址就相当于现实中某条路上的“××号××室”。其中“号”对应的号码是分配给整个子网的，而“室”对应的号码是分配给子网中的计算机的，这就是网络中的地址。“号”对应的号码称为网络号，“室”对应的号码称为主机号，这个地址的整体称为IP地址。通过IP地址我们可以判断出访问对象服务器的位置，从而将消息发送到服务器。消息传送的具体过程在后面的章节有详细讲解，不过现在我们先简单了解一下。发送者发出的消息首先经过子网中的集线器，转发到距离发送者最近的路由器上。接下来，路由器会根据消息的目的地判断下一个路由器的位置，然后将消息发送到下一个路由器，即消息再次经过子网内的集线器被转发到下一个路由器。前面的过程不断重复，最终消息就被传送到了目的地。</p>
<p><img src="/img/network12.jpg"></p>
<p>前面这些就是TCP/IP中IP地址的基本思路。了解了这些知识之后，让我们再来看一下实际的IP地址。如图1.9所示，<strong>实际的IP地址是一串32比特的数字，按照8比特（1字节）为一组分成4组，</strong>分别用十进制表示然后再用圆点隔开。这就是我们平常经常见到的IP地址格式，但仅凭这一串数字我们无法区分哪部分是网络号，哪部分是主机号。在IP地址的规则中，网络号和主机号连起来总共是32比特，但这两部分的具体结构是不固定的。在组建网络时，用户可以自行决定它们之间的分配关系，因此，我们还需要另外的附加信息来表示IP地址的内部结构。</p>
<p><img src="/img/network13.jpg"></p>
<h4 id="1-2-2-域名和IP地址并用的理由"><a href="#1-2-2-域名和IP地址并用的理由" class="headerlink" title="1.2.2 域名和IP地址并用的理由"></a>1.2.2 域名和IP地址并用的理由</h4><p>TCP/IP网络是通过IP地址来确定通信对象的，因此不知道IP地址就无法将消息发送给对方，这和我们打电话的时候必须要知道对方的电话号码是一个道理。因此，在委托操作系统发送消息时，必须要先查询好对方的IP地址。</p>
<p>可能你会问“既然如此，那么在网址中不写服务器的名字，直接写IP地址不就好了吗？”实际上，如果用IP地址来代替服务器名称也是能够正常工作的。<strong>然而，就像你很难记住电话号码一样，要记住一串由数字组成的IP地址也非常困难。</strong>因此，相比IP地址来说，网址中还是使用服务器名称比较好。</p>
<p><strong>不过从运行效率上来看，这并不能算是一个好主意。</strong>互联网中存在无数的路由器，它们之间相互配合，根据IP地址来判断应该把数据传送到什么地方。那么如果我们不用IP地址而是改用名称会怎么样呢？IP地址的长度为32比特，也就是4字节，相对地，域名最短也要几十个字节，最长甚至可以达到255字节。换句话说，使用IP地址只需要处理4字节的数字，而域名则需要处理几十个到255个字节的字符，这增加了路由器的负担，传送数据也会花费更长的时间。</p>
<h4 id="1-2-3-Socket库提供查询IP地址的功能"><a href="#1-2-3-Socket库提供查询IP地址的功能" class="headerlink" title="1.2.3 Socket库提供查询IP地址的功能"></a>1.2.3 Socket库提供查询IP地址的功能</h4><p>向DNS服务器发出查询，也就是向DNS服务器发送查询消息，并接收服务器返回的响应消息。换句话说，对于DNS服务器，我们的计算机上一定有相应的DNS客户端，而相当于DNS客户端的部分称为DNS解析器，或者简称解析器。通过DNS查询IP地址的操作称为域名解析，因此负责执行解析(resolution)这一操作的就叫解析器(resolver)了。</p>
<p>解析器实际上是一段程序，它包含在操作系统的Socket库中，在介绍解析器之前，我们先来简单了解一下Socket库。首先，库到底是什么东西呢？库就是一堆通用程序组件的集合，其他的应用程序都需要使用其中的组件。库有很多好处。首先，使用现成的组件搭建应用程序可以节省编程工作量；其次，多个程序使用相同的组件可以实现程序的标准化。除此之外还有很多其他的好处，因此使用库来进行软件开发的思路已经非常普及，库的种类和数量也非常之多。Socket库也是一种库，其中包含的程序组件可以让其他的应用程序调用操作系统的网络功能，而解析器就是这个库中的其中一种程序组件。</p>
<p>Socket库是用于调用网络功能的程序组件集合。</p>
<h4 id="1-2-4-通过解析器向DNS服务器发出查询"><a href="#1-2-4-通过解析器向DNS服务器发出查询" class="headerlink" title="1.2.4 通过解析器向DNS服务器发出查询"></a>1.2.4 通过解析器向DNS服务器发出查询</h4><p>调用解析器后，解析器会向DNS服务器发送查询消息，然后DNS服务器会返回响应消息。响应消息中包含查询到的IP地址，解析器会取出IP地址，并将其写入浏览器指定的内存地址中。</p>
<h4 id="1-2-5-解析器的内部原理"><a href="#1-2-5-解析器的内部原理" class="headerlink" title="1.2.5 解析器的内部原理"></a>1.2.5 解析器的内部原理</h4><p>下面来看一看当应用程序调用解析器时，解析器内部是怎样工作的.</p>
<p><img src="/img/network14.jpg"></p>
<p>顺带一提，向DNS服务器发送消息时，我们当然也需要知道DNS服务器的IP地址。只不过这个IP地址是作为TCP/IP的一个设置项目事先设置好的，不需要再去查询了。不同的操作系统中TCP/IP的设置方法也有差异，Windows中的设置如下图所示，解析器会根据这里设置的DNS服务器IP地址来发送消息。</p>
<p><img src="/img/network15.jpg"></p>
<h3 id="1-3-全世界DNS服务器的大接力"><a href="#1-3-全世界DNS服务器的大接力" class="headerlink" title="1.3 全世界DNS服务器的大接力"></a>1.3 全世界DNS服务器的大接力</h3><h4 id="1-3-1-DNS服务器的基本工作"><a href="#1-3-1-DNS服务器的基本工作" class="headerlink" title="1.3.1 DNS服务器的基本工作"></a>1.3.1 DNS服务器的基本工作</h4><p>DNS服务器就是根据这些记录查找符合查询请求的内容并对客户端作出响应的。</p>
<p><img src="/img/network16.jpg"></p>
<p>DNS服务器的基本工作就是根据需要查询的域名和记录类型查找相关的记录，并向客户端返回响应消息。</p>
<h4 id="1-3-2-域名的层次结构"><a href="#1-3-2-域名的层次结构" class="headerlink" title="1.3.2 域名的层次结构"></a>1.3.2 域名的层次结构</h4><p>我们假设要查询的信息已经保存在DNS服务器内部的记录中了。如果是在像公司内部网络这样Web和邮件服务器数量有限的环境中，所有的信息都可以保存在一台DNS服务器中，其工作方式也就完全符合我们前面讲解的内容。然而，互联网中存在着不计其数的服务器，将这些服务器的信息全部保存在一台DNS服务器中是不可能的，因此一定会出现在DNS服务器中找不到要查询的信息的情况。下面来看一看此时DNS服务器是如何工作的。</p>
<p>直接说答案的话很简单，就是将信息分布保存在多台DNS服务器中，这些DNS服务器相互接力配合，从而查找出要查询的信息。不过，这个机制其实有点复杂，因此我们先来看一看信息是如何在DNS服务器上注册并保存的。</p>
<p>首先，DNS服务器中的所有信息都是按照域名以分层次的结构来保存的。层次结构这个词听起来可能有点不容易懂，其实就类似于公司中的事业集团、部门、科室这样的结构。层次结构能够帮助我们更好地管理大量的信息。</p>
<p>DNS中的域名都是用句点来分隔的，比如<a href="http://www.lab.glasscom.com，这里的句点代表了不同层次之间的界限，就相当于公司里面的组织结构不用部、科之类的名称来划分，只是用句点来分隔而已。在域名中，越靠右的位置表示其层级越高，比如www.lab.glasscom.com这个域名如果按照公司里的组织结构来说，大概就是“com事业集团glasscom部lab科的www”这样。其中，相当于一个层级的部分称为域。因此，com域的下一层是glasscom域，再下一层是lab域，再下面才是www这个名字。" target="_blank" rel="noopener">www.lab.glasscom.com，这里的句点代表了不同层次之间的界限，就相当于公司里面的组织结构不用部、科之类的名称来划分，只是用句点来分隔而已。在域名中，越靠右的位置表示其层级越高，比如www.lab.glasscom.com这个域名如果按照公司里的组织结构来说，大概就是“com事业集团glasscom部lab科的www”这样。其中，相当于一个层级的部分称为域。因此，com域的下一层是glasscom域，再下一层是lab域，再下面才是www这个名字。</a></p>
<p>这种具有层次结构的域名信息会注册到DNS服务器中，而每个域都是作为一个整体来处理的。换句话说就是，一个域的信息是作为一个整体存放在DNS服务器中的，不能将一个域拆开来存放在多台DNS服务器中。不过，DNS服务器和域之间的关系也并不总是一对一的，一台DNS服务器中也可以存放多个域的信息。为了避免把事情搞得太复杂，这里先假设一台DNS服务器中只存放一个域的信息，后面的讲解也是基于这个前提来进行的。于是，DNS服务器也具有了像域名一样的层次结构，每个域的信息都存放在相应层级的DNS服务器中。例如，这里有一个公司的域，那么就相应地有一台DNS服务器，其中存放了公司中所有Web服务器和邮件服务器的信息</p>
<h4 id="1-3-3-寻找相应的DNS服务器并获取IP地址"><a href="#1-3-3-寻找相应的DNS服务器并获取IP地址" class="headerlink" title="1.3.3 寻找相应的DNS服务器并获取IP地址"></a>1.3.3 寻找相应的DNS服务器并获取IP地址</h4><p>下面再来看一看如何找到DNS服务器中存放的信息。这里的关键在于如何找到我们要访问的Web服务器的信息归哪一台DNS服务器管。</p>
<p>互联网中有数万台DNS服务器，肯定不能一台一台挨个去找。我们可以采用下面的办法。首先，将负责管理下级域的DNS服务器的IP地址注册到它们的上级DNS服务器中，然后上级DNS服务器的IP地址再注册到更上一级的DNS服务器中，以此类推。也就是说，负责管理lab.glasscom.com这个域的DNS服务器的IP地址需要注册到glasscom.com域的DNS服务器中，而glasscom.com域的DNS服务器的IP地址又需要注册到com域的DNS服务器中。这样，我们就可以通过上级DNS服务器查询出下级DNS服务器的IP地址，也就可以向下级DNS服务器发送查询请求了</p>
<p>在前面的讲解中，似乎com、jp这些域（称为顶级域）就是最顶层了，它们各自负责保存下级DNS服务器的信息，但实际上并非如此。在互联网中，com和jp的上面还有一级域，称为根域。根域不像com、jp那样有自己的名字，因此在一般书写域名时经常被省略，如果要明确表示根域，应该像<a href="http://www.lab.glasscom.com.这样在域名的最后再加上一个句点，而这个最后的句点就代表根域。不过，一般都不写最后那个句点，因此根域的存在往往被忽略，但根域毕竟是真实存在的，根域的DNS服务器中保管着com、jp等的DNS服务器的信息。由于上级DNS服务器保管着所有下级DNS服务器的信息，所以我们可以从根域开始一路往下顺藤摸瓜找到任意一个域的DNS服务器。" target="_blank" rel="noopener">www.lab.glasscom.com.这样在域名的最后再加上一个句点，而这个最后的句点就代表根域。不过，一般都不写最后那个句点，因此根域的存在往往被忽略，但根域毕竟是真实存在的，根域的DNS服务器中保管着com、jp等的DNS服务器的信息。由于上级DNS服务器保管着所有下级DNS服务器的信息，所以我们可以从根域开始一路往下顺藤摸瓜找到任意一个域的DNS服务器。</a></p>
<p>除此之外还需要完成另一项工作，那就是将根域的DNS服务器信息保存在互联网中所有的DNS服务器中。这样一来，任何DNS服务器就都可以找到并访问根域DNS服务器了。因此，客户端只要能够找到任意一台DNS服务器，就可以通过它找到根域DNS服务器，然后再一路顺藤摸瓜找到位于下层的某台目标DNS服务器（图1.15）。分配给根域DNS服务器的IP地址在全世界仅有13个，而且这些地址几乎不发生变化，因此将这些地址保存在所有的DNS服务器中也并不是一件难事。</p>
<p><img src="/img/network17.jpg"></p>
<p>如图上图所示，客户端首先会访问最近的一台DNS服务器（也就是客户端的TCP/IP设置中填写的DNS服务器地址），假设我们要查询<a href="http://www.lab.glasscom.com这台Web服务器的相关信息。由于最近的DNS服务器中没有存放www.lab.glasscom.com这一域名对应的信息，所以我们需要从顶层开始向下查找。最近的DNS服务器中保存了根域DNS服务器的信息，因此它会将来自客户端的查询消息转发给根域DNS服务器。根域服务器中也没有www.lab.glasscom.com这个域名，但根据域名结构可以判断这个域名属于com域，因此根域DNS服务器会返回它所管理的com域中的DNS服务器的IP地址，意思是“虽然我不知道你要查的那个域名的地址，但你可以去com域问问看”。" target="_blank" rel="noopener">www.lab.glasscom.com这台Web服务器的相关信息。由于最近的DNS服务器中没有存放www.lab.glasscom.com这一域名对应的信息，所以我们需要从顶层开始向下查找。最近的DNS服务器中保存了根域DNS服务器的信息，因此它会将来自客户端的查询消息转发给根域DNS服务器。根域服务器中也没有www.lab.glasscom.com这个域名，但根据域名结构可以判断这个域名属于com域，因此根域DNS服务器会返回它所管理的com域中的DNS服务器的IP地址，意思是“虽然我不知道你要查的那个域名的地址，但你可以去com域问问看”。</a> 接下来，最近的DNS服务器又会向com域的DNS服务器发送查询消息。com域中也没有<a href="http://www.lab.glasscom.com这个域名的信息，和刚才一样，com域服务器会返回它下面的glasscom.com域的DNS服务器的IP地址。以此类推，只要重复前面的步骤，就可以顺藤摸瓜找到目标DNS服务器，只要向目标DNS服务器发送查询消息，就能够得到我们需要的答案，也就是www.lab.glasscom.com的IP地址了。" target="_blank" rel="noopener">www.lab.glasscom.com这个域名的信息，和刚才一样，com域服务器会返回它下面的glasscom.com域的DNS服务器的IP地址。以此类推，只要重复前面的步骤，就可以顺藤摸瓜找到目标DNS服务器，只要向目标DNS服务器发送查询消息，就能够得到我们需要的答案，也就是www.lab.glasscom.com的IP地址了。</a></p>
<p><img src="/img/network18.jpg"></p>
<h4 id="1-3-4-通过缓存加快DNS服务器的响应"><a href="#1-3-4-通过缓存加快DNS服务器的响应" class="headerlink" title="1.3.4 通过缓存加快DNS服务器的响应"></a>1.3.4 通过缓存加快DNS服务器的响应</h4><p>上图展示的是基本原理，与真实互联网中的工作方式还是有一些区别的。在真实的互联网中，一台DNS服务器可以管理多个域的信息，因此并不是像图1.16这样每个域都有一台自己的DNS服务器。图中，每一个域旁边都写着一台DNS服务器，但现实中上级域和下级域有可能共享同一台DNS服务器。在这种情况下，访问上级DNS服务器时就可以向下跳过一级DNS服务器，直接返回再下一级DNS服务器的相关信息。</p>
<p>此外，有时候并不需要从最上级的根域开始查找，因为DNS服务器有一个缓存功能，可以记住之前查询过的域名。如果要查询的域名和相关信息已经在缓存中，那么就可以直接返回响应，接下来的查询可以从缓存的位置开始向下进行。相比每次都从根域找起来说，缓存可以减少查询所需的时间。</p>
<p>并且，当要查询的域名不存在时，“不存在”这一响应结果也会被缓存。这样，当下次查询这个不存在的域名时，也可以快速响应。</p>
<p><strong>这个缓存机制中有一点需要注意，那就是信息被缓存后，原本的注册信息可能会发生改变，这时缓存中的信息就有可能是不正确的。因此，DNS服务器中保存的信息都设置有一个有效期，当缓存中的信息超过有效期后，数据就会从缓存中删除。而且，在对查询进行响应时，DNS服务器也会告知客户端这一响应的结果是来自缓存中还是来自负责管理该域名的DNS服务器。</strong></p>
<h3 id="1-4-委托协议栈发送消息"><a href="#1-4-委托协议栈发送消息" class="headerlink" title="1.4 委托协议栈发送消息"></a>1.4 委托协议栈发送消息</h3><h4 id="1-4-1-数据收发操作概览"><a href="#1-4-1-数据收发操作概览" class="headerlink" title="1.4.1 数据收发操作概览"></a>1.4.1 数据收发操作概览</h4><p>知道了IP地址之后，就可以委托操作系统内部的协议栈向这个目标IP地址，也就是我们要访问的Web服务器发送消息了。要发送给Web服务器的HTTP消息是一种数字信息(digital data)，因此也可以说是委托协议栈来发送数字信息。收发数字信息这一操作不仅限于浏览器，对于各种使用网络的应用程序来说都是共通的。因此，这一操作的过程也不仅适用于Web，而是适用于任何网络应用程序。</p>
<p>和向DNS服务器查询IP地址的操作一样，这里也需要使用Socket库中的程序组件。不过，查询IP地址只需要调用一个程序组件就可以了，而这里需要按照指定的顺序调用多个程序组件，这个过程有点复杂。发送数据是一系列操作相结合来实现的，如果不能理解这个操作的全貌，就无法理解其中每个操作的意义。因此，我们先来介绍一下收发数据操作的整体思路。</p>
<p>使用Socket库来收发数据的操作过程如下图。简单来说，收发数据的两台计算机之间连接了一条数据通道，数据沿着这条通道流动，最终到达目的地。我们可以把数据通道想象成一条管道，将数据从一端送入管道，数据就会到达管道的另一端然后被取出。数据可以从任何一端被送入管道，数据的流动是双向的。不过，这并不是说现实中真的有这么一条管道，只是为了帮助大家理解数据收发操作的全貌。</p>
<p><img src="/img/network19.jpg"></p>
<p>收发数据的整体思路就是这样，但还有一点也非常重要。光从图上来看，这条管道好像一开始就有，实际上并不是这样，在进行收发数据操作之前，双方需要先建立起这条管道才行。建立管道的关键在于管道两端的数据出入口，这些出入口称为套接字。我们需要先创建套接字，然后再将套接字连接起来形成管道。实际的过程是下面这样的。首先，服务器一方先创建套接字，然后等待客户端向该套接字连接管道。当服务器进入等待状态时，客户端就可以连接管道了。具体来说，客户端也会先创建一个套接字，然后从该套接字延伸出管道，最后管道连接到服务器端的套接字上。当双方的套接字连接起来之后，通信准备就完成了。接下来，就像我们刚刚讲过的一样，只要将数据送入套接字就可以收发数据了。</p>
<p>我们再来看一看收发数据操作结束时的情形。当数据全部发送完毕之后，连接的管道将会被断开。管道在连接时是由客户端发起的，但在断开时可以由客户端或服务器任意一方发起。其中一方断开后，另一方也会随之断开，当管道断开后，套接字也会被删除。到此为止，通信操作就结束了。</p>
<p>综上所述，收发数据的操作分为若干个阶段，可以大致总结为以下4个</p>
<p>(1)创建套接字（创建套接字阶段）</p>
<p>(2)将管道连接到服务器端的套接字上（连接阶段）</p>
<p>(3)收发数据（通信阶段）</p>
<p>(4)断开管道并删除套接字（断开阶段）</p>
<p>在每个阶段，Socket库中的程序组件都会被调用来执行相关的数据收发操作。不过，在探索其具体过程之前，我们来补充一点内容。前面这4个操作都是由操作系统中的协议栈来执行的，浏览器等应用程序并不会自己去做连接管道、放入数据这些工作，而是委托协议栈来代劳。</p>
<h4 id="1-4-2-创建套接字阶段"><a href="#1-4-2-创建套接字阶段" class="headerlink" title="1.4.2 创建套接字阶段"></a>1.4.2 创建套接字阶段</h4><p>下面我们就来探索一下应用程序（浏览器）委托收发数据的过程。这个过程的关键点就是像对DNS服务器发送查询一样，调用Socket库中的特定程序组件。访问DNS服务器时我们调用的是一个叫作gethostbyname的程序组件（也就是解析器），而这一次则需要按照一定的顺序调用若干个程序组件，其过程如下图所示，请大家边看图边继续看下面的讲解。其中，调用Socket库中的程序组件的思路和图1.11旁边关于调用解析器的说明是一样的，请大家回忆一下。</p>
<p>首先是套接字创建阶段。客户端创建套接字的操作非常简单，只要调用Socket库中的socket程序组件就可以了。</p>
<p>套接字创建完成后，协议栈会返回一个描述符，应用程序会将收到的描述符存放在内存中。描述符是用来识别不同的套接字的，大家可以作如下理解。我们现在只关注了浏览器访问Web服务器的过程，但实际上计算机中会同时进行多个数据的通信操作，比如可以打开两个浏览器窗口，同时访问两台Web服务器。这时，有两个数据收发操作在同时进行，也就需要创建两个不同的套接字。这个例子说明，同一台计算机上可能同时存在多个套接字，在这样的情况下，我们就需要一种方法来识别出某个特定的套接字，这种方法就是描述符。我们可以将描述符理解成给某个套接字分配的编号。也许光说编号还不够形象，大家可以想象一下在酒店寄存行李时的场景，酒店服务人员会给你一个号码牌，向服务人员出示号码牌，就可以取回自己寄存的行李，描述符的原理和这个差不多。当创建套接字后，我们就可以使用这个套接字来执行收发数据的操作了。这时，只要我们出示描述符，协议栈就能够判断出我们希望用哪一个套接字来连接或者收发数据了。</p>
<p><img src="/img/network20.jpg"></p>
<p>内部分为创建套接字、连接Web服务器、发送数据、接收数据、断开连接几个阶段。</p>
<h4 id="1-4-3-连接阶段：把管道接上去"><a href="#1-4-3-连接阶段：把管道接上去" class="headerlink" title="1.4.3 连接阶段：把管道接上去"></a>1.4.3 连接阶段：把管道接上去</h4><p>接下来，我们需要委托协议栈将客户端创建的套接字与服务器那边的套接字连接起来。应用程序通过调用Socket库中的名为connect的程序组件来完成这一操作。这里的要点是当调用connect时，需要指定描述符、服务器IP地址和端口号这3个参数。</p>
<p>第1个参数，即描述符，就是在创建套接字的时候由协议栈返回的那个描述符。connect会将应用程序指定的描述符告知协议栈，然后协议栈根据这个描述符来判断到底使用哪一个套接字去和服务器端的套接字进行连接，并执行连接的操作。</p>
<p>第2个参数，即服务器IP地址，就是通过DNS服务器查询得到的我们要访问的服务器的IP地址。在DNS服务器的部分已经讲过，在进行数据收发操作时，双方必须知道对方的IP地址并告知协议栈。这个参数就是那个IP地址了。</p>
<p>第3个参数，即端口号，这个需要稍微解释一下。可能大家会觉得，IP地址就像电话号码，只要知道了电话号码不就可以联系到对方了吗？其实，网络通信和电话还是有区别的，我们先来看一看IP地址到底能用来干什么。</p>
<p>总而言之，就是当调用connect时，协议栈就会执行连接操作。当连接成功后，协议栈会将对方的IP地址和端口号等信息保存在套接字中，这样我们就可以开始收发数据了。</p>
<h4 id="1-4-4-通信阶段：传递消息"><a href="#1-4-4-通信阶段：传递消息" class="headerlink" title="1.4.4 通信阶段：传递消息"></a>1.4.4 通信阶段：传递消息</h4><p>当套接字连接起来之后，剩下的事情就简单了。只要将数据送入套接字，数据就会被发送到对方的套接字中。当然，应用程序无法直接控制套接字，因此还是要通过Socket库委托协议栈来完成这个操作。</p>
<p>首先，应用程序需要在内存中准备好要发送的数据。根据用户输入的网址生成的HTTP请求消息就是我们要发送的数据。接下来，当调用write时，需要指定描述符和发送数据，然后协议栈就会将数据发送到服务器。由于套接字中已经保存了已连接的通信对象的相关信息，所以只要通过描述符指定套接字，就可以识别出通信对象，并向其发送数据。接着，发送数据会通过网络到达我们要访问的服务器。</p>
<p>接下来，服务器执行接收操作，解析收到的数据内容并执行相应的操作，向客户端返回响应消息。</p>
<p>当消息返回后，需要执行的是接收消息的操作。接收消息的操作是通过Socket库中的read程序组件委托协议栈来完成的（图1.18③’）。调用read时需要指定用于存放接收到的响应消息的内存地址，这一内存地址称为接收缓冲区。于是，当服务器返回响应消息时，read就会负责将接收到的响应消息存放到接收缓冲区中。由于接收缓冲区是一块位于应用程序内部的内存空间，因此当消息被存放到接收缓冲区中时，就相当于已经转交给了应用程序。</p>
<h4 id="1-4-5-断开阶段：收发数据结束"><a href="#1-4-5-断开阶段：收发数据结束" class="headerlink" title="1.4.5 断开阶段：收发数据结束"></a>1.4.5 断开阶段：收发数据结束</h4><p>当浏览器收到数据之后，收发数据的过程就结束了。接下来，我们需要调用Socket库的close程序组件进入断开阶段（图1.18④）。最终，连接在套接字之间的管道会被断开，套接字本身也会被删除。</p>
<p>断开的过程如下。Web使用的HTTP协议规定，当Web服务器发送完响应消息之后，应该主动执行断开操作[插图]，因此Web服务器会首先调用close来断开连接。断开操作传达到客户端之后，客户端的套接字也会进入断开阶段。接下来，当浏览器调用read执行接收数据操作时，read会告知浏览器收发数据操作已结束，连接已经断开。浏览器得知后，也会调用close进入断开阶段。</p>
<p>这就是HTTP的工作过程。HTTP协议将HTML文档和图片都作为单独的对象来处理，每获取一次数据，就要执行一次连接、发送请求消息、接收响应消息、断开的过程。因此，如果一个网页中包含很多张图片，就必须重复进行很多次连接、收发数据、断开的操作。对于同一台服务器来说，重复连接和断开显然是效率很低的，因此后来人们又设计出了能够在一次连接中收发多个请求和响应的方法。在HTTP版本1.1中就可以使用这种方法，在这种情况下，当所有数据都请求完成后，浏览器会主动触发断开连接的操作。</p>
<h2 id="2、用电信号传输TCP-IP-—-探索协议栈和网卡"><a href="#2、用电信号传输TCP-IP-—-探索协议栈和网卡" class="headerlink" title="2、用电信号传输TCP/IP — 探索协议栈和网卡"></a>2、用电信号传输TCP/IP — 探索协议栈和网卡</h2><p>第1章，我们从解析浏览器中输入的网址开始，探索了生成HTTP请求消息、委托操作系统发送消息等步骤。本章，我们将讲解操作系统中的协议栈是如何处理数据发送请求的。</p>
<p><img src="/img/network21.jpg"></p>
<p>(1)创建套接字</p>
<p>从应用程序收到委托后，协议栈通过TCP协议收发数据的操作可以分为4个阶段。首先是创建套接字，在这个阶段，我们将介绍协议栈的内部结构、套接字的实体，以及创建套接字的操作过程。到这里，大家应该可以对套接字到底是什么样的一个东西有一个比较具体的理解。</p>
<p>(2)连接服务器</p>
<p>接下来是客户端套接字向服务器套接字进行连接的阶段。我们将介绍“连接”具体是进行怎样的操作，在这个过程中协议栈到底是如何工作的，以及客户端和服务器是如何进行交互的。</p>
<p>(3)收发数据</p>
<p>两端的套接字完成连接之后，就进入收发消息的阶段了。在这个阶段，协议栈会将从应用程序收到的数据切成小块并发送给服务器，考虑到通信过程中可能会出错导致网络包丢失，协议栈还需要确认切分出的每个包是否已经送达服务器，对于没有送达的包要重新发送一次。这里我们将对收发数据的情形加以说明。</p>
<p>(4)从服务器断开连接并删除套接字</p>
<p>收发消息的操作全部结束之后，接下来要断开服务器的连接并删除套接字。断开操作的本质是当消息收发完成后客户端和服务器相互进行确认的过程，但这个过程并不只是相互确认并删除套接字那么简单，其中有些地方是很有意思的。</p>
<p>(5)IP与以太网的包收发操作</p>
<p>在介绍TCP协议收发消息的操作之后，我们再来看看实际的网络包是如何进行收发的。协议栈会与网卡进行配合，将数据切分成小块并封装成网络包，再将网络包转换成电信号或者光信号发送出去。介绍完这个过程之后，大家应该就可以对计算机网络功能有一个完整的概念了。</p>
<p>(6)用UDP协议收发数据的操作</p>
<p>TCP协议有很多方便的功能，比如网络包出错丢失时可以重发，因此很多应用程序都是使用TCP协议来收发数据的，但这些方便的功能也有帮倒忙的时候，在这种情况下我们还有另外一种叫UDP的协议。这里我们将介绍UDP的必要性以及它与TCP的差异。</p>
<h3 id="2-1-创建套接字"><a href="#2-1-创建套接字" class="headerlink" title="2.1 创建套接字"></a>2.1 创建套接字</h3><h2 id="3、从网络到网络设备-—-探索集线器、交换机和路由器"><a href="#3、从网络到网络设备-—-探索集线器、交换机和路由器" class="headerlink" title="3、从网络到网络设备 — 探索集线器、交换机和路由器"></a>3、从网络到网络设备 — 探索集线器、交换机和路由器</h2><h2 id="4、通过接入网进入互联网内部-—-探索接入网和网络运营商"><a href="#4、通过接入网进入互联网内部-—-探索接入网和网络运营商" class="headerlink" title="4、通过接入网进入互联网内部 — 探索接入网和网络运营商"></a>4、通过接入网进入互联网内部 — 探索接入网和网络运营商</h2><h2 id="5、服务器端的局域网中有什么玄机"><a href="#5、服务器端的局域网中有什么玄机" class="headerlink" title="5、服务器端的局域网中有什么玄机"></a>5、服务器端的局域网中有什么玄机</h2><h2 id="6、请求到达web服务器，响应返回浏览器-—-短短几秒“漫长旅程”迎来终点"><a href="#6、请求到达web服务器，响应返回浏览器-—-短短几秒“漫长旅程”迎来终点" class="headerlink" title="6、请求到达web服务器，响应返回浏览器 — 短短几秒“漫长旅程”迎来终点"></a>6、请求到达web服务器，响应返回浏览器 — 短短几秒“漫长旅程”迎来终点</h2>
        
        <div id="comment-container">
        </div>
    </div>

    <div style="position:fixed;right:10px;bottom:15px;color: #999;cursor: pointer;" onclick="window.scrollTo(0,0)">回到顶部</div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/fanky-c">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p style="padding-top:10px;">
        <span>/</span>
        
            
               <span><a href="http://www.fankyc.cn">fanky_c</a></span>
            
        <span>/</span>
        
            
               <span><a href="https://beian.miit.gov.cn" target="_blank">粤ICP备19149804号</a></span>
            
        <span>/</span>
        
            
               <span><a href="#">It helps SEO</a></span>
            
        <span>/</span>
        
    </p>
    
    <p style="padding-top:5px;">
        <!--<span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>-->
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a>
    </p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<!-- <script async src="//cdn.jsdelivr.net/gh/sukkaw/busuanzi@2.3/bsz.pure.mini.js"></script> -->

</html>
