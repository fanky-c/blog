[{"title":"笔试题","url":"/2023/11/29/笔试题/","content":"\n### 1、防抖和节流函数\n\n防抖的主要思想是，当事件被触发后，延迟一定时间再执行相关操作。如果在这个延迟期内再次触发了同样的事件，就会重新计时。\n\n```js\nconst debounce = function(fn, delay) {\n  let timer = null;\n  return function() {\n    const that = this;\n    if(timer){\n      clearTimeout(timer);\n      timer = null;\n    }\n    timer = setTimeout(function(){\n      // 防止this为window\n      fn.apply(that, arguments);\n    }, delay)\n   }\n}\n\nwindow.addEventListener('resize', debounce(()=>{\n  console.log('防抖执行');\n}, 300));\n```\n\n\n节流的主要思想是，在一定时间内只允许函数执行一次，无论事件触发了多少次。\n\n```js\nconst throttle = function(fn, delay){\n  let lastTime = 0;\n  return function() {\n    const now = Date.now();\n    if(now - lastTime > delay){\n      fn.apply(this, arguments);\n      lastTime = now;\n    }\n  }\n}\n\nwindow.addEventListener('scroll', throttle(()=>{\n  console.log('节流执行');\n}, 300));\n```\n\n\n### 2、实现bind方法\n\nbind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。\n\n```js\n// 1、原生bind\nconst obj = {\n  name: 'zc',\n  age: 12\n}\nfunction say(sex){\n  console.log(`name: ${this.name}, age: ${this.age}, sex: ${sex}, 参数: ${[...arguments]}`);\n}\nconst mySay = say.bind(obj, 'female');\nmySay(111); // name: zc, age: 12, sex: female, 参数: female,111\n\n// 2、实现myBind\nFunction.prototype.myBind = function(context) {\n  const that = this;\n  const args = Array.prototype.slice.call(arguments, 1);  // 获取额外参数\n\n  return function() {\n    const newArgs = Array.prototype.slice.call(arguments);  // 获取调用时出入的参数\n    return that.apply(context, [...args, ...newArgs]); // 执行原始函数并传递参数\n  }\n}\n\nconst mySay1 = say.myBind(obj, 'female');\nmySay1(222); // name: zc, age: 12, sex: female, 参数: female,222\n```","tags":["编码","笔试题","面试题"]},{"title":"纳瓦尔宝典","url":"/2023/10/31/纳瓦尔宝典/","content":"\n## 第一部分 财富\n### 第一章 积累财富\n#### 1、认识财富创造的原理\n假设有一天，我创业失败，身无分文，这时把我随意丢到任何一个说英语的国家的街道上，我相信自己会在5年或10年内重新变得富有，因为我已经掌握了“赚钱”这门技巧，而这门技巧人人都能学会。**赚钱跟工作的努力程度没什么必然联系。即使每周在餐厅拼命工作80个小时，也不可能发财。要想获得财富，你就必须知道做什么、和谁一起做、什么时候做。与埋头苦干相比，更重要的是理解和思考。当然，努力非常重要，不能吝啬自己的努力，但必须选择正确的方式。**\n\n追求财富，而不是金钱或地位。财富是指在你睡觉时仍能为你赚钱的资产。金钱是我们转换时间和财富的方式。地位是你在社会等级体系中所处的位置。\n\n**获得财富的一个途径，就是为社会提供其有需求但无从获得的东西，并实现规模化。**\n\n培养迭代思维。生活中所有的回报，无论是财富、人际关系，还是知识，都来自复利。\n\n不要跟愤世嫉俗和消极悲观的人合作。他们的预言会自我实现。\n\n**专长指的是无法通过培训获得的知识。如果社会可以培训你，那么社会也可以培训他人来取代你。**\n\n要想有所专长，就要追求真正的兴趣和热爱，而不是盲目追逐热点。\n\n累积专长的过程，对你而言就像玩耍，对他人来说则很吃力。\n\n**专长的传授需要通过师傅带徒弟的方式完成，而无法通过学校教育完成。**\n\n代码和媒体是不需要许可就能使用的杠杆。这两个杠杆是新富阶层背后的杠杆。你可以创建软件和媒体，让它们在你睡觉时为你工作。\n\n如果不会写代码，那就出书、写博客、做视频、录播客\n\n**工作时要拼尽全力，毫无保留。不过，共事的人和工作的内容比努力程度更重要。**\n\n**世界上没有快速致富的教程。即使有，那也只是提供教程的人想从你身上赚钱。**\n\n**把自己产品化**\n\n这句话有两个重点，一个是“自己”，一个是“产品化”。“自己”具有独特性，“产品化”是发挥杠杆效应；“自己”具有责任感，“产品化”需要专长。“自己”其实也具有专长。因此，这两个重点就可以概括上述所有的理念。\n\n如果想要实现致富的长期目标，你就应该问问自己：“这是我真正想要的东西吗？我的规划目标是我真正想要的吗？”得到肯定的答案后，再问问自己：“我实现产品化了吗？我实现规模化了吗？我选择规模化的方式是劳动力、资本，还是代码或媒体？”由此可见，“把自己产品化”这个阐述方便简单，便于记忆。\n\n“把自己产品化”很难。所以我才说“把自己产品化”要花几十年——并不是要花几十年执行，而是要把大部分时间用于思考：我能提供什么独特的价值？\n\n**财富和金钱的区别是什么？**\n\n金钱是我们转移财富的方式。金钱是社会的信用符号，具有调用别人时间的能力。\n\n**如果我做好了本职工作，为社会创造了价值，社会就会对我说：“谢谢你，因为你在过去所做的工作，我们在未来欠你一些东西。这是一张欠条，我们可以把这个叫作钱。”**\n\n所以，我对财富的定义是在睡觉时也能带来收入的企业和资产。\n\n要想在社会上赚到钱，就要为社会提供其有需求但无从获得的东西。如果社会已经创造出需要的产品和服务，你也就不被需要了。\n\n社会总是需要新事物。如果想变得富有，你就要弄清楚你能为社会提供哪些其有需求但无从获得的东西，而提供这些东西对你来说又是轻松自然的事情，在你的技术和能力范围内。\n\n下一步是思考如何规模化，因为只提供一个产品或一项服务是远远不够的，必须提供成千上万个，甚至几十万、几百万、几十亿个，最好人手一个。\n\n\n#### 2、找到天赋所在，积累专长\n他们的销售技能显然也是习得的，但一定不是在课堂上学到的。他们可能在学校操场上学会了如何推销，可能是在跟父母的沟通中学会了讨价还价，也可能有一些遗传基因在里面。\n\n专长无法被教授，但可以被学习。\n\n**想要找准适合自己的专长，可以回想一下在孩提时代或青少年时期，有哪些事情是你几乎不费吹灰之力就可以完成的。有时候，即使你自己不觉得那是一门技能，身边的人也会留意到。你的母亲或者你成长过程中最好的朋友会知道你有什么特别之处。**\n\n其实，人生大部分时间都是在寻找，寻找那些最需要你的人，寻找那些最需要你的事情。\n\n以我为例，我喜欢阅读，也喜欢科技。我学得很快，但非常容易喜新厌旧。如果我的工作是对一个问题研究20年，那么我肯定做不好。我现在的职业是风险投资。要做好风投，就需要迅速跟上新科技的发展速度（由于新科技层出不穷，我“喜新厌旧”的个性反而是件好事），所以做风投与我的专长和技能相当契合。\n\n如果你在研究的时候不是百分之百投入，其他百分之百投入的人就会超过你。他们的表现会比你好不是一点儿，而是很多，因为我们讨论的是创意领域的竞争。在创意领域，复利效应非常明显，杠杆效应也非常明显。\n\n互联网极大地拓宽了职业空间。大多数人还没有清晰地认识到这一点。通过互联网，每个人都可以找到自己的受众。只要在网上进行独特的自我表达，你就有机会传播快乐，累积财富，打造产品，创立企业。\n\n**有了互联网，只要你在自己的领域做到最好，只要你能规模化你所提供的特别内容，那么就算你的兴趣很小众，你也能有所发展。**\n\n有一条推文我没有放入“如何致富”的推文风暴里，但值得一读。这条推文的内容非常简单：“只有独辟蹊径，才能避开竞争。”从本质上看，竞争就是模仿，与他人竞争，是因为你跟别人在做一样的事情。但是，每个人都是独一无二的，不要模仿他人。\n\n**最好的工作与委任或学位无关。最好的工作是终身学习者在自由市场中的创造性表达。**\n\n致富最重要的技能是成为终身学习者，无论想学什么，你都得找到途径和方法。以前的赚钱模式是读4年大学，拿到学位，在某个专业领域干上30年。现在不一样了，时代的发展日新月异，必须在9个月内掌握一门新专业，而这门专业在4年后就过时了。但在专业存在的这3年里，你可以变得非常富有。\n\n#### 3、投资交友，着眼长远\n\n你曾说：“生活中所有的回报，无论是财富、人际关系，还是知识，都来自复利。”如何判断自己是否获得了复利呢？\n\n商业关系中的复利效应非常重要。看看社会上的顶级角色，为什么有些人能够担任上市公司首席执行官，或者管理几十亿美元的资金？这源于别人对他们的信任。之所以能够得到信任，是因为他们打造的人际关系和事业产生了复利效应。他们以极为直观和负责的方式投入事业，向世界证明自己品行正直，高度诚信。\n\n**个人声誉方面也存在复利效应。如果一个人声誉良好，数十年如一日，不断打造和积累自己的声誉，这个人就一定会得到关注和重视。而如果一个人才华横溢，却没有利用声誉的复利效应，相比之下，注重声誉的人的价值就会高出其成千上万倍。**\n\n一旦找到正确的事业和一同前行的人，就要全身心投入。接下来，持续精进几十年，就能从人际关系和经济利益上获得巨大的回报。因此，复利效应非常重要。\n\n99%的努力终将白费。\n\n**显然，没有一种努力是完全白费的，因为我们总能在努力的过程中学到一些东西。任何经历都可以成为学习的机会。**举例来说，回顾求学生涯，当时写的论文、读的书、做的练习，99%不适用于现实社会。学到的一些地理和历史知识你从未派上用场，学的一门外语你早已不再使用，一些数学知识你也早已全然忘记。\n\n当然，学校的学习经历的确教会了我们一些东西。比如，你理解了努力的重要性，一些理念也潜移默化地成为你的精神动力，或者在一定程度上促使你从事当前的职业，等等。然而，至少从以目标为导向的现实社会的角度看，你在学校里付出的努力只有1%得到了回报。\n\n再以约会为例。在遇到你的人生伴侣之前，你会跟不同的人约会。从目标层面看，这些约会纯属浪费时间（虽然从个人成长和学习体验方面看并非如此）。\n\n我说这些，并不是在自作聪明地断言“生命中99%的时间都被浪费了，只有1%被用在了正确的地方”。我想说的是，你应该在经过深思熟虑后，清醒地认识到自己需要从大多数事情（人际关系、工作、学习）中找到可以尽全力去付出的那部分，以充分获取复利效应。\n\n在约会过程中，如果意识到两个人不会走入婚姻殿堂，那么你也许应当尽早结束这段关系，开始下一段旅程。当学习的时候，比如学习地理或历史，如果意识到学到的知识你永远不会用，那就放弃这门课程吧。把精力用在无用的东西上是浪费时间，浪费脑力。\n\n我不是说那99%的事情都不要做，因为我们很难确定剩下的1%到底是什么。我的意思是：努力找到不会被浪费的1%。这1%对你是有意义的，值得你用余生去追求。一旦找到，你就要心无旁骛，全力以赴。\n\n**出发点不重要， 行为本身才重要**\n\n#### 4、承担责任\n要认识到，在现代社会，下行风险并没那么大。在良好的生态系统中，即使个人破产，债务也可以被一笔勾销。我最熟悉的是硅谷的环境，但是整体而言，只要个人诚实正直，确实付出了努力，人们就会原谅你的失败。\n\n失败真的没有那么可怕，所以我们都应该勇于承担更多责任。\n\n#### 5、创立企业或买入股权\n我们需要了解获得权益回报和赚取薪资报酬的区别。如果你是通过出租时间来换取报酬的，即使从事律师和医生等高薪职业，你能够获得的报酬也非常有限，不足以让你实现财务自由。而如果拥有企业股权，**你就可以获得被动收入——即使你在度假，企业也在帮你赚钱。**\n\n有些医生的确实现了财务自由，那也是因为他们自己开了公司。他们设立私人诊所，打造品牌，以品牌吸引客户，也有些医生通过生产医疗设备、发明某种程序或流程等获得了知识产权收益。\n\n#### 6、找到杠杆\n在现在这个时代，杠杆无处不在，真正的求知欲所带来的高经济回报前所未有。**想要打造良好的职业基础，就要追随自己真正的求知欲上下求索，而不是盲目跟风眼下赚钱的热门行业。**\n\n有意思的是，正是在独特的热爱和爱好的驱动下，我们才得以掌握只有自己或一小部分人才知道的知识。如果能够把求知欲和兴趣爱好结合、相融，我们就更有可能找到自己的所爱。\n\n如果一件事物一开始让你兴致盎然，后来又让你觉得索然无味，那么它只是暂时分散了你的注意力，并不是你心智上真正的好奇所在。请继续寻找。\n\n无论做什么事情，我都以事情本身为目标。这也是艺术创作的一个鲜明特征。无论是创业、健身还是恋爱、交友，我始终都认为生命的意义在于专注于事情本身，体验过程，享受当下。**神奇的是，当专注于事情本身时，你反而能做得更好。即使是赚钱，你也能成为赚得最多的那个。**\n\n**对一件事情的欲望越小，顾虑就越少，执念就越少，反而越会顺其自然，遵循内心。你会以自己擅长的方式，始终不渝地做下去，工作质量也会因此提高。**\n\n**不要追逐所谓的“热门”，而要追求自己真正感兴趣的事情。如果在追随好奇心和求知欲的过程中又满足了社会需求，你就能得到优厚的经济回报。**\n\n\n**认真想一想，社会上还有哪些尚未得到满足的需求，而你怎样才能成为第一个提供相关产品或服务的人，并将其规模化。这才是赚钱真正的挑战。**\n\n\n总体而言，杠杆有三种。\n\n1、**第一种是劳动力杠杆：**我甚至认为这是一种最落后的杠杆，因为管理他人是一件非常复杂、极具挑战的工作，需要高超的领导技巧，弄不好管理者会落个众叛亲离、被手下生吞活剥的下场。\n\n2、**资本是第二种相对较好的杠杆形式：**资本杠杆就是用钱来扩大决策的影响力。 资本杠杆的放大效应非常明显。管理资本要比管理人更容易，因为随着资本的不断增长，其管理难度会远远低于管理不断扩张的团队。\n\n3、**第三种杠杆就是“复制边际成本为零的产品”：**其中包括书籍、媒体、电影、代码。在所有不需要他人许可就能使用的杠杆中，代码可以说是最强大的一种——只需要一台计算机就够了。\n\n**复制边际成本为零的产品是最值得研究的杠杆，也是最重要的杠杆。这是一种全新的杠杆形式，问世仅几百年。这种杠杆始于印刷机。广播媒体加速了其发展，而互联网和编程的出现更是使其产生了爆发式增长。不需要他人为你打工，也不需要他人给你投资，你就可以把劳动成果放大成百上千倍。**\n\n本书就是一种杠杆。在过去，如果要分享我的理念，我就得坐在讲堂里，现场讲课，最多也就讲给几百个人听。\n\n**无论处于人生的哪个阶段，努力的目标都是不断提高自己的独立性，而不是升职加薪。拥有独立性，为自己独特的产出成果负责（而不是像打工一样为投入的时间负责），这才是最理想的状态。**\n\n**人生的一大目标应该是掌控自己的时间。理想的工作是利用杠杆效应的工作。在这种工作模式下，你可以掌控自己的时间，并能对自己的产出成果负责。**\n\n**如果你有专长，有责任感，又懂得如何利用杠杆效应，社会为你提供的金钱回报就会与你的价值相匹配。这时，你就能节省下更多时间，进而变得超级高效。你不需要为开会而开会，不需要努力表现自己，也不需要通过汇报材料体现你的工作量——你只要关注工作本身就可以了。**\n\n\n**任何一款产品的构建和销售都是这样的，投入与产出不存在必然联系。世界上的工作本质上分为两种：存在杠杆的工作和不存在杠杆的工作。所以不要选择类似客服这样的支持性工作。这种工作投入和产出的关系相对紧密，产出主要取决于投入的时长**\n\n想加入一家伟大的科技公司，**销售技能和构建技能必备其一。如果二者都不具备，那就去学习。**\n\n**用头脑赚钱，而不是用时间赚钱。**\n\n随着层级不断向上，杠杆效应愈加明显，责任愈加重大，需要的专长也越来越多。在劳动力杠杆的基础上增加资本杠杆，在劳动力杠杆和资本杠杆的基础上增加代码杠杆，通过这种方式，创业规模越来越大，也越来越接近拥有所有上行潜力，实现价值极值，而不再仅仅是领取薪水那么简单。\n\n以领取月薪的打工者为起点，志存高远，不断提升目标，努力获得更多杠杆效应，承担更多责任，学习更多专长。将这些结合起来，再加上复利效应的神奇作用，假以时日，你就可以变得非常富有。\n\n唯一需要避免的就是身败名裂的风险。\n\n避免身败名裂的意思就是不要锒铛入狱。所以，不要做任何违法违纪的事情，任何事都不值得拿自己的自由和声誉去冒险。要避免一败涂地的灾难性损失。避免身败名裂也意味着不要做那些可能会威胁自身安全或健康的事情。你必须照顾好自己的身体。\n\n不要做可能会让你全盘皆输的事情。不要孤注一掷、铤而走险。相反，要把赌注押在那些胜算较大、能带来巨大利益的事情上。\n\n#### 7、用判断力赚钱\n要获得更多的自由时间，就要对选择的专业领域、工作性质、职业路径以及与雇主达成的交易类型做出审慎的判断。一旦做出正确的决策，你就无须担心时间管理的问题了。**于我而言，我希望单纯靠判断力来获得报酬，而不是靠劳作。我想让机器人、资本或计算机完成实际工作，而我只靠判断力赚钱。**\n\n**没有人问他工作有多努力，没有人问他几点起床、几点睡觉。大家都说：“巴菲特，你只要把业务搞好就行了。”**\n\n**普通人把时间浪费在短期思考上，浪费在毫无价值的繁重工作上。而巴菲特会用一年斟酌判断，然后用一天采取行动。他一天的行动可以影响未来几十年。**\n\n只要在优秀的基础上稍微提高一点儿，做到卓越，经济回报就会呈数量级增加。而杠杆效应进一步放大了经济回报的差异。在杠杆时代，在自己的领域做到极致非常重要。\n\n#### 8、分清主次，聚焦重点\n**我从未一次性赚到一大笔钱，都是积少成多，更多是通过持续不断地创办企业、创造机会和开展投资来创造财富，而不是毕其功于一役。**我的个人财富也不是在关键的一年迅速累积起来的，而是积水成渊：持续创造更多选择、更多业务、更多投资，探索更多在我能力范围内的事情。\n\n\n**问题一、你说过：“如果你内心鄙视财富创造，财富就会对你避而远之。”可以解释一下吗？**\n\n如果爱慕虚荣、事事攀比，当遇到比自己好的人时，你就会心生讨厌，甚至心怀忌恨。与别人进行商业合作，如果你对对方有任何负面的想法或评价，他们就会感受到。人类与生俱来就能感知其他人内心深处的感受。因此，做人必须摆脱攀比心态。\n\n**毫不夸张地说，仇富心理会阻碍你致富，因为你没有正确的心态和精神状态，也无法在正确的层面上与人交往。保持乐观，积极向上，这种态度非常重要。从长远看，乐观主义者往往会取得更好的发展。**\n\n**问题二、对初出茅庐的年轻人来说，最重要的事情是什么？**\n\n最重要的是，要在重大决定上花更多时间。**人生早期有三个重大决定：a、在哪里生活，b、和谁在一起，c、从事什么职业。**\n\n在开启一段亲密关系之前，我们总是很少花时间深思熟虑。我们把大量时间用于工作，却很少花时间想清楚自己应该从事什么样的工作。居住的城市几乎可以完全决定一个人的生活轨迹，但我们很少花时间认真思考哪个城市更宜居。\n\n**问题三、想要做到与成功人士为伍，你认为最重要的一件或两件事是什么？**\n\n找到自己擅长的领域，然后用自己的技能去帮助他人：提供免费的产品或服务，主动向世界传递善意。好人终有好报。只要始终如一，假以时日，付出就一定能获得相应的回报。但不要计较自己付出了多少——一旦开始计较，耐心就会被消耗殆尽。\n\n**问题四、你初次创业的决定是如何做出的？**\n\n我知道有些人从未想过自己创业。**社会的普遍共识是，给别人打工才符合常理，才是明智的选择。但仔细想想，这种长久存在的观点究竟是如何产生的？这种想法本身就带有明显的等级色彩。**\n\n\n#### 9、找到如玩耍般的工作\n\n我学会了如何赚钱，因为钱是生活必需品。当赚钱的必要性消失后，我就不再关心钱的问题了。至少对我个人来说，工作是达到目的的一种手段。当然，赚钱也是达到目的的一种手段。但跟赚钱相比，我对解决问题更感兴趣。\n\n**看透游戏，就会厌倦游戏。我已经到了厌倦游戏的阶段。我认为没有什么终极目标或目的。我只是遵从内心的感受和想法，过好每一天。我是真的只活在当下。**\n\n**问题一、你对退休的定义是什么？**\n\n退休就是不再为了想象中的明天而牺牲今天。当你能活在当下，内心充盈地度过每一天时，你就达到了退休的状态。\n\n\n**问题二、如何达到退休状态？**\n\n1. 第一种方法是存钱。只要存款够多，被动收入（不用动一根手指）就能满足开销。\n2. 第二种方法是把开销降为零——出家修行。\n3. 第三种方法是做自己热爱的事情，完全乐在其中，有钱没钱无所谓。所以，实现退休状态有很多种方法。\n\n避开竞争陷阱的方法就是做独一无二的自己，找到自己能做到独步天下的事情。做到最好，只因热爱。如果你真的热爱一个事物，那就追随本心，努力找到利用它满足社会真实需求的切入点，利用杠杆效应扩大规模，以个人名义担起责任。这样，在承担风险的同时，你也将获得相应的回报，拥有自己所提供产品或服务的所有权或股权，然后持续精进。\n\n**问题三、财务自由后，你赚钱的动力下降了吗？**\n\n下降了，也没下降。说“下降”了，是因为缺钱带来的绝望感已经消失，压力变小了。\n\n说“没下降”，是因为在现阶段，创业和赚钱于我而言更像是一门“艺术”，乐趣更多了\n\n**以前创业是为了实现某个目标，现在是为了把企业做到极致，使之成为精美的艺术品。有意思的是，我觉得现在反而比以前做得好多了。**\n\n**我永远都在“工作”。但是，别人眼里的工作于我而言就像是玩耍。正因如此，我才确信没有人可以在我的领域与我匹敌。因为我觉得工作就是玩耍，所以我可以一天玩16个小时。如果有人想跟我竞争，那么他们肯定会输，因为他们不可能一周工作7天，每天工作16个小时。**\n\n\n**问题四、赚到多少钱会让你有安全感？**\n\n对钱的贪欲之所以有害，是因为欲望是个无底洞。贪念会一直占据你的心灵，让你无法自拔。热爱金钱，赚取金钱，本身无可厚非，但关键是赚的钱再多也永远不会感到满足。**人之所以永远不会感到满足，是因为欲望这个开关一旦被打开，就不会在某个具体数字面前自动关停，正所谓欲壑难填。所以，不要以为赚到某个数额的钱，人自然就会满足了、停手了。**\n\n赚钱的目的是解决财务问题，满足物质需求。**我认为，摆脱金钱贪念最好的办法就是，赚了钱之后不要升级自己的生活方式。赚到钱的人往往会自然而然地提高生活水准。**假设你一次性赚到一大笔钱，而不是靠日积月累。此时你依然保持着原有的生活方式，还没来得及升级，你的金钱就会远远超出你的实际需求和欲望，这反而让你达到一种财务自由的状态。\n\n还有一点对我有所裨益：**我把自由看得高于一切。我说的自由是多种多样的：想做什么就做什么的自由，不想做什么就不去做的自由，不受自我情绪或外界影响的自由，等等。自由是我最珍视的价值。**\n\n\n**问题五、我必须创办一家公司才能获得成功吗？**\n\n硅谷最成功的人分为两类。\n\n1. 第一类是做风险投资的人，因为他们非常多元化，控制着曾经是稀缺资源的东西。\n2. 第二类是极为擅长识别公司发展阶段和前景的人\n\n\n**问题六、就是那些本来在谷歌，却在脸书仅有100个员工时加入脸书，又在在线支付服务商Stripe刚发展到100人时加入Stripe的人吗？**\n\n如果年轻时没有在职务上有所突破，职业生涯后期就很难后来居上。所以，在小公司创立之初就加入是一个不错的选择，因为此时没有那么多阻碍提前晋升的硬性条件。\n\n对刚刚开启职业生涯的人来说（甚至稍晚阶段的人也一样），最重要的资源是公司能给你带来的人脉资源。要思考一下自己会跟什么样的人共事，他们将来会如何发展。\n\n\n#### 10、如何获得运气\n\n**问题一、你为什么主张“不要靠运气发财”？**\n\n在获得财富的过程中，你要排除“运气”这个不可控因素。\n\n\n**问题二、但是运气好的确有利于赚钱，对吗？**\n\n运气分为：\n\n1. 第一种运气是不期而遇的运气，一个人的好运完全源于他控制范围之外、意料之外的事情，比如获得意外之财、遇到贵人等等。\n2. 第二种运气源于坚持不懈、孜孜不倦、屡败屡战、不断尝试，是靠个人主动创造机会获得的。\n3. 第三种获得好运的方式就是善于发现好运。如果你在某个领域技艺娴熟、经验丰富，那么当这个领域实现了意外突破时，你就会在第一时间洞悉，这时，其他不熟悉这个领域的人会无动于衷\n4. 第四种运气是最奇妙、最难得的一种，那就是打造独特的个性、独特的品牌、独特的心态，让运气找到你。\n\n获得好运的方法：\n\n1. 希望好运不期而至。\n2. 不停地折腾，直到撞上大运。\n3. 做好心理准备，对别人错过的机会保持敏感。\n4. 把你所做的事情做到极致。精益求精，直到名副其实。让机会自动找到你，让运气成为必然。\n\n\n**问题三、社交有多重要？**\n\n**我认为商业社交纯属浪费时间。**\n\n我知道有很多人和公司在推广“打造社交网络”这个概念，因为这符合他们的利益，能为他们的商业模式服务。但事实上，如果你建造的东西很有意思，那就会有更多人想要了解你。在经营业务之前先试图建立业务关系完全是在浪费时间。我的人生哲学会让人觉得更舒适：“做一个创造者，创造出人们想要的有趣的东西。展示你的技能，练习你的技能，最终会有合适的人找到你。”\n\n\n**问题四、如何确定一个人是否值得信赖？你会关注哪些信号？**\n\n**如果一个人大谈特谈自己有多诚实，那么他很可能是不诚实的。这只是我学到的一个小小的警示信号。当一个人不断宣扬自己的价值观，或者自我吹嘘时，那就意味着他在掩饰什么。**\n\n鲨鱼吃得很好，但是过着被鲨鱼包围的生活。\n\n如果连你都不爱自己，那么还有谁会爱你呢？\n\n\n#### 11、保持耐心\n\n随着年龄和阅历的增长，我逐渐发现，只要有足够的耐心，优秀的人就会成就一番大事业。\n\n大凡优秀之人，假以时日，都会大放异彩。这个时间期限可能比你想象的要长，也可能与他们自己的预期不符，但是，是金子总会发光。\n\n运用专长，结合杠杆效应，最终，你的才华和努力会得到相应的回报。\n\n**对自己热爱的事物孜孜不倦，乐此不疲，不断精进，日积月累。不要去计算自己投入的时间和精力，因为一旦开始计算，你就会失去耐心。**\n\n江山易改，本性难移。所谓“性格决定命运”，就是一个人不断重复自己的行为模式，好的坏的、优点缺点，最终会得到与自己的行为相对应的结果。\n\n始终主动付出、不断奉献，不要斤斤计较、患得患失。\n\n“但行好事，莫问前程”不容易，不仅不容易，而且难于上青天。“只求付出，不求回报”是人生中最难做到的一件事，但也是让人收获最大的一件事。那些从小锦衣玉食、游手好闲的人，很难找到人生的意义和价值。\n\n**人生真正的履历，其实就是一生所承受痛苦的集合。**如果临终前要直面真正的自我，回顾这一生做过哪些有意义的事，那么你能想起来的一定都是你所做出的牺牲和迎接过的挑战。\n\n**在物质世界里，金钱不能给人带来快乐，不能解决人的健康问题，不能让所有家庭变得美满和睦，不能让人免受情绪波动的困扰。但金钱可以买到自由，可以解决许多外在的问题。所以，赚钱是一个合情合理的奋斗目标。**\n\n### 第二章 增强判断力\n\n**真正聪明的人，从不走捷径。**\n\n#### 1、判断力\n\n在人的一生中，如果想赚尽可能多的钱，如果想以一种可预测的方式致富，就要时刻走在时代的最前沿，学习科技、学习设计、学习艺术，成为行业翘楚。\n\n**把时间花在省钱上是不会致富的； 省出时间来赚钱才是正确的思路。**\n\n努力的作用被大大高估了。在现代经济中，工作的努力程度并没有那么重要。\n\n**问题一、那什么被低估了呢？**\n\n判断力。判断力被低估了\n\n**问题二、你能给判断力下个定义吗？**\n\n我对智慧的定义是“知道个人行为的长期后果”，用于解决外部问题的智慧其实就是判断力。或者说，智慧和判断力是高度关联的：一个智慧而富有判断力的人，首先要知道个人行为的长期后果，然后做出正确的决策并付诸行动。\n\n时间的投入是必需的，但判断力更重要。在前进的过程中，方向比速度更重要，特别是运用了杠杆以后。在每个岔路口选对方向，其重要程度要远远超过前进的努力程度。人生就是选择正确的方向，然后朝这个方向奋力前行\n\n#### 2、如何清晰思考？\n\n与“聪明”相比，“思路清晰”是一种更好的赞誉。\n\n真正聪明的人是思路清晰的思考者。他们把基础知识和基础层面了解得非常透彻。相较于背诵各种复杂的概念，我更愿意吃透基础知识。死记硬背学来的概念无法被有机地整合到一起，而且会与基础知识脱节。如果在需要用到一些概念时却无法通过基础知识推导出来，你就会迷失在现有知识的迷宫中，你就成了简单的背诵机器\n\n**问题一、有效决策体现在很多方面，其中一个方面可以归结为处理现实问题。当你做决定时，你如何确保自己是在直面现实问题？**\n\n要直面现实，就要放下自我，消除自我意识，忘记自我判断，平复自我情绪。人虽然是高级动物，但情绪化的自我意识的存在会带来反刍式思维，让一些欲望蒙蔽我们的双眼，让我们看不清现实，从而让我们对“世界应该怎样”妄下判断。这种情况经常发生，尤其是在把政治诉求和商业问题搅在一起时。\n\n阻碍我们看清现实的最大因素就是我们对现实“应有的样子”有先入为主的印象。\n\n痛苦的时刻就是真相大白的时刻。只有处于痛苦之中，你才会被迫接受现实，而只有接受现实，你才能做出有意义的改变，取得有意义的进步。由此可见，只有实事求是，才能不断改进，不断前行。\n\n我深知，越是渴望以某种特定的方式解决问题，我就越不可能看清事实。因此，尤其是在涉及公司事务时，如果某件事进展不顺利，我就会尽力公开承认存在的问题，对合伙人、朋友和同事开诚布公。这样一来，我对任何人都不会有任何隐瞒。如果不用隐瞒别人，我就不用再欺骗自己，解除了心灵的羁绊和束缚，我就更能看清现实了。\n\n非常聪明的人往往都是特立独行的，他们坚持独立思考、亲力亲为，以厘清事情的来龙去脉\n\n#### 3、摆脱自我束缚，认清世界真相\n\n在日常生活中，基于习惯的行为模式无处不在。人生会遇到各种各样的问题，我们不可能把遇到的每个问题都当成第一次。在解决各类问题的过程中，我们逐渐养成了很多习惯。我们把这些习惯和自我认知、自我认同、自我意识紧密地捆绑在一起，并对习惯形成深深的依赖。“我是纳瓦尔，我就习惯这样做。”\n\n**当然，习惯有好有坏。要持续成长，很重要的一点是学会打破现有的条件反射，改掉不良习惯。要善于剖析自我，梳理每个习惯是怎样形成的。比如：“这个习惯可能是我在蹒跚学步的时候养成的，当时是为了吸引父母的注意。我在成长过程中不断强化这个习惯，现在它已经成为我的一部分。这个习惯对现阶段的我还有帮助吗？它会让我更快乐吗？会让我更健康吗？可以帮助我完成计划、实现目标吗？”**\n\n跟大多数人相比，我的习惯性没有那么强。我不喜欢对日常生活进行规划。我也有一些习惯，但这些习惯都是我刻意培养的，而不是在成长过程中无意形成的。\n\n从长远看，承受痛苦也是人生的必修课，它可以带来两大收获：一是痛苦可以让人接受世界的本来面目；二是痛苦可以大大改变一个人的自我，虽然过程非常煎熬。\n\n举例来说，如果一个竞技运动员身受重伤（比如，李小龙），他当然非常痛苦，但他必须接受现实，明白竞技运动并不是他生命的全部，运动员也不是他身份的全部。受伤的他也许可以去研究哲学，为自己赢得一个哲学家的新身份。\n\n#### 4、学习决策技巧\n传统美德对我们的决策具有很大的启发意义：**要选择从长期来看让我们受益最大的做法，而不是只顾眼前得失。**\n\n几乎所有的偏见都是为了帮助人们在信息不完整的情况下迅速做出判断。对于重要的决策，要抛开记忆和身份，专注于问题本身。\n\n**我从不考虑“我喜欢或不喜欢”这样的问题。我只关注事实，我思考问题的角度是“事实就是这样”，或者“事实不是这样”。**\n\n**问题一、关于培养诚实的态度和率直的表达方式使其成为本能这件事，你有什么建议吗？**\n\n把自己的真实想法告诉所有人。现在就开始这样做。表达方式不一定要很直白。当一个人同时展现出高度的自信和关爱的力量时，他就会散发出人格魅力。诚实待人、积极向上，这是我们在任何时候几乎都可以做到的\n\n越觉得自己无所不知，规避和处置风险的方法越少。\n\n#### 5、发现好的心智模型\n\n在决策的过程中，大脑是一台根据过往记忆进行预测的机器。\n\n在根据记忆进行预测的过程中，推理逻辑是最靠不住的：“这件事在过去发生了，因此在未来也会发生。”这种推理过于依赖特定环境，带有经验主义色彩。其实，做决策要具体问题具体分析，有效决策需要的是原则和心智模型。\n\n我把自己的推文和其他人的推文作为格言。发推文有助于我提炼所学知识的精髓，也有助于我温故而知新。大脑的空间是有限的，毕竟一个人的神经元数量是有限的，所以你可以把推文视为指针、地址或助记符，其目的是帮助你记住那些更深层次的原则。而只有将这些原则与过往的亲身经历相结合，你才能加深理解和记忆。\n\n如果没有结合亲身经历，推文读起来就会像鸡汤集锦，内容精彩，一时间让人备受鼓舞。你甚至还把它们做成精美的海报，以时时激励自己。但很可能过段时间你就忘掉了，继续按部就班地生活。所谓的心智模型，其实就是有助于调取你所学知识的简单方法\n\n**进化论**\n我认为，现代社会的很多现象都可以用进化论来解释。有一种理论认为，文明的存在是为了解决交配权的分配问题。从纯粹的性选择角度看，人类社会精子充足，卵子稀少，所以存在分配问题。\n\n究其根本，人类的所有发明和成就都是为了解决交配权的分配问题。\n\n**反推法**\n我认为自己并没有能力找到“正确方法”。相反，我努力的方向是逐一排除不奏效的方法。我认为成功就是不犯错。成功的关键并不在于做出正确判断，而在于避免做出错误判断。\n\n**复利效应**\n我举个金融的例子来说明什么是复利。假设每年从1美元中获得10%的收益，那么第一年可以赚10%，最后得到1.10美元，第二年得到1.21美元，第三年得到1.33美元。收益金额会不断增加。如果以每年30%的复利利率计算，连续30年，最终得到的不是本金的10倍或20倍，而是数千倍。\n\n**可证伪性**\n对那些声称“科学”站在自己一边的人来说，最重要的原则，同时也是他们理解得最不透彻的原则，就是可证伪性。如果不能做出可证伪的预测，那就不是科学。要让人们相信某个理论是真理，这个理论就应该具有预测能力，而且必须是可证伪的。\n\n我认为宏观经济学不可信，因为宏观经济学家做出的预测是不可证伪的，而可证伪性才是科学的标志。\n\n**如果难以抉择，那答案就是否定的**\n\n如果面临艰难选择，比如：\n\n我应该跟这个人结婚吗？\n\n我应该接受这份工作吗？\n\n我应该买这栋房子吗？\n\n我应该搬到这个城市吗？\n\n我应该和这个人做生意吗？\n\n如果你难以抉择，答案就是否定的。原因是，现代社会充满了选择，有成千上万个选择。我们生活在一个有70亿人口的星球上，我们和互联网上的每个人都相互连接，世界上有成千上万的职业供我们选择。大千世界，芸芸众生，选择永远不缺。\n\n人做不到绝对确定，但是我们一定要在非常确定的情况下再做出决定。\n\n有时我们实在难以抉择，甚至需要列出清单，对不同选项的利弊进行对比和权衡。选择放弃吧，如果难以抉择，答案就是否定的\n\n\n**迎难而上**\n一条简单的人生经验：**如果在一个艰难的决定上意见不统一，你就应该选择短期内更痛苦的道路。**\n\n如果面对两个选择，利弊各占50%，你就应该选择短期内更艰难、更痛苦的道路。\n\n从本质上看，两条道路中的一条会带来短期痛苦，而另一条会在未来引发更长久的痛苦。为了回避矛盾，大脑会本能地选择摆脱短期痛苦。\n\n前提条件是，两个选择利弊相当，但如果一条道路会带来短期痛苦，那么它也会带来长期收益。而根据复利效应，长期收益才是你想要的。\n\n以运动为例。运动对我来说并不是一件快乐的事，因为我会在短期内感到痛苦。但是从长远看，我会变得更好，因为我的肌肉更发达了，身体更健康了。\n\n读书也一样，读有难度的书会让大脑不堪重负，短时间内感到疲劳。但从长远看，读书会让我变得越来越聪明，因为我在持续挑战大脑处理信息的极限，提高大脑的工作能力，进而不断吸收新概念。\n\n因此，一般来说，应该选择短期痛苦，以换取长期收益。\n\n**建立新的心智模型最有效的方法是什么？**\n\n海量阅读，多多益善\n\n每天花一个小时阅读科学、数学和哲学类书籍，7年内，你就可能跻身少数的成功人士之列。\n\n#### 6、学会热爱阅读\n\n不要比谁读书更快。书越好，你越要慢慢阅读、慢慢吸收。\n\n阅读的题材和内容并不重要。最终，你会追随自己的兴趣，完成大量阅读。你的生活也会因此得到极大的改善。这就好比最好的锻炼方式就是做自己感兴趣的、每天都能坚持的运动。同样的道理也适用于书籍、博客、推特，或者任何有思想、有信息、有学习内容的东西，最好的阅读就是自己感兴趣的、爱不释手的阅读。\n\n指出别人观点中明显的偏颇，意味着要么你攻击的对象不聪明，要么你自身不聪明。\n\n如果一本书被写出来只是为了赚钱，那么不要读它。\n\n**问题一、对阅读中获得的信息你如何消化吸收并融会贯通？**\n\n向别人讲解你学到的东西。教学相长。\n\n人与人的区别不是“受过教育”和“没受过教育”，而是“喜欢阅读”和“不喜欢阅读”。\n\n**问题二、如果想成为一个更清醒、更独立的思考者，在接下来的60天里，我能做些什么？**\n\n阅读数学、科学和哲学领域的经典作品。不要读畅销书，不要看新闻。避免加入任何所谓的“读书俱乐部”，避免追求任何的社群认同。把真理置于社群认同之上。\n\n如果能成为一台永动学习机，你就永远不缺赚钱的途径。\n\n我们现在身处推特和脸书的时代，得到的都是碎片化的智慧精华，吸收起来非常困难。读书对现代人来说已经非常困难了，因为我们的大脑已经被训练成特定模式，大脑同时接受了两个相互矛盾的训练\n\n\n在解决问题时，问题越古老，解决方案存在的时间越长。如果是一个古老的问题，比如如何保持身体健康，如何保持冷静和平和，什么样的价值体系是好的，如何经营好家庭，诸如此类的问题，古老的解决方案可能更好。\n\n**一颗平静的心，一个健康的身体，一个充满爱的家。这些东西是金钱买不到的，必须通过努力才能获得。**\n\n## 第二部分 幸福\n### 第三章 学习幸福\n\n**别太把自己当回事。你只是一只会做计划的猴子。**\n\n#### 1、幸福是一种技能\n\n我认为，幸福就像所有其他的宏大话题一样，其含义会随着时空的转换而不断变化。小时候，你会问妈妈：“人死了以后会发生什么？世界上真的有圣诞老人吗？真的存在上帝吗？我应该感到快乐吗？我应该跟谁结婚？”诸如此类的问题都没有显而易见的正确答案，因为没有哪个答案适用于所有人。当然，这些问题最终会有答案，只不过答案只适用于单一的个体。\n\n甲之真理，乙之谬论，反之亦然。我所理解的幸福与你所理解的幸福可能大相径庭。我认为，探索自己对幸福的定义非常重要。\n\n《道德经》对此进行了全面深刻的阐述，我的分析当然不能与其相提并论，但归根到底，万物皆有二元性和极性。如果我说现在我很开心，那就意味着在某个时刻我很伤心。如果我说一个人有魅力，意思就是其他人没有魅力。每一个积极想法都有一个消极想法的种子蕴含其中，反之亦然，这就是为什么生命的伟大在很大程度上源于苦难。人必须先看到消极的一面，才能去憧憬和欣赏积极的一面。\n\n如果想获得内心的平和，你就必须超越对万事万物的善恶评判。\n\n大自然没有幸福或不幸福的概念。从宇宙大爆炸到现在，自然的发展遵循完备的数学定律和一系列因果关系。大自然的一切都浑然天成。幸福或不幸福只存在于我们的大脑，因为我们有欲望，所以给事物贴上了“完美”或“不完美”的标签。\n\n随着时间的流逝，我也开始相信，个体是渺小的，如沧海之一粟，微不足道。这样的认知对我获得幸福感很有裨益。假如你自认为是全宇宙最重要的人，你就会有让整个宇宙屈从于你的意志——既然你是最重要的，那么宇宙怎么可以不符合你的心意呢？如果宇宙不按照你的意志来运转，你就会觉得不对劲儿。\n\n幸福就是消除缺憾感之后的感受。\n\n剔除了“幸福”和“不幸福”的状态，剩下的就是中性状态，但中性状态并不意味着平淡。很多人认为，中性状态是索然无味、缺乏激情的。事实并非如此，中性状态是孩子才有的状态。我们会发现孩子通常都很快乐，那是因为他们真的会沉浸在周围的环境里，沉浸在当下，而不是期待环境来契合自己的喜好和欲望。我认为，中性状态其实是一种完美的状态。只要不沉溺于自己的想法、不执着于自己的欲望，你就可以获得快乐。\n\n**问题一、练习冥想能帮助你接受现实吗？**\n\n可以，但作用其实微乎其微。（大笑）即使你长期练习冥想，但有人说错了话，刺激到你，你的平和状态也可能瞬间被打破，再次回到受自我驱动的状态\n\n冥想当然比什么都不做要好。但即使练习冥想，当真正的精神或情感痛苦到来时，你也难有招架之力。所以，真正的幸福只是内心平和的副产品，主要还是源于接受现实，而不是改变外部环境。\n\n理性很强的人可以通过训练自己的无感反应获得平和，即学会漠视自己无法控制的事物。\n\n我不参与政治。\n\n我不在乎那些无关紧要的事。\n\n我降低自己的身份感。\n\n#### 2、幸福是一种选择\n\n大脑就像身体一样，是可塑的。我们花费大量时间和精力，努力改造外部世界，改造他人，改造自己的身体，却没有考虑过改造自己的大脑，只是简单地接受了年轻时被塑造的自己。\n\n记忆和身份只是来自过去的负担，让我们无法自由自在、心无旁骛地活在当下。\n\n\n#### 3、幸福需要活在当下\n\n我认为，过去就是过去了，没有回忆，没有遗憾，没有放不下的人，没有忘不掉的旅行。既往不恋。人之所以感到痛苦，很多时候是因为拿以往和现在做比较。\n\n以往种种未能实现的欲念会带来现在的缺憾感，而我们又将弥补现实缺憾的希望寄托于未来。消除缺憾感会让人更容易活在当下。\n\n关于“开悟”，我读到过一个很好的定义：“思考的间隙即开悟。”意思是说，开悟不需要在山顶修行30年，而是一个时时刻刻都可以达到的境界。你每天都可以提高自己的开悟水平。\n\n#### 4、幸福需要心境平和\n\n**问题一、幸福感与目的感是相互关联的吗？**\n\n人们赋予“幸福”太多内涵，我都不确定这个词是什么意思了。对现在的我而言，幸福的本质更倾向于平和，而不是快乐。我觉得平和与目的无法共存。\n\n如果你是在追随内在的目的，做自己想做的事情，那么你自然会觉得幸福。但如果目的是外界强加给你的，你做的是不得不做的事情，如“社会希望我做这件事”，“爸爸是爷爷的长子，我又是爸爸的长子，因此我必须这样做”，“我欠债了，负担很重，必须努力”，等等，那么你是不会幸福的。\n\n如果你找个地方坐下来，尝试着什么都不做，这个时候，焦虑感是最明显的。我说的什么都不做，是不要读书，不要听音乐，不要做任何事情，只是坐着。只是这一件事，你就做不到，因为焦虑感会让你如坐针毡，会不停地催促你站起来去做事。所以，很重要的一点就是，你要意识到，是焦虑感让你感到不快乐。而这种焦虑感源于一连串不断涌现的想法。\n\n我应对焦虑的方法就是不与之对抗，让自己意识到这种焦虑感源于脑海中此起彼伏的想法。\n\n\n#### 5、欲望是主动选择的不开心\n\n我觉得人类最常犯的一个错误就是，认为自己会因外部环境变化而获得幸福。我不这样认为。我知道我的想法并非原创，也不新颖，这并不是我的总结，而是佛学的终极智慧。\n\n举例来说，我买了一辆新车，现在等着提车。我自然会很关注这件事，每天晚上都上论坛查看、研究相关信息。我为什么要这样做？只是一辆普普通通的车，不会给我的生活带来什么实质性改变。我知道，只要车一到手，我就不会再关注它了。问题的关键在于，我沉迷于对外物的“欲望”。我对外部事物会带给我幸福和快乐的执念其实是一种痴念。\n\n从根本层面上看，从自身以外的事物中寻求幸福，本身就是缘木求鱼。当然，我并不是说物质世界不重要。作为一种社会性动物，人需要去履行一些社会职责。人的一生就是在力所能及的范围内减少无序状态，即所谓“局部熵减”，这是你的人生责任。\n\n每个人都有自己的责任。我们生活在这个世界上，不可能每天躺在沙滩上冥想。人需要实现自我价值，应当承担起属于自己的职责和使命。\n\n我们的根本错觉是：总有一样东西会让我一直满足、永远快乐。\n\n欲望就是你跟自己的约定，约定的内容是：不得到我想要的东西，我是不会快乐的。我觉得大部分人都没有意识到，这就是欲望的本质。我们每天都生活在欲望中，又奇怪为什么自己不快乐。我已然认识到，欲望是我痛苦的来源。所以，我会对欲望保持清醒，这样我就可以慎重选择自己的欲望。我的目标是，无论在什么情况下，都尽量不让自己对生活有一个以上的欲望。当然，我知道，即使只选择一个欲望，我也是在自寻烦恼。\n\n最近我明白了一个道理：相较于做一些不是自己百分之百想要做的事情，努力调整欲望更重要。\n\n#### 6、成功不一定带来幸福\n\n幸福就是满足现状。而成功源于对现状的不满，是对现状的改造。两者只能选一个。\n\n**问题一、有人说，人有两次生命，第二次生命始于你意识到生命只有一次的那一刻。你的第二次生命是何时开始的？又是怎样开始的？**\n\n我花了很多时间奋力拼搏，就是为了获得物质上的成功和社会的认可。得到之后（至少当这些东西对我来说已经没有那么重要的时候），我意识到，身边跟我一样成功或正在奋力取得更大成功的人，似乎并没有那么幸福。我个人的经验完全符合享乐适应理论：再好的东西，我也很快就习惯了，它们无法再带给我刺激或愉快的感觉了。\n\n生存和繁衍的本能驱使人们劳作，而享乐适应让我们步履不停。幸福的秘诀在于，知道何时停下劳作的脚步，开始随心去玩耍。\n\n**问题二、谁是你心目中的成功人士？**\n\n对现在的我来说，真正的赢家是那些已经完全退出游戏的人，甚至根本不玩游戏的人，是那些已经超越了游戏的人。这些人的内心无比强大，有极强的自控力和清醒的自我意识，他们不需要从任何人那里获得任何东西。\n\n之所以有烦恼，是因为他不能独自安静地在一个房间里坐着。”如果你能坐上30分钟，同时保持幸福的心境，你就是成功的。这是一种超然物外的境界，不过极少有人能做到。\n\n在现实生活中，内心的平和状态不是一劳永逸的，也不会是一成不变的。心理状态总在不断变化。在大多数情况下，接受并顺应现实，是获得幸福的核心技能。\n\n基本上你可以从生活中得到自己想要的一切，但前提是，你的目标只有一个，而且你对这件事的渴望超过其他一切。\n\n#### 7、嫉妒是幸福的敌人\n\n我认为，生活本身没有那么难，是我们自己把生活变难了。我在生活中努力摆脱“应该”这个词。当“应该”在脑海中出现时，其背后隐藏的是负罪感或社会规训。如果做一件事是因为“应该”，那就表示你内心是不想这么做的，而违背自己的心意会让你变得痛苦不堪。因此，我努力在生活中减少“应该”做的事。\n\n社会告诉我们：“快去锻炼吧。好好打扮吧。”这是一场多人竞争的游戏，我们做得好不好会受到别人的检视。社会还告诉我们：“快去赚钱吧。去买栋大房子吧。”这又是一场外在的多人竞争游戏，参与游戏的人也会受到别人的检视。而训练自己获得幸福感完全是内在的，不需要外界评判你的进展，认可你的结果。你是在跟自己竞争，这是一场单人游戏。\n\n而现实是，生活就是一场单人游戏。人独自出生，独自死亡，独自解读人世间的一切。你的记忆只属于你一个人。你出生前无人在意，你离开人世后也无人在意，你存在于人世间只是短短几十年，人生就是一场单人游戏。\n\n瑜伽和冥想很难坚持的一个重要原因也许就是，它们只关乎内心，没有外在价值，属于纯粹的单人游戏。\n\n**问题一、巴菲特曾经提出这样一个问题，你是想成为世人眼里最差但自己心里最好的情人，还是想成为世人眼里最好但自己心里最差的情人？这个问题就是一个很好的例子，它说明存在内在和外部两套评价标准。**\n\n直到有一天，我意识到，我嫉妒别人，只是嫉妒他们的某些方面，而我不可能只拥有我嫉妒的那些东西。我不能只想要那个人的身材、财富或个性。如果要交换人生，我就必须接受对方全部的人生，包括他的反应、欲望、家庭、幸福感、人生观、自我形象等各个方面。你可以接受吗？如果你不愿意与别人进行百分之百的交换，嫉妒就毫无意义。\n\n\n#### 8、幸福源于好习惯\n\n获取幸福是一种技能，就像懂得营养搭配是一种技能，节食减肥是一种技能，锻炼是一种技能，赚钱是一种技能，与异性交往是一种技能，拥有良好的人际关系是一种技能，爱也是一种技能一样。要掌握这些技能，首先要认识到技能是可以通过学习获得的。一旦下定决心学习技能，你的世界就会变得更加美好。\n\n工作时，和比自己更成功的人在一起。\n\n玩耍时，和比自己更快乐的人在一起。\n\n**问题一、幸福是一种什么样的技能？**\n\n要掌握获取幸福这个技能，你需要不断试错，通过亲身体验找到哪些方法有用。比如，你可以试试坐姿冥想，它对你有用吗？是密宗冥想有用，还是内观冥想有用？是需要10天的静修，还是20分钟就够了？\n\n**问题二、我们该如何打造获取幸福的技能？**\n\n可以通过养成好习惯来获取。不喝酒、不吃糖可以提高情绪的稳定性，远离社交媒体（脸书，Snapchat和推特）也可以提高情绪的稳定性。\n\n随着年龄的增长，有些人的幸福感越来越强，而有些人变得越来越不快乐，一个重要的原因就是，两类人群习惯不同。在选择习惯的时候，你需要考虑清楚：这是能增加我的长期幸福感的习惯吗？\n\n不能因为一个人恰好是你的邻居或同事，你就不加选择地跟他成为朋友。最幸福和最乐观的人会选择五只正确的黑猩猩做朋友。\n\n处理冲突的首要原则是，不要和经常参与冲突的人在一起。我对任何不可持续甚至难以维系的事情都不感兴趣，包括人际关系。\n\n获得幸福最重要的诀窍之一就是，认识到这是一种你可以锻炼的技能，是一个你可以做出的选择。也就是说，一个人可以选择幸福，并为之奋斗。这跟选择减脂增肌、为事业奋斗、学习微积分没什么两样。\n\n\n#### 9、于接受中寻找幸福\n\n在生活中，无论面对何种状况，你都有三种选择：改变现状，接受现状，逃避现状。\n\n试图改变现状是一种欲望。在成功改变现状之前，欲望会让人感到痛苦。所以不要总想着去改变外部环境。在任何特定的时间段，只选择一个最有价值的欲望，作为自己的奋斗目标和动力之源。\n\n**问题一、为什么不能同时选择两个欲望？**\n\n如果你一直在想，“我需要这样做，我想要那个东西，这种情况必须改变”，你就很难保持心态平和。\n\n无论面对何种状况，你都有三种选择：改变现状，接受现状，逃避现状。很多人在遇到问题时会踟蹰不前，陷入空想：希望改变现状却没有横下一条心去改变，希望转身离开却没有毅然决然地离去，同时又不能心平气和地接受现状。这种纠结和回避的态度正是人生中大部分痛苦的来源。我在脑海里对自己说得最多的就是两个字：接受。\n\n**问题二、你所谓的“接受”是什么样子的？**\n\n所谓接受，就是无论结果如何，都可以泰然处之；就是保持心态平衡，大脑专注；就是退一步海阔天空；就是观大势，顾全局，谋长远。\n\n人生不如意事十之八九。但是，该来的终归要来，有时，正在发生的也许就是最好的。我们越早接受现实，就能越早适应现实。\n\n一个方法是退后一步，回顾经历过的痛苦。我还会把这些痛苦写下来：上次分手，上次生意失败，上次健康出问题，后来都发生了什么？这样我就可以看到在随后的几年里我的成长和进步。\n\n另一个应对小挫折的方法就是换个角度看问题。当我遭遇挫折时，部分自我会立即做出消极反应。但现在我已经学会自问：“这种情况有什么积极的意义吗？”\n\n比如，开会要迟到了，这件事对我有什么好处吗？好处就是我可以放松一下，看鸟观云。而且，我也可以少花一些时间在那个无聊的会议上。任何事情都有积极的一面。\n\n**问题三、如何学会接受无法改变的事情？**\n\n从根本上说，就是学会坦然面对死亡。\n\n相对于宇宙，你就像一只在夜空中闪烁的萤火虫，你的生命转瞬即逝。如果能彻底认识到你所做的一切不过是徒劳，你就能获得巨大的幸福感和平和感，因为你会意识到，生命不过是一场游戏。但生命是一场有趣的游戏。在这场游戏中，唯一重要的事情就是，随着生命的展开，你要不断地体验现实。既然如此，你为什么不以最积极的方式去诠释自己经历的一切呢？\n\n所以，也许1万年、10万年后，人们会说：“哦，对，美国人，我听说过美国人。” 人固有一死，死后万事皆空。所以，好好享受生命吧。对社会做一些积极的贡献。向世界主动释放和传播爱。给他人带来快乐和幸福。让生活多一些笑声。珍视眼前的每个瞬间。承担使命，尽职尽责，不枉此生。\n\n### 第四章 自我救赎\n\n医生不能让你健康。\n\n老师不能让你变聪明。\n\n禅师不能让你冷静。\n\n最终，你必须自己负起责任。最终，你必须自己负起责任。\n\n#### 1、选择做自己\n\n当今社会存在的一个普遍现象，也是许多人此刻正在做的事情，就是苦苦挣扎，自我鞭策：“我需要做这件事，我需要做那件事，我需要……”不，你什么都不需要做。你唯一应该做的事，是你自己想做的事。\n\n**你唯一应该做的事，是你自己想做的事。** 别人总希望你以特定的方式做事，但如果不再费心去揣摩别人的期待，你就能听到自己脑海中那个微弱的声音。那个声音代表了你真实的想法。倾听它，你就可以做自己了。\n\n**在“做自己”这件事情上，没有人能与你竞争。你永远不会像我一样擅长做我自己，我也永远不会像你一样擅长做你自己。当然，做人要虚心聆听，博采众长，但不要盲目模仿。模仿他人纯属徒劳。**相反，每个人都有独一无二的资质技能、专业知识、能力才干、个人欲望，这些是世界上其他人所没有的，是先天基因和后天经验共同作用的结果。\n\n你的人生目标是找到最需要你的人、事业、项目或艺术。大千世界，芸芸众生，总有一些人和事会与你完美契合。不要基于别人正在做的事为你自己列清单、做决策。你永远不会成为他们，你永远都不擅长做另一个人。\n\n要做出原创性贡献，必须非理性地痴迷。\n\n\n#### 2、选择关爱自己\n\n我生活中的第一要务是我的身体健康。对我来说，健康的重要性高于幸福，高于家庭，高于工作。我的身体健康是一切的起点，排在第一位，紧随其后的是我的心理健康和精神健康。接着是家人的健康和幸福。在确保了这些之后，我就可以按照自己的意志在这个世界上自由活动了。\n\n**健康问题是对人生影响最大的问题。**\n\n**问题一、作为一种高级动物，人类应该遵循符合自然规律的生活方式，现代社会是如何让我们逐渐背离了应有的生活方式的？**\n\n就运动而言，人类更应该去户外玩耍活动，而不是在跑步机上挥汗如雨。\n\n我们本不该生活在一个完全无菌、彻底干净的环境中，因为这种环境无法有效训练人体的免疫系统，进而导致过敏频发，这就是所谓的“卫生假说”。\n\n我们本不该每5分钟就拿起手机查看一下社交媒体。当看到别人给我们点赞时，我们会很开心，如果别人留下一句愤怒的评论，我们就会很生气。情绪上的大起大落让我们无比焦虑。\n\n**当所有人都有病时，我们就不认为这是一种病了。**\n\n**问题二、你认为哪种运动习惯对你的生活有最积极的影响？**\n\n如果你有10个或15个不同的优先事项，都不分主次地被丢到同一个筐里，那就等于没有优先级，最终你一件事都做不成。\n\n我所做的就是，认定我生命中的第一要务是自己的身体健康，这件事的优先级高于我的幸福，高于我的家庭，高于我的工作。一切始于身体健康。\n\n**养成习惯的方法和过程并不重要，甚至连做什么都不重要，重要的是每天坚持。**\n\n**我要重复一遍，每天坚持才是最重要的，坚持做什么是次要的。对个人而言，最好的锻炼就是每天都能坚持去做的那种锻炼。**\n\n**选择简单模式，人生会越来越困难；选择困难模式，人生会越来越简单。**\n\n#### 3、冥想+精神力量\n\n**问题一、为什么冥想的力量如此强大？**\n\n我们大部分的痛苦都来自逃避。洗冷水澡的痛苦主要源于进入冷水时的蹑手蹑脚和小心翼翼。一旦站到冷水下面，你就会发现那其实一点儿都不痛苦，只是有点儿冷。身体感觉到的冷跟头脑中想象的冷是不一样的。承认身体感到冷，并直面这种感受，应对它，接受它，但不要因此感到精神痛苦。洗两分钟冷水澡不会要了你的命。\n\n**问题二、你现在在进行冥想练习吗？**\n\n从前，每次看到发量很少的人，我的第一反应通常都是：“哈哈，这个人头发真少。”我为什么要通过嘲笑他人让自己感觉良好呢？我为什么需要感觉自己的发量还不错呢？原因就是，我已经开始脱发了，我很担心自己的头发会掉光，所以才试图通过嘲笑发量不如我的人来获得心理安慰。我发现，我90%的想法都受到恐惧的驱动，剩下的10%可能受到欲望的驱动。\n\n而在练习无选择觉知冥想的过程中，你不做任何决断，不评判任何事情，只是全盘接受。如果能在散步时这样做10到15分钟，你就能达到一种非常平静和感恩的状态。无选择觉知这种冥想法对我很有用。\n\n\n生活技巧：躺在床上的时候，可以尝试冥想。这样，你要么进入深度冥想，要么会入睡。不管结果是哪种都很好。\n\n这些不曾解决的痛苦、错误、恐惧和欲望已经成为你的一部分，像藤蔓一样附着在你的周身，让你失去童年时的好奇心，失去活在当下、乐在其中的能力，失去内心的快乐。那怎样才能把这些藤蔓从身上扯下来呢？答案就是冥想。\n\n冥想并不难。你要做的就是坐在那里什么都不做。只是坐下来，闭上眼睛告诉自己：“我只想让自己休息一小时。这是我远离喧嚣生活的一小时，在这一小时里，我什么都不会做。”“如果有想法喷涌而出，那就任其喷涌吧。我不会与之对抗，也不会进一步思考，既不接受，也不拒绝。\n\n\n**问题三、有没有哪一刻你意识到自己是可以控制对事物的理解的？我觉得一个普遍存在的问题是，人们没有意识到自己可以控制对一件事的理解和应对。**\n\n从某种程度上说，整个社会都有沉迷和上瘾的症状。人们追求刺激的行为、心流状态或性高潮，其目的就是摆脱自己的思维，摆脱脑海中的声音，摆脱过分强烈的自我意识。\n\n我的最低目标是，不让自我意识随着年龄的增长继续发展并被强化。我希望自我意识减弱、变柔和，这样我就可以更好地融入当下的现实生活，接受大自然和这个世界的本来面目，像孩子一样随心所欲、天真烂漫地欣赏一切。\n\n**问题四、注意力高度集中就像把自己从一个特定的框架中抽离出来，虽然你还保持着自己的思维，但你看问题的角度已经变了，是这样吗？**\n\n每个人都有自己独特的基因组合。小时候，你的基因组合会对外部环境做出反应，同时你的大脑会记录下所有经历，不管是好的还是坏的。此后，你会利用这些记忆预判未来的所有事件，不断尝试预测和改变未来。\n\n随着年龄的增长，你会积累海量的偏好。这些习惯性反应最终会变成失控的货运列车，控制你的情绪。但情绪不应该被下意识的反应控制，而应该由我们的意识主动控制。我们应该研究如何控制自己的情绪。如果一个人能按照意志调整状态，那就非常有掌控感。\n\n大脑本身就是一块肌肉，可以被训练，可以被调节。但由于社会的随意破坏、随机塑造，大脑已经在我们的控制范围之外了。如果带着觉知和意图审视自己的大脑（这种审视应该是一个时时刻刻都要进行的长期练习），你就可以分析自己的思想、情绪、想法和反应。在自我剖析、自我了解的基础上，你就可以重新配置自己的系统了。你可以根据自己的需要重写程序。\n\n冥想是屏蔽社会的噪声，倾听自己的声音。\n\n只有以冥想本身为目的，冥想才会“起作用”。\n\n徒步旅行是行走冥想。\n\n写日记是书写冥想。\n\n冲澡是意外冥想。\n\n静坐是直接冥想。\n\n#### 4、选择自我塑造\n\n最了不起的超能力就是改变自我的能力。\n\n**问题一、你一生中犯过的最大的错误是什么？你是怎么走出来的？**\n\n我犯过很多错。面对错误，我都用同样的方式进行反思和总结。这些错误都是那个年龄段难以避免的，当时并不能觉察，只有事后才会显现出来。为了走出错误的阴影，我扪心自问：“当30岁时，你会给20岁的自己什么建议？当40岁时，你会给30岁的自己什么建议？”\n\n我们拥有三观五感、七情六欲，最后与世长辞。如何解读自己的遭遇，完全取决于自己，每个人对这些遭遇都有不同的解读方式。说真的，如果人生可以重来，我还是会做出同样的选择，只是希望自己可以控制情绪波动，多一些宽容和平静，少一些戾气和愤怒。\n\n换作今天，我不会再让自己被这种焦虑和愤怒的情绪控制。我会直接跟当事人谈：“事情是这样的，我准备这样做，我准备用这种手段。这样公平，那样不公平。\n\n**再强调一次，习惯就是一切——主导着我们的一切行为和思维方式。有些习惯是从小养成的，包括如厕、什么时候能哭、什么时候不能哭、什么时候能笑、什么时候不能笑等等。于是，我们逐渐养成了各种习惯——通过后天学习，一些行为变成了我们的一部分。**\n\n**想要拥有内心的平静，必须先拥有身体的平静。**\n\n有人会说：“我想要保持身材，想要健康。现在我太胖了，身材都走样了。”塑形需要锻炼，如果只坚持三个月，是不能养成习惯的，锻炼的效果也无法维持。养成习惯、保持身材至少需要十年的时间。正常情况下，我们每过六个月就要改掉一些坏习惯、养成一些好习惯，当然，具体周期取决于自我改变的速度。\n\n**迅速采取行动，并对结果保持耐心。**\n\n一旦决定去做，就要迅速采取行动，并全神贯注，全力以赴。同时，要对结果保持耐心，因为你唯一能把握的只有自己，他人和外界环境都纷繁复杂、充满变数。\n\n#### 5、选择自我成长\n\n**我觉得设定具体目标的做法并不科学。史考特·亚当斯有句名言：“要建立系统，而不是设定目标。”运用你的判断力确定什么样的环境有助于你茁壮成长，然后在周围创造一个这样的环境，由此增加成功的概率。**\n\n我不会也不想成为世界上最成功的人。我只想尽力通过最高效的方式成为最成功的自己。我想要的生活是，如果能活1 000次，那么其中的999次，我都过着成功的生活。我未必是亿万富翁，但每一次的人生都不差。我做不到让生活的方方面面都遂心如意，但我建立了自己的系统，确保不合心意的情况屈指可数。\n\n当然，我四肢健全，智力正常，受过教育。想要成功，一些先决条件是不可或缺的。但是，如果你正在读这本书，很可能你已经具备了获得成功的必要条件，那就是一个正常运作的身体和一个功能正常的大脑。\n\n**如果有什么事情是你以后想做的，现在就去做，人生没有“以后”。**\n\n**问题一、你个人如何学习新的学科？**\n\n我没有宗教信仰，但我有精神信仰。对我来说，研究宇宙法则是我所能做的最虔诚的事情。有宗教信仰的人会去麦加或麦地那朝圣，向先知致敬，而在学习科学的时候，我能获得同样的敬畏感，也能深刻地感受到自我的渺小。对我来说，这种感受是无与伦比的。虽然只学习了最基础的知识，但是我有这样的体验。这就是阅读科学知识的美妙之处。\n\n**问题二、你是否认同这样的观点：“如果阅读的内容与他人相似，思考的东西就会和别人雷同？”**\n\n我觉得现在大家不管读什么，几乎都是为了获得社会认可。\n\n有些人读了上百本解读进化论的书，却从未读过达尔文关于进化论的原著。这个世界上的宏观经济学家多如牛毛，我认为他们中的大多数人虽然读过大量的经济学论文，但是没有读过亚当·斯密的任何著作。\n\n在某种程度上，这种阅读是为了获得社会认可。这么做是为了融入其他猴子，为了适应群体生活。但要从生活中获得回报，你需要做的并不是合群，而是从人群中脱颖而出。\n\n社会认可是在群体内部进行的。如果想得到社会认可，就需要去阅读整个社会群体都在阅读的东西。而要想在群体中脱颖而出，就需要有一定的逆向思维和反叛精神，能够说出：“不，我就是要做自己选择的事情。不管社会结果如何，我就是要学自己觉得有意思的东西。”\n\n**问题三、你认为选择离经叛道是损失厌恶心理在起作用吗？因为一旦背离当前的轨道，你就不能确定是在朝着积极还是消极的结果发展，是吗？**\n\n正是如此。我想这就是为什么我所认识的最聪明、最成功的人一开始都是失败者。如果自认为人生失败，被社会抛弃，在正常的社会中没有合适的角色，你就能专心做自己的事情，而不会被能否成功困扰。这样反而更有可能找到一条成功的道路。“我永远不受欢迎，我永远不被接受。我已经是个失败者了。反正也得不到别人拥有的东西，我只要开心地做自己就好了。”这样想对开始做事的人来说是一种很好的心态。\n\n每个人都有一些做起来动力十足的事情，只是这些事因人而异。即使是那些所谓“没有动力”的人，在打游戏的时候也会突然充满干劲儿。所以，我认为动力是相对的，你只需要找到自己感兴趣的东西。\n\n流血流汗，埋头苦干，直面困难，这些都是一夜成名的必经之路。\n\n**问题四、如果你要给子女传授一两条人生原则，这些原则会是什么？**\n\n第一条原则是阅读，广泛地阅读。阅读面要广，不要局限于社会认可的书，更不要局限于我推荐的书。要为了阅读而阅读，培养对阅读的热爱。即使喜欢读言情小说、侦探书或漫画书也没关系，不存在所谓的垃圾。开卷有益，尽管读吧。假以时日，你会找到那些你应该读和喜欢读的东西。\n\n第二条原则是，掌握与阅读技巧相关的数学和说服技能。这两种技能有助于你在现实世界里活得游刃有余、畅行无阻。\n\n拥有说服技能很重要，因为如果能影响自己的同胞，你就可以做成很多事情。我认为，说服力是一项实实在在的技能，而且是可以学会的，并没有那么难。\n\n数学有助于解决生活中所有复杂的难题。如果想赚钱，如果想研究科学，如果想了解博弈论、政治、经济、投资或计算机，你就需要学好数学，因为所有这些都以数学为核心。数学是自然界最基本的语言。\n\n只需要知道基本的统计学、算术等就够了。你应该对统计学和概率了如指掌，烂熟于心。\n\n#### 6、选择解放自我\n\n**最难的不是做自己想做的事，而是知道自己想要什么。**\n\n要注意，这个世界上根本没有什么“成年人”，假装成熟的人多了，也就有了成年人。你必须找到属于自己的路，按照自己的方式去挑选、抉择、取舍。先想清楚自己想要的是什么，然后付诸行动\n\n**问题一、你的价值观发生了怎样的变化？**\n\n以前我对自由的定义是“随心所欲即自由”——想做什么就做什么，想什么时候做就什么时候做。而现在，我追求的是内在的自由，“无忧无虑即自由”。例如，从愤怒中解脱的自由，从悲伤中解脱的自由，无须做出反应的自由，无须被迫做事的自由，等等。以前我总是在追求“想做什么就做什么”的自由，现在我追求“不想做什么就不做什么”的自由，追求内心和外在的无拘无束\n\n伪装意味着要年复一年地（而不是几分钟）让自己身处烦心伤脑的关系和工作中。\n\n**问题二、从期待中解脱出来**\n\n如果他人因对你抱有期待而受伤，那就是他们的问题。如果他们和你有约在先，那就是你的问题。但如果他们只是单方面对你有所期待，那就完全是他们的问题，与你毫无关系。他们会对生活有各种各样的期待，越早打破他们对你的期待越好。\n\n**勇气不是在枪林弹雨中冲锋陷阵，而是不在乎别人怎么想。**\n\n珍惜自己的时间。你唯一真正拥有的就是时间。时间比金钱更重要，比朋友更重要，比什么都重要。你的时间就是你的一切。不要浪费自己的时间。\n\n珍惜时间并不意味着不能放松下来享受生活。只要是做自己想做的事情，你就不是在浪费时间。但是，如果没有把时间花在想做的事情上，既没有赚到钱，也没有学到东西，你就要问问自己到底在瞎忙什么。\n\n不要花自己的时间去取悦别人。别人快不快乐是他们的问题，不是你的问题。你快乐了，别人也会快乐。你快乐了，别人会问你是如何快乐起来的，他们会从中学到点儿什么，但是你没有责任让别人快乐。\n\n**问题三、从愤怒中解脱出来**\n\n什么是愤怒？愤怒是一种强烈的情绪表达，是一个人尽可能向对方表明自己有能力使用暴力的情绪表达。愤怒是暴力的前兆。\n\n**愤怒就是对情况失去控制时的表现。愤怒是跟自己的契约，你同意让自己陷入身体、精神和情感的混乱，直到现实发生改变。**\n\n愤怒本身就是一种惩罚。一个愤怒的人试图把你的头摁到水下，但同时他也在溺水。\n\n**问题四、从雇佣关系中解脱出来**\n\n那些生活水平远远低于自己收入水平的人享受着一种自由，这种自由是那些忙于不断提升自己的生活方式的人无法企及的。\n\n一旦真正掌握了自己的命运，无论好坏，你就再也不会让别人告诉你你该做什么了。\n\n**问题五、从不受控制的思考中解脱出来**\n\n我正在努力培养一个很重要的习惯，那就是试图叫停自己的心猿。在孩童时期，每个人都是一张白纸，可以无忧无虑地活在当下，基本上都可以根据自己的本能对环境做出反应。我认为这时可谓生活在“真实世界”里。到了青春期，欲望开始萌发，这是你第一次真正渴望得到某样东西。你开始进行长期规划，开始大量思考，开始逐步打造身份，培养自我意识，争取得到自己想要的东西。\n\n举个例子，你走在一条人来人往、有着一千个人的马路上，那么这一千个人无时无刻不在头脑中喃喃自语。他们不断地评判着自己看到的一切，头脑中回想着昨天发生在自己身上的事情，也在幻想明天会发生什么。他们唯一没有做的事情就是关注当下最基本的现实。这种思维模式在我们做长期规划或者解决问题时是好事，对我们完成生存和繁衍的任务也有益处。\n\n但是，我觉得它非常不利于个人幸福。对我来说，大脑应该是仆人和工具，而不是主人。我不应该全天候地受到心猿的控制和驱使。\n\n大脑总会陷入不受控制的思考，我想改掉这个习惯。当然，这并不容易。\n\n**忙碌的思绪会加速主观时间的流逝。**\n\n\n\n\n### 第五章 哲学\n\n#### 1、生命的意义\n\n\n#### 2、按照自己的价值观生活\n\n**问题一你的核心价值观是什么？**\n\n诚实是我最核心的价值观之一。我说的诚实，指的是做真实的自己。在某些环境中，我们需要注意自己的言谈举止，在跟一些人相处时，我们说话要字斟句酌。我不想待在这样的环境里，也不想跟这样的人相处。如果心里一套、嘴上一套，我的大脑就需要多个线程同时处理信息，这样我就无法活在当下，因为每次与人交谈，我都在追悔过去或计划未来。我只想跟一类人相处，在他们面前我可以做到心口如一。\n\n**在对别人撒谎之前，你必须先对自己撒谎。**\n\n另一个基本的价值观是，我不赞成任何短期思维或短期交易。如果生意伙伴在跟他人的合作中一味追求短期利益，我就不想跟他们合作了。生活中所有的回报，无论是财富、人际关系、爱情、健康、活动，还是习惯，都来自复利。我只想选择值得一辈子深交的伙伴和能获得长期回报的事情。\n\n一个价值观是，我赞同平级关系，不接受等级关系。我不想高于任何人，也不想低于任何人。如果我和别人不能像平级那样对待彼此，我就不想和他们交往了。\n\n还有一个价值观，现在我觉得愤怒是毫无意义的。年轻的时候我认为愤怒是好事，是男子汉气概的象征，但现在，我喜欢佛教的说法：“执怒就像握了一把要丢向他人的热煤炭，被烫伤的人反而是你。”我不想生气，也不想和愤怒的人在一起。我把愤怒的人从自己的生活中剔除了。我不是在评判他们。我自己也经历了很多愤怒。他们必须自己解决这个问题。去别的地方生别人的气吧，不要影响我。\n\n**若要找到一位优秀的伴侣，你先要成为一位优秀的伴侣**\n\n#### 3、理性佛教\n\n问题越古老，答案存世的时间越长。\n\n**问题一、你如何定义智慧？**\n\n**智慧是一种知道个人行为的长期后果的思维能力。 如果仅仅通过语言就可以传授智慧，我们今天就不需要努力了**\n\n\n#### 4、我们唯一拥有的就是当下\n\n除了当下，一切都是不存在的。没有人能够回到过去，也没有人能够以任何有意义的方式成功地预测未来。唯一存在的就是此时此地，就是你恰好存在的这个时刻和在宇宙空间里的这个位置。\n\n死亡唯一的真正含义就是不再有未来的时刻。\n\n#### 5、一些原则\n\n**1、人生要义：活在当下。**\n\n**2、阅读（学习）是终极元技能，可以换来其他任何东西。**\n\n**3、生活中所有的回报都来自复利。**\n\n**4、用头脑赚钱，而不是用时间赚钱。**\n\n**5、生命的伟大在很大程度上源于苦难。**\n\n**6、思考的间隙即开悟**","tags":["个人成长","思维认知"]},{"title":"jsbridge原理","url":"/2023/10/31/jsbridge原理/","content":"\n\n<img src=\"/img/jsbridge1.webp\" width=\"auto\" />\n\n<img src=\"/img/jsbridge2.awebp\" width=\"auto\" />\n\n## 1. JSBridge 的起源\n开发维护成本 和 更新成本 较低的 Web 技术成为混合开发中几乎不二的选择，而作为 Web 技术逻辑核心的 JavaScript 也理所应当肩负起与其他技术『桥接』的职责，并且作为移动不可缺少的一部分，**任何一个移动操作系统中都包含可运行 JavaScript 的容器，例如 WebView 和 JSCore。所以，运行 JavaScript 不用像运行其他语言时，要额外添加运行环境。**因此，基于上面种种原因，JSBridge 应运而生。\n\n移动端混合开发中的 JSBridge，主要被应用在两种形式的技术方案上：\n\n1. 基于 Web 的 Hybrid 解决方案：例如微信浏览器、各公司的 Hybrid 方案\n2. 非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案：例如 React-Native\n\n\n## 2. JSBridge 的用途\nJSBridge 就像其名称中的『Bridge』的意义一样，是 Native 和非 Native 之间的桥梁，**它的核心是 构建 Native 和非 Native 间消息通信的通道，而且是 双向通信的通道。**\n\n所谓 双向通信的通道:\n\n1. JS 向 Native 发送消息 : 调用相关功能、通知 Native 当前 JS 的相关状态等\n2. Native 向 JS 发送消息 : 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等\n\n*消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？*\n\n## 3. JSBridge 的实现原理\n\nJavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的 Webkit 引擎、JSCore）。由于这些 Context 与原生运行环境的天然隔离，我们可以将这种情况与 RPC（Remote Procedure Call，远程过程调用）通信进行类比，将 Native 与 JavaScript 的每次互相调用看做一次 RPC 调用。\n\n在 JSBridge 的设计中，可以把前端看做 RPC 的客户端，把 Native 端看做 RPC 的服务器端，从而 JSBridge 要实现的主要逻辑就出现了：通信调用（Native 与 JS 通信） 和 句柄解析调用。\n\n### 3.1 JSBridge 的通信原理\n\n#### 3.1.1 JavaScript 调用 Native\n\nJavaScript调用 Native 的方式，主要有两种：**注入 API 和 拦截 URL SCHEME。**\n\n**方式一、注入API**\n注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。\n\n客户端注入：\n\n```js\n// wkwebview\n@interface WKWebVIewVC ()<WKScriptMessageHandler>\n\n@implementation WKWebVIewVC\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init];\n    configuration.userContentController = [[WKUserContentController alloc] init];\n    WKUserContentController *userCC = configuration.userContentController;\n    // 注入对象，前端调用其方法时，Native 可以捕获到\n    [userCC addScriptMessageHandler:self name:@\"nativeBridge\"];\n\n    WKWebView wkWebView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];\n\n    // TODO 显示 WebView\n}\n\n- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {\n    if ([message.name isEqualToString:@\"nativeBridge\"]) {\n        NSLog(@\"前端传递的数据 %@: \",message.body);\n        // Native 逻辑\n    }\n}\n\n\n// android\npublicclassJavaScriptInterfaceDemoActivityextendsActivity{\nprivate WebView Wv;\n\n    @Override\n    publicvoidonCreate(Bundle savedInstanceState){\n        super.onCreate(savedInstanceState);\n\n        Wv = (WebView)findViewById(R.id.webView);\n        final JavaScriptInterface myJavaScriptInterface = new JavaScriptInterface(this);\n\n        Wv.getSettings().setJavaScriptEnabled(true);\n        Wv.addJavascriptInterface(myJavaScriptInterface, \"nativeBridge\");\n\n        // TODO 显示 WebView\n\n    }\n\n    publicclassJavaScriptInterface{\n         Context mContext;\n\n         JavaScriptInterface(Context c) {\n             mContext = c;\n         }\n\n         publicvoidpostMessage(String webMessage){\n             // Native 逻辑\n         }\n     }\n}\n```\n\n前端调用方式：\n\n```js\n// ios\nwindow.webkit.messageHandlers.nativeBridge.postMessage(message);\n\n// android\nwindow.nativeBridge.postMessage(message);\n```\n\n\n**方式二、拦截URL SCHEME**\n\n**先解释一下 URL SCHEME：URL SCHEME是一种类似于url的链接，是为了方便app直接互相调用设计的，**形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的，例如: qunarhy://hy/url?url=ymfe.tech，protocol 是 qunarhy，host 则是 hy。\n\n拦截 URL SCHEME 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。\n\n在时间过程中，这种方式有一定的 缺陷：\n\n1. 使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。\n2. 创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长。\n\n但是之前为什么很多方案使用这种方式呢？因为它 支持 iOS6。而现在的大环境下，iOS6 占比很小，基本上可以忽略，所以并不推荐为了 iOS6 使用这种 并不优雅 的方式。\n\n\n#### 3.1.2 Native 调用 JavaScript\n\n相比于 JavaScript 调用 Native， Native 调用 JavaScript 较为简单，毕竟不管是 iOS 的 UIWebView 还是 WKWebView，还是 Android 的 WebView 组件，都以子组件的形式存在于 View/Activity 中，直接调用相应的 API 即可\n\nNative 调用 JavaScript，其实就是执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上。\n\n```js\n// wkwebview\n[wkWebView evaluateJavaScript:javaScriptString completionHandler:completionHandler];\n\n// android\nwebView.loadUrl(\"javascript:\" + javaScriptString);\n\n// android 新版本\nwebView.evaluateJavascript(javaScriptString, new ValueCallback<String>() {\n    @Override\n    publicvoidonReceiveValue(String value){\n\n    }\n});\n```\n\n### 3.2 JSBridge 接口实现\n\n从上面的剖析中，可以得知，JSBridge 的接口主要功能有两个：调用 Native（给 Native 发消息） 和 接被 Native 调用（接收 Native 消息）。因此，JSBridge 可以设计如下：\n\n```js\n/**\n * 在上面的文章中，提到过 RPC 中有一个非常重要的环节是 句柄解析调用，\n * 这点在 JSBridge 中体现为 句柄与功能对应关系。\n * 同时，我们将句柄抽象为 桥名（BridgeName），最终演化为 一个 BridgeName 对应一个 Native 功能或者一类 Native 消息\n */\nwindow.JSBridge = {\n    // 调用 Native\n    invoke: function(bridgeName, data) {\n        // 判断环境，获取不同的 nativeBridge\n        nativeBridge.postMessage({\n            bridgeName: bridgeName,\n            data: data || {}\n        });\n    },\n    receiveMessage: function(msg) {\n        var bridgeName = msg.bridgeName;\n        var data = msg.data || {};\n        // 具体逻辑\n    }\n};\n```\n\nJSBridge 大概的雏形出现了。现在终于可以着手解决这个问题了：消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？\n\n对于 JSBridge 的 Callback ，其实就是 RPC 框架的回调机制。当然也可以用更简单的 JSONP 机制解释:\n\n> 当发送 JSONP 请求时，url 参数里会有 callback 参数，其值是 当前页面唯一 的，而同时以此参数值为 key 将回调函数存到 window 上，随后，服务器返回 script 中，也会以此参数值作为句柄，调用相应的回调函数。\n\n由此可见，callback 参数这个 唯一标识 是这个回调逻辑的关键。这样，我们可以参照这个逻辑来实现 JSBridge：用一个自增的唯一 id，来标识并存储回调函数，并把此 id 以参数形式传递给 Native，而 Native 也以此 id 作为回溯的标识。这样，即可实现 Callback 回调逻辑。\n\n\n```js\n(function () {\n    var id = 0,\n        callbacks = {},\n        registerFuncs = {};\n\n    window.JSBridge = {\n        // 调用 Native\n        invoke: function(bridgeName, callback, data) {\n            // 判断环境，获取不同的 nativeBridge\n            var thisId = id ++; // 获取唯一 id\n            callbacks[thisId] = callback; // 存储 Callback\n            nativeBridge.postMessage({\n                bridgeName: bridgeName,\n                data: data || {},\n                callbackId: thisId // 传到 Native 端\n            });\n        },\n        receiveMessage: function(msg) {\n            var bridgeName = msg.bridgeName;\n            var data = msg.data || {};\n            var callbackId = msg.callbackId;  // Native 将 callbackId 原封不动传回\n            var responstId = msg.responstId;\n            // 具体逻辑\n            // bridgeName 和 callbackId 不会同时存在\n            if (callbackId) {\n                if (callbacks[callbackId]) { // 找到相应句柄\n                    callbacks[callbackId](msg.data); // 执行调用\n                }\n            } else if (bridgeName) {\n                if (registerFuncs[bridgeName]) { // 通过 bridgeName 找到句柄\n                    var ret = {},\n                        flag = false;\n                    registerFuncs[bridgeName].forEach(function(callback) => {\n                        callback(data, function(r) {\n                            flag = true;\n                            ret = Object.assign(ret, r);\n                        });\n                    });\n                    if (flag) {\n                        nativeBridge.postMessage({ // 回调 Native\n                            responstId: responstId,\n                            ret: ret\n                        });\n                    }\n                }\n            }\n        },\n        register: function(bridgeName, callback) {\n            if (!registerFuncs[bridgeName])  {\n                registerFuncs[bridgeName] = [];\n            }\n            registerFuncs[bridgeName].push(callback); // 存储回调\n        }\n    };\n})();\n```\n> 这一节主要讲的是，JavaScript 端的 JSBridge 的实现，对于 Native 端涉及的并不多。在 Native 端配合实现 JSBridge 的 JavaScript 调用 Native 逻辑也很简单，**主要的代码逻辑是：接收到 JavaScript 消息 => 解析参数，拿到 bridgeName、data 和 callbackId => 根据 bridgeName 找到功能方法，以 data 为参数执行 => 执行返回值和 callbackId 一起回传前端。 Native 调用 JavaScript 也同样简单，直接自动生成一个唯一的 ResponseId，并存储句柄，然后和 data 一起发送给前端即可。**\n\n\n\n## 4. JSBridge 如何引用\n\n### 4.1 由 Native 端进行注入\n\n注入方式和 Native 调用 JavaScript 类似，直接执行桥的全部代码。\n\n它的优点在于：桥的版本很容易与 Native 保持一致，Native 端不用对不同版本的 JSBridge 进行兼容；与此同时，它的缺点是：注入时机不确定，需要实现注入失败后重试的机制，保证注入的成功率，同时 JavaScript 端在调用接口时，需要优先判断 JSBridge 是否已经注入成功。\n\n\n### 4.2 JavaScript 端引用\n\n**直接与 JavaScript 一起执行。**\n\n与由 Native 端注入正好相反，它的优点在于：JavaScript 端可以确定 JSBridge 的存在，直接调用即可；缺点是：如果桥的实现方式有更改，JSBridge 需要兼容多版本的 Native Bridge 或者 Native Bridge 兼容多版本的 JSBridge。\n\n\n\n\n\n<br />\n[文章来源于](https://juejin.cn/post/6844903585268891662)","tags":["jssdk","JSBridge","WebViewJavascriptBridge"]},{"title":"javascript重难点实例分析","url":"/2023/10/30/javascript重难点实例分析/","content":"\n## 1、javascript重点概念\n\n### 1.1 javascript的基本数据类型介绍\n\n**基本数据类型：Undefined、Null、Boolean、Number、String、Symbol**\n\n**引用数据类型：Object、Function、Array、Date等类型**\n\n#### 1.1.1 Undefined类型\n\nUndefined类型只有一个唯一的字面值undefined，表示的是一个变量不存在。\n\n下面是4种常见的出现undefined的场景：\n\n1. 使用只声明而未初始化的变量时，会返回“undefined”。\n2. 获取一个对象的某个不存在的属性（自身属性和原型链继承属性）时，会返回“undefined”。\n3. 函数没有明确的返回值时，却在其他地方使用了返回值，会返回“undefined”。\n4. 函数定义时使用了多个形式参数（后文简称为形参），而在调用时传递的参数的数量少于形参数量，那么未匹配上的参数就为“undefined”\n\n#### 1.1.2 Null类型\n\nNull类型只有一个唯一的字面值null，表示一个空指针对象，这也是在使用typeof运算符检测null值时会返回“object”的原因.\n\n下面是3种常见的出现null的场景:\n\n1. 一般情况下，如果声明的变量是为了以后保存某个值，则应该在声明时就将其赋值为“null”。\n2. JavaScript在获取DOM元素时，如果没有获取到指定的元素对象，就会返回“null”。\n3. 在使用正则表达式进行捕获时，如果没有捕获结果，就会返回“null”。\n\n#### 1.1.3  Undefined和Null两种类型的异同\n\n相同点：\n\n1.  Undefined和Null两种数据类型都只有一个字面值，分别是undefined和null。\n2. Undefined类型和Null类型在转换为Boolean类型的值时，都会转换为false。所以通过非运算符（！）获取结果为true的变量时，无法判断其值为undefined还是null。\n3. 在需要将两者转换成对象时，都会抛出一个TypeError的异常，也就是平时最常见的引用异常。\n4.  Undefined类型派生自Null类型，所以在非严格相等的情况下，两者是相等的，如下面代码所示。\n\n\n不同点：\n\n1. null是JavaScript中的关键字，而undefined是JavaScript中的一个全局变量，即挂载在window对象上的一个变量，并不是关键字。\n2.  在使用typeof运算符检测时，Undefined类型的值会返回“undefined”，而Null类型的值会返回“object”。\n3. 在通过call调用toString()函数时，Undefined类型的值会返回“[object Undefined]”，而Null类型的值会返回“[object Null]”。\n4. 在需要进行数值类型的转换时，undefined会转换为NaN，无法参与计算；null会转换为0，可以参与计算。\n5. 无论在什么情况下都没有必要将一个变量显式设置为undefined。如果需要定义某个变量来保存将来要使用的对象，应该将其初始化为null。这样不仅能将null作为空对象指针的惯例，还有助于区分null和undefined。\n\n#### 1.1.4 Boolean类型\n\n（1）String类型转换为Boolean类型\n\n1.  空字符串\"\"或者''都会转换为false。\n2. 任何非空字符串都会转换为true，包括只有空格的字符串\" \"。\n\n（2）Object类型转换为Boolean类型\n\n1. 当object为null时，会转换为false。\n2. 如果object不为null，则都会转换为true，包括空对象{}。\n\n### 1.2 Number类型\n在JavaScript中，Number类型的数据既包括了整型数据，也包括了浮点型数据。\n\n① 八进制：如果想要用八进制表示一个数值，那么首位必须是0，其他位必须是0～7的八进制序列。如果后面位数的字面值大于7，则破坏了八进制数据表示规则，前面的0会被忽略，当作十进制数据处理。\n\n```js\nvar num1 = 024; // 20  2*8+4*1\nvar num2 = 079; // 79  最后一位9超出了八进制字面值，所以不属于八进制数据，最终按照十进制处理，结果为79。\n```\n\n② 十六进制: 如果想要用十六进制表示一个数值，那么前两位必须是0x，其他位必须是十六进制序列（0～9，a～f或者A～F）。如果超过了十六进制序列，则会抛出异常。\n\n```js\nvar num3 = 0x3f;  // 63  3×16+15\nvar num4 = 0x2g;  // SyntaxError: Invalid or unexpected token 最后一位g超出了十六进制所能表示的字面值区间，所以不满足十六进制数据表示规则\n```\n\n**Null类型转换为Number类型**\n\nNull类型只有一个字面值null，直接转换为0。\n\n**Undefined类型转换为Number类型**\n\nUndefined类型只有一个字面值undefined，直接转换为NaN。\n\n**Object类型转换为Number类型**\n\nObject类型在转换为Number类型时，会优先调用valueOf()函数，然后通过valueOf()函数的返回值按照上述规则进行转换。如果转换的结果是NaN，则调用toString()函数，通过toString()函数的返回值重新按照上述规则进行转换；如果有确定的Number类型返回值，则结束，否则返回“NaN”。\n\n#### 1.2.1  Number类型转换\n\n##### 1.2.1.1 Number()函数\n\nNumber()函数可以用于将任何类型转换为Number类型，它在转换时遵循下列规则。\n\n① 如果是数字，会按照对应的进制数据格式，统一转换为十进制并返回。\n\n```js\nNumber(10);    // 10\nNumber(010);   // 8，010是八进制的数据，转换成十进制是8\nNumber(0x10);  // 16，0x10是十六进制数据，转换成十进制是16\n```\n\n② 如果是Boolean类型的值，true将返回为“1”，false将返回为“0”。\n\n③ 如果值为null，则返回“0”。\n\n```js\nNumber(null);  // 0\n```\n\n④ 如果值为undefined，则返回“NaN”。\n\n```js\nNumber(undeﬁned); // NaN\n```\n\n⑤ 如果值为字符串类型，则遵循下列规则。\n\n· 如果该字符串只包含数字，则会直接转换成十进制数；如果数字前面有0，则会直接忽略这个0。\n\n· 如果字符串是有效的浮点数形式，则会直接转换成对应的浮点数，前置的多个重复的0会被清空，只保留一个。\n\n· 如果字符串是有效的十六进制形式，则会转换为对应的十进制数值。\n\n```js\nNumber('0x12'); // 18\nNumber('0x21'); // 33\n```\n\n· 如果字符串是有效的八进制形式，则不会按照八进制转换，而是直接按照十进制转换并输出，因为前置的0会被直接忽略。\n\n```js\nNumber('010');   // 10\nNumber('0020');  // 20\n```\n\n⑥ 如果值为对象类型，则会先调用对象的valueOf()函数获取返回值，并将返回值按照上述步骤重新判断能否转换为Number类型。如果都不满足，则会调用对象的toString()函数获取返回值，并将返回值重新按照步骤判断能否转换成Number类型。如果也不满足，则返回“NaN”。\n\n**以下是通过valueOf()函数将对象正确转换成Number类型的示例。**\n\n```js\nvar obj = {\n   age: 21,\n   valueOf: function () {\n      return this.age;\n   },\n   toString: function () {\n      return 'good';\n   }\n};\n\nNumber(obj);  // 21\n```\n\n**以下是通过toString()函数将对象正确转换成Number类型的示例。**\n\n```js\nar obj = {\n   age: '21',\n   valueOf: function () {\n       return [];\n   },\n   toString: function () {\n       return this.age;\n   }\n};\n\nNumber(obj);  // 21\n```\n\n**以下示例是通过valueOf()函数和toString()函数都无法将对象转换成Number类型的示例（最后返回“NaN”）。**\n\n```js\nvar obj = {\n   age: '21',\n   valueOf: function () {\n       return 'a';\n   },\n   toString: function () {\n       return 'b';\n   }\n}\n\nNumber(obj);  // NaN\n```\n\n**如果toString()函数和valueOf()函数返回的都是对象类型而无法转换成基本数据类型，则会抛出类型转换的异常。**\n\n```js\nvar obj = {\n   age: '21',\n   valueOf: function () {\n       return [];\n   },\n   toString: function () {\n       return [];\n   }\n};\n\nNumber(obj);  // 抛出异常TypeError: Cannot convert object to primitive value\n```\n\n##### 1.2.1.2 parseInt()函数\n\n在使用parseInt()函数将字符串转换成整数时，需要注意以下5点。\n\n* （1）非字符串类型转换为字符串类型\n\n如果遇到传入的参数是非字符串类型的情况，则需要将其优先转换成字符串类型，即使传入的是整型数据。\n\n```js\nparseInt('0x12', 16);  // 18\nparseInt(0x12, 16);    // 24\n```\n第一条语句直接将字符串\"0x12\"转换为十六进制数，得到的结果为1×16+2=18；\n\n第二条语句由于传入的是十六进制数，所以会先转换成十进制数18，然后转换成字符串\"18\"，再将字符串\"18\"转换成十六进制数，得到的结果为1×16+8=24。\n\n\n* （2）数据截取的前置匹配原则\n\nparseInt()函数在做转换时，对于传入的字符串会采用前置匹配的原则。即从字符串的第一个字符开始匹配，如果处于基数指定的范围，则保留并继续往后匹配满足条件的字符，直到某个字符不满足基数指定的数据范围，则从该字符开始，舍弃后面的全部字符。在获取到满足条件的字符后，将这些字符转换为整数。\n\n```js\nparseInt(\"fg123\", 16);  // 15\n```\n\n对于字符串'fg123'，首先从第一个字符开始，'f'是满足十六进制的数据，因为十六进制数据范围是0～9，a～f(A～F)，所以保留'f'；然后是第二个字符'g'，它不满足十六进制数据范围，因此从第二个字符至最后一个字符全部舍弃，最终字符串只保留字符'f'；然后将字符'f'转换成十六进制的数据，为15，因此最后返回的结果为“15”。\n\n如果遇到的字符串是以\"0x\"开头的，那么在按照十六进制处理时，会计算后面满足条件的字符串；如果按照十进制处理，则会直接返回“0”。\n\n```js\nparseInt('0x12',16);   // 18 = 16 + 2\nparseInt('0x12',10);   // 0\n```\n\n需要注意的一点是，如果传入的字符串中涉及算术运算，则不执行，算术符号会被当作字符处理；如果传入的参数是算术运算表达式，则会先运算完成得到结果，再参与parseInt()函数的计算。\n\n```js\nparseInt(15 * 3, 10);   // 45，先运算完成得到45，再进行parseInt(45, 10)的运算\nparseInt('15 * 3', 10); // 15，直接当作字符串处理，并不会进行乘法运算\n```\n\n* （3）对包含字符e的不同数据的处理差异\n\n```js\nparseInt(6e3, 10);     // 6000\nparseInt(6e3, 16);      // 24576\nparseInt('6e3', 10);    // 6\nparseInt('6e3', 16);     // 1763\n```\n\n第一条语句parseInt(6e3, 10)，首先会执行6e3=6000，然后转换为字符串\"6000\"，实际执行的语句是parseInt('6000', 10)，表示的是将字符串\"6000\"转换为十进制的整数，得到的结果为6000。\n\n第二条语句parseInt(6e3, 16)，首先会执行6e3=6000，然后转换为字符串\"6000\"，实际执行的语句是parseInt('6000', 16)，表示的是将字符串\"6000\"转换为十六进制的数，得到的结果是6×163 = 24576。\n\n第三条语句parseInt('6e3', 10)，表示的是将字符串'6e3'转换为十进制的整数，因为字符'e'不在十进制所能表达的范围内，所以会直接省略，实际处理的字符串只有\"6\"，得到的结果为6。\n\n第四条语句parseInt('6e3', 16)，表示的是将字符串'6e3'转换为十六进制的整数，因为字符'e'在十六进制所能表达的范围内，所以会转换为14进行计算，最后得到的结果为6×162 +14×16 + 3 = 1763。\n\n* （4）对浮点型数的处理\n\n如果传入的值是浮点型数，则会忽略小数点及后面的数，直接取整。\n\n```js\nparseInt('6.01', 10); // 6\nparseInt('6.99', 10); // 6\n```\n\n经过上面的详细分析，我们再来看看以下语句的执行结果。以下语句都会返回“15”，这是为什么呢？\n\n```js\nparseInt(\"0xF\", 16);    // 十六进制的F为15，返回“15”\nparseInt(\"F\", 16);      // 十六进制的F为15，返回“15”\nparseInt(\"17\", 8);      // 八进制的\"17\"，返回结果为1×8 + 7 = 15\nparseInt(021, 8);      // 021先转换成十进制得到17，然后转换成字符串\"17\"，再转换成八进制，返回结果为1×8 + 7 = 15\n\nparseInt(\"015\", 10);   // 前面的0忽略，返回“15”\nparseInt(15.99, 10);   // 直接取整，返回“15”\nparseInt(\"15,123\", 10); // 字符串\"15,123\"一一匹配，得到\"15\"，转换成十进制后返回“15”\nparseInt(\"FXX123\", 16); // 字符串\"FXX123\"一一匹配，得到\"F\"，转换成十六进制后返回“15”\nparseInt(\"1111\", 2);    // 1×23 + 1×22 + 1×2 + 1 = 15\nparseInt(\"15 * 3\", 10); // 字符串中并不会进行算术运算，实际按照\"15\"进行计算，返回“15”\nparseInt(\"15e2\", 10);   // 实际按照字符串\"15\"运算，返回“15”\nparseInt(\"15px\", 10);   // 实际按照字符串\"15\"运算，返回“15”\nparseInt(\"12\", 13);     // 按照十三进制计算，返回结果为1×13 + 2 = 15\n```\n\n* （5）map()函数与parseInt()函数的隐形坑\n\n设想这样一个场景，存在一个数组，数组中的每个元素都是Number类型的字符串['1','2', '3', '4']，如果我们想要将数组中的元素全部转换为整数，我们该怎么做呢？\n\n我们可能会想到在Array的map()函数中调用parseInt()函数，代码如下。\n\n```js\nvar arr = ['1', '2', '3', '4'];\n\nvar result = arr.map(parseInt);\n\nconsole.log(result);\n```\n但是在运行后，得到的结果是[1, NaN, NaN, NaN]，与我们期望的结果[1, 2, 3, 4]差别很大，这是为什么呢？\n\n上面的代码实际与下面的代码等效。\n\n```js\narr.map(function (val, index) {\n  return parseInt(val, index);\n});\n\nparseInt('1', 0);  // 1\nparseInt('2', 1);  // NaN\nparseInt('3', 2);  // NaN\nparseInt('4', 3);  // NaN\n```\n任何整数以0为基数取整时，都会返回本身，所以第一行代码会返回“1”。\n\n##### 1.2.1.3 parseFloat()函数\n\n① 如果在解析过程中遇到了正负号（+ / -）、数字0～9、小数点或者科学计数法（e / E）以外的字符，则会忽略从该字符开始至结束的所有字符，然后返回当前已经解析的字符的浮点数形式。\n\n```js\nparseFloat('+1.2');   // 1.2\nparseFloat('-1.2');   // -1.2\nparseFloat('++1.2');  // NaN，符号不能连续出现\nparseFloat('--1.2');  // NaN，符号不能连续出现\nparseFloat('1+1.2');  // 1，'+'出现在第二位，不会当作符号位处理\n```\n\n② 字符串前面的空白符会直接忽略，如果第一个字符就无法解析，则会直接返回“NaN”。\n\n```js\nparseFloat('  1.2'); // 1.2\nparseFloat('f1.2');  // NaN\n```\n\n③ 对于字符串中出现的合法科学运算符e，进行运算处理后会转换成浮点型数，这点与parseInt()函数的处理有很大的不同。\n\n```js\nparseFloat('4e3');   // 4000\nparseInt('4e3', 10); // 4\n```\n\n④ 对于小数点，只能正确匹配第一个，第二个小数点是无效的，它后面的字符也都将被忽略。\n\n```js\nparseFloat('11.20');  // 11.2\nparseFloat('11.2.1'); // 11.2\n```\n\n下面是使用parseFloat()函数的综合实例。\n\n```js\nparseFloat(\"123AF\");   // 123，匹配字符串'123'\nparseFloat(\"0xA\");     // 0，匹配字符串'0'\nparseFloat(\"22.5\");    // 22.5，匹配字符串'22.5'\nparseFloat(\"22.3.56\"); // 22.3，匹配字符串'22.3'\nparseFloat(\"0908.5\");  // 908.5，匹配字符串'908.5'\n```\n\n##### 1.2.1.4  结论\n\n· Number()函数转换的是传入的整个值，并不是像parseInt()函数和parseFloat()函数一样会从首位开始匹配符合条件的值。如果整个值不能被完整转换，则会返回“NaN”。\n\n· parseFloat()函数在解析小数点时，会将第一个小数点当作有效字符，而parseInt()函数在解析时如果遇到小数点会直接停止，因为小数点不是整数的一部分。\n\n· parseFloat()函数在解析时没有进制的概念，而parseInt()函数在解析时会依赖于传入的基数做数值转换。\n\n\n#### 1.2.2 isNaN()函数与Number.isNaN()函数对比\nNumber类型数据中存在一个比较特殊的数值NaN（Not a Number），它表示应该返回数值却并未返回数值的情况。\n\nNaN存在的目的是在某些异常情况下保证程序的正常执行。例如0/0，在其他语言中，程序会直接抛出异常，而在JavaScript中会返回“NaN”，程序可以正常执行。\n\n**NaN有两个很明显的特点，第一个是任何涉及NaN的操作都会返回“NaN”，第二个是NaN与任何值都不相等，即使是与NaN本身相比。**\n\n```js\nNaN == NaN;  // false\n```\n在判断NaN时，ES5提供了isNaN()函数，ECMAScript 6（后续简称ES6）为Number类型增加了静态函数isNaN()。\n\n##### 1.2.2.1 isNaN()函数\n\n```js\nisNaN(NaN);            // true\nisNaN(undeﬁned);       // true\nisNaN({});             // true\n\nisNaN(true);           // false，Number(true)会转换成数字1\nisNaN(null);           // false，Number(null)会转换成数字0\nisNaN(1);              // false\nisNaN('');             // false，Number('')会转换为成数字0\nisNaN(\"1\");            // false，字符串\"1\"可以转换成数字1\nisNaN(\"JavaScript\");   // true，字符串\"JavaScript\"无法转换成数字Date类型\nisNaN(new Date());     // false\nisNaN(new Date().toString());  // true\n```\n\n##### 1.2.2.2 Number.isNaN()函数\n既然在全局环境中有isNaN()函数，为什么在ES6中会专门针对Number类型增加一个isNaN()函数呢？\n\n这是因为isNaN()函数本身存在误导性，而ES6中的Number.isNaN()函数会在真正意义上去判断变量是否为NaN，不会做数据类型转换。只有在传入的值为NaN时，才会返回“true”，传入其他任何类型的值时会返回“false”。\n\n```js\nNumber.isNaN(NaN);        // true\nNumber.isNaN(undeﬁned);   // false\nNumber.isNaN(null);       // false\nNumber.isNaN(true);       // false\nNumber.isNaN('');         // false\nNumber.isNaN(123);        // false\n```\n\n上面代码运行后，除了传入NaN会返回“true”以外，传入其他的值都会返回“false”。如果在非ES6环境中想用ES6中的isNaN()函数，该怎么办呢？我们有以下兼容性处理方案。\n\n```js\n// 兼容性处理\nif(!Number.isNaN) {\n    Number.isNaN = function (n) {\n       return n !== n;\n    }\n}\n```\n\n##### 1.2.2.3 总结\n· isNaN()函数在判断是否为NaN时，需要先进行数据类型转换，只有在无法转换为数字时才会返回“true”；\n\n· Number.isNaN()函数在判断是否为NaN时，只需要判断传入的值是否为NaN，并不会进行数据类型转换。\n\n#### 1.2.3 浮点型运算\n**在JavaScript中，整数和浮点数都属于Number类型，它们都统一采用64位浮点数进行存储**\n\n虽然它们存储数据的方式是一致的，但是在进行数值运算时，却会表现出明显的差异性。整数参与运算时，得到的结果往往会和我们所想的一样，而对于浮点型运算，有时却会出现一些意想不到的结果，如下面的代码所示。\n\n```js\n// 加法\n0.1 + 0.2 = 0.30000000000000004\n0.7 + 0.1 = 0.7999999999999999\n\n// 减法\n1.5 - 1.2 = 0.30000000000000004\n0.3 - 0.2 = 0.09999999999999998\n\n// 乘法\n0.7 * 180 = 125.99999999999999\n9.7 * 100 = 969.9999999999999\n\n// 除法\n0.3 / 0.1 = 2.9999999999999996\n0.69 / 10 = 0.06899999999999999\n```\n得到这样的结果，大家是不是觉得很奇怪呢？0.1 + 0.2为什么不是等于0.3，而是等于0.30000000000000004呢？接下来我们一探究竟。\n\n##### 1.2.3.1 浮点运算不准确原因\n首先我们来看看一个浮点型数在计算机中的表示，它总共长度是64位，其中最高位为符号位，接下来的11位为指数位，最后的52位为小数位，即有效数字的部分。\n\n· 第0位：符号位sign表示数的正负，0表示正数，1表示负数。\n\n· 第1位到第11位：存储指数部分，用e表示。\n\n· 第12位到第63位：存储小数部分（即有效数字），用f表示，如图1-1所示。\n<br>\n  <img src=\"/img/float.jpeg\"  alt=\"浮点运算\" height = \"auto\"/>\n<br>\n**因为浮点型数使用64位存储时，最多只能存储52位的小数位，对于一些存在无限循环的小数位浮点数，会截取前52位，从而丢失精度，所以会出现上面实例中的结果。**\n\n\n##### 1.2.3.2 浮点运算计算过程\n接下来以0.1 + 0.2 = 0.30000000000000004的运算为例，看看为什么会得到这个计算结果。\n\n首先将各个浮点数的小数位按照“乘2取整，顺序排列”的方法转换成二进制表示。\n\n具体做法是用2乘以十进制小数，得到积，将积的整数部分取出；然后再用2乘以余下的小数部分，又得到一个积；再将积的整数部分取出，如此推进，直到积中的小数部分为零为止。\n\n然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位，得到最终结果。\n\n0.1转换为二进制表示的计算过程如下。\n\n```js\n0.1 * 2 = 0.2 //取出整数部分0\n\n0.2 * 2 = 0.4 //取出整数部分0\n\n0.4 * 2 = 0.8 //取出整数部分0\n\n0.8 * 2 = 1.6 //取出整数部分1\n\n0.6 * 2 = 1.2 //取出整数部分1\n\n0.2 * 2 = 0.4 //取出整数部分0\n\n0.4 * 2 = 0.8 //取出整数部分0\n\n0.8 * 2 = 1.6 //取出整数部分1\n\n0.6 * 2 = 1.2 //取出整数部分1\n```\n\n1.2取出整数部分1后，剩余小数为0.2，与这一轮运算的第一位相同，表示这将是一个无限循环的计算过程。\n\n```js\n0.2 * 2 = 0.4 //取出整数部分0\n\n0.4 * 2 = 0.8 //取出整数部分0\n\n0.8 * 2 = 1.6 //取出整数部分1\n\n0.6 * 2 = 1.2 //取出整数部分1\n...\n```\n因此0.1转换成二进制表示为0.0 0011 0011 0011 0011 0011 0011……（无限循环）。\n\n同理对0.2进行二进制的转换，计算过程与上面类似，直接从0.2开始，相比于0.1，少了第一位的0，其余位数完全相同，结果为0.0011 0011 0011 0011 0011 0011……（无限循环）。\n\n将0.1与0.2相加，然后转换成52位精度的浮点型表示。\n\n```js\n 0.0001 1001 1001 1001 1001 1001  1001 1001 1001 1001 1001 1001 1001   (0.1)\n+ 0.0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011   (0.2)\n= 0.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100\n```\n\n##### 1.2.3.3  解决方案\n\n这里提供一种方法，主要思路是将浮点数先乘以一定的数值转换为整数，通过整数进行运算，然后将结果除以相同的数值转换成浮点数后返回。\n\n下面提供一套用于做浮点数加减乘除运算的代码。\n\n```js\nconst operationObj = {\n   /**\n    * 处理传入的参数，不管传入的是数组还是以逗号分隔的参数都处理为数组\n    * @param args\n    * @returns {*}\n    */\n   getParam(args) {\n      return Array.prototype.concat.apply([], args);\n   },\n\n   /**\n    * 获取每个数的乘数因子，根据小数位数计算\n    * 1.首先判断是否有小数点，如果没有，则返回1；\n    * 2.有小数点时，将小数位数的长度作为Math.pow()函数的参数进行计算\n    * 例如2的乘数因子为1，2.01的乘数因子为100\n    * @param x\n    * @returns {number}\n    */\n   multiplier(x) {\n      let parts = x.toString().split('.');\n      return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);\n   },\n\n   /**\n    * 获取多个数据中最大的乘数因子\n    * 例如1.3的乘数因子为10，2.13的乘数因子为100\n    * 则1.3和2.13的最大乘数因子为100\n    * @returns {*}\n    */\n   correctionFactor() {\n       let args = Array.prototype.slice.call(arguments);\n       let argArr = this.getParam(args);\n       return argArr.reduce((accum, next) => {\n           let num = this.multiplier(next);\n           return Math.max(accum, num);\n       }, 1);\n   },\n\n   /**\n    * 加法运算\n    * @param args\n    * @returns {number}\n    */\n   add(...args) {\n       let calArr = this.getParam(args);\n       // 获取参与运算值的最大乘数因子\n       let corrFactor = this.correctionFactor(calArr);\n       let sum = calArr.reduce((accum, curr) => {\n           // 将浮点数乘以最大乘数因子，转换为整数参与运算\n           return accum + Math.round(curr * corrFactor);\n       }, 0);\n       // 除以最大乘数因子\n       return sum / corrFactor;\n   },\n\n   /**\n    * 减法运算\n    * @param args\n    * @returns {number}\n    */\n   subtract(...args) {\n       let calArr = this.getParam(args);\n       let corrFactor = this.correctionFactor(calArr);\n       let diﬀ = calArr.reduce((accum, curr, curIndex) => {\n          // reduce()函数在未传入初始值时，curIndex从1开始，第一位参与运算的值需要\n          // 乘以最大乘数因子\n          if (curIndex === 1) {\n              return Math.round(accum * corrFactor) - Math.round(curr * corrFactor);\n          }\n          // accum作为上一次运算的结果，就无须再乘以最大因子\n          return Math.round(accum) - Math.round(curr * corrFactor);\n       });\n     // 除以最大乘数因子\n       return diﬀ / corrFactor;\n   },\n\n   /**\n    * 乘法运算\n    * @param args\n    * @returns {*}\n    */\n   multiply(...args) {\n      let calArr = this.getParam(args);\n      let corrFactor = this.correctionFactor(calArr);\n      calArr = calArr.map((item) => {\n          // 乘以最大乘数因子\n          return item * corrFactor;\n      });\n      let multi = calArr.reduce((accum, curr) => {\n          return Math.round(accum) * Math.round(curr);\n      }, 1);\n      // 除以最大乘数因子\n      return multi / Math.pow(corrFactor, calArr.length);\n   },\n\n   /**\n    * 除法运算\n    * @param args\n    * @returns {*}\n    */\n   divide(...args) {\n       let calArr = this.getParam(args);\n       let quotient = calArr.reduce((accum, curr) => {\n           let corrFactor = this.correctionFactor(accum, curr);\n           // 同时转换为整数参与运算\n           return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);\n       });\n       return quotient;\n   }\n};\n```\n\n### 1.3 String类型\nJavaScript中的String类型（字符串类型）既可以通过双引号\"\"表示，也可以通过单引号''表示，而且是完全等效的，这点与Java、PHP等语言在字符串的处理上是不同的。\n\n**如果是引用类型的数据，则在转换时总是会调用toString()函数，得到不同类型值的字符串表示；如果是基本数据类型，则会直接将字面值转换为字符串表示形式。例如null值和undefined值转换为字符串时，会直接返回字面值，分别是\"null\"和\"undefined\"。**\n\n#### 1.3.1 String类型的定义与调用\n\n在JavaScript中，有3种定义字符串的方式，分别是字符串字面量，直接调用String()函数与new String()构造函数。\n\n1. 字符串字面量\n\n```js\nvar str = 'hello JavaScript';  // 正确写法\nvar str2 = \"hello html\";       // 正确写法\nvar str = 'hello css\";         // 错误写法，首尾符号不一样\n```\n\n2.  直接调用String()函数\n\n① 如果是Number类型的值，则直接转换成对应的字符串。\n\n```js\nString(123);     // '123'\nString(123.12);  // '123.12'\n```\n\n② 如果是Boolean类型的值，则直接转换成'true'或者'false'。\n\n```js\nString(true);  // 'true'\nString(false); // 'false'\n```\n\n③ 如果值为null，则返回字符串'null'；\n\n```js\nString(null);  // 'null'\n```\n\n④ 如果值为undefined，则返回字符串'undefined'；\n\n```js\nString(undeﬁned); // 'undeﬁned'\n```\n\n⑤ 如果值为字符串，则直接返回字符串本身；\n\n```js\nString('this is a string');  // 'this is a string'\n```\n\n⑥ 如果值为引用类型，则会先调用toString()函数获取返回值，将返回值按照上述步骤①～⑤判断能否转换字符串类型，如果都不满足，则会调用对象的valueOf()函数获取返回值，并将返回值重新按照步骤①～⑤判断能否转换成字符串类型，如果也不满足，则会抛出类型转换的异常。\n\n以下是通过toString()函数将对象正确转换成String类型的示例:\n\n```js\nvar obj = {\n   age: 21,\n   valueOf: function () {\n       return this.age;\n   },\n   toString: function () {\n       return 'good';\n   }\n};\nString(obj);  // 'good'\n```\n\n以下是通过valueOf()函数将对象正确转换成String类型的示例:\n\n```js\nvar obj = {\n   age: '21',\n   valueOf: function () {\n       return this.age;\n   },\n   toString: function () {\n       return [];\n   }\n};\nString(obj);  // '21'\n```\n\n如果toString()函数和valueOf()函数返回的都是对象类型而无法转换成原生类型时，则会抛出类型转换的异常:\n\n```js\nvar obj = {\n   age: '21',\n   valueOf: function () {\n       return [];\n   },\n   toString: function () {\n       return [];\n   }\n};\nString(obj);  // 抛出异常TypeError: Cannot convert object to primitive value\n```\n\n3. new String()构造函数\n\nnew String()构造函数使用new运算符生成String类型的实例，对于传入的参数同样采用和上述String()函数一样的类型转换策略，最后的返回值是一个String类型对象的实例。\n\n```js\nnew String('hello JavaScript'); // String {\"hello JavaScript\"}\n```\n\n4. 三者在作比较时的区别\n\n基本字符串在作比较时，只需要比较字符串的值即可；而在比较字符串对象时，比较的是对象所在的地址。\n\n```js\nvar str = 'hello';\nvar str2 = String(str);\nvar str3 = String('hello');\nvar str4 = new String(str);\nvar str5 = new String(str);\nvar str6 = new String('hello');\n\nstr === str2;   // true\nstr2 === str3;  // true\nstr3 === str4;  // false\nstr4 === str5;  // false\nstr5 === str6;  // false\n```\n\n对于str4、str5和str6，因为是使用new运算符生成的String类型的实例，所以在比较时需要判断变量是否指向同一个对象，即内存地址是否相同，很明显str4、str5、str6都是在内存中新生成的地址，彼此各不相同。\n\n\n5. 函数的调用\n\n在String对象的原型链上有一系列的函数，例如indexOf()函数、substring()函数、slice()函数等，通过String对象的实例可以调用这些函数做字符串的处理。\n\n但是我们发现，采用字面量方式定义的字符串没有通过new运算符生成String对象的实例也能够直接调用原型链上的函数。\n\n这是为什么呢？\n\n**实际上基本字符串本身是没有字符串对象的函数，而在基本字符串调用字符串对象才有的函数时，JavaScript会自动将基本字符串转换为字符串对象，形成一种包装类型，这样基本字符串就可以正常调用字符串对象的方法了。**\n\n\n#### 1.3.2 String类型常见算法\n\n##### 1.3.2.1  字符串逆序输出\n\n给定一个字符串'abcdefg'，执行一定的算法后，输出的结果为'gfedcba'。\n\n1. 算法1\n\n算法1的主要思想是借助数组的reverse()函数。\n\n首先将字符串转换为字符数组，然后通过调用数组原生的reverse()函数进行逆序，得到逆序数组后再通过调用join()函数得到逆序字符串。\n\n```js\n// 算法1：借助数组的reverse()函数\nfunction reverseString1(str) {\n   return str.split('').reverse().join('');\n}\n```\n\n2. 算法2\n\n算法2的主要思想是利用字符串本身的charAt()函数。\n\n从尾部开始遍历字符串，然后利用charAt()函数获取字符并逐个拼接，得到最终的结果。charAt()函数接收一个索引数字，返回该索引位置对应的字符。\n\n```js\n// 算法2：利用charAt()函数\nfunction reverseString2(str) {\n   var result = '';\n   for(var i = str.length - 1; i >= 0; i--){\n       result += str.charAt(i);\n   }\n   return result;\n}\n```\n\n3. 算法3\n\n算法3的主要思想是通过递归实现逆序输出，与算法2的处理类似。\n\n递归从字符串最后一个位置索引开始，通过charAt()函数获取一个字符，并拼接到结果字符串中，递归结束的条件是位置索引小于0。\n\n```js\n// 算法3：递归实现\nfunction reverseString3(strIn,pos,strOut){\n   if(pos<0)\n      return strOut;\n   strOut += strIn.charAt(pos--);\n   return reverseString3(strIn,pos,strOut);\n}\n\n\nvar str = 'abcdefg';\nvar result = '';\nconsole.log(reverseString3(str, str.length - 1, result));\n```\n\n4. 算法4\n\n算法4的主要思想是通过call()函数来改变slice()函数的执行主体。\n\n调用call()函数后，可以让字符串具有数组的特性，在调用未传入参数的slice()函数后，得到的是一个与自身相等的数组，从而可以直接调用reverse()函数，最后再通过调用join()函数，得到逆序字符串。\n\n```js\n// 算法4: 利用call()函数\nfunction reverseString4(str) {\n   // 改变slice()函数的执行主体，得到一个数组\n   var arr = Array.prototype.slice.call(str);\n   // 调用reverse()函数逆序数组\n   return arr.reverse().join('');\n}\n```\n\n5. 算法5\n\n算法5的主要思想是借助栈的先进后出原则\n\n由于JavaScript并未提供栈的实现，我们首先需要实现一个栈的数据结构，然后在栈中添加插入和弹出的函数，利用插入和弹出方法的函数字符串逆序。\n\n首先，我们来看下基本数据结构——栈的实现。通过一个数组进行数据存储，通过一个top变量记录栈顶的位置，随着数据的插入和弹出，栈顶位置动态变化。\n\n栈的操作包括两种，分别是出栈和入栈。出栈时，返回栈顶元素，即数组中索引值最大的元素，然后top变量减1；入栈时，往栈顶追加元素，然后top变量加1。\n\n```js\n// 栈\nfunction Stack() {\n   this.data = []; // 保存栈内元素\n   this.top = 0;   // 记录栈顶位置\n}\n\n// 原型链增加出栈、入栈方法\nStack.prototype = {\n   // 入栈:先在栈顶添加元素，然后元素个数加1\n   push: function push(element) {\n       this.data[this.top++] = element;\n   },\n   // 出栈：先返回栈顶元素，然后元素个数减1\n   pop: function pop() {\n       return this.data[--this.top];\n   },\n   // 返回栈内的元素个数，即长度\n   length: function () {\n       return this.top;\n   }\n};\n```\n\n```js\n// 算法5：自定义栈实现\nfunction reverseString5(str) {\n   //创建一个栈的实例\n   var s = new Stack();\n   //将字符串转成数组\n   var arr = str.split('');\n   var len = arr.length;\n   var result = '';\n   //将元素压入栈内\n   for(var i = 0; i < len; i++){\n      s.push(arr[i]);\n   }\n   //输出栈内元素\n   for(var j = 0; j < len; j++){\n      result += s.pop(j);\n   }\n   return result;\n}\n\n// 使用\nvar str = 'abcdefg';\nconsole.log(reverseString5(str));\n```\n\n##### 1.3.2.2 统计字符串中出现次数最多的字符及出现的次数\n\n假如存在一个字符串'helloJavascripthellohtmlhellocss'，其中出现次数最多的字符是l，出现的次数是7次。\n\n1. 算法1\n\n算法1的主要思想是通过key-value形式的对象来存储字符串以及字符串出现的次数，然后逐个判断出现次数最大值，同时获取对应的字符，具体实现如下。\n\n· 首先通过key-value形式的对象来存储数据，key表示不重复出现的字符，value表示该字符出现的次数。\n\n· 然后遍历字符串的每个字符，判断是否出现在key中。如果在，直接将对应的value值加1；如果不在，则直接新增一组key-value，value值为1\n\n· 得到key-value对象后，遍历该对象，逐个比较value值的大小，找出其中最大的值并记录key-value，即获得最终想要的结果。\n\n```js\n// 算法1\nfunction getMaxCount(str) {\n   var json = {};\n   // 遍历str的每一个字符得到key-value形式的对象\n   for (var i = 0; i < str.length; i++) {\n       // 判断json中是否有当前str的值\n       if (!json[str.charAt(i)]) {\n           // 如果不存在，就将当前值添加到json中去\n           json[str.charAt(i)] = 1;\n       } else {\n           // 如果存在，则让value值加1\n           json[str.charAt(i)]++;\n       }\n   }\n   // 存储出现次数最多的值和出现次数\n   var maxCountChar = '';\n   var maxCount = 0;\n   // 遍历json对象，找出出现次数最大的值\n  for (var key in json) {\n      // 如果当前项大于下一项\n      if (json[key] > maxCount) {\n          // 就让当前值更改为出现最多次数的值\n          maxCount = json[key];\n          maxCountChar = key;\n      }\n   }\n   //最终返回出现最多的值以及出现次数\n   return '出现最多的值是' + maxCountChar + '，出现次数为' + maxCount;\n}\nvar str = 'helloJavaScripthellohtmlhellocss';\ngetMaxCount(str); // '出现最多的值是l，出现次数为7'\n```\n\n2. 算法2\n\n算法2同样会借助于key-value形式的对象来存储字符与字符出现的次数，但是在运算上有所差别。\n\n· 首先通过key-value形式的对象来存储数据，key表示不重复出现的字符，value表示该字符出现的次数。\n\n· 然后将字符串处理成数组，通过forEach()函数遍历每个字符。在处理之前需要先判断当前处理的字符是否已经在key-value对象中，如果已经存在则表示已经处理过相同的字符，则无须处理；如果不存在，则会处理该字符item。\n\n· 通过split()函数传入待处理字符，可以得到一个数组，该数组长度减1即为该字符出现的次数。\n\n· 获取字符出现的次数后，立即与表示出现最大次数和最大次数对应的字符变量maxCount和maxCountChar相比，如果比maxCount大，则将值写入key-value对象中，并动态更新maxCount和maxCountChar的值，直到最后一个字符处理完成。\n\n· 最后得到的结果即maxCount和maxCountChar两个值。\n\n```js\n// 算法2\nfunction getMaxCount2(str) {\n   var json = {};\n   var maxCount = 0, maxCountChar = '';\n   str.split('').forEach(function (item) {\n       // 判断json对象中是否有对应的key\n       if (!json.hasOwnProperty(item)) {\n           // 当前字符出现的次数\n           var number = str.split(item).length - 1;\n           // 直接与出现次数最大值比较，并进行更新\n           if(number > maxCount) {\n               // 写入json对象\n               json[item] = number;\n               // 更新maxCount与maxCountChar的值\n               maxCount = number;\n               maxCountChar = item;\n           }\n       }\n   });\n\n   return '出现最多的值是' + maxCountChar + '，出现次数为' + maxCount;\n}\n\nvar str = 'helloJavaScripthellohtmlhellocss';\ngetMaxCount2(str); // '出现最多的值是l，出现次数为7'\n```\n\n3. 算法3\n\n算法3的主要思想是对字符串进行排序，然后通过lastIndexOf()函数获取索引值后，判断索引值的大小以获取出现的最大次数。\n\n· 首先将字符串处理成数组，调用sort()函数进行排序，处理成字符串。\n\n· 然后遍历每个字符，通过调用lastIndexOf()函数，确定每个字符出现的最后位置，然后减去当前遍历的索引，就可以确定该字符出现的次数。\n\n· 确定字符出现的次数后，直接与次数最大值变量maxCount进行比较，如果比maxCount大，则直接更新maxCount的值，并同步更新maxCountChar的值；如果比maxCount小，则不做任何处理。\n\n· 计算完成后，将索引值设置为字符串出现的最后位置，进行下一轮计算，直到处理完所有字符。\n\n```js\n// 算法3\nfunction getMaxCount3(str) {\n   // 定义两个变量，分别表示出现最大次数和对应的字符\n   var maxCount = 0, maxCountChar = '';\n   // 先处理成数组，调用sort()函数排序,再处理成字符串\n   str = str.split('').sort().join('');\n   for (var i = 0, j = str.length; i < j; i++) {\n       var char = str[i];\n       // 计算每个字符串出现的次数\n       var charCount = str.lastIndexOf(char) - i + 1;\n       // 与次数最大值作比较\n       if (charCount > maxCount) {\n           // 更新maxCount和maxCountChar的值\n           maxCount = charCount;\n           maxCountChar = char;\n       }\n       // 变更索引为字符出现的最后位置\n       i = str.lastIndexOf(char);\n   }\n   return '出现最多的值是' + maxCountChar + '，出现次数为' + maxCount;\n}\n\nvar str = 'helloJavaScripthellohtmlhellocss';\ngetMaxCount3(str);  // '出现最多的值是l，出现次数为7'\n```\n\n4. 算法4\n\n算法4的主要思想是将字符串进行排序，然后通过正则表达式将字符串进行匹配拆分，将相同字符组合在一起，最后判断字符出现的次数。\n\n· 首先将字符串处理成数组，调用sort()函数进行排序，处理成字符串。\n\n· 然后设置正则表达式reg，对字符串使用match()函数进行匹配，得到一个数组，数组中的每个成员是相同的字符构成的字符串。\n\n· 遍历数组，依次将成员字符串长度值与maxCount值进行比较，动态更新maxCount与maxCountChar的值，直到数组所有元素处理完成。\n\n```js\n// 算法4\nfunction getMaxCount4(str) {\n   // 定义两个变量，分别表示出现最大次数和对应的字符\n   var maxCount = 0, maxCountChar = '';\n   // 先处理成数组，调用sort()函数排序,再处理成字符串\n   str = str.split('').sort().join('');\n   // 通过正则表达式将字符串处理成数组(数组每个元素为相同字符构成的字符串)\n   var arr = str.match(/(\\w)\\1+/g);\n   for (var i = 0; i < arr.length; i++) {\n       // length表示字符串出现的次数\n       var length = arr[i].length;\n       // 与次数最大值作比较\n       if (length > maxCount) {\n           // 更新maxCount和maxCountChar\n           maxCount = length;\n           maxCountChar = arr[i][0];\n       }\n   }\n   return '出现最多的值是' + maxCountChar + '，出现次数为' + maxCount;\n}\n\nvar str = 'helloJavaScripthellohtmlhellocss';\ngetMaxCount4(str);  // '出现最多的值是l，出现次数为7'\n```\n\n5. 算法5\n\n算法5的主要思想是借助replace()函数，主要实现方式如下。\n\n· 通过while循环处理，跳出while循环的条件是字符串长度为0。\n\n· 在while循环中，记录原始字符串的长度originCount，用于后面做长度计算处理。\n\n· 获取字符串第一个字符char，通过replace()函数将char替换为空字符串''，得到一个新的字符串，它的长度remainCount相比于originCount会小，其中的差值originCount - remainCount即为该字符出现的次数。\n\n· 确定字符出现的次数后，直接与maxCount进行比较，如果比maxCount大，则直接更新maxCount的值，并同步更新maxCountChar的值；如果比maxCount小，则不做任何处理。\n\n· 处理至跳出while循环，得到最终结果。\n\n```js\n// 算法5\nfunction getMaxCount5(str) {\n   // 定义两个变量，分别表示出现最大次数和对应的字符\n   var maxCount = 0, maxCountChar = '';\n   while (str) {\n       // 记录原始字符串的长度\n       var originCount = str.length;\n       // 当前处理的字符\n       var char = str[0];\n       var reg = new RegExp(char, 'g');\n       // 使用replace()函数替换处理的字符为空字符串\n       str = str.replace(reg, '');\n       var remainCount = str.length;\n       // 当前字符出现的次数\n       var charCount = originCount - remainCount;\n       // 与次数最大值作比较\n       if (charCount > maxCount) {\n          // 更新maxCount和maxCountChar的值\n          maxCount = charCount;\n          maxCountChar = char;\n       }\n   }\n   return '出现最多的值是' + maxCountChar + '，出现次数为' + maxCount;\n}\n\nvar str = 'helloJavaScripthellohtmlhellocss';\ngetMaxCount5(str);  // '出现最多的值是l，出现次数为7'\n```\n\n\n##### 1.3.2.3 去除字符串中重复的字符\n\n假如存在一个字符串'helloJavaScripthellohtmlhellocss'，其中存在大量的重复字符，例如h、e、l等，去除重复的字符，只保留一个，得到的结果应该是'heloJavscriptm'。\n\n","tags":["js难点","js重点"]},{"title":"英语音标学习","url":"/2023/10/17/英语音标学习/","content":"\n\n## 元音（20）\n\n### 单元音（12）\n```js\n// 1、两难\n[æ] --> b(a)g    [a:] --> c(ar)\n[e] --> l(e)g    [ʌ] --> b(u)s\n\n// 2、两易\n[i:] --> s(ee)    [u:] --> r(u)ler\n[i] --> s(i)t     [u]  --> l(oo)k\n\n// 3、两嘴型\n[ɔ:] --> n(o)rth  [ə:] --> e(ar)th\n[ɔ]  --> b(o)x    [ə]  --> teach(er)\n```\n\n### 双元音（8）\n\n**两个单元音组成就是双元音**\n\n```js\n[ai] --> sk(y)\n[ei] --> n(a)me\n[ɔi] --> b(oy)\n\n[iə] --> (ear)\n[eə] --> (air)\n[uə] --> s(ure)\n\n[au] --> n(ow)\n[əu] --> kn(ow)\n```\n\n\n## 辅音（28）","tags":["英语音标","48个音标","元音","辅音"]},{"title":"前端跨域总结","url":"/2023/10/12/前端跨域总结/","content":"\n## 1、什么是跨域\n在前端领域中，跨域是指浏览器允许向服务器发送跨域请求，从而克服浏览器同源限制\n\n### 1.1 什么是同源策略？\n同源策略是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。**所谓同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。**\n\n同源策略限制以下几种行为：\n\n* Cookie、LocalStorage 和 IndexDB 无法读取\n* DOM和JS对象无法获得\n* xhr请求不能发送\n\n## 2、常见的跨域场景\n\n<table border=\"1\" >\n  <thead>\n    <tr>\n      <th>URL</th>\n      <th>说明</th>\n      <th>是否允许通信</th> \n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>\n      1. www.domain.com/a.js\n      2. www.domain.com/b.js\n      3. www.domain.com/lab/c.js\n      </td>\n      <td>同一域名，不同文件或路径</td>\n      <td>允许</td>\n    </tr>\n    <tr>\n      <td>\n      1. www.domain.com:8000/a.js\n      2. www.domain.com/b.js\n      </td>\n      <td>同一域名，不同端口</td>\n      <td>不允许</td>\n    </tr> \n    <tr>\n      <td>\n        1. http://www.domain.com/a.js\n        2. http://192.168.4.12/b.js\n      </td>\n      <td>域名和域名对应相同ip</td>\n      <td>不允许</td>\n    </tr>\n    <tr>\n      <td>\n          1. http://www.domain.com/a.js\n          2. http://x.domain.com/b.js\n          3. http://domain.com/c.js\n      </td>\n      <td>主域相同，子域不同</td>\n      <td>不允许</td>\n    </tr>            \n  </tbody>\n</table>\n\n\n## 3、跨域的解决方案\n### 3.1 JSONP跨域\njsonp的原理就是利用<script\\>标签没有跨域限制，通过<script\\>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。\n\n**缺点：jsonp的缺点：只能发送get一种请求。**\n\n```js\n// 前端\n <script>\n    var script = document.createElement('script');\n    script.type = 'text/javascript';\n\n    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数\n    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';\n    document.head.appendChild(script);\n\n    // 回调执行函数\n    function handleCallback(res) {\n        alert(JSON.stringify(res));\n    }\n </script>\n\n// nodejs 服务端\nvar querystring = require('querystring');\nvar http = require('http');\nvar server = http.createServer();\n\nserver.on('request', function(req, res) {\n    var params = querystring.parse(req.url.split('?')[1]);\n    var fn = params.callback;\n\n    // jsonp返回设置\n    res.writeHead(200, { 'Content-Type': 'text/javascript' });\n    res.write(fn + '(' + JSON.stringify(params) + ')');\n\n    res.end();\n});\n\nserver.listen('8080');\nconsole.log('Server is running at port 8080...');\n```\n\n### 3.2 跨域资源共享（CORS）\n CORS是一个W3C标准，全称是\"跨域资源共享\"（Cross-origin resource sharing）。\n它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。\nCORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。\n\n浏览器将CORS跨域请求分为简单请求和非简单请求。\n\n**A、只要同时满足一下两个条件，就属于简单请求：**\n\n1. 使用下列方法之一：head、get、post\n2. 请求的Heder是: \n   1. Accept\n   2. Accept-Language\n   3. Content-Language\n   4. Content-Type: 只限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain\n\n\n对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。\n\n\n**B、复杂请求：**\n非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求（preflight）。\n\n**预检请求**\n\n 预检\"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。请求头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，\"预检\"请求的头信息包括两个特殊字段。\n\n  1）Access-Control-Request-Method：必选\n\n  2）Access-Control-Request-Headers：可选\n\n\n### 3.3 nginx代理跨域  \nnginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin等字段。\n\n1）nginx配置解决iconfont跨域\n  \n  浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。\n\n2）nginx反向代理接口跨域\n\n### 3.4 nodejs中间件代理跨域\n\n### 3.5 document.domain + iframe跨域\n**此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。**\n\n```js\n// 父窗口\n<iframe id=\"iframe\" src=\"http://child.domain.com/b.html\"></iframe>\n<script>\n    document.domain = 'domain.com';\n    var user = 'admin';\n</script>\n\n\n// 子窗口\n<script>\n    document.domain = 'domain.com';\n    // 获取父窗口中变量\n    console.log('get js data from parent ---> ' + window.parent.user);\n</script>\n\n```\n\n### 3.6 postMessage跨域\n postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：\n\n1. 页面和其打开的新窗口的数据传递\n2. 多窗口之间消息传递\n3. 页面与嵌套的iframe消息传递\n\n```js\n// a.html (www.domain1.com/a.html)\n<iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"></iframe>\n<script>       \n    var iframe = document.getElementById('iframe');\n    iframe.onload = function() {\n        var data = {\n            name: 'aym'\n        };\n        // 向domain2传送跨域数据\n        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');\n    };\n\n    // 接受domain2返回数据\n    window.addEventListener('message', function(e) {\n        alert('data from domain2 ---> ' + e.data);\n    }, false);\n</script>\n\n\n// b.html (www.domain2.com/b.html)\n<script>\n    // 接收domain1的数据\n    window.addEventListener('message', function(e) {\n        alert('data from domain1 ---> ' + e.data);\n\n        var data = JSON.parse(e.data);\n        if (data) {\n            data.number = 16;\n\n            // 处理后再发回domain1\n            window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');\n        }\n    }, false);\n</script>\n```\n\n<br >\n[参考文档](https://juejin.cn/post/6844903882083024910)","tags":["cors","跨站资源共享","前端跨域"]},{"title":"重复工作如何提升个人价值","url":"/2023/10/11/重复工作如何提升个人价值/","content":"\n## 背景\n思考问题： 如何在已经比较熟悉的工作领域挖掘成长空间，持续发展不停滞，保持自己的竞争力？\n\n**文章背景**\n\n1. 随着互联网行业的逐步成熟， 0-1的新技术的突破工作很少， 1-100应用实践才是工作日常\n2. 新技术（大模型、区块链）虽被看好，但没大规模普及到日常工作中\n3. 企业降本增效的大环境，大部分工作都是业务需求，大部分是通过工程能力实现功能，亦或通过架构优化提升非功能性技术指标\n\n## 重复性工作定义\n既然要讨论重复性工作中如何培养匠心，我们先看看什么样的工作无法培养匠心。\n\n举个例子，**烹饪和泡方便面**。\n\n为什么泡方便面没有培养匠心的空间呢？我们从几点分别看一下。\n\n一、**从需求看结果：选择泡面时，通常是为了快速饱腹，满足基本的味道要求即可**，极少有人会从泡面中追求额外的美食享受。**即，泡面的结果价值空间不大。**\n\n二、**从过程看：泡面过程对泡面最终味道评价影响不大，**泡面的原料、配比、味道以及形态，都是在泡面生产过程中就已经固化为最终产品属性。**即，泡面过程对价值的贡献度较低。**\n\n三、**从可预测性看：泡面自身的设计就是以简化过程，**减少过程对结果的影响为目标，这是速食食品的普遍特点。在泡面过程中虽然可以调控水温、时长、调料用量，但每个调整动作确定后，对结果的影响基本也就被确定了。**即，结果的可预测性很高。**\n\n综上，不论重复泡多少次方便面，都无法培养泡面执行人的匠心。\n\n从泡面的例子可以总结为三个指标的公式：** 业务对个人能力提升判断 =（结果价值空间*过程对价值的贡献度）/ 可预测性。**\n\n一、结果价值空间高，可以是烹饪场景下的大业务量，正向盈利情况。比如连锁饭店、高档饭店。\n\n二、过程对价值的贡献度高，如稀有食材需要特殊处理方法，高难度菜品对刀功、烹调手法有高要求。\n\n三、可预测性低，即可能性多。同样的菜品，通过不同厨师的烹饪，表现可以截然不同，哪怕是炒土豆丝，即使在同一个厨师手上，也未必味道稳定如一。同样，因为菜品本身就有低预测性的特点，所以大众点评的推荐才会体现价值。\n\n以上三条，至少要有一条命中，就有匠心的空间。三条都命中，就有机会培养极致的匠心。所以顶级厨师的画像通常是：大饭店、会做难度超高的菜品，并且还会持续创新优化（降低自己的可预测性）。\n\n**对标到技术工作中：**\n\n一、价值空间高：通常是大流量业务、高盈利业务、主营业务或战略业务。（战略价值也是很高的价值）。\n\n二、过程对价值的贡献度高：如大模型技术在对话类业务上带来的极致体验，如双十一高并发能力对GMV的支撑度。\n\n三、可预测性低：如搜索推荐算法对流量效果的影响，如营销活动对转化率的贡献，都具有不确定性特点。或许有人会问，算法有效果的不确定性，那么工程的预测性是不是注定就很高？也不是。工程能力如果成功实现，结果是确定的，但要看到，工程能力在成功和失败之间，仍然有bug、宕机带来的不确定性，并且可能会是致命性的失败。所以工程能力的价值通常更多体现在大流量高并发业务中，也是因为大流量场景相比小流量场景，系统能力的可预测性变低了。所以为什么文案/图标展示类功能的重复性不能带来增值，也是因为这种功能实现的可预测性太高了（太容易成功了）。\n\n## 重复性工作如何提升技术\n\n### 提升技术路径分析\n\n**如果我既不在主营业务，业务现在也不需要创新性技术，日常只是做些小功能需求，我已经做的非常熟练了，那么我的成长空间还有吗？还能培养技术的匠心吗？**\n\n一、首先，看业务结果的价值空间：业务上有多少类型的功能？要求什么样的技术栈？性能表现怎样？是否有过系统架构重构？每个业务都对技术有着天然的要求，首先看看自己是否都参与或负责过不同类型的技术工作，即是否充分挖掘了业务提供给你的全部价值空间。\n\n二、其次，尽可能提升过程对结果的贡献度，不要把技术工作做成简单的承接需求，而是理解洞察业务模式、发展阶段，从而理解业务需求背后的整体逻辑，把非显式的需求，通过更优的技术方案进行实现，比如有时要快速高频迭代，有时要极致的交互体验，有时要通过架构降低资源成本，以及任何时刻都要尽可能考虑未来架构扩展。虽然只要掌握一种技术方案就可以承接需求，但更好的做法是掌握多种技术方案，并有策略的选择当下最优的方式。\n\n三、最后，是结果的可预测性。同一个人做不同项目时，他的成功概率是稳定的吗？不同人做同一个项目，完成结果差异大吗？通过这些问题分析可预测性，折算出我们所能获得的机会。说人话就是这个工作是否足够难、足够复杂，以至于工作结果并不能稳定交付？反过来的例子就好理解了：能稳定交付的工作我们通常会逐步交给资历浅一些的同学，标准化程度足够高的，也可以交给外包。俗话说富贵险中求，不能保证成功的项目，更能培养人。\n\n\n用上述三个角度分析我们现在的工作内容，会得出一个很鸡汤的结论：**在现有的工作内容上，我们总可以挖的再深一些。从完成到优秀、从卓越到举一反三、从稳定交付到创新优化，每个工作内容都有着潜在的价值空间，都可以培养我们的匠心。**\n\n那么为什么现实并不是这种（空间大，机会多）感觉呢？因为还有一个隐藏指标在起作用：成本。我们花费的成本是我们宝贵的时间，用熟悉的方式解决问题，还是用创新的方式解决问题，虽然后者可以提升过程贡献度，也可能提升结果价值空间，但学习并应用一种新方式，要付出更多的时间精力成本。在快节奏业务压力下，潜意识就会选择成本更低的方式，特别是项目倒排下，我们不得不选择成本优先。\n\n\n### 具体提升技术的路径\n\n1、结果价值空间：除了常规意义的项目结果外，这个变量可以扩展出更多结果的定义。比如完成项目之外，写了文档，总结了方法论，沉淀了某个组件，做了一次分享，这些动作都增加了结果的定义，从而扩展了结果价值空间。简称：一举多得。\n\n2、过程对价值的贡献度：重新定义价值后，过程对价值的贡献度自然也就变化了。如果结果价值包括了写一篇文章，那么文章怎么写，写成什么样，就可以有很多不同的方法，随之产生不同的贡献度。简称：八仙过海各显神通。\n\n3、结果的可预测性：首先，通过扩展”结果”到多维度定义，已经联动的降低了结果的可预测性。而对单一结果而言，影响这个变量需要面对更多挑战。\n\n分为两个角度思考：\n1. 自己和别人比，组织会通过标准化、体系化、规范化让大家都掌握成功的确定性路径，在这个过程中，如果我们不主动求新求变，就会泯然众人。\n2. 自己和自己比，我们通常想要消除失败的概率，但如果我们不能同时扩展成功的多种可能性时，结果的可预测性会坍缩在稳定的“一般性”成功上，说人话就是：当你能够稳稳的成功时，如果成功的方式一成不变，那别人对你做这项工作也就没什么新的期待了。超出他人的预期，潜台词就是不要让别人预判到你会以什么样的姿势成功。简称：出其不意、出类拔萃、出奇制胜、出神入化、出人头地。\n\n\n\n\n<br>\n[文档来源于](https://mp.weixin.qq.com/s/nG51m27twdv43FAiFSlQSA)","tags":["个人成长","重复性工作保持自己竞争力","挖掘成长空间"]},{"title":"思考, 快与慢","url":"/2023/04/17/思考-快与慢/","content":"\n### 1、快思考和慢思考\n#### 1.1 概览\n\n**a、快思考（系统一）：是无意识且快速的，不怎么费脑力，没有感觉，完全处于自主控制状态。例如：回答2+2**\n\n快思考的运行是无意识且快速的，不怎么费脑力，没有感觉，完全处于自主控制状态。\n\n\n**b、慢思考（系统二）：是将注意力转移到需要费脑力的大脑活动上来，例如复杂的运算、文章中某页出现a的次数。慢思考的运行通常与行为、选择和专注等主观体验相关联。**\n\n慢思考的运作是高度多样化的，但所有这些运作方式都有一个共同特征：所有运作都需要集中注意力，如若注意力分散，运作也会随之中断\n\n\n#### 1.2 一张愤怒的脸和一道乘法题\n\n##### 1.2.1 系统一遇到麻烦，系统二会出面解决\n\n系统2在系统1无法提供问题答案时，就会被激活，这好比你碰到了“17×24”这样的乘法题，系统1无法给出答案，系统2便被激活来解决问题。当你遇到令人吃惊的事情时，同样会感到自己有意识的那部分注意力会瞬间激增。另外，在系统1所设定的世界里，电灯不会跳，猫不会像狗一样汪汪叫，“猩猩”也不会穿过篮球场。如若事物违反了系统1所设定的关于世界的模式，系统2同样会被激活。\n\n系统1和系统2的分工是非常高效的：代价最小，效果最好。通常情况下，这种分工很有效，因为系统1很善于完成自己的本职工作：它在熟悉情境中采取的模式是精确的，所作出的短期预测是准确的，遇到挑战时做出的第一反应也是迅速且基本恰当的。然而，系统1存在成见，在很多特定的情况下，这一系统易犯系统性错误。你会发现这个系统有时候会将原本较难的问题作简单化处理，对于逻辑学和统计学问题，它几乎一无所知。系统1还有一个更大的局限，即我们无法关闭它。\n\n\n##### 1.2.2 冲突与自我控制\n\n自主反应和控制这种反应的意图之间存在冲突，这种冲突在生活中极为普遍。我们差不多都有过这样的经历：在餐厅里，自己的邻座是一对穿着怪异的夫妻，但我们会尽量不去盯着他们看。我们也清楚，如果看书时老是重读不知所云的内容，这就说明我们在强迫自己去读一本无聊的书。在冬季严寒的地区，许多司机都有着这样的记忆：当他们的车在冰上滑行失去控制时，他们必须放弃平时的做法，竭力去按照已反复演练过的指示进行操作：“如果车打滑，做什么都行，就是别踩刹车！”另外，每一个人都有强忍着不诅咒别人去死的经历。系统2的众多任务中就包括抑制系统1产生的这些冲动。换句话说，系统2负责人们的自我控制。\n\n\n##### 1.2.3 看上去不等于实际上等长的两条线\n\n<img src=\"/img/think1.jpg\" style=\"max-width:95%\" />\n\n这幅图没有什么特别之处：两条不同长度的水平线，两端有朝向不同方向的箭头，并且下面一条线明显比上面那条线长。这是我们看到的所有内容，而且我们肯定相信自己的眼睛。但是，如果你曾经见过这幅图，就会认出这便是那幅著名的缪勒–莱耶错觉图，要证实这一错觉很简单，只需要找把尺子量一量，你就会发现其实两条水平线是等长的。\n\n\n提到认知错觉，最常被问及的问题就是能否避免这种错觉。上述各例传达的信息不容乐观。因为系统1是自主运行的，我们无法随意使其停止，因此直观思维所导致的错误常常难以避免。\n\n作为一种生活方式，时刻保持警觉性并不是一件好事，想要这样做也并不实际。总是质疑自己的想法会使我们的生活非常枯燥乏味，因为系统2在代替系统1进行日常抉择时总是耗时很长且非常低效。最好的解决办法就是妥协：学会区别常会出现重大错误的情境，在风险很高的时候，尽力避免这些错误。前文中曾提到过，发现别人的错误总比发现自己的错误更容易。\n\n\n> 这是你系统1的想法，放慢速度，听听系统2的看法吧\n\n#### 1.3 电影的主角和配角\n虽说不太可能，但假设本书真的被拍成电影的话，自视为主角的系统2一定只能做个配角。在这个故事中，系统2的典型特征表现在其各项活动都需要努力，但其自身却很懒惰，除了必需的努力外，它不愿多付出，哪怕是一点点。因此，虽然系统2认为是自己选择了人们的想法和行为，可实际上，这些选择都是在系统1的引导下完成的，系统1才是这个故事的真正主角。然而，一些至关重要的任务却只有系统2才能执行，因为这些任务需要付出努力和控制自我，由此方可抑制系统1产生的直觉和冲动。\n\n**瞳孔是衡量与思维活动形影不离的生理刺激的标尺，我们可以通过瞳孔了解大脑的运行状况。**\n\n**如果达成同一个目标的方法有多种，人们往往会选择最简单的那一种。在经济行为中，付出就是成本，学习技能是为了追求利益和成本的平衡。因为懒惰是人类的本性。**\n\n#### 1.4 惰性思维与延迟满足的矛盾\n不断转换任务和提高大脑运转速度从本质上说是不会让人感到快乐的，人们总是尽可能避开这种情况，这就说明了为什么最省力法则能成为法则。\n\n人们也能花很长时间和大量精力进行一项工作。心理学家米哈里·契克森米哈(Mihaly Csikszentmihalyi)对这种无须作出努力的状态的研究比别人都多，他将这种状态命名为心流，而且此名称已成为一个心理学术语了。体验过心流的人将其描述为“一种将大脑注意力毫不费力地集中起来的状态，这种状态可以使人忘却时间的概念，忘掉自己，也忘掉自身问题”，他们对这种状态所带来的愉悦感的描述非常吸引人，米哈里称之为“最优体验”。很多活动都能带来心流体验，不论是画画还是摩托车比赛。我认识几个作者，出书就是他们的最优体验。对于一个作者而言，这样容易满足是件幸事。心流巧妙地区分了两种努力形式：对任务的关注和对注意力的严格控制。\n\n**自我控制需要集中注意力，需要付出努力。换种说法就是，控制思想和行为是系统2（慢思考）的任务之一。**\n\n##### 1.4.1 脱口而出的错误答案\n所有的玫瑰都是花。\n\n有些花会很快凋谢。\n\n因此，有些玫瑰也会很快凋谢。\n\n大部分大学生觉得这个推论是合理的。但事实上，这个论证是有问题的，因为玫瑰可能不会很快凋谢。\n\n**这个实验使我们对在日常生活中做出的推论丧失了信心。这个实验使我们认为，当人们相信某个结论是正确的时候，他们很可能会相信支持这个结论的论证，哪怕这些论证不正确。**\n\n避免思维上懒惰的人可以被叫做“勤快人”。他们更机警，思维更活跃，不会满足于貌似正确的答案，对自己的直觉也常持怀疑态度。心理学家基思·斯坦诺维奇认为他们更理性。\n\n##### 1.4.2 今天得到1000美元，1年后得到10000美元，你选哪个？\n研究人员通过一面单面镜观察这些孩子，他们等待期间的行为总会使观察者大笑。有些孩子成功地经受住了15分钟的考验，其成功原因是他们能把注意力从诱人的奖励上移开。10年或15年之后，那些忍住了诱惑和没忍住诱惑的孩子之间会出现很大差别。忍住了诱惑的孩子在认知任务——尤其是高效地重新分配注意力方面的控制力更强。当他们还年轻时，他们染上毒品的可能性更小。智力水平的巨大区别也随之出现：在4岁时表现出更强的自我控制能力的孩子在智力测验中得到了更高的分数。\n\n测试者发现，注意力训练不仅提升了这些孩子的执行控制能力，而且他们在智力测验中的笔试成绩也提高了，并且这种提升的状态可以维持几个月不变。\n\n他还对这项测试中得分很低的那些学生的特点进行了跟踪研究，发现他们更倾向于用脑海中最先出现的想法来回答问题，而不愿意费事去验证自己的直觉。这些人身上的系统2的监测功能往往较弱。那些遇到各种难题都跟着直觉走的人也易于接受系统1的其他暗示，特别是在冲动、不耐烦以及急功近利的时候，这些人就更易接受系统1的各种暗示了。\n\n我们这场心理剧中的两个角色有着不同的“人格”。系统1是冲动、凭直觉的；而系统2则具备推理能力，它很谨慎，但对一些人而言，这个系统也是懒惰的。我们从不同人的不同特点中发现了相关性：有些人倾向于系统2，而有些人则更接近于系统1。这个简单的测试可以较好地反映出惰性思考的特点。\n\n**高智商并不能消除成见。要想消除成见，还需具备另一种能力，他称其为理性。**\n\n\n> 不幸的是，她总是喜欢凭直觉随口就说，也许连表达感谢都词不达意吧，弱弱的系统2啊\n\n#### 1.5 联想神奇力量\n苏格兰哲学家大卫·休谟(David Hume)将联想的原则缩减为三个：相似性、时空相接以及因果关系。自休谟时代以后，我们对联想的定义发生了巨大变化，但他的三原则仍可作为定义所有联想的基础。\n\n你的行为和感情有时会受制于你自己甚至都没有意识到的事件,那些以老年为主题造句子的年轻人比其他人走得要慢得多。\n\n当人们看到一些教室和学校储物柜的照片时，他们往往也倾向于支持关于教育的提案。\n\n那些点头（表示同意的动作）的受试者往往易于接受他们听到的信息，而那些摇头的受试者则易于否定那些信息。要强调的是，受试者并没有意识到上述问题，他们只是习惯性地将否定或接受的态度与其常用的身体语言联系起来而已。**由此可见，老话讲“不管你怎么想的，都得心平气和”，这真是条很好的建议，只有真正做到心平气和，你才可能有回报。**\n\n我们所处的文化环境中有很多能让人想起钱的事物，这些事物以我们意识不到的方式影响着我们的行为和态度。\n\n在一个专制国家中，到处挂着领袖的肖像不仅能向你传达“老大哥在看着你”的感觉，还会使你逐渐丧失自主的思想和独立的行为能力。\n\n#### 1.6 你的直觉有可能只是错觉\n\n认知放松的原因和结果，如下图：\n\n<img src=\"/img/think2.jpg\" style=\"max-width:95%\" />\n\n如果一个句子印刷清晰，或是被多次重复，或是已经深植于脑海，人们就能在认知放松的状态下顺畅地将其解读出来。听别人说话时，如果心情好，或者咬一支笔迫使自己“笑”，都能使认知放松。反之，若说明书印刷模糊，颜色浅，句子冗长，语言晦涩，也许心情也不好，甚至在皱眉，这些情形都会使人处于认知紧张状态。\n\n##### 1.6.1 由记忆造成的错觉\n错觉这个词会让人马上联想到视错觉，因为我们都很熟悉那些令人产生误解的图片。不过，并不是只有视觉才会产生错觉，记忆也容易产生错觉，并且这种现象更加普遍。\n\n当你指认一个早已见过的词语时，会感到更加放松。正是这种放松使你产生了那种熟悉的感觉（记忆错觉）。\n\n##### 1.6.2 什么样的信息更容易让人信服\n**想让人们相信谬误有个可靠的方法，那就是不断重复，因为人们很难对熟悉感和真相加以区别。**\n\n如果你很在意自己在别人眼里是否值得信赖、是否聪明睿智，那么说话时就言简意赅吧，能用简单句的时候就别用复杂句。\n\n在一篇名为“不切实际地运用华丽辞藻的后果：使用长句毫无必要”的文章中，他指出用浮夸的语言来表达熟悉的概念是一种智商低下、可信度差的表现。\n\n例如：水滴石穿，绳锯木断； 亡羊补牢，为时不晚。\n\n**系统2是非常懒惰的，它不愿付出努力。如果可能的话，消息的接收方会离所有需要付出精力的事物远远的，包括名字复杂的信息源。在大多数情况下，系统2都会采纳系统1的建议，并继续运作。**\n\n##### 1.6.3 股票代码上口，回报率也相对较高\n当系统2参与到那些需要努力的事情中时，我们就会感到认知紧张。另一方面，无论是什么原因引起的认知紧张都有可能将系统2调动起来，改变人们处理问题的方式，使他们不再随意且凭直觉做事，而是转向更加专注的分析性思维。\n\n研究人员召集了40名普林斯顿大学的学生来做这个认知反应测试，其中有一半问卷使用的是浅灰色的小字。拿到这部分问卷的学生可以辨认出上面是些什么字，但这样的字体会导致他们认知紧张。测试结果清楚地表明：当问卷上的字体清晰时，90%的学生至少会犯一个错误；但当字体勉强能够辨认时，他们的错误率却降到了35%。是的，你没有看错：字体模糊不清时，学生的表现更好。**这是因为，无论认知紧张是由什么原因造成的，它都更有可能激发系统2来抑制系统1所给出的直觉性答案。**\n\n曝光效应并不依赖对熟悉程度有意识的体验，事实上，曝光效应完全脱离了意识：当重复的单词或图片迅速闪过，快到观察者根本没有意识到看见它们时，观察者同样还是更为喜欢重复率高的单词或图片。现在我们应该清楚的是，系统1能对系统2意识不到的那些事的印象做出回应。事实上，当人们完全没有意识到自己看见了刺激物时，其曝光效应会更强。\n\n##### 1.6.4 创新是发生在能让人联想无限的环境中的\n一个更引人注目的结果是，心情不好的受试者完全无法准确地完成这个直觉性任务，他们的猜测还没有随便选择的准确率高。心情显然能够影响系统1的运行：**当我们不舒服和不开心时，就会丧失自己的直觉。**\n\n**好心情使系统2放松对行为的控制：当人们心情好时，直觉和创造力会增强，但也会放松警惕，易犯逻辑性错误，这种关联与曝光效应一样，在生理上也讲得通。**好心情是事情进展顺利的信号，周围的环境是安全的，卸下防备并没有什么影响；坏心情则说明事情进展不那么顺利，有可能存在威胁，必须要保持警觉。认知放松与愉快的感觉互为因果。\n\n\n> **“熟悉了，就会喜欢，这就是一种曝光效应。”**\n\n> **“我今天心情很好，我的系统2也比平时懒惰，我得格外小心了。”**\n\n\n#### 1.7 意料之外和情理之中\n##### 1.7.1 从第一次的惊喜到第二次的习以为常\n系统1的主要功能是维护并更新你个人世界的模式，它呈现的都是常态下的思维模式。这个模式由许多联想和结果共同构成，这些联想由情境、事件、行为等概念引发，而结果则总是伴随某种规律出现，有可能是两者同时出现，也有可能出现时间只差那么一点点。\n\n**“摩西上方舟时，每种动物各带了多少？”发觉这个问题有问题的人太少了，因而有人将此称为“摩西错觉”。摩西并没有带动物上方舟，带动物上方舟的是诺亚**\n\n\n##### 1.7.2 简的钱包是怎么丢的呢？\n“弗雷德的父母来迟了，酒席承办商应该很快就到了，弗雷德很生气。”你知道为什么弗雷德会生气，也知道他生气不是因为酒席承办商还没来。在你的联想网络中，生气和不准时被看成是可能的因果关系，但生气和盼望酒席承办商来的想法却没有这种联系。在你读到这句话时，脑海中马上就形成了一个连贯的故事，你立即知道了弗雷德生气的原因。找到这种因果联系是理解一个故事的一部分，也是系统1的一种无意识行为。而系统2——也就是有意识的自我——在接收到这个主观理解后，也接受了这种因果关系。\n\n事实上，所有的标题都要满足我们对逻辑连贯的需求：一件大事必然会带来一些后果，而这些后果也需要一些原因对其作出解释。我们对那天发生的事情所知有限，于是系统1便熟练地将这些知识片段组合成一个连贯的因果关系。\n\n请读这个句子：\n\n在纽约拥挤的大街上逛了一天，欣赏完美景后，简发觉自己的钱包丢了。\n\n研究人员对读过这个句子的人（这些人同时也读过许多其他故事）进行了一次突击性的回想实验，发现这些读者认为“扒手”这个词比“景色”一词与该句子联系更紧密，尽管后者在句子中出现了而前者却没有。联想连贯性原则告诉我们实实在在发生的事情。丢钱包这件事可能有很多不同的原因：钱包从口袋里掉了出去，或者落在了餐厅等。但是，丢钱包、纽约以及拥挤的街道三种想法同时存在时，这些读者都把丢钱包的原因指向了扒手，因此整个故事看上去也是合理的。\n\n\n**示例 --- 常态和原因:**\n\n> 1、她接受不了自己只是运气不好这个解释，她需要一个有前因后果的解释，否则她会认为是有人在故意破坏她的工作。\n\n> 2、若最后发现第二个申请人也是我的一个老朋友，我就不会像看到第一个来申请的朋友那么惊讶了。只要情节稍有重复，一种新体验也就不那么新鲜了\n\n\n#### 1.8 字母‘B’ 与数字 ‘13’\n\n当我们对答案不确定时，系统1就根据过往经历去赌一个答案。这种下赌的规则是明智的：最近发生的事及当前情境是作抉择时最重要的因素。如果脑中没有闪现出任何最近发生的事，那更为遥远的记忆便会呈现出来。你最早、记忆最为深刻的经历一定是唱英文字母歌，这首歌的开头一定是“ABC”，而不是“A13 C”。\n\n\n有意识的怀疑需要同时在脑中记住多种互不相容的解释，需要付出努力，而这并不是系统1的长项。易变和怀疑是系统2的职责范围。\n\n\n##### 1.8.1 是什么让你相信了那些荒谬之词？\n联想记忆的运作是导致“确认偏误”的原因之一。如果有人问你：“山姆友好吗？”你就会想到山姆的各种行为举止；而如果有人问你：“山姆是不是很不友好？”你就很难想起他的许多举动。\n\n##### 1.8.2 光环效应与群体的智慧\n如果你赞同一个总统的政见，你可能也会喜爱他的声音及着装。喜爱（或讨厌）某个人就会喜爱（或讨厌）这个人的全部——包括你还没有观察到的方面——这种倾向就叫做光环效应。\n\n我们对一个人性格特征的观察顺序是随机的。然而，顺序的确很重要，因为光环效应注重第一印象，而后续信息在很大程度上都被消解掉了。\n\n企业高管需要花大量时间主持会议，独立判断原则（及解除错误关联）可以直接应用到这些工作中。一条简单的规则就能发挥作用：在开始讨论某个问题之前，先让与会的每一位成员各自写下简短的意见阐明自己的观点。这个过程很好地利用了小组里不同知识和见解的价值。而开放性讨论这一常规做法总会注重那些发言早而又强势的人的意见，使得其他人一味附和他们的观点。\n\n##### 1.8.3 眼见为实的想法往往让我们仓促作出决定\n\n只掌握一方证据的受试者比掌握了双方证据的受试者更有自信。这正说明人们根据已有信息勾勒出的故事的连贯性增强了他们的自信心。一个好故事最重要的是信息的前后一致性，而不是其完整性。的确，你常会发现：知道得很少反而可以把已知的所有事物都囊括进连贯的思维模式中。\n\n·框架效应：同一信息的不同表达方式常常会激发人们不同的情感。“手术后一个月内的存活率是90%”的说法要比“手术后一个月的死亡率是10%”更令人安心。同样，说凉菜“90%不含脂肪”要比说“10%含有脂肪”更具吸引力。很明显，前述每组句子的深层含义都是相同的，只是表达方式不同而已，但人们通常能读出不同的含义，而且觉得自己的所见就是事实。\n\n·比率忽略：回忆一下史蒂夫，那个本性怯懦、做事井井有条，常被看做图书管理员的人。这个人物性格的描述是生动形象的，尽管你清楚地知道男性农民比男性图书管理员多，但在考虑这个问题时，你总会忽略这个事实。你觉得自己的所见即为事实。\n\n**示例 --- 过早下结论:**\n\n> 1、她对这个人的管理技能一无所知。之所以对他印象很好，是因为曾经听他作过一次精彩的报告。\n\n> 2、在讨论之前大家先独自考虑一下这个问题，这样可以避免观点的相互干扰，这样更利于集思广益。\n\n> 3、他们并不想了解更多信息，因为那样可能会破坏整个故事情节。他们更愿意相信眼见即为事实。\n\n#### 1.9 我们究竟是如何作出判断的？\n系统2接受问题或提出问题：不管是提问还是回答，它都能引导注意力并搜寻记忆来找到答案。\n系统1以不同的方式运行，不断监视着大脑内外发生的一切，没有特定意图，也无须付出多少努力，只是对当时的情形作出全方位评估。\n\n\n**示例 --- 判断问题:**\n\n> 评价一个人是否有吸引力是一种基本判断，不管你是否想这样做，这种评价都是不由自主进行的，也会对你产生影响。\n\n\n#### 1.10 目标问题与启发性问题形影不离\n对一个人不是特别了解时，你就知道自己是不是喜欢他；你也不知道自己为什么会相信或者不相信一个陌生人；你没有作过调查分析，却能感觉到一家企业一定会成功。有时，对于一些无法完全弄懂的问题，你也总能作出答案，而回答的依据是什么，连你自己也说不清道不明。\n\n##### 1.10.1 找个相对简单的问题来作答\n对于有难度的问题，我们总是很难快速找到令人满意的答案，此时系统1就会找到一个相关问题来回答，这个问题比原来的问题更易作答。我把这种回答一个问题而绕开另一个问题的做法叫做“替代”。\n\n用一个问题替代原来的问题是一个解决难题的好策略， 请看下面的“目标问题”：\n\n<img src=\"/img/think3.jpg\" style=\"max-width:95%\" />\n\n\n##### 1.10.2 立体启发法：远处的物体看上去更高大\n\n你最近觉得幸福吗？你上个月有多少次约会？\n\n你上个月有多少次约会？你最近觉得幸福吗？\n\n这一次的结果完全不同。在这种顺序下，约会次数和幸福感之间的相关度能达到心理测试的最高水。\n\n有多次约会的学生想起了自己生活中快乐的事，而那些没有约会的学生想起的都是孤独和被拒绝的情节。\n\n##### 1.10.3 情感启发式：因为喜欢，所以认同\n一旦加入情感因素，结论对论证的主导作用便会最大程度地凸显出来。心理学家保罗·斯洛维克(Paul Slovic)提出了“情感启发式”的概念，认为人们的好恶决定了他们的世界观。你的政治倾向决定了你对各类论证的看法，即它们是令人信服的还是难以服众的。如果你对当前的医疗政策还满意，就会相信该政策能给自己带来很多好处，而且你相信在这个政策下，花同样的钱能做更多的事。\n\n到目前为止，我似乎已经将其描述成一个给系统1留有足够余地的默许监视器。我描述的系统2还具有主动搜寻记忆的功能、复杂计算功能、比较功能、规划功能和决策功能。在球拍和球的问题中以及许多其他的两个系统相互作用的例子中，系统2似乎总是处于最高决策地位，并有能力抵制系统1的建议，它能使事情放缓，开始进行逻辑分析。自我批评是系统2的功能之一。但在态度方面，系统2更像是系统1各种情感的赞许者而非批评者，也可以说是其各种情感的转让者而非实施者。它搜寻的信息和论据多半局限于与已有看法一致的信息，并不着意对其进行调查审核。积极且追求连贯的系统1为要求不高的系统2提供了各种解决方案。\n\n**系统1的特点:**\n\n自主且快速运行，只需付出较少努力，甚至不用付出努力，没有自主控制的感觉。\n\n夸大情感的一致性（光环效应）。\n\n将注意力集中在当前的证据上，忽略不存在的证据（眼见即为事实）\n\n真正去计算，而不是空想（思维的发散性）\n\n对损失的反应比获得更强烈（损失厌恶）。\n\n·严密设计决策问题，分别进行讨论。\n\n### 2、启发法和偏见\n#### 2.1 大数法则与小数定律\n根据定义，一个随机事件是不需要解释的，但一连串的随机事件就有规律可循。\n\n我们从一个令人费解的事实说起：肾癌的发病率在各县有所不同，且是有规律的，我用统计学理论对此作了解释：相比于大样本，极端的结果（高发病率和低发病率）更容易出现在小样本中。这样的解释不存在因果联系。某县的人口稀少既不会引发癌症，也不能避免癌症，只会使癌症的发病率比人口稠密地方的发病率更高（或更低）。这就是真相，没什么可解释的。\n\n*(1)大样本比小样本更精确。*\n\n*(2)小样本比大样本产生极端结果的概率大。*\n\n上述内容概括起来就是：没错，你知道大样本的结果更精确，但你现在可能才意识到你并不清楚为什么它们更精确。\n\n\n**小样本的出错风险可能高达50%**\n\n使用一个足够大的样本是降低这种风险的唯一方法。选择小样本的研究者只能看自己是不是能选对合适的样本了。\n\n**信任多于质疑的普遍性偏见**\n\n系统1在了解事实之前就根据零散的证据拼凑了一个饱满的形象。如果相信小数定律，急于下结论的机制就会运作起来。通常情况下，它会建构一个言之成理的说法使你相信自己的直觉判断。\n\n\n**对随机事件作出因果解释必然是错的**\n\n简单说来，如果你听从自己的直觉，就常常会因为把随机事件看做是有规律的事件而犯错。我们都非常愿意相信生活中大多数事情并不是随机的。\n\n\n**示例——小数定律:**\n\n观察的样本太小，所以不能作出任何推断。我们不要遵从小数定律\n\n在我们有足够大的样本之前，我计划对实验结果暂时保密。否则，我们会有过早下结论的风险。\n\n#### 2.2 锚定效应在生活中随处可见\n锚定效应。人们在对某一未知量的特殊价值进行评估之前，总会事先对这个量进行一番考量，此时锚定效应就会发生。\n\n如果有人问你甘地死时年龄是否大于114岁，你在估测他的死亡年龄时会比锚定问题是35岁（死亡）时更高。你在考量买房要花多少钱时，也会受到要价的影响。同样的房子，如果市场价格高，它就显得比市场价格低时更有价值，即使你决心抵制价格的影响也没有用。\n\n**a. 对锚定值的调整常常是不足的**\n从锚定的数字开始，然后估测它是过高还是过低，接着让大脑从锚定数值上“转移”并逐渐调整你的估值。\n\n为什么你在开车下了高速公路驶入城市街道时还会开那么快——如果是边聊天边开车，速度尤其容易快。调整不足就是对这一现象的最好解释。孩子在房间里喜欢把音乐开得很大声，父母却很恼火，两代人关系紧张，其原因也是调整不足。勒伯夫和沙菲尔注意到“家长要求孩子应将音乐调到‘适当’的音量，但听着特别大声音乐的孩子即使想这样做也难，还会认为家长忽视了他们真心作出的让步，这是因为他们无法从充分的高锚定值中调整过来”。这里提到的司机和孩子都有意地（将数值）向下调整，但两者都没有（将这个值）调整到位。\n\n**b. 暗示就是一种锚定效应**\n\n请回答：\n\n甘地去世时比144岁大还是小？\n\n甘地去世时多少岁？\n\n你是否会把144岁向下调整来得出自己的评估？也许不会，但这个大得离奇的数字仍然会影响你的估测。我的直觉告诉我，锚定就是一种暗示。如果有人只是提起某件事，而他的话却促使我们去看、去听或是去感受这件事，此时的情形就可以用锚定来形容。例如，“你的左腿现在是否微微麻木了”这个问题常会使相当多的人回答说他们的左腿确实感到有些异样。\n\n暗示即一种启动效应，它会有选择地找出相应的证据。你完全不会相信甘地活到了144岁，但你的联想机制却会对一位逝去的老人产生印象。\n\n\n**c. 作为这幢房子的主人，你能接受的最低售价是多少？**\n\n请回答：\n\n最高的那棵红杉树是高于1200英尺还是低于1200英尺？\n\n你认为那棵最高的红杉树有多高？\n\n不出所料，（关于那棵最高的红杉树有多高）两个组给出了完全不同的平均评估：844英尺和282英尺。两者的差距有562英尺。\n\n锚定效应在实验室中司空见惯，在现实世界中其影响同样毫不逊色。几年前的一个实验中，实验人员让一些房地产经纪人对一幢待售房子的价值进行评估。这些经纪人亲自去看了这所房子，还仔细研究了一本小册子，里面包括这幢房子的全面信息和售价。其中一半经纪人评估的售价比标价高很多，另一半评估的售价则比标价低很多。每位经纪人都给出了自己认为合理的售价，同时（假定自己是这幢房子的房主）她们还给出了自己能够接受的最低售价。实验人员随后问这些经纪人哪些因素影响了她们的决策。出乎意料的是，售价并非影响因素之一。这些经纪人十分得意，因为她们没有被这个因素所左右。她们坚称标价没有影响到她们对这一问题的回应，但实际上她们错了：锚定指数是41%。事实上，专业人士和对房地产一无所知的商学院学生一样，都受到了锚定效应的影响。后者的锚定指数是48%。\n\n没有提到锚定问题，这些对环境都很敏感的探索馆参观者会说他们愿意拿出的钱平均为64美元。当锚定金额只有5美元时，平均捐款则是20美元。当锚定金额达到400美元时，人们的捐款平均数就达到了143美元。\n\n*锚定效应在某些情形下看起来也是合理的。毕竟，那些被问到难题的人肯定会去抓住这根救命稻草的，况且这个锚定值也是根貌似合理的稻草。如果你对加利福尼亚的树所知无几，却又被问到红杉树是否高于1200英尺，此时你可能就会认为这个数字与真实数字相差不远。因为是那些知道这种树真实高度的人想出的这个问题，所以这个锚定值也许是个有价值的提示。 但是，锚定效应研究有一个重要发现，即锚定值显然是任意的，它也许和可能有信息价值的锚定值一样有效。*\n\n\n**d. 锚定效应何时适用，何时不适用？**\n\n第一次在集市上讨价还价也是这样，先发锚定有着重大的影响。我在教学生谈判时，给他们的建议是如果你认为是对方作出了无礼的提议，你就不应该提出同样无礼的提议，因为两者之间有距离的话会使此后的商谈难以进行。你应该大吵大闹，夺门而出，或者威胁对方说自己也会这样做，要让对方明白以这个数字为基准的话，谈判将难以继续。\n\n\n在讨论小数定律时我们发现，如果一则消息没有马上被视为谎言，那么不管其可靠性如何，它都会对联想系统产生同样的影响。这个消息的重点是故事，随便根据什么信息编造的都无所谓，即使这则消息的信息量很少，质量很差劲也无所谓，因为眼见即为事实。当你读到一个拯救受伤登山客的人的英勇故事时，这个故事对你的联想记忆产生的影响和一篇新闻报道或电影简介大体差不多。*锚定效应是由这个联想激发引起的。这个故事是否真实、是否可信一点都不重要。随机锚定的强大影响是锚定效应的极端例子，因为随机锚定显然没有提供什么信息。*\n\n**你不知道它是如何引导和限制你的思考的，因为你不能想象如果锚定改变（或不存在）你会如何思考。但是，你应该假设任何一个公开谈判时的数字都对你有锚定效应，如果概率大，你应该抵制（你的系统2）该效应。**\n\n**示例---锚定**\n\n> 被告律师提出一个微不足道的证明，证明中提到了一个荒谬的小损失，这些律师就是想让法官们拿这个损失做锚定。\n\n\n\n#### 2.3 科学地利用可得性启发法\n我们的项目中有一项是对“可得性启发法”进行研究。我们问自己，人们在想要估计某类事件的出现频率时到底是怎么做的，这些事件包括“人在60岁之后的离婚概率”或“（是否是）危险的植物”等。我们认为这种自问就是启发法。这些问题的答案很简单：**从记忆中搜寻这类问题的实例，如果搜寻过程既轻松又顺畅，这些事的发生概率就会被判断为很大。**\n\n##### 2.3.1 意识到自己的偏见有利于团队关系融洽\n与其他判断启发法一样，可得性启发法就是用一个问题替代另一个问题：**你希望估测某一范畴的大小或某一事件的（发生）频率，但你却会提到自己想到相关实例的轻松程度。**问题的替代必然会产生系统性错误。你会发现启发法是如何通过一个简单的过程导致偏见的，不直接说出（事件发生的）频率，而是列举那些使你轻松想起相关实例的因素，其中的每个因素都会成为偏见的潜在来源。\n\n* **你可以很轻松地回想起引起自己注意的突出事件。**好莱坞明星的离婚事件和政客的性丑闻事件格外引人注目，想到这些实例并不难。因此，你很容易夸大好莱坞离婚事件和政客性丑闻事件的频率。\n\n* **一个大事件会暂时提高此类事件的可得性。**飞机失事事件会有媒体来报道，这也会暂时改变你对飞行安全的看法，接着你又看到路旁有辆汽车着火了，于是这些事故会暂时盘踞在你的脑海中，你会觉得这个世界此时充满更多难以预料的事。\n\n* **亲身经历、生动的图片和鲜活的例子比发生在别人身上的事、单纯的文字或是统计数据更容易让人回想起来。**一个与你相关的判决错误会逐渐削弱你对司法体系的信任度，其影响程度比你在报纸上读到类似事件的影响更深。\n\n\n**有个很著名的可得性实验表明，意识到自己的偏见可以使夫妻和睦相处，而且很可能在其他的合作计划中与他人的关系也很融洽。 夫妻二人记自己的努力和贡献比记对方的清楚得多，而且可得性的不同导致了对频率判断的不同。**\n\n同样的偏见对常见的观察同样适用，很多合作团队成员感觉他们做的事超出了自己的分内工作，还感到其他人并不感激自己作出的贡献。 **任何情况下，每个人都该牢记这一点。你做的事情偶尔会超出自己的分内事，但你应该知道，当你有可能有这种感觉的时候，你的团队里的每个成员也都可能有同感。**\n\n\n\n##### 2.3.2 可得性偏见会影响我们对自己或他人的看法\n\n**自我评估是由事件呈现在脑海中的轻松度来衡量的。轻松地想起某件事的体验比想起事情的数量更重要。**\n\n想起新事例的困难增速远远超出了他们的预计。正是这种超出预期的低顺畅性使那些被要求列举12个事例的人将自己描述成优柔寡断之人。\n\n**各种各样的证据都指向统一结论，即那些跟着系统1走的人更容易受可得性偏见的影响，比那些警惕性更高的人受影响的程度更大。**\n\n**示例---可得性**\n\n> 因为上个月发生了两架飞机相撞事件，她现在更愿意坐火车。这真是愚蠢，风险其实并没有真正降低，这就是可得性偏见\n\n> 他应该看些统计数据。\n\n> 这位执行总裁连续多次成功，因此失败不会轻易在她的脑海中出现。可得性偏见使得她过于自信\n\n\n#### 2.4 焦虑情绪与风险政策的设计\n##### 2.4.1 被闪电击中与食物中毒，哪种意外致死率更高？\n对死亡原因的估测因媒体报道而有所改变。我们对事件发生频率的估测也会受到自己接触这些信息和频率与个人情感强烈程度等因素的影响。\n\n\n当人们更青睐于某项技术时，他们就会认为此项技术更有优势、风险更小；如果他们不喜欢某项技术，则只会想到其缺点和寥寥几个优点。\n\n\n##### 2.4.2 如何避免小概率的风险事件演变成公共危机？\n\n人类发明“风险”这个概念是为了帮助自己理解和应对生活中的危险和不确定情况。尽管这些危险是真实存在的，但却没有“真正风险”或“客观风险”这回事。\n\n我们的大脑解决小风险的能力有一个基本限度：我们要么完全忽视风险，要么过于重视风险，没有中间地带。每位等待晚归女儿的家长都能体验到这种感觉。你也许知道真的是（几乎是）没有什么可担心的，但你的大脑会不自觉地闪现危险的景象。正如斯洛维克所言，焦虑对伤害的可能性还不够敏感。你想到了分子（即你在新闻中看到的悲惨新闻），却没有想到分母。\n\n\n将效用层叠发挥到极致的人最有可能是那些恐怖分子。除了几次可怕的事件，比如“9.11”事件，恐怖袭击导致的死亡人数与其他死亡原因相比是非常小的。即使在恐怖活动猖獗的国家，比如以色列，每周的死亡人数也远不及交通事故死亡的人数多。\n\n\n政策制定者必须努力保护公众不受恐惧情绪的影响，而不是只保护其不受真实存在的危险的伤害。\n\n\n**示例---效用层叠**\n\n> 她对一项创意大为赞赏，说它收益大，无成本。我认为这就是种情绪启发式\n\n> 这是一个效用层叠的例子：被媒体和公众大肆宣扬的事还没发生，电视上就满是关于此事的报道，每个人都在谈论这件事。\n\n#### 2.5 猜一下，汤姆的专业是什么？\n汤姆是你们国家一所著名院校的研究生。请预测汤姆就读于以下9个专业的概率，并对专业进行排序。用1表示最有可能就读的专业，9表示最无可能的。\n\n工商管理\n\n计算机科学\n\n工程学\n\n人文与教育\n\n在这个问题中，人文与教育专业的基础比率指的就是这个专业的学生人数占全体学生总数的比率。在缺乏与汤姆相关的具体资料的情况下，你可能会根据基础比率进行猜测，相比计算机科学和图书馆学，汤姆更有可能被人文与教育专业录取，因为人文与教育专业的招生规模比另外两个专业的招生规模大。**在没有其他信息可供参考时，采取基础比率的方法最容易。**\n\n##### 2.5.1 依据典型性作出预测是下意识的行为\n\n尽管他比任何人都清楚基础比率在预测中的作用，但当他看到某个人的性格描述时，就会忽略掉这些比率。不出所料，他用对典型性的判断替代了对概率的评估。\n\n我们对相似性的判断可以完全不受基础比率的影响，不受可能会出现的不当描述的影响，但是在判断概率时，如果忽略基础比率和证据的可靠性的话，就注定会犯错误。\n\n**他学习成绩好不了，看那一身文身吧”，听到有人这样说时，他们一定是受到了典型性启发式的影响。如果我们通过某个下巴的轮廓或铿锵有力的演讲来判断这个职位候选人是否具有领导才能，此时我们依赖的就是典型性。**\n\n职业棒球球探在预测某个选手是否会成功时，他们大体上看的是球员的体格和相貌。这本书的主角是奥克兰“运动家棒球队”的经理比利·比恩(Billy Beane)。他作出了一个大家都不愿接受的决定：**否决球探们的建议，通过选手过去表现的统计数据来挑选球员。**“运动家棒球队”挑选出来的选手都以低会费入队，因为其他球队都因为没有想到用数据来判断，因而拒绝了这些选手。“运动家棒球队”很快就以低成本达成了最佳结果。\n\n##### 2.5.2 典型性启发的两宗罪\n用典型性来判断概率有一些重要的优点，它所带来的初始印象通常比乱猜一气更为精确。\n\n* 在大多数情况下，表现得很友好的人实际上也很友好。\n\n* 又高又瘦的职业运动员很有可能是打篮球的而不是踢足球的\n\n* 年轻的男性会比年老的女性更不要命地踩油门。\n\n**典型性的第一宗罪就是，它过于喜爱预测不可能发生的（低基础比率的）事件。**\n\n下面就是一个例子：如果你看见一个人在纽约地铁里阅读《纽约时报》，下面哪种情况与读报者更吻合？\n\n她有博士学位。\n\n她没有大学文凭。\n\n\n典型性会告诉你应该选有博士学位那位，但这样做并不一定是明智的。你应该充分考虑第二个选项，因为纽约地铁里更多的是没有大学文凭的人，而不是有博士学位的人。\n\n对于每一个人来说，汤姆读某个专业的概率就是那个专业招生规模的基础比率。然而，得知汤姆的个性特征后，人们再也不会将基础比率纳入考虑范围了。\n\n增强系统2的激活状态能有效提高回答汤姆问题的准确率。\n\n系统1引起了错误的直觉，系统2采纳了这个直觉，并将其运用在判断当中。然而，造成系统2犯下此类错误的原因有两个——忽视与懒惰\n\n\n**典型性的第二宗罪是它对证据质量不够敏感。**\n\n**当你怀疑信息的可靠性时，可以做一件事：作概率判断时，往基础比率那方面想。别期望遵循这条原则会很容易——它需要在付出很多努力的情况下，才能实现自我监督和自我控制。**\n\n\n想要得出汤姆问题的正确答案，你应该遵从最先出现在自己脑海中的想法，若认为某招生人数多的专业（人文与教育、社会科学与社会工作）被选中的概率高，则稍微降低其概率；若认为某招生人数少的专业（图书馆学、计算机科学）被选中的概率低，则稍微提高其概率。**如果你对汤姆一无所知，你作出的抉择就不是你的初衷了，你手头上的那点信息也不能相信了。所以，你应该让基础比率在预测时起主导作用。**\n\n##### 2.5.3 用贝叶斯定理来约束直觉\n你认为明天会下雨的概率只不过是你的臆测，你不应该相信头脑里出现的所有想法。你的信念必须受限于概率逻辑。所以，如果你相信明天某个时候会下雨的概率是40%，就该相信不会下雨的概率是60%，那么明天早晨下雨的概率就一定不会是50%。如果你相信某个候选人当选总统的概率是30%，并且相信他在首次竞选成功后再次当选的概率是80%，你就必须相信他连任的概率是24%。\n\n关于贝叶斯定理，有两点我们要铭记在心，要知道我们总是喜欢把事情搞得一团糟。**第一，基础比率十分重要，即便是在手头的案例已有证据的情况下依然如此；第二，通过分析证据得到的直观印象通常都会被夸大。**\n\n眼见即为事实与联想一致性的结合易使我们相信自己编纂的故事。以下是对贝叶斯定理关键点的总结：\n\n* 以相对合理的基础比率对结果的可能性作出判断。\n* 质疑你对证据的分析。\n\n\n**示例---典型性与基础比率**\n\n> 这家新成立的企业看起来好像不会倒闭，但是这个行业的成功基础比率非常之低。我们又怎么能知道这家企业就是个特例（一定能成功）呢？\n\n> 他们一直在重复犯同样的错误：用并不充分的证据来预测罕见的事件。当证据不充分时，我们应该以基础比率作为判断依据。\n\n> 我知道这份报告绝对是具有毁灭性意义的，也许它的证据十分确凿，但我们凭什么相信呢？我们必须在做计划时保持一定的怀疑态度才行。\n\n\n#### 2.6 琳达问题的社会效应\n##### 2.6.1 琳达不可能只是一名普通的银行出纳吧？\n我们的实验中最著名也最受争议的地方是设计了一位虚拟的女士，名叫琳达·阿莫斯和我拟造了琳达问题，用以说明启发式在判断中的作用以及它与逻辑相悖的地方。以下是我们对琳达的描述：\n\n琳达，31岁，单身，一位直率又聪明的女士，主修哲学。在学生时代，她就对歧视问题和社会公正问题较为关心，还参加了反核示威游行。\n\n\n下面两种情况哪种可能性更大？\n\n琳达是银行出纳。\n\n琳达是银行出纳，同时她还积极参与女权运动。\n\n通常，当人们没能运用明显相关的逻辑原则时，就会出现“谬误”。阿莫斯和我引入了“合取谬误”(conjunction fallaly)这个想法，通过直接比较，人们总会认为两个事件（在此即为银行出纳和女权主义者）的联合出现比只出现其中一件事（银行出纳）的可能性要大，此时就出现了合取谬误。\n\n\n\n请思考下列一组问题中的两个描述，并对其可能性作出评估。\n\n明年北美某地将有一次洪灾，1000多人将被淹死。\n\n明年加利福尼亚某时将有一次地震，此次地震将导致洪水，1000多人将被淹死。\n\n\n加利福尼亚地震的情节要比北美洪灾的情节更合乎情理，尽管加利福尼亚地震的概率非常小。**不出所料，人们对更详细、更丰富的描述作出的概率判断更高，这一点有违逻辑。预言家总会给其客户设下陷阱：对情节加以详述会使其更可信，却更不可能成为现实。**\n\n下面两个论述哪个可能性更大？\n\n简是位老师。\n\n简是位老师，她走路去上班。\n\n**这两个问题与琳达问题一样，有相同的逻辑结构，但它们却没有引起谬误，因为更详细的结果只是更详细而已，不会更让人信服，或更有连贯性，或更讲得通。对貌似合理和连贯性的评估不会产生概率问题的答案。在与之相矛盾的直觉缺位时，逻辑就会起作用。**\n\n\n##### 2.6.2 少即是多的逻辑悖论\n\n<img src=\"/img/think4.jpg\" style=\"max-width:95%\" />\n\n假设A、B两套餐具质量相当，那么哪套更值钱呢？这个问题很简单。你可以看到A套包括B套所有的餐具，另外还多出7件完好无损的餐具，所以A套“必然”更值钱。的确，综合评估组的受试者宁愿多花点钱买A套餐具也不愿买B套，A套标价为32美元，B家标价为30美元。\n\n**在单一评估组中则出现了完全相反的结果，其中B套标价（33美元）比A套（23美元）高很多，我们都知道为何会出现这一结果。用具组合（包括餐具）通过标准和原型展示出来，因为没有人想买破损的餐具，于是你立即感觉到A套组合的平均价值比B套组合的平均价值低。如果以平均价值引导估测，人们认为B套更值钱也就不足为奇了。奚恺元将这样的结果模式称为“少即是多”。从A套中拿走16件餐具（有7件是完好无损的），它的价值就会提升了。**\n\n\n\n如果你去法庭就会看到律师们往往采用两种批评风格：**要想推翻某个案件，他们往往会去质疑支持此案的最有力证据，他们会找准证词中最薄弱的地方，让目击证人变得不值得相信。**关注弱点在政治辩论中也很常见。我认为在科学争论中这是不恰当的。\n\n**示例：**\n\n> 他们构建了一个非常复杂的情节，还坚持说这个情节出现的可能性很大。这不是真的，这只是个貌似合理的故事而已\n\n> 对于贵重的产品他们还附赠一个便宜的小礼物，这样的话，整套产品就不那么吸引人了。少即是多就是这个意思。\n\n#### 2.7 因果关系比统计学信息更具说服力\n一辆出租车在夜晚肇事后逃逸。\n\n这座城市有两家出租车公司，其中一家公司的出租车是绿色的，另一家是蓝色的。\n\n你知道以下数据：\n\n·这座城市85%的出租车是绿色的，15%是蓝色的。\n\n·一位目击证人辨认出那辆肇事出租车是蓝色的。当晚，警察在出事地点对证人的证词进行了测试，得出的结论是：目击者在当时能够正确辨认出这两种颜色的概率是80%，错误的概率是20%。\n\n这场事故的出租车是蓝色而不是绿色的概率是多少？\n\n**这是“贝叶斯定理”的一个标准问题。我们可以从中得到两条信息：一个基础比率以及不完全可靠的目击者证词。若没有目击者，肇事出租车是蓝色的概率（即蓝色出租车的基础比率）为15%。若两家出租车公司规模一样大的话，基础比率就会变成无用信息，你就只需考虑目击者的证词，因而这个问题的概率就是80%。我们可以用贝叶斯定理将这两个信息源结合起来，得出正确答案是41%。然而，你可能会想到当人们面对这个问题时是怎样做的：他们会忽略基础比率，只考虑目击者的因素。因此，最普遍的答案是80%。**\n\n##### 2.7.1 因果关系基础比率与思维定式\n现在，请考虑一下上述问题的另一种表述方式，在这个表述中，只有基础比率发生了变化。\n\n·两家公司拥有数量相同的出租车，但是在出租车造成的事故中，绿色出租车占85%。\n\n·关于目击证人的信息与上例相同\n\n在第一个表述中，蓝色出租车的基础比率是关于这座城市出租车的统计学事实。大脑极其渴望找到其中的因果关系，但却一筹莫展：这座城市绿色和蓝色出租车的数量与出租车司机肇事后逃逸到底有什么因果关系呢？\n\n而在第二个表述中，开绿色出租车的司机比开蓝色出租车的司机肇事率高5倍。于是你会马上得出结论：**开绿色出租车的司机是一群莽撞的疯子！现在，你认为绿色出租车司机是莽撞的，并对这家公司所有你并不认识的司机都抱有这种印象，我们称之为思维定式。我们很容易将这样的思维定式设定在因果关系里，因为莽撞是使出租车司机与肇事逃逸产生因果联系的相关事实。**\n\n\n这个出租车的实例阐明了两种基础比率。**“统计学基础比率”(statistical base rates)是指某一事件所属类别的事实总量，与单独事件无关；而“因果关系基础比率”(causal base rates)则会改变你对单独事件的看法。对两种基础比率，人们往往会区别对待：**\n\n**·统计学基础比率普遍受到轻视，当人们手头有与该事件相关的具体信息时，有时还会完全忽略这一比率。**\n\n**·因果关系基础比率被视为个别事件的信息，人们很容易将这一比率与其他具体事件的信息结合起来考虑问题。**\n\n\n与因果关系相关的那个出租车问题存在一种思维定式：绿色出租车的司机是危险的。思维定式是指人们会（至少暂时会）将自己对某个团体的看法延伸到这个团体中每一个成员的身上（团体存在某些问题，其中的成员无一例外也都会有这些问题）\n\n有些思维定式的错误是致命的，负面的思维定式可能会产生可怕的后果，但这样的心理学事实无法避免：不管是对是错，思维定式都是我们对不同范畴事物的看法。\n\n我们认为应该将基础比率视为与整体相关的统计学事实，而不是与个人相关的假设性事实。**换句话说，我们反对利用因果关系基础比率。**\n\n##### 2.7.2 我们并没有自己想的那样乐于助人\n社会心理学家理查德·尼斯贝特(Richard Nisbett)和他的学生尤金·博吉达(Eugene Borgida)很早之前就在密歇根大学做了这个实验。他们向学生描述了前几年在纽约大学进行的那个著名的“帮助实验”。他们将实验受试者分别带入房间，并要求他们对着麦克风谈论自己的生活和烦恼。他们轮流叙述两分钟，每个房间的麦克风只有在受试者讲述时才会出声。每一组有6位受试者，其中一位是我们派去扮演受试者的工作人员。这位工作人员是第一个叙述的人，他是按照研究人员准备的稿子说的。他说他很难适应纽约的生活，并十分尴尬地承认自己很容易抽搐，在紧张的时候尤其如此。接着，所有受试者都依次叙述。当那位工作人员再次对着麦克风讲述时，他变得焦虑和不连贯，他说他感到一阵抽搐，希望有人能帮助他。他最后几句说的是“有没有人……能……救救我……（喘气声）我……我要……死了，我要……死了（气哽声，然后安静了下来）”。此时，下一位受试者的麦克风被自动打开，人们再也听不到那位有可能濒临死亡的人的动静了。\n\n你认为这个实验的其他受试者会做些什么呢？到现在为止，受试者知道他们中的一员癫痫发作并希望得到帮助，然而他们觉得可能已经有几个人冲出去并提供了帮助，所以自己可以安然地待在隔间中。实验结果是：15个受试者中，只有3个人立刻对请求做出了反应。6个人没有踏出过房间，另外5个人在“癫痫患者”明显气哽时才冲出房间。**这项实验说明当某人知道其他人也听到了同样的求救信息时，就会感到自己肩上的责任变小了。**\n\n**与从别人那儿听到令人惊奇的事实相比，你更有可能因为从自己的行为中发现惊人的事实而学到知识。**\n\n**示例---原因和数据**\n\n> 我们不能假设仅仅通过统计数据他们就能真正学到知识，需要再给他们一两个有代表性的个体案例来影响他们的系统1（作出判断）\n\n\n#### 2.8 所有表现都会回归平均值\n\n一般来说，只有学员的表现远远超出平均值时才能得到这位教练的表扬。但也许学员只是恰巧在那一次表现得很好，而后又变差，这与是否受到表扬毫无关系\n\n##### 2.8.1 第二次的表现与第一次并无因果联系\n**一般来说，人们会认为过度自信以及人们对其期望过高的压力造成了这些人表现不佳。**不过，这个诅咒可以用更简单的方式来解释：能够成为《体育画报》封面人物的运动员在前一赛季一定表现极为出色，也许这种出色的表现在很大程度上源于运气——运气是善变的，接下来他就没那么走运了。\n\n\n##### 2.8.2 回归现象的意义不亚于发现万有引力\n\n从这些实验可以看出，子代的高度和母本高度似乎并不相关，但似乎前者比后者更趋于平均。如果母本较高，那么子代就会变矮；如果母本较矮，则子代就会变高。实验显示，子代向平均值的回归与母本高矮的差异是成比例的。\n\n我们理解“回归”概念存在很多困难，这些困难皆源自两个系统——系统1和系统2。在相当数量的案例中，即便提供了一些统计数据，若无特殊说明，“相关”与“回归”的关系还是相当模糊的。因此，系统2认为理解这种关系很难。因为从某种程度上讲，**这是由于我们总是要求对事物进行因果关系解释，这也是系统1的一个特征。**\n\n如果给一群抑郁儿童喝了某种功能饮料的话，一段时间后，他们的病情会有很大的好转。如果抑郁儿童每天都花一段时间倒立，或是把一只猫抱在怀里20分钟，这些举动也可以使病情好转。多数读者读了这则新闻之后会不由自主地认为：喝功能饮料和抱猫的行为的确使抑郁儿童的病情得到了改善，但这个结论却无法得到证实。\n\n他们也犯过同样的错误——将相关性和因果性混淆在一起。**回归平均值是科学研究中的常见问题，有经验的科学家都会小心提防这种毫无缘由的因果推论所形成的陷阱。**\n\n读过本章，你就知道将每家店的销售额增加10%显然是不对的。**你应当使自己的预测具有回归性：对于业绩不好的店，预测增长率应高于10%；对于业绩较好的店，预测值应低于这个值（甚至是负值）**\n\n\n**示例---回归平均值**\n\n> 她说经验教会她一个道理，批评比赞扬更有用。不过她不明白这是回归平均值在发挥效用\n\n> 我们的筛选过程并不是很完美，所以我们会考虑回归性。有些极其优秀的候选人也会让我们失望，对此我们并不感到惊讶\n\n#### 2.9 如何让直觉性预测更恰当有效？\n有些预测判断，比如那些工程师所作的预测，**主要就是通过查找表格、精确计算以及对类似项目的结果进行仔细分析得来的。还有一些预测则需要直觉和系统1的共同参与，主要有两种类型。有些直觉主要依靠反复训练得来的技能和经验。**加里·克莱因在《力量的源泉》(Source of Power)一书中及其他场合曾提到过象棋高手、火场指挥员和内科医生所作的快速自动判断及选择，用以阐释这种经验性直觉，即由于识别出熟悉的线索，大脑中快速呈现出当前问题的解决方案。\n\n##### 2.9.1 偏离预测方向的直觉\n在以色列国防军队服役期间，很长时间我都待在一支部队里，这支部队通过一系列面试及实战测试来挑选后备实训军官。成功预测的特定标准为这些人在军官学校的最终成绩。这些等级评定的效度非常低（我会在后面的章节详细说明）。若干年后，这支部队仍旧存在，而彼时我已成为一名教授，并且正与阿莫斯合作研究直觉性判断问题。我一直与这支部队的工作人员保持着密切联系，于是便请他们帮个忙。除了他们通常使用的评估候选人的评分系统以外，我还让他们猜测每个学员将来在军官学校中可能得到的分数。他们搜集了几百份这样的预测。所有作出这些预测的军官都知道学校给学员评分时用的是字母评分系统，也知道所有学员得到的A、B、C各等级的近似比例。实验结果令人惊讶：预测出来的A和B的频率几乎与学校的结业成绩中的A、B等级的频率等同。\n\n这些发现提供了一个引人注目的例子，这个例子涉及替代和强度匹配两个方面。作出预测的军官完全将这两个任务混淆在一起了：\n\n· 他们平时的任务是对候选人在该部队的表现作出评价。\n\n· 我让他们执行的任务是对候选人的未来成绩作出切实预测。\n\n他们运用强度匹配将自己的评级简单地转换为军官学校的评分结果。由于无法解决预测中存在（相当大）的不确定性，他们的预测又一次完全无法回归（平均值）。\n\n\n\n##### 2.9.2 对直觉性预测的偏见进行修正\n**按照以下4个简单步骤来做，我们就可以进行无偏见预测：**\n\n1. 先估测出平均绩点的平均值。\n\n2. 根据你对证据的印象算出与之相匹配的平均绩点。\n\n3. 对你的证据和平均绩点的关联作出估计。\n\n4. 如果关联度是0.3，则从估算出的平均绩点的平均值中抽出30%，放到与之匹配的平均绩点里。\n\n步骤1为你提供了基准线，即在你除了知道朱莉是个快毕业的大学生之外什么也不知道的情况下，预测她的平均绩点。在没有信息的情况下，你很有可能预测其为一般水平。（这一点与你对汤姆的预测相似，在对他一无所知的情况下，你便将企业管理专业毕业生的基础比率放在了他的身上。）\n\n步骤2是你的直觉性预测，这个预测将你的估计和证据进行了匹配。\n\n步骤3使你离开基准线靠向自己的直觉，但你能离开的距离取决于你对关联性的估测。\n\n在步骤4中，尽管你最终作出的预测还是受到了直觉的影响，但是这个影响力已经小很多了。\n\n在你需要预测一个定量数值时，就可以运用这个方法，例如在预测平均绩点、投资效益、公司发展的业绩时，这个方法就可以派上用场。这个方法以你的直觉为基础，但是削弱了直觉的影响，使它回归到平均值上了。当你有充分的理由对自己的直觉性预测的准确性充满信心时，即证据和预测之间联系非常紧密，进行调整的余地就会很小。\n\n\n\n##### 2.9.3 两位教授候选人，应该选择哪一位？\n\n无偏见预测的一个特征就是，只有在信息非常有效时才允许人们对罕见或极端的事件作出预测。如果你期待自己作出恰当有效。\n\n如果信息量有限，你也无法预测到一个出色的高中生会成为普林斯顿大学的优等生；同理，一个风险资本家永远不会认为新创立的公司在起步阶段时成功的概率会“很高”。\n\n一个部门要雇用一位年轻的教授，他们希望这位教授未来的学术能力能够达到最高水平。该部门的调查委员会最后将候选人圈定为两个：\n\n* 金最近完成了毕业设计。她的推荐信中都是对她的溢美之词，而且面试时她说得也很好，给在场的每个人都留下了深刻的印象。不过她没有什么实质性的科研成果。\n\n* 简经过过去3年的学习取得了博士后头衔，学术成果颇丰，研究也做得非常出色，但她在面试时表现得不如金出色。\n\n我们直觉会选择金，因为她给人的印象更深刻，而且眼见即为事实。但与简的信息相比，金的相关信息则少很多。**我们可以回想一下小数原则。事实上，你从关于金的描述中得到的信息样本比简的要小，而且在小样本中更容易发现极端的结果。小样本的结果往往有更多的运气成分，因此在判断金将来的表现时，更应该回归平均值。若觉得金更有可能退步，最终你就会选择简，尽管你对她的印象并不深刻。**如果按照学术能力来选人，我会投给简一票，但我得先努力克服自己对金的直觉印象——金更有希望。跟着我们的直觉走比违背直觉感觉更自然、更亲切。\n\n\n\n**示例---直觉性预测**\n\n> 那家新成立的公司已经深入人心了，但我们不能指望他们将来也能做得这么好。他们的营销之路很长，回归的空间也很大\n\n> 我们的直觉性预测的确令人鼓舞，但这个预测可能离现实太远了，还是让我们再看看手中的信息资料，让预测回归到平均状态吧。\n\n> 我读过关于那个品牌的一篇评论，评价极高，然而这很可能只是侥幸成功。我们应该这样想：对这个品牌的评论很多，而我们看到的这个正巧是评价最高的。\n\n\n\n### 3、过渡自信与决策错误\n#### 3.1 \"知道\"的错觉\n此前讨论的光环效应是思维连贯性形成的部分原因，因为这一效应使我们更有可能将自己对某人所有品质的看法和对其特别重要特质的判断匹配起来。例如，如果觉得这位棒球投手又帅又强壮，那我们也很容易会认为他投球水平一定很高。光环效应也可能是负面的：如果觉得一位运动员很丑，我们就很可能会低估他的竞技能力。**光环效应通过夸大评估的一致性来保持简单和连贯的特点：好人只做好事，坏人全都很坏。** “希特勒喜欢狗和小鸡”这种说法，不论你听过多少次，无论如何都不会相信。因为根据光环效应，如此坏的人是不会有任何善意的，而这句话却违背了这一点。一致性使我们的想法有些固执，感觉模糊不定。\n\n光环效应还有最后一个阶段，即给该故事的主角戴上不可战胜的光环。\n\n运气的成分越多，从中能学到的就越少。\n\n##### 3.1.1 后见之明的社会成本\n**后见之明的偏见对决策者的评估行为有着恶劣影响，它导致观察者不是根据判断过程的合理性来评估一个判断的好坏，而是以结果的好坏作为判断标准。** 假设有一个低风险的外科手术，手术期间发生了一件始料未及的事故，病人因此死亡。事后，陪审团更倾向于相信手术本来就存在风险，而且主刀医生应该比其他人更清楚这一点。即使在制定决策时其想法是合理的，这一结果偏见也会使人们几乎不可能对他的决策作出正确评估。\n\n好的决策如果产生了坏的结果，我们就会责备那些决策制定者；而对那些只是在事后才能明确看出是正确的决策而言，其制定者也不会因此得到什么赞扬。这便是典型的“结果偏见”。\n\n很难在事后评论人们是否严格依照标准运作过程行事，因此那些希望自己的决定能经受住后见之明检测的决策制定者只好采用官僚的做派——极不情愿冒风险。由玩忽职守引起的起诉变得越来越常见，内科医生们以多种方式改变了自己的诊疗程序：要求患者作更多检查，请教专家更多病例，采用保守疗法，即使这些方法未必奏效也要用。这些行为与其说对病人有益，倒不如说是保护了医生，埋下了利益冲突的隐患。不断增强的责任可谓福祸参半。\n\n**尽管后见之明和结果偏见总会有滋生风险之嫌，却也会给那些不负责任的冒险者带来不应得的回馈，例如某位将军或企业家一次疯狂的冒险举动竟然成功了。那些一直很幸运的领导者不但从未因冒太大的风险而受到惩罚，相反，人们总会相信他们有很强的鉴别力和先见之明，能够预见成功；而那些曾经怀疑过他们的明智的人事后也会被视为平庸、胆小、懦弱之辈。几次幸运的冒险便会给一个不顾后果的领导人罩上耀眼的光环：极富远见、英勇果敢。**\n\n##### 3.1.2 真的存在能让企业基业长青的秘诀吗？\n身为瑞士一所商学院教授的菲利普·罗森茨威格(Philip Rosenzweig)曾写过一本书——《光环效应》(The Halo Effect)，该著作颇有见地。他在书中表明，**有两种类型的商业书籍很受欢迎，能够满足人们对虚幻确定性的需求。这两种类型包括：描写特别的个人和企业（常见的）成功与（偶尔）失败的历史；分析成功与比较成功企业之间的区别。他总结道，成功和失败的故事常会夸大领导风格和管理措施对公司业绩的影响，因此这些故事基本上都没什么用。**\n\n**明明是同一个人和同样的行为，在事情进展顺利时就是讲究方法，而事情进展不顺利时就成了死板，光环效应的影响的确太大了，因此你也许会发现自己对前述想法十分抵触。**由于光环效应，我们将因果关系抛到脑后：我们很容易相信公司的失败是因为其执行总裁僵化死板，而真实情况是其执行总裁之所以显得死板是因为这家公司正每况愈下。错觉就是这样产生的。\n\n**示例---后见之明**\n\n> 这个错误很明显，但这不过是后见之明，你事前根本无法知道。\n\n> 他从这则关于成功的故事中学到了太多，多得有些过头了，他现在已经陷入了叙事谬误的误区。\n\n> 我们不要带有结果偏见。尽管结果偏见有时也很管用，但这个决定是很愚蠢的。\n\n#### 3.2 未来是不可预测的\n\n##### 3.2.1 士兵测评的有效性错觉\n每次得到的结果几乎总是相同的：我们对这些士兵在军官学校的表现进行预测的能力弱到完全可以被忽略掉。我们的预测也就比凭空猜想强点，但也强不了多少。\n\n**其实我们知道自己的预测只比随意乱猜强一点，一般情况下都是这样，但我们仍然感觉自己所作的每一项预测都是有根据的，而且我们还会按照自己的预测行事。这让我想起了缪勒–莱耶错觉，我们都知道图中的线段是等长的，但一眼看过去仍然觉得它们长度不同。我对这种类推非常感兴趣，所以特意为我们的这种体验创造了一个术语：有效性的错觉。**\n\n对某个判断的主观自信并不是对这个判断正确概率的合理评估。自信是一种感觉，它能反映出某条信息和处理该信息时所体现的认知放松的一致性。**由衷地承认不确定性乃明智之举，但如果有人声称自信满满，只能说明他在脑海里已经构建了一个连贯的情节，当然这个情节未必是真实的。**\n\n##### 3.2.2 投资股票的技能错觉\n麦基尔的核心理念是，一只股票的价格包含了关于公司价值和对股票前景的最佳预测的所有信息。\n\n众多研究者有一个普遍认同的观点，那就是几乎所有炒股的人，**不管他们对股票是否了解（很少人了解股票），都在玩碰运气的游戏。**交易者的主观经验只不过是他们在很不确定的情况下作出的看似明智的猜测而已。然而在高效率的市场中，明智的猜测比瞎猜也准不了多少。\n\n\n##### 3.2.3 主观自信与专业文化为认知错觉提供了生存的土壤\n**认知错觉比视觉错觉更顽固。**缪勒–莱耶错觉虽然告诉你线段长度是相同的，但这没有改变你看线段的方式，却改变了你的行为。现在你知道不能相信自己对末端有箭头的线段长度的印象，而且你还知道在一般的缪勒–莱耶错觉中不能相信自己的眼睛。如果有人问起线段的长度，你会说出别人告诉你的长度，而不是你将看到的错误长度。与此相反，当我和同事们在以色列军队中得知领导能力评估实验的有效性很低时，我们很理智地接受了这一事实，但这并未影响我们的感觉及此后的行动\n\n##### 3.2.4 专家预测的准确度比不上扔飞镖的猴子\n知识最丰富的人反而常常不大可靠，原因是学到更多知识的人对自己的技能产生了一种无限放大的错觉，进而变得不切实际、过于自信。\n\n**本章的主要观点并不是说那些企图预测未来的人会犯很多错误，即使不说也是如此。我们应该了解的第一点是，预测错误不可避免，因为这个世界就是不可预知的；我们应该了解的第二点是，我们不应该相信高度主观的自信就是准确性的指示器（低度自信可能更有益处）。**\n\n**示例---有效性错觉与技能错觉**\n\n> 他知道这份记录表明这种疾病的变化几乎是不可预知的，他怎么会对这个病例表现得这么自信？听起来像是有效性错觉。\n\n> “是什么让他觉得自己比市场更聪明呢？是技能错觉吗？”\n\n> 问题不在于这些专家是否训练有素，而在于他们的世界是否是可预测的\n\n#### 3.3 直觉判断和公式运算， 孰优孰劣？\n##### 3.3.1 专家预测比不上简单运算准确\n\n这项研究得出了一个惊人的结论：要提升预测的准确度，最终的结果应由公式给出，在低效的情况下尤其如此。例如，在医学院的学生录取工作中，最终决定一般由面试候选人的老师来做。这一依据是片面的，但他们的推测也有可靠的证据：如果面试官也参与最终的录取工作，面试的过程很可能会降低选拔过程的准确性。这是因为面试官过于相信自己的直觉，他们会很重视个人的喜好而忽略很多其他信息，从而降低了有效性。同样，专家在评估新酒的价格时会品尝酒，这种信息的反面作用大于正面。当然，即使清楚天气对酒质的影响，专家们也无法保证公式那样的一致性。\n\n一个住院医生问阿普加医生如何对新生儿作系统评估。她回答道：“这很简单，你可以这样做。”阿普加快速写下了5个变量（心率、呼吸、反应、肌肉强度和颜色）以及3个分数（0、1、2分别代表各个变量的稳健度）。阿普加意识到自己可能会有所突破，而且这一突破还可能被应用到所有的产房中，她便开始用这种方法评估每一个出生一分钟的婴儿。一个得到8分以上的婴儿一般是肤色粉红、蠕动、啼哭、面部扭曲并拥有100次以上的脉搏，这样的婴儿外形很好。低于4分的婴儿一般是浑身青紫、肌肉松弛、不爱动且心跳微弱，这样的婴儿需要立即救治。**应用了阿普加的评分原则后，产房的护士们终于在判断婴儿情况是否危险的问题上有了一套标准，人们认为这个公式对减少婴儿的夭折率起到了很重要的作用。**\n\n\n##### 3.3.2 让许多业内人士烦恼的运算法\n\n对通过数理统计来作决定的厌恶情绪影响着人类，这种厌恶源于我们本身对自然事物的偏好以及对人工合成产物的否定。选苹果时，如果有人问我们喜欢有机的苹果还是商业种植的，大多数人都会倾向于“全天然”的那个。即使被告知两者的口味相同、营养相同而且同样卫生，很多人还是会选择有机水果。商人们甚至发现，标签上印有“全天然”或者“不添加防腐剂”时，销量就会增加。\n\n作重要决定时，对运算法的偏见就会被放大。米尔指出：“有些临床医师会因一个‘盲目的、机械化的’公式而耽误了可以治疗的病例，这是很可怕的，但我也没有什么好办法来缓和这种令人恐惧的情形。\n\n\n##### 3.3.3 “闭上眼睛”的直觉判断比主观判断更可取\n\n幸运的是，我读过保罗·米尔那本一年前出版发行的“小书”。我很相信书中的论证，认为简单的运算法优于临床的直觉判断。我总结出，当前的面试之所以失败，部分原因是它允许面试者按照个人的喜好作决定，这个决定会因面试者的心理活动而发生一些变动。相反，我们应该用限时的项目来获得受试者在正常环境下更具体的信息。我从米尔那里还学到了我们应该摒弃这种用面试者的整体评估来给新兵打分的方法。米尔的书中指出这种评估不值得相信，而运算法从分散的评价中得出的结果则更有价值。\n\n通过这些标准化的真实问题，我希望能够排除光环效应，排除人们喜好的第一印象对判断结果的影响。为了进一步预防各种光环的影响，我要求面试官依照固定的顺序去测试这6个特点，在测试下一个特点之前要对前一个特点按5分制打分。我告诉他们不要为新兵在部队的未来发展操心。他们唯一的工作就是找出与新兵的过去相关的信息并以此来给每一个特性打分。“你们的作用就是提供可靠的测定值，”我说，“处理预测有效性的工作让我来。”我这句话的意思是我要用公式来整合他们的具体得分。\n\n为了避免光环效应，你必须在一定时间内完成某一个特性的信息采集并对其打分，之后才能测试下一个。不要越过某个特性去测其他项目。评估每个候选者时，要将这6项评分累加起来。由于你要负责作出最终决定，那就不要“闭眼”测试了。即使你认为其他候选人更合适，也一定要雇用那个得分最高的人——请尽量克制自己创造“断腿”机会改变排位的想法。大量的研究可以向你保证：只要按照该过程操作，你就能找到最合适的人选。这比人们通常用的那些没有准备就开始面试，并依靠“我看到了他深邃的眼神，我喜欢自己看到的一切“这类主观判断要好得多。\n\n\n**示例---人工判断和公式运算**\n\n> 不管何时，只要公式能替代人工判断，我们至少应该考虑一下（运算法）。\n\n> 他认为自己的判断既缜密又微妙，但实际上把一些分数简单地整合在一起也许会更胜一筹。\n\n> 我们应该事先考虑清楚自己有多重视这些候选者以往的表现，否则，对他们的第一印象会对我们产生过多的影响。\n\n#### 3.4 什么时候可以相信专家的直觉？\n##### 3.4.1 直觉就在眨眼之间\n格拉德威尔这本书开篇的故事令人印象深刻：一些艺术名家鉴赏雕像中的杰作——一个阔步行走的男孩雕像。有些专家本能地认为这个雕像是仿冒品，但也说不清楚是什么让自己有这种感觉的。读了这本书的人（有数百万人读过）都认为直觉在其中起了作用。**这些专家知道雕塑是仿冒的，却不知道自己为什么知道——这正是对直觉的定义**\n\n调查指挥官们是怎样不加选择就做出正确决策的。最初的假设是指挥官会将其分析限制在两个选项中，但这个假设已被证实是错误的。事实上，指挥官只萌生了一个选项，且这个选项也正是他们所需要的。他们花了超过10年的时间进行真实和虚拟的演练，以识别出合适的选项作为首选，而在有真实需要时，他们就可以利用这个累积了多年的指令库。他们评估某个选项的方法是在脑部模拟这个选项，看它是否适用于当时的情况……如果他们考虑的这个做法大概可行，他们就会这样做；如果这样做不太好，他们就会对其进行调整；如果不易调整，他们就会选择下一个最有可能的选项。然后，重复上面所说的过程，直到找到一个合适的做法。\n\n##### 3.4.2 专家型直觉的习得\n恐惧可以被感知，事实上也很容易被感知，因为无须亲身经历只需通过语言就能感知。对危险有着“第六感”的消防员肯定有很多机会讨论及思考多种他并没有亲自参与的火灾，并在脑中对会有什么样的线索出现以及该怎样反应进行演练。我还记得，一名没有作战经历的年轻排长在带领部队穿越峡谷时会很紧张，因为他曾经学习过这样的地形很可能会有埋伏。学习需要一定的反复强化。\n\n情感学习可能很快，但学习我们所说的“专业技能”通常需要很长时间。学习专业技能，例如高水平的国际象棋、职业篮球以及消防技能，很复杂也很缓慢，因为某个领域的专业技能涉及的不仅是一项单一的技能，还包含了很多小技巧。象棋就是一个很好的例子。一名专业棋手一眼就能看清一个复杂的棋局，但达到那样的能力水平却需要很多年。对象棋大师的各项研究表明，想要达到高水平需要至少10000个小时的专注练习（大约需要在6年的时间里每天练习5小时）。在注意力高度集中的这若干个小时内，一个谨慎的棋手会熟悉数以千计的棋局，且每个棋局中的棋子都有攻守关系。\n\n掌握下棋的技巧要比学习朗读更难也更慢，因为象棋的“字母表”含有更多的字母，每个“单词”也包含许多字母。然而，经过上千小时的练习以后，象棋大师能够一眼就“读”出棋局。他想出的那几步棋通常也都很高明，有时还会令对手措手不及。他们可以处理自己从未遇到过的“单词”，还能找到一个新的方法去解释一个熟悉的“单词”。\n\n##### 3.4.3 环境有规律可循，直觉才可相信\n早些时候，我研究过人们自信的来源，认为以下两点与之相关：认知放松和一致性。如果我们能很轻松地想到自己想要的那个故事，且各个情节之间并无矛盾时，我们就会很有自信。但是放松和一致并不能保证我们充满自信的观点就是正确的。联想机制会抑制怀疑并引发与当前情况相符合的想法与信息。遵从眼见即为事实原则的大脑可通过忽略自己所不知道的事而变得过于自信。因此，许多人容易对没有事实根据的直觉怀有高度的自信也就不足为奇了。我和克莱因最终就一个重要的原则达成了共识：人们对直觉的自信心不能作为他们判断的有效性的可靠指标。换句话说，当有人告诉你你应该相信他们的判断时，不要相信他们，也不要相信自己。\n\n\n如果主观自信不可信的话，我们该怎样评估直觉判断的有效性呢？判断在什么时候才能反映出真实的技能水平呢？什么时候会显现出有效性错觉呢？回答这些问题需考虑到技能习得的两个基本条件：\n\n**1、一个可预测的、有足够规律可循的环境。**\n\n**2、一次通过长期训练学习这些规律的机会。**\n\n**当满足以上两个条件时，就可以培养出直觉来了。象棋这个活动就需要在极具规律的环境下进行，桥牌和扑克也提供了有力的、能支撑技能的统计学规律。医生、护士、运动员以及消防员面对的都是复杂但却基本有序的情境。相反，作长期预测的股票投资者以及政治学者是在有效性为零的环境中进行的。他们的失败反映了他们尝试预测的事物基本是不可预见的。**\n\n\n在毫无章法的环境下，运算法远远优于人工判断有两个原因：运算法比人工判断更可能观察到不怎么有效的线索，还可能通过利用这样的线索将正确性保持在适度水平上。\n\n**请记住这条规则：在环境缺乏牢靠的规律时，不要相信直觉。**\n\n环境中的某些规律会比其他规律更容易察觉并容易加以利用。想想你是如何形成自己的刹车方式的。当你学习转弯时，你渐渐学会了何时放油门以及用多大力气踩刹车。现在，弯道改变了，但多次转弯的经历已使你能在任何弯道上在恰当的时间以恰当的力度踩刹车。学习这项技能的条件是很理想的，因为你在每次遇到弯道时都能收到及时、清楚的反馈：转弯顺畅时你会感到很舒服，但如果刹车没有踩到底，你就会感到车子有些难以控制。港口引航员调动大型船舶的情境也有一定的规律，但只凭借经验是很难学到这项技能的，因为行动之间可能会有长时间的推迟，这样的推迟还会带来显著的后果。**专业人员是否有机会培养直觉性专业技能主要取决于反馈的质量和速度，以及是否有足够的时间进行练习。**\n\n##### 3.4.4 直觉的对错评估\n在我们的实验快结束时，我和加里·克莱恩就上面提及的那个问题给出了一个一般性答案：什么时候可以相信有经验的专业人士的直觉？**我们的结论是，大多数情况下，我们还是可以将可能是有效的直觉与可能是无效的直觉区分开来的。这就好比判断一件艺术作品的真假一样，关注这件作品的出处通常比关注作品本身的判断准确率更高。**如果环境有足够的规律性，并且在判断时有机会掌握这些规律，联想机制就会识别这些情境并做出快速且准确的预测与决策。这些条件若得到满足，你就可以相信某个人的直觉。\n\n在一个不够规律或效度较低的环境中，判断启发式就会被激活。系统1通常会用另一个问题快速替换掉难题，创造出并不存在的关联。此时回答的问题并不是预期的那一个，但这个答案会很快出现在人们的脑海中，会通过系统2宽松的审查。你可能想预测某个公司的商业前景，并相信这就是你正在判断的事，但实际上，你对这家公司高管能力的印象主宰了你的评估。因为替代是自动发生的，你通常并不清楚自己（你的系统2）赞同并采纳的判断源自何处。如果这是唯一出现在大脑里的判断，你可能就无法将它与你根据专业直觉得来的有效判断进行主观上的区分。这就是主观自信不能作为直觉准确性指标的原因：即使判断的是错误的问题，在作出这一判断时仍可能有高度的自信。\n\n你可能会问：为什么我和加里·克莱因立即想到了通过评估环境规律和专家学习经历的方法来估测专家的直觉能力，而不是通过专家的自信程度来评判，还会问我们答案可能是什么。其实解决方案一开始就很明显。我们先前就知道火场指挥官和儿科护士的直觉是有效的，而米尔研究的那些专业人士以及股票投资者和经济学者的直觉则不准确。\n\n\n**示例--专家型直觉**\n\n> 对这个特别任务，她有多少专业技能？做过多少练习\n\n> 他真的相信这些新成立的公司的环境有足够的规律来证明与基础比率背道而驰的直觉吗\n\n> 她对自己的决策非常自信，但主观自信并不是评估准确性的标准\n\n\n#### 3.5 努力养成采纳外部意见的决策习惯\n**我遵循了我们已经计划好要纳入课程体系的流程：从一个团队获取信息的合理方法并不是通过公开讨论，而是通过私下收集大家的观点来完成。**这个流程与常规的公开讨论不同，它更加充分地利用了每个成员的相关知识。我收集了大家的预测，并将结果记录在黑板上。\n\n这个令人尴尬的插曲成了我职业生涯中一段最具启发性的经历。我从中悟出了三点，\n\n第一点是显而易见的，我偶然得到了两种截然不同的预测方法。\n\n后来，这两种方法被我和阿莫斯称为内部意见和外部意见。第二点是我们最初的预测，即完成项目需要大约两年的时间，体现出一种规划谬误。\n\n我花了很长的时间才悟出第三点，我将这一点称为非理性坚持，一如我们那天做的荒唐事：没有终止那个项目。面对选择时，我们因为事业心而丢掉了理性。\n\n##### 3.5.1 比起外部意见，我们更偏向内部意见\n如果你对一个事件的了解仅限于其所属类别，其他情况一概不知，此时作出的预测就是基准预测。正如前文所述，基准预测应该是进一步调整的锚定。如果你只知道某位女士住在纽约，却被问到她的身高的话，你的基准预测就是你对纽约女性平均身高的合理猜测。\n\n如果得到了与案例相关的特定信息，例如那位女士的儿子是他所在高中篮球队的首发中锋，你就会将预测转向一个合理的方向。希莫将我们团队与其他团队的对比说明，我们所作的预测较基准预测而言更糟糕，而基准预测已经是糟糕透顶了。\n\n##### 3.5.2 规划谬误：过于乐观的计划随处可见\n\n我和阿莫斯创造了“规划谬误”这个新词来描述下列计划和预测：\n\n1. 不切实际地接近理想状况（的计划和预测）。\n\n2. 可通过参考类似案例的数据得到提高（的计划和预测）\n\n1997年7月，爱丁堡规划中的新苏格兰议会大楼预计的最高预算是4000万英镑。到了1999年6月，建楼的预算就变成了1.09亿英镑。2000年4月，规划者将“成本上限”修改为1.95亿英镑。到2001年11月，他们又将“最终成本”预估为2.41亿英镑。这个最终成本在2002年年末的时候又上涨了两次，成为2.946亿英镑。到2003年6月，预算又增加了3次，达到3.758亿英镑。这栋大楼最终在2004年建成，最终耗资约为4.31亿英镑。\n\n规划者与决策者的乐观心态并不是造成超支的唯一原因。厨房改造和武器系统的承包人都承认（尽管不是对他们的客户承认），他们都会通过扩充最初计划而获取最大利益。客户们无法想象他们的意愿会随时间的推移而逐渐增多，而没能预测到这些情况的事实也恰好反映出这一点。如果他们制订一个较为现实的计划并严格按计划进行，最终就不会花掉这么多钱了。\n\n最初预算的误差并不总是无知的。制订计划的人都希望自己的计划能得到上级和顾客的认可。通常也正是这种愿望的驱使，他们才制订出了不切实际的计划。他们这样做还因为仅仅由于超支或超时不太可能会导致项目被中途叫停。在这些例子中，避免规划谬误的最大责任落在了批准计划的决策者身上。如果这些决策者没有意识到外部意见的必要性，他们就会犯下规划谬误的错误。\n\n\n##### 3.5.3 减少决策错误的有效方法\n\n如何通过改进的方法提高预测的准确性？上面的说法可算做唯一一条最为重要的建议了。**在预测时使用相似团队的分布信息被称为采纳“外部意见”，它是避免规划谬误的有效方法。**\n\n弗林夫伯格使用的预测方法与为克服对基础比率的忽视而采取的建议非常相似：\n\n1. 识别对应的参考类别（例如厨房改建和大型铁路项目等）。\n\n2. 获取参考类别的统计数据（每英里铁路的造价或是支出超过预算的百分比），利用这些数据作出基准预测。\n\n3. 如果有特别的原因说明这个项目多少会比同类项目的乐观偏差更为明显，则可使用此例的具体信息对基准预测进行调整。\n\n高管们为了抢占资源很容易会提出过于乐观的计划，因此，各个组织面临着控制高管这种倾向的挑战。**运转良好的组织会奖励规划师，因为他们提出的方案精准而又切实可行；当然也会处罚规划师，因为他们没能对遇到的困难作出预测或是没能考虑到他们本可以规避的困难，即未知的未知数。**\n\n在我们预测风险项目的结果时，高管们很容易会掉入规划谬误的陷阱。**在规划谬误的支配下，他们根据脱离现实的乐观心态来做决策，而不是根据对利益得失以及概率的理性分析做决策。他们高估了利益，低估了损失。他们设想了成功的场景，却忽略了失败和误算的可能性。因此，他们所追求的行动方案不太可能在预算之内完成，也不大可能按时完成，这个方案可能也无法实现预期的回报——甚至都无法完成。**\n\n**如果在开始做这个项目时就有了合理的基准预测，那么我们就不会再将项目进行下去了，但我们已经投入了大量精力——这是一个沉没成本悖论的例子，我们将在本书后半部分重点关注这个问题。放弃这个项目会令我们很尴尬，**尤其是我，而且我也没有直接的理由这样做。在危急时刻转变方向比较容易，但这并不是一个危急时刻，因为我们得到的只是一些不相干的人的实例。与我们在自身努力后得到不好的结果相比，外部意见更容易被忽略。\n\n**示例---外部意见和内部意见**\n\n> 他正在采纳内部意见，他应该忽略自己案例的情况，去看看其他案例是什么情况。\n\n> 她掉进了规划谬误的陷阱。她设想了一个最为理想的情景，但有多种原因可能导致计划失败，她无法预见所有原因。\n\n> 我们又加大了投资，因为我们不想承认失败。这是一个沉没成本悖论的例子吗？\n\n\n#### 3.6 乐观主义是一把双刃剑\n规划谬误只是普遍存在的乐观偏见的一种表现形式。**我们中的大多数人都认为世界是美好的，但世界却没有想象般美好；我们觉得自己的贡献很大，但事实上并没有那么大；我们认为自己设定的目标很容易实现，但其实实现的可能性也没有那么大。我们还容易夸大自己预测未来的能力，进而导致乐观的过度自信，这可能会影响到决策。**乐观偏见也许是认知偏见中最重要的一种。如果你性情乐观，就应该既乐观又谨慎，因为乐观偏见可能有益，也可能带来风险。\n\n##### 3.6.1 乐观主义者过度自信的代价\n抱有乐观心态很正常，但一些幸运儿比其他人更为乐观。如果你天生就有乐观偏见，无须别人告知，你就知道自己是个幸运儿，因为你已经感到幸运了。**乐观心态大多是遗传下来的，是人类普遍存在的一种性情，偏向于看到事物积极的一面。如若让你为自己的孩子求个愿望，你应该真心希望他或她有个乐观的心态。乐观主义者通常都是开朗快乐的，也因此颇受欢迎。他们对失败和困难的承受力都比较强，患抑郁症的概率低，免疫系统良好，也更注重身体健康。他们感觉自己比别人健康，事实上他们的确更长寿。**有些人会夸大自己的预期寿命，认为自己的寿命会超过保险界的统计数据。而对这些人的研究表明，他们的工作时间较长，对自己未来的收入更有信心，离婚之后更容易再婚（典型的“精神胜利法”），也更容易投资个股。**当然，只有那些带有轻微偏见并且能在不脱离实际的前提下“强调积极因素”的人才能享受乐观主义带来的益处。**\n\n一项对小型企业创始人的调查总结道，**企业家对待生活的态度普遍比中层主管乐观。他们成功的经历印证了他们对自己的判断和掌控能力的信心。他们的自信因别人的崇拜而增强。这条推理使我们得出一个假说：对他人生活影响巨大的人可能是乐观和过度自信的，这种人承担的风险远大于自己所能意识到的水平。**\n\n\n有偏见并不奇怪。如果最近某人开了家意大利餐厅，你在采访他时就不要期待她会低估自己成功的概率或说自己缺乏经营餐馆的能力。但你肯定会纳闷儿：如果她通过一些渠道得知了胜算率，还会继续投入金钱和时间吗？或是她在得知胜算率（有60%的新餐厅3年后会歇业）以后，会考虑胜算率吗？答案是，她可能不会考虑采纳外部意见。\n\n一般说来，个体经营的财务收益属于中等：同等条件下，人们通过向雇主出售自己的技能得到的平均回报要比经营自己的企业更高。这表明乐观主义是普遍、执拗且代价昂贵的。\n\n即使大多数风险承担者最终总是收获失望，但那些因乐观而承担的风险企业家毫无疑问都会为激发资本主义社会的经济活力作出贡献。\n\n##### 3.6.2 竞争忽视：为何大片会扎堆上映？\n\n人们倾向于用愿望思维来解释企业家身上的乐观主义，但是情感只是乐观主义产生的一部分原因。认知偏见起了很重要的作用，特别是系统1的其中一个特征，即眼见即为事实。\n\n* 我们将注意力集中在目标上，锚定我们的计划，却忽视了相关的基础比率，导致规划谬误。\n\n* 我们只关注自己想做的和能做的，却忽视了他人的计划和技能。\n\n* 我们只重视自己已知的，却忽视自己未知的，因此我们对自己的信念过度自信。\n\n* 在解读过去和预测未来时，我们强调了技能的因果角色，却忽视了运气的影响。因此，我们产生了“控制错觉”\n\n“90%的司机都相信自己的车技要高于平均水平”这一心理学发现已得到了证实，也已成了文化的一部分，还成了普遍存在的高于均数效应的主要例子。。然而，对这个发现的解读在近几年发生了改变，原来认为这是一种自我膨胀，现在则认为这是一种认知偏见。请考虑下面两个问题：\n\n* 你是一个好司机吗？\n\n* 你是一个高于平均水平的司机吗？\n\n第一个问题很简单，人们很快就可作答，且多数司机都会答“是”。第二个问题要难很多，大多数受试者几乎都不可能谨慎而又正确地作答，因为这需要对司机的平均水平进行评估。读到这里，对于人们会用简单答案回答难题这一观点你已有所了解。虽然受试者将自己的水平与平均水平进行比较，却从未考虑过平均水平究竟是什么水平。**对高于均数效应的认知解释有一项证据，即当人们被要求完成一项困难的任务时，他们会不假思索地将自己划在平均水平以下。结果，只要表现还说得过去，人们就总是喜欢表现得过于乐观。**\n\n\n我曾经有过几次机会询问新成立的创新型公司的创办者及其合作人一个问题：**公司取得的成绩在多大程度上取决于你在公司的作为？这明显是个简单的问题；人们很快就能回答出来，而且在我所抽取的小样本中，认为自己与公司成功的关联度没有低于80%的。即使他们并不肯定此时自己是否成功，这些有胆量的人也都认为自己的命运完全掌握在自己手中。他们肯定错了：新公司的成绩更多取决于其竞争者、市场的变化以及自身的调控。然而，眼见即为事实的原则也起到了一部分作用，企业家会自然而然地将注意力放在他们最为了解的地方——他们的计划、行为、最直接的威胁和机遇等，例如筹资能力。他们对竞争者所知较少，也就自然地认为竞争者与公司未来没多大关系。**\n\n竞争忽略的结果是产生了许多额外入口：众多竞争者进入市场，导致市场不能保证赢利，所以平均下来，其结果就是亏损。对于新进入市场的公司来说，这样的结果会令其失望，但是这对总体经济的影响却可能是积极的。事实上，一些创新型企业的失败标志着新的市场需要更有能力的竞争者。乔瓦尼·多西(Giovanni Dosi)和丹·洛瓦洛称这些创新型企业为“乐观主义烈士”，对经济有益，对投资者有害。\n\n##### 3.6.3 是你太糟糕，而不是我太笨拙\n\n杜克大学的学者们搜集了11600份这样的预测并检验了它们的准确性。结论非常明显：大型企业的财务主管对股票市场的短期走向一无所知，他们估测出的值与真实值的相关系数接近零！当他们说股市走低时，股市多半可能会上扬。这些发现并不令人吃惊。真正糟糕的消息是，这些财务总监似乎并不知道他们的预测是没有价值的。\n\n这说明财务总监过度相信自己预测市场的能力了。**“过度自信”是眼见即为事实的一种表现：在估测质量时，我们会依赖大脑呈现的信息并构建一个使估测合理的、具有逻辑的解释。一个人不可能采用自己没有想到的那些信息，** 也许是因为他从来就不知道这些信息吧。\n\n**对环境的不确定性了解不足必然会导致经济行为人承担本可以避免的风险。然而，无论在社会生活中还是在股票市场中，乐观主义极其重要。个人及企业会奖励那些提供了冒险且有误导性信息的人，而不是说真话的人**\n\n青睐过度自信的专家的领域并不仅限于金融预测。其他专业人士必须面对这样一个事实：一位实至名归的专家需要表现出很高的自信程度。临床医生显现出的不确定是一种懦弱的表现。自信的人比对事情持不确定态度的人更受人推崇。在危机中，极度的不确定会造成严重后果，而且在风险高的时候承认自己只是在猜测的做法特别不易被接受。所以，假装知道通常是首选的解决方式。\n\n我一直认为，在科学研究这一领域，乐观对成功而言同样不可或缺：**我遇到的成功的科学家都会夸大他或她正在进行的研究的重要性。我还相信，不爱夸大自己重要性的人在反复面对挫折和失败时会一蹶不振，这种情况也是大多数研究人员的结局。**\n\n##### 3.6.4 “事前验尸”：部分克服乐观偏见的方法\n\n他将自己的提议称为“事前验尸”。流程十分简单：当一个机构即将做出一个重要决策但还没有正式下达决议时，克莱恩提议召集对这个决策有所了解的人开一次简短的会议。**在会议之前有一个简短的演说：“设想我们在一年后的今天已经实施了现有计划，但结果惨败。请用5～10分钟简短写下这次惨败的缘由。”**\n\n**事前验尸观点有两个主要优点：决策快要制定好时，许多团队成员会受到集体思考的影响，而事前验尸则扼制住了这种影响。另外，它还激发了那些见多识广的个人的想象力，并将他们的想法引导到最需要它们的方向。**\n\n当一个团队将注意力集中在决策上，特别是当领导宣布他的意图时，人们对计划好的步骤的可行性的疑虑就会渐渐减弱，到最后，这样的怀疑还会被认为是对团队和领导的不忠诚。如果某个团队中只有支持决策的人才有发言权，那么对怀疑的抑制就会造成这个团队的过度自信。事前验尸的主要优点是它引发了怀疑。另外，它还助长了支持决策的人去探寻他们先前没有考虑到但却可能存在的威胁。事前验尸并不是灵丹妙药，也不能提供完整措施使我们避免恼人的意外，但这一方法在一定程度上可以减少计划的损失。而这些损失一般都是因眼见即为事实的偏差以及盲目的乐观主义导致的。\n\n**示例--乐观偏见与过度自信**\n\n> 他们有控制错觉，他们严重低估了障碍。\n\n> 这是一个过度自信的例子，他们似乎认为自己知道的比实际的多\n\n> 我们应该开一个事前验尸会议，有人也许能想到一个被我们忽略了的威胁。\n\n\n### 4、选择与风险\n#### 4.1 事关风险与财富的抉择\n你愿意选择哪一项？\n\nA.抛硬币决定。如果是正面，你会得到100美元；如果是背面，你就什么都得不到。\n\nB.肯定会得到46美元。\n\n在这个例子中，我们两个都会选B选项，而且很可能你也会这么选.\n\n**示例——伯努利理论的错误**\n\n> “3年前，他有2万美元的奖金，他对此已经很满意了，但他的薪水自那以后只涨了20%，所以他需要更多的奖金来获得同样的效用。\"\n\n> 两个人都愿意接受自己拿到的薪水，但他们对这份薪水的满意度不一样，因为他们的参照点是不同的。她目前的薪水更高。\n\n> 她在申请离婚赡养费。实际上她愿意调解，但他更愿意上法庭。这种分歧是意料之中的——她只能稳赚，所以要规避风险；而他面对的却都是糟糕的结果，所以他更愿意冒险。\n\n\n#### 4.2 更人性化的前景理论\n\n##### 4.2.1 面对财富，你会选择规避风险还是冒险一搏？\n\n问题1：你会选择哪一个？\n\n肯定会得到900美元，还是有90%的可能性会得到1000美元？\n\n问题2：你会选择哪一个？\n\n必定会损失900美元，还是有90%的可能性会损失1000美元？\n\n**你只是喜欢得到，不喜欢失去——几乎可以肯定地说，你对失去的厌恶程度远大于你对得到的喜欢程度。**\n\n**对亏损的反应比对同等数量盈余的反应要强烈得多。这就是所谓的损失厌恶。**\n\n##### 4.2.2 损失厌恶：人们对亏损的反应比对盈余的反应大得多\n\n问题5：现在，用抛硬币来打赌。\n\n如果是背面，你会输掉100美元。\n\n如果是正面，你会赢得150美元。\n\n这个赌局吸引人吗？你想参加吗？\n\n尽管这个赌局的预期值显然是有利的，因为你坐收的赢利铁定比你可能遭受的亏损小，但你可能还是不愿下这个赌注——大多数人都不会愿意这样做。\n\n对于大多数人来说，对失去100美元的恐惧比得到150美元的愿望更强烈。我们从众多此类观察中得出结论，即**失去比得到给人的感受更强烈，因此人们往往会规避损失。**\n\n但当实验人员要求参与实验的受试者“像商人那样思考”时，他们对损失的规避感就不那么强烈了，他们对损失的情绪反应（通过情感激励的心理指数来测量）也大大减弱了\n\n\n##### 4.2.3 前景理论无法应对令人失望的事\n\nA.有百万分之一的概率赢得100万美元。\n\nB.有90%的概率赢得12美元，有10%的概率什么也得不到。\n\nC.有90%的概率赢得100万美元，有10%的概率什么也得不到。\n\n“什么也得不到”在三种情况下都是可能会出现的结果，前景理论在这三种情况下给这种结果分配了相同的价值。“什么也得不到”是个参照点，且其价值是零。这些说法和你的经历相符吗？当然不是。“什么也得不到”在前两种情况下是被期望但未能实现的事，没有给其分配价值也是讲得通的。相反，在第三种情况下，没能获利就会让人非常失望。这就好比私下里向你保证会给你加工资，赢得一大笔钱的可能性那么大，这就建立了一个新的暂时参照点。相对于你的期望而言，“什么也得不到”无异于一种巨大的损失。前景理论无法应对这种情况，因为在结果（在这里是指“什么也得不到”）出现的可能性很小或另外一种选择很有价值时，前景理论是不会允许这种结果的价值发生改变的\n\n\n**示例——前景理论**\n\n> 他是损失厌恶的典型例子，因而连非常有利的机会也被他拒绝了。\n\n> 她非常有钱，因而她对微不足道的所得反应那么强烈着实让人费解。\n\n> 他把损失看得比所得要重一倍。不过这也很正常。\n#### 4.3 禀赋效应与市场交易\n\n边际效用递减，即你的休假天数越多，就越不会在意自己是否还想多休息一天，而且每多一天，这一天的意义就比前一天更小。同样，你的收入越高，就越不关心自己是否会额外再得到一美元，而且为换取一天的额外休假，你愿意放弃的钱数也会有所增加。\n\n##### 4.3.1 像商人那样思考和交易\n\n李斯特发现那些缺乏经验的商人中只有18%的人愿意和别人交换礼物。与之形成鲜明对比的是，那些经验丰富的商人并没有表现出任何禀赋效应的迹象：他们中有48%的人进行了交易！\n\n经验丰富的商人显然已经学会了正确提问，**即“与可以得到的其他东西相比，那个杯子真的是我特别想‘得到’的吗”。经济学家会问这个问题，有了这个问题，禀赋效应就不复存在了，因为得到的快乐和放弃的痛苦之间的不对称性没有关联。**\n\n**示例——禀赋效应**\n\n> 她不在意自己能得到两个职位中的哪一个，但公告发布一天之后，她就不再想换了。这就是禀赋效应！\n\n> 他只是不想以低于自己买房的价格卖掉自己的房子。损失厌恶起作用了\n\n> 他是个吝啬鬼，只要花钱就觉得赔了\n\n#### 4.4 公平性---经济交易的参照点\n\n##### 4.4.1 目标就是参考点\n损失厌恶系数指的是两种动机的相对强度：我们想要规避损失的动机要强于获得利益的动机。参照点所关注的是现状，但它还会是将来的目标，即没有实现的目标就是种损失，超过了目标就是种所得。\n\n\n##### 4.4.2 我们为什么不愿意改变现状？\n我们为什么不愿意改变现状？避免损失的动机和获得收益的动机强度并不对称，这一点在许多情况下都有体现。\n在商务谈判中，尤其是在对现有合同的重新商谈中、在典型的劳动商议和在贸易或限制军备的国际谈判中，这种不对称是长期存在的一个特征。现有的条款确定了参照点，协议中任何方面拟定的变更都会被看成是一方对另一方作出的让步。损失厌恶会产生一种不对称，使得双方难以达成共识。你对我作出的让步是我的所得，但它们却是你的损失；损失使你产生的痛苦会比它们给我带来的快乐更多。因此，你对这种让步的价值会比我赋予它的价值高。当然，你要求我作出的让步对于我来说也会是这样，你对我作出的让步也不会给予足够的价值评价！对越来越小的蛋糕进行商讨非常困难，因为即使损失，也要将其分配出去。人们在蛋糕越来越大时，显得更随和。\n\n\n**改革通常包括保护利益相关者的不追溯条款，例如以下情形：劳动力减少是由于（退休、辞职、死亡等原因造成的）人员缩减而不是开除；工资或福利的缩减只会在将来的工人身上施行。损失厌恶是一种强大而保守的力量，它偏爱机构或个人对当前生活的细小改变。**\n\n##### 4.4.3 商人提价或降低员工工资的行为公平吗？\n是什么造成了商人、雇主以及房主的不公平交易行为？我们研究了公众对这一问题的看法。问卷中的首要问题是：因为这种不公平行为招来的骂名是否会使他们追逐利润的行为收敛些？我们的发现是：会。而且我们还发现，公众评估哪家公司也许真的（不）会收敛时所依照的道德原则可以明鉴得失。其基本原则是，当前的工资、价格或租金设定了一个参照点，不可违背这个参照点。有些公司将自身的损失强加给顾客或工人，使自己回到交易参照点，这样做是不公平的，除非这样做是为了保护自身的权利\n\n一家五金店一直以15美元的价格出售雪铲。某日下了大雪，第二天早上店主就将雪铲的价格提高到了20美元。\n\n你认为这种行为：\n\n完全公平、可以接受、不公平、很不公平\n\n按标准的经济行为模式来看，这家五金店的行为是公平的：通过提高价格来回应需求的增加。而调查对象却不这么认为，82%的人选择了不公平或很不公平。他们显然是将大雪前的雪铲价格看成了参照点，而将提升的价格看成是店主强加给顾客的损失，因为这家店并不是不得已才这样做的，而是因为它选择这样做。我们发现公平性的一条基本原则是：**不可利用市场的力量将损失强加给他人。**\n\n\n**示例——损失问题**\n\n> 这项改革肯定无法通过。那些必然受损的人会比那些必然获利的人更加强烈地反对这种做法。\n\n> 如果他们觉得利益的蛋糕的确在变大，就会发现再次商议更容易。因为他们不是在分配损失，而是在分配所得。\n\n> 我们的客户对价格上涨并无抱怨，因为他们知道我们的成本也上涨了。他们尊重我赢利的权利。\n\n\n#### 4.5 对结果可能性的权衡\n权衡时，你肯定会考虑到这些结果的可能性：有50%的概率赢得100万美元当然要比只有1%的概率更吸引人。权衡有时是有意识的，有时是经过深思熟虑的。然而，大多情况下，这些总体评估都是由系统1作出的。\n\n##### 4.5.1 可能性效应与确定性效应\nA.从零提升到5%。\n\nB.从5%提升到10%。\n\nC.从60%提升到65%。\n\nD.从95%提升到100%。\n\n从零到5%的巨大转变表明了“可能性效应”(possibility effect)，这一效应会是我们高估那些出现可能性极低的结果的发生频率。大量买彩票的人表明，他们愿意花超出预期价值的钱来换取赢得大奖的渺茫机会。\n\n从95%提升到100%是另一种实质性改变，也会产生巨大的影响，是“确定性效应”(certainty effect)\n\n\n##### 4.5.2 四重模式：可能性与决策权重的关系模型\n人类的很多不幸处境都在右上角那栏中得到了体现，也就是说人们在面临的抉择比较糟糕时会孤注一掷，尽管希望渺茫，他们也宁愿选择使事情更糟的较大可能性以换取避免损失的希望，这种做法常会使可控制的失误变成灾难。\n\n**示例——四重模式**\n\n> 他试图用庭外和解的手段来解决这个无意义的诉讼案件，以避免损失，然而却不大可能。这是过分看重较小可能性的结果。既然会面对很多相似的问题，他最好还是不要放弃。\n\n> 他们知道瓦斯爆炸的可能性很小，但他们想要消除这种可能性。这是可能性效应，而且他们想要的是再无后患。\n\n#### 4.6 被过分关注的罕见事件\n极其生动的死亡或爆炸画面的影响因媒体的关注以及人们的频繁交谈而不断加强，在身处具体的情境时，尤其如此，例如看见了一辆巴士时。此类情绪一触即发、身不由己且无法控制，会使人们本能地想要保护自己。**系统2可能“知道”发生危险的概率很小，但即使知道也无法消除人们内心的不安和躲避危险的冲动。我们无法停止系统1的运行。**\n\n**“罕见事件不是被忽视就是被过度重视。”**不过，这个说法并没有详细说明在什么情况下事件会被忽视，什么情况下会被过度重视，也没有从心理学上对此作出解释。\n\n##### 4.6.1 你认为一支三流球队获得NBA总冠军的可能性有多大？\n人们是怎样作出判断，怎样确定决策权重的呢？让我们先来看两个简化的回答，然后再对答案进行证实。以下就是这两个十分简单的答案：\n\n* 人们高估了罕见事件的概率。\n\n* 人们在做决策时过高权衡了罕见事件。\n\n尽管过高估计和过高权衡是两个不同的现象，却有着同样的心理机制，即集中注意力、证实性偏差以及认知放松。\n\n\n这些发现对规划谬误以及其他乐观主义的表现形式作出了新的阐述。**当某个人努力预测某个方案的结果时，就可以切实且轻松地成功执行某项方案。相反，失败的可能性则会被忽略，因为事情出问题的情况错综复杂。对自己职业前景进行评估的那些企业家与投资者很容易高估自己的机会，也喜欢过高权衡自己的估值。**\n\n##### 4.6.2 画面感越强，决策权重越大\n**普林斯顿的这个团队说，他们已经观察到人们对与情感相关的结果的出现概率的敏感度很低，这种情况很正常。赌钱属于例外情况。赌钱时，人们对概率的敏感度相对较高，因为他们有确切的预期值。**\n\n新的假设为，在第二个案例中，对概率的敏感度会更低，因为与“一笔钱”这个抽象的概念相比，蓝色信封能唤起更为丰富的想象。你在脑中构建这个事件时，即使知道赢的概率很小，但奖品的生动画面仍然会浮现出来。认知放松同样也对确定性效应产生了影响：当你脑海中闪现关于某个事件生动的画面时，这个事件不发生的可能性所带来的影响同样也很生动，因此就会被过度权衡。增强的可能性效应与增强的确定性效应相结合以后，决策权重很难在21%的概率和84%的概率之间发生改变。\n\n##### 4.6.3 对风险的表述方式不同，所做决策可能截然相反\nA罐中有10个球，其中有1个是红色的。\n\nB罐中有100个球，其中有8个是红色的。\n\n你会选哪个罐子呢？因为选A罐的胜算是10%，选B罐是8%，所以作出正确选择应该不难，但实际并非如此：大约有30%～40%的学生选择了红球数量较多的那个罐子，而不是胜算率高的那一个。\n\n**正如你可能想到的那样，人们在这种情况下作出的愚蠢选择已经引起众多研究者的关注。他们对这种偏见也有不同的命名，而我使用的是保罗·斯洛维克的命名“分母忽视”。如果你将注意力集中在能使你胜利的球上，就不会去关注那些不能使你赢的球。生动的画面也是产生分母忽视的原因，至少我有过这样的经历。当我想到小罐子时，我看到的是一个小红球在一片白色的背景中；当我想到大罐子时，我看到的是8个红球在一堆白球当中，这样的画面增强了我对胜利的信心。**\n\n**分母忽视这个观点有助于解释为什么不同的风险表达方式所造成的效果会有这么大的不同。**\n\n##### 4.6.4 罕见事件又为何会被人忽视？\n\n现在仍然没有能够阐释凭经验选择的方法，但无论在实验中还是在现实世界里，大家都普遍认同一点，即对罕见事件的决策权重较低有一个绝对主要的原因：**许多受试者从未经历过罕见事件！大多数加州的市民从未体验过大地震，2007年时也没有银行家切身经历过大规模的金融危机。**\n\n**示例——罕见事件**\n\n> 即使在日本，海啸也很少发生，但是海啸在我们头脑中的画面非常生动形象，游客也因此会高估海啸发生的可能性。\n\n> 他们想让人们意识到风险是存在的。这也就是他们会使用‘每1000人中有1人死亡’这个说法的原因，这种做法利用了分母忽视效应。\n\n#### 4.7 能带来长远收益的风险政策\n人们在收益状态下更倾向于规避损失，在亏损状态下更倾向于承担风险。（明确收益下延误损失， 明确损失下倾向赌徒）\n\n##### 4.7.1 宽框架还是窄框架？\n处于收益状态时规避损失、处于亏损状态时承担风险是需要付出代价的。这些态度会使你不愿冒险，而愿付出额外的费用去得到肯定可获得的赢利，还会使你愿意付出额外费用（包含在预期价值中）以避免肯定的亏损。两种情况下付出的这些钱来源都一样，在同时面临这两种问题时，你的矛盾态度就不会很乐观。\n\n1. 窄框架：分别思考两个简单的决策问题。\n\n2. 宽框架：一个有4个选项的综合决策问题。\n\n我们有限的大脑很难达到逻辑一致性的理想状态，因为我们易受眼见即为事实原则的影响，不愿动脑筋。另外，即使有人告诉我们应该综合考虑问题，我们自己还是倾向于在问题刚出现的时候立刻做出决策。我们既没有意愿也没有精力去增强偏好的一致性，我们的偏好也不会自动变得一致，它们处于理性代理模式。\n\n##### 4.7.2 聪明的投资者不会每天都看股票行情表\n保罗·萨缪尔森是20世纪著名的经济学家。他曾问过他的某个朋友是否愿意玩一个抛硬币的游戏，玩这个游戏可能会损失100美元，也可能会获得200美元。他的朋友答道：“我不会接受，因为我觉得获得200美元的满足感无法抵消我损失100美元的痛苦。但如果你保证将硬币抛100次的话，我就和你玩这个游戏。\n\n在窄框架的情况下，他们被告知在做决策时应该“将每一个决策都当做你唯一需要做的决策”，并且要体会这些决策带给自己的情绪反应。在宽框架的情况下做决策的建议，包括“将自己想象为商人”，“你总是做这样的事”，以及“将它看做众多财政决策中的一个，这样一个决策会在将来一起被并入‘证券投资组合’中。\n\n宽框架缓解了人们对损失的情绪反应，增强了他们承担风险的意愿。\n\n损失厌恶和窄框架的结合是一个代价更大的祸端。个人投资者可以通过降低查看自己投资结果的频率来避免这一祸端，并在获得宽框架带来的情感收益的同时节约时间、减轻痛苦。时刻关注每日的经济波动是种亏本的对策。 因为频繁的低额损失带来的痛苦比同样频率的低额收益带来的快乐程度更为强烈。一个季度查看一次就足够了，对于个人投资者来说，这样的频率还要高一些。刻意避免查看短期结果，除了可使投资者的心情更为愉快以外，还可以提升决策和结果的品质。\n\n\n##### 4.7.3 风险政策可以抵消风险厌恶的偏见\n外部意见和风险政策是补救两种不同偏见的方法，而这两种偏见会影响许多决策的制定：**规划谬误中的过度乐观以及损失厌恶中的过度谨慎。这两种偏见相互对立。过度乐观使个人和组织免于损失厌恶的不好影响；损失厌恶使人们不会产生过度自信的乐观主义。这样的结果对于决策制定者来说是有益的。乐观主义者认为他们做决策时比在实际情况下更为谨慎，而损失厌恶者则会正确地拒绝危险的提议（在没有外部意见的情况下，他们是可能接受这些提议的）。当然，我们不能保证这些偏见会在所有情况下都相互抵消。能够同时消除过度乐观以及过度规避风险的机构应该采取这种做法，将外部意见与风险政策结合来考虑应该可以实现其目的。**\n\n\n**示例---风险政策**\n\n> 告诉她应该像商人那样思考！有赚，当然也有赔。\n\n> 我们公司每个部门经理在其所在领域都采取损失厌恶的做法。这很正常，但造成的后果是，这个机构不敢冒险。\n\n> 我决定每个季度查看一次我的证券投资组合。我总是选择规避损失，因此在面对每天价格波动的情况下总是不能做出理性的决策。\n\n\n#### 4.8 心理账户是如何影响我们的选择？\n亿万富翁再赚几亿美元不是出于经济原因，实验经济学项目的参与者获取额外的赞助也不是出于经济原因，**钱是衡量一个人自身利益与自我成就感的标尺。**\n\n\n##### 4.8.1 你会卖掉赢利的股票还是亏损的股票？\n\n两个狂热的球迷计划到离他们约64公里远的地方看篮球赛。其中一个人买了门票；另一个人在买票的途中遇见了一个朋友，免费得到了票。现在，有预报称比赛当晚会有暴风雪。这两位持票的球迷谁会更愿意冒着暴风雪去看比赛？\n\n答案很明显，我们知道买了票的那个球迷更有可能会去。心理账户也为此提供了解释。 但是我们应该这样想：“如果我的票是从朋友那儿得来的，我还会冒着暴风雪驾车吗？”但只有积极的、受过相关训练的大脑才会想到提出这样的难题。\n\n你需要钱来操办女儿的婚礼，所以想卖掉一些股票。你记得自己每一只股票的买进价，也能分辨出某只股票是“赢利股”（即当前价值高于你的买进价的股票），或是亏损股。在你所有的股票中，蓝莓牌瓷砖是一只赢利股；如果你在今天将其售出，就会得到5000美元的收益。你持有蒂芙尼电机相同的股份，现值是5000美元，但低于你的买进价格。你更有可能出售哪一只股票？\n\n**可以预料，金融研究中已经记录了大量人们售出自己的赢利股、保留亏损股的偏好——这被视为一种偏见，关于此还有一个晦涩难懂的名字：处置效应。**\n\n**理性的代理人会对证券投资组合有一个整体的看法，会售出最无可能在未来赢利的股票，而不是去考虑它是赢利股还是亏损股。**\n\n董事会非常清楚这样的冲突，所以当某位执行总裁因受困于先前的决策影响而不愿避免再造成损失的话，董事会就会将其替换掉。董事会成员不见得认为新的执行总裁比原先的更有能力，但他们知道新的总裁不会有与原总裁一样的心理账户，在评估当前机会的选择时，他也就更容易忽视过去投资的沉没成本。\n\n##### 4.8.2 哪种选择会让你更后悔？\n为了理解后悔与常态的关系，请思考下列情境：\n\n布朗先生几乎从不让旅行者搭便车。昨天他让一个男人搭了便车，然后他被抢了。\n\n史密斯先生经常让旅行者搭便车。昨天他让一个男人搭了便车，然后他被抢了。\n\n这两个人谁更可能感到后悔？\n\n答案不出我们所料：有88%的受试者认为布朗先生会更后悔，12%的受试者认为是史密斯先生。\n\n**带有批判性的观察者会将这两个人的行为与合理行为的传统常态相比较，更可能会批评史密斯先生，因为他总是习惯性地承担这种不可预知的风险。我们会忍不住说，史密斯先生是自食其果，布朗先生是走了霉运。但布朗先生更应被指责，因为他在这件事上的做法与他平时的性格不符。**\n\n\n##### 4.8.3 因为害怕将来后悔而作出不理性的选择\n\n为什么家长不愿为了钱而让孩子承担风险，哪怕只是增加一点风险。值得注意的是，这种态度对于我们想保护的人的安全来说，是不合逻辑且有潜在危害的。即使是最慈爱的父母，他们用来保护自己孩子的时间和金钱也是有限的（保护孩子安全的心理账户预算有限），因此，使这些资源的作用发挥到极致似乎很合理。通过买稍差的杀虫剂可以节约一小笔钱，但会增加孩子中毒的风险。然而，节约的这笔钱却可以更好地用在消除其他威胁孩子健康的事情上，例如买一个更为安全的儿童汽车座椅或是插座罩。禁忌权衡反对任何增加风险的可能，但这并不是利用健康预算的有效方法。**事实上，相较于想要保障孩子安全的愿望，这种抗拒可能更多的是出于害怕自己会后悔。任何在考虑后接受了这种交易的家长都会假设，想到杀虫剂带来危害时他们后悔和羞愧的画面。**\n\n你还可以采取一些预防措施，以防止将来后悔。也许最有效的方法就是做到对可能会后悔的事心中有数。如果你能够在情况变糟糕时，先仔细考虑自己是否会后悔再作决定，那么你将来的遗憾也就可能会更少一些。**你应该也知道，后悔总是伴随着后见之明的偏见而来，所以，任何你能做的、防止后见之明的措施都有可能是有益的。我个人躲避后见之明的方法是：在做有长远影响的决策之时，不要太过周密，但也不要完全凭偶然行事。如果你考虑到了一点点，你可能在事后说，“我本可以作出更好的选择”，这种后见之明就更会令你很不甘心。**\n\n**示例 --- 心理账户**\n\n> 他对现金支付和信用卡支付有不同的心理账户。我不断地提醒他，钱就是钱，并没有多大区别。\n\n> 他一直保留着那只股票，只是因为不想在关闭心理账户时处于损失状态。这就是处置效应。\n\n\n#### 4.9 评估结果的逆转\n\n**示例--逆转**\n\n> 当你将框架放大时，你就会做出更明智的决策，事实往往如此。\n\n> 当你单独看某件事时，你很容易受系统1的情感反应的支配。\n\n#### 4.10 善用框架效应，让生活更美好\n2006年世界杯总决赛是意大利队和法国队之间的较量。“意大利队赢了”，“法国队输了”，两个句子描述了这场比赛的结果，这两句含义相同吗？回答要看怎么理解“含义”这个词了。\n\n从逻辑推理的角度来看，这两个描述比赛结果的句子是可以互换的，因为它们所指的状况相同。\n\n含义还有另一层观念，在这层观念中“意大利队赢了”和“法国队输了”的意思并不相同。在这层观念中，对某个句子含义的理解发生在你的联想机制中。这两个句子引发了不同的联想。“意大利队赢了”让人们想起了意大利队，以及该队为了赢得比赛所作的努力。“法国队输了”会让人们想起法国队，还有法国队为什么会失败，包括法国队的球星齐达内用头撞了意大利队队员。这两句话引起大脑的联想，即系统1如何对此反应，这确实有不同的“含义”。逻辑上相同的陈述引发了不同的反应，这一事实使得人们无法像经济人那样可靠且有理性。\n\n\n##### 4.10.1 情感的框架效应很难抵挡\n若某赌注有10%的概率赢得95美元，有90%的概率损失5美元，你会接受这个赌注吗？\n\n若某彩票有10%的概率赢得100美元，有90%的概率什么也得不到，你愿意花5美元买这张彩票吗？\n\n首次，要花点时间弄明白这两个问题是相同的。在这两个问题中，你都要决定是否愿意接受某一不确定的可能，即拿到95美元或损失5美元。有人作选择会基于理性，他们会给出两个相同的答案，但这样的人是少数。事实上，其中有一个问题引起了很多正面的答复，这个问题是第二个。一个不好的结果如果被架构为不会赢的彩票的成本，比被简单地描述成输掉一个赌注更易被接受。**我们对以下这个说法不应该感到惊讶：损失能比成本引起更强烈的负面感觉。选择不是基于现实的，因为系统1就不是基于现实的。**\n\n**在获得时，偏向确定的事； 在损失时，偏向赌一把。**\n\n\n对手术短期结果的两种描述是：\n\n第一个月的存活率是90%。\n\n在第一个月里，有10%的死亡率。\n\n你已经知道了结果：在第一个框架下（84%的医生选择了它），手术治疗要比在第二个框架下（50%的受试者选择放射治疗）更受欢迎。\n\n重新构架是要付出努力的，而且系统2通常很懒惰。除非有明显的理由需要这样做外，否则，大多数人都会被动地接受在框架下的决策问题，因此很少有机会发现我们的偏好受框架约束而不是现实约束的程度。\n\n##### 4.10.2 用框架性政策助推人们作出更好的选择\n假设美国正为一场来自亚洲的异常疾病作准备，这场疾病估计会夺取600人的性命。为战胜这一疾病，我们提出了两种方案。假设对方案结果准确的科学估测如下：\n\n如果采用了方案A,200人会获救。\n\n如果采用了方案B，有1/3的可能会救600人，有2/3的可能一个人也救不了。\n\n很多受试者都会选择方案A：他们更愿意选择确定的选项，而不想赌一把。\n\n方案的结果在第二种说法中有了不同的框架，如：\n\n如果采用了方案A',400人会死。\n\n如果采用了方案B'，有1/3的可能没人会死，而有2/3的可能有600人都会死。\n\n请仔细看并对比两种说法：方案A和A'的结果是相同的，方案B和B'的结果也是相同的。然而在第二个框架下，很多人都选择赌一把。\n\n两种框架下不同的选择都符合前景理论。在前景理论中，根据结果的好坏，我们对打赌还是确定的事的选择也会不同。\n\n**1、当结果是正面的时候，决策制定者更愿意选择确定的事（他们是风险规避者）；**\n\n**2、当结果都是负面的时候，他们更愿意拒绝确定的事，愿意赌一把（他们会冒险）。**\n\n**示例--框架和现实**\n\n> 如果他们能对自己会得到多少钱而不是会损失多少钱有个框架的话，就会对将要发生的事有心理准备。\n\n> 通过改变参照点来重新架构问题吧，假想我们没有拥有过某个东西，我们会认为它值多少钱呢？\n\n> 对于损失，要在大脑中将其引入‘一般收入’，这样你就会感觉好一点！\n\n\n### 5、两个自我\n\n> **1、效用只对于消费者来说的，消费者经济行为所导致对自己的效果好坏大小。**\n\n> **2、效应是对于当一个经济变量变化所引起另一个经济变量变化的大小的值，如收入效应，替代效应，挤出效应，货币效应，利率效应等等。**\n\n#### 5.1 体验效用与决策效应不一致\n例如，期望效用理论就是控制决策效用的合理性原则，它与快乐体验没有关系。当然，若人们想要的正巧是自己喜欢的，喜欢的也是自己所选择的时候，“效用”的这两种含义就一致了\n\n##### 5.1.1 如何测量体验效用？\n1. 如果目的是为了减少患者的痛苦记忆，那降低最为疼痛时的疼痛感就比将疼痛的过程减到最短更为重要。同样的道理，如果患者在过程结束时感到的疼痛相对较轻，他对此过程的记忆就会更好，那么逐渐减轻疼痛比急剧减轻更可取。\n\n2. 如果想减少实际体验到的痛苦，迅速完成这个过程或许更合适，即使这样做会让患者更疼痛并给患者留下可怕的记忆。\n\n你认为这两个目标哪一个更好？我没有作调查，但我认为会有很多人选择痛苦记忆较少的那个。我觉得将这种困境看做是两个自我之间的利益冲突会更容易理解一点（这与我们所熟悉的两个系统不符合）。经验自我是回答“现在疼吗”这种问题的，而记忆自我则是回答“总体如何”这种问题的。我们只有通过记忆才能保存生活体验，因此，在我们思考生命时，唯一能采取的观点来自于记忆自我。\n\n我曾作过一个关于将记忆和体验区分开的困难的演讲。结束后，我听到了一名观众的评论。他说聚精会神地听唱片中的交响乐时，由于光盘有刮痕，快结束时产生了令人厌恶的声音，糟糕的结尾往往“毁了全部的体验”。但实际上毁的并非是体验，只是对它的记忆而已。经验自我几乎有了完美的经验，糟糕的结尾并不能将其抹去，因为这种体验已经发生了。这位听众将整个体验定义为失败，就因为它的结尾很糟糕，但他却忽略了40分钟的音乐带给他的快乐。实际体验真的毫无价值吗？\n\n##### 5.1.2 记忆自我夸大了痛苦体验\n在本实验中，我们观察到的偏向是我们在之前讲到的“少即是多”的另一个例子。其他“少即是多”的例子包括奚恺元的实验，即给低于总价值的24个盘子附加上几个盘子，因为附加的盘子中有的是坏的。还有一个例子是琳达问题，即激进的妇女会被认为更像是主张女权主义的银行出纳，而不是普通的银行出纳。其中的相似性并非偶然。系统1同样的操作特点说明了三种情况：系统1是用平均水平、规范和原型来表示集合，而不是用各条件的集合。冰手实验就是多个时刻的集合，而记忆自我会将每个时刻作为典型时刻记下来。这又会导致冲突。对于通过经验自我来评估各个时刻的客观观察者来说，最重要的是“曲线下的区域”，因为它表示的正是这段时间内受试者承受的所有痛苦，这本质上属于总结。相比之下，记忆自我保存的记忆是对代表性的时刻的感受，受到高峰和结束时刻的强烈影响。\n\n其他的经典研究表明，对老鼠大脑内的特殊区域（老鼠的大脑和人类的大脑相似）进行电刺激会产生强烈的快乐感，这种快乐感很强烈，以至于在某些情况下，老鼠（实验者可通过操纵杠杆刺激其大脑）会很兴奋，连停下来进食都不可能，最终被饿死。实验者可用不同电流强度和持续的电刺激能使大脑产生快乐的区域。需要再次强调的是，只有电流强度会起作用。在一定程度上，增加电刺激的持续时间并不会使动物更能感受到这种快感。支配人类记忆自我的规则有一个漫长的发展史\n\n##### 5.1.3 记忆没那么可靠\n几年前就一直困扰我的注射难题中最有用的一个想法就是：多次使人同样痛苦的注射，其体验效用可用计算注射次数的方法进行测量。如果所有的注射都同样令人厌恶，那么其中20次注射的痛苦程度会是10次注射的2倍，并且从20次注射减少至18次与从6次减少到4次给人们带来的减少痛苦感受的程度是相同的。如果决策效用与体验效用不相符，那么肯定是决策出错了。冰手实验也体现了这样的逻辑：持续90秒浸在冷水里比其前60秒在冷水里更痛苦。如果人们愿意选择忍受较长时间的浸泡，则说明他们的决定是错的。在我之前遇到的难题中，决策和体验之间的差异源于越来越小的敏感度：18次和20次之间的差异并不是很明显，似乎还没有6次和4次注射之间的差异明显。在冰手实验中，这种错误则反映出了记忆的两个原则：过程忽视和峰终定律。这些机制虽然不同，但结果却是一样的：决策与体验不协调。\n\n\n**示例 - 体验效用**\n\n> 你完全是从记忆自我的角度思考你失败的婚姻的。离婚就像是以刺耳的音符结束的交响乐。事实上，它虽然结束时很糟糕，但这并不意味着整首交响乐都那么糟。\n\n> 这是关于过程忽视的一个负面例子。尽管好的体验的时间要比不好的体验时间多10倍，但你还是将好的体验和不好的等同并加以权衡了。\n\n\n#### 5.2 人生如戏\n##### 5.2.1 比起整个人生，我们更在意人生的结局\n我们并非只在歌剧院才会感受到人生如同故事，并希望它会有个好结局。当我们听说一位和女儿疏远多年的妇人逝世时，也想知道她在死前是否已经与女儿冰释前嫌。我们所关心的不只是女儿的心情，而是希望这位母亲的故事更为圆满。关怀某个人通常体现在关心这个人故事的完整性，而不是他的感觉。一些事情还会改变已经去世的人的故事，这些事情也可能使我们深深动容。例如：一个男人到死都深信自己的妻子很爱他。所以，当我们听说他的妻子多年前就有了情夫，与这个男人在一起只是为了他的钱时，就会为这个男人感到悲哀。尽管，这个丈夫一生都很快乐，我们还是会同情他。若某位科学家的某项重要发现在她死后被证实是错误的，我们也会为她感到耻辱，尽管她自己并没有体验过这种耻辱。当然，更重要的是，我们都极度关注自己的人生故事，并希望故事的主角正派，结局完美。\n\n心理学家埃德·迪耶内(Ed Diener)及他的学生们对过程忽视和峰终定律是否会主宰我们对整个人生中所作的评估感到好奇。迪耶内简要地描述了简的一生（简是虚构出来的人物）：简从未结婚生子，一场车祸让她丧命，但死的时候并不痛苦。对于简的故事有这么一个版本：她一生都非常幸福（这种幸福可能持续了30年或60年），她将工作视为享受，喜爱度假，花了很多时间与朋友聚会，培养自己的爱好。在故事的第二个版本中，简的寿命被延长了5年，她于35岁或65岁逝世。迪耶内描述说简生命的最后5年很快乐，但不及从前那样快乐。每位受试者在读过其中一份为简设计好的“传记”以后，都需要回答两个问题，“纵观简的一生，你认为她的人生有多圆满”以及“你认为简的一生经历了多大的幸福或不幸”。\n\n**研究的结果进一步证实了过程忽视和峰终定律。**在组间实验中（不同受试者看到的实验情景不同），将简的寿命延长一倍不会使受试者对她人生的圆满度或是整体的幸福度改变观点。显然，她的一生是由一个典型的时间段代表，与总体的时间无关。因此，她的“总体幸福”是生命中一段典型时期体验到的幸福，而不是整个生命过程中体验到的幸福。\n\n由这个观点可以得知，迪耶内和他的学生们也发现了“少即是多”的效应。这个效应清楚地表明，平均（典型）可替代总体。若给原本一直都非常幸福的生命增加5年“还算幸福”的日子，会导致人们对这个生命总体幸福度的评估大幅降低。\n\n**在评估整个生命以及一些有趣的事时，高潮与结尾很重要，过程通常会被忽略。**\n\n##### 5.2.1 关于上一次旅行，你还能记起多少？\n请思考度假时的选择。你是希望在去年去过且很熟悉的海滩度过愉快的周末，还是想充实新的记忆？为了满足这些不同的选择，两种截然不同的行业随之出现：度假村提供了恢复元气的休闲方式；旅游业则帮助人们构建故事、收集记忆。许多旅行者会近乎疯狂地拍照，这说明储存记忆是人们旅游的重要目的，这个目的会影响我们旅游的计划和体验。照相的人并不认为当时的景色只能供自己欣赏片刻，他们将景色当做未来的记忆来收藏。照片对于记忆自我来说很有用，尽管我们很少会长时间或多次观看这些照片，有的照片我们甚至没再看过，但是拍照并不一定就是旅行者的经验自我欣赏风景的最佳方式。\n\n很多时候我们都通过自己想要储存的故事或记忆来评估旅行。“难忘”这个词常都用来描述旅行中的亮点，明确地阐述旅行的目的。在其他情况下，我们会想到“喜爱”这个词，这是对此刻永生难忘的宣言，尽管这并不总是准确，会随着时间的变化而变化。有自我意识的记忆体验会得到重视、被赋予意义，这是其他体验无法实现的\n\n埃德·迪耶内及他的团队提供的证据表明，是记忆自我选择了旅行方式。他们要求一些学生记日记，记录下春假期间他们对自己经历的评估。学生在假期结束之时，还需提供自己对整个假期的整体评估。最后，他们还需说明自己是否愿意再次这样度假。统计分析说明，他们是否想要重复假期的意愿完全取决于最后的评估，即使是最后的评分也不能代表他们在日记中描述的经历，他们依然会这样选择。就像冰手实验一样，无论对错，当人们在作是否重复某个经历的决定时，他们都会由记忆作出选择。\n\n\n#### 5.3 你有多幸福？\n有许多事是我们愿意继续、不想停止的，包括心理和生理上的愉悦。**我想到的海伦想要继续做下去的事情是全身心投入到某项工作中去，这种全身心投入的状态被米哈里称为心流。心流是艺术家在创作时、人们在被电影和书籍或是填字游戏深深吸引住时的一种状态。**人们处于这些情境时，往往不愿被打扰。我也有过类似的记忆：我小时候，当我母亲从我手中把玩具拿走，要带我去公园时，我总会哭。在公园里，当她将我从秋千上抱走，带我去玩滑梯时，我也会哭。抗拒中断当前事情表明：无论是玩玩具还是荡秋千，我当时都正玩得愉快。\n\n\n##### 5.3.1 测量经验自我的幸福感\n现在，我们可以通过手机来采集经验样本。**具体方法是：将某个人的手机设置为在每天任意的时间响或振动，随后，手机会在打断这个受试者后，显示一些关于她正在做什么以及和谁在一起的问题。手机还会显示评定量表，以供受试者报告她各种感受的强度，这些感受有：快乐、紧张、愤怒、担心、投入程度、身体上的疼痛等。**\n\n##### 5.4.1 幸福的方法\n巨大的样本使得我们可以进行全面的分析，证实了情境因素、生理健康以及社会接触等对于经验自我幸福感的重要性。当然，头痛也会使人痛苦，而某人某天感受的第二个最佳参照点就是这个人是否与朋友和亲人接触。说快乐就是将时间用在你爱的人和爱你的人身上的确有一点儿夸张。\n\n钱可以买到快乐吗？这是人们最常问的关于幸福的问题。对45万名受试者回应的盖洛普海斯威斯幸福指数分析以及对1000名美国人的每日调查，为我们提供了惊人而又明确的答案。结论是贫穷使人悲惨，富有可能会提升某个人的生活满意度，但总体来说来却不能提高经验自我的幸福感。\n\n**更高的收入会削弱人们享受生活中小乐趣的能力。**\n\n**示例--幸福感**\n\n> 增加幸福感的最简单方法是分配好你的时间。你能抽出更多时间做自己喜欢做的事情吗\n\n> 如果你的收入超过了满意水平，你能够拥有更多使人愉快的经历，但你将会丧失一些享受小乐趣的能力\n\n\n#### 5.4 思考生活\n##### 5.4.1 生活满意度：一个很难回答的问题\n\n##### 5.4.2 被放大了的幸福错觉\n分析了数据以后，我显然赢得了那场家庭辩论。正如预期的那样，两个地区的学生对天气的态度是不同的：加州人很享受当地的气候，而中西部人却厌恶当地的气候。然而，气候并不是决定幸福感的重要因素，甚至加州学生与中西部学生的生活满意度也根本没有任何不同。**我们还发现，我的妻子并不是唯一一个认为加州人更为幸福的人。两个地区的学生都犯了和我妻子同样的错误，我们还能追溯到此错误的根源，即他们都夸大了气候的重要性。我们将这种错误称为聚焦错觉。**\n\n聚焦错觉的本质是眼见即为事实，就上面例子来看，即是对气候给予过多的权重，却忽略了其他影响幸福的因素。为了理解这种错觉强大的影响力，请花几秒钟思考下面的问题：\n\n你从自己的车上能得到多大快乐？\n\n你能立刻得到答案，因为你知道自己有多喜爱和欣赏自己的车。你将其替换成了另一个不同的问题：“你在什么时候能从车中得到快乐？”这个问题的答案可能会令你惊奇，但也是简单直接的：当你考虑到自己的车时，你就能从车中得到快乐（或不快）。当然，你也不会常想到自己的车。正常情况下，你平时开车时是不会花很多时间思考自己的车的，你会想一些其他的事情，而你的心情也由你所想的事决定。当你尝试评估自己有多喜爱车时，你实际上回答的是另一个更为具体的问题：“当你考虑自己的车时，你能从车中得到多少快乐？”这个替换导致你忽略了自己很少想起车的事实，这是过程忽视的一种形式。其结果就是聚焦忽略。如果你喜欢自己的车，你就有可能夸大从其中得到的快乐，这会使你在想到当前这辆车的优点或是考虑是否要买辆新车时出现错觉。\n\n类似的偏见使得人们对加州人幸福感的判断发生了偏差。当被问到加州人的幸福感时，你可能会想到加州比较特别的活动，例如夏天可以爬山，或是羡慕那里冬天气候温和。但事实上，加州人很少参与那些活动。不仅如此，加州的常驻居民在对自己的生活进行总体评估时，根本没怎么想到气候这个问题。如果你一生都住在加州，而且不怎么去旅游的话，那么加州就像自己的10根脚趾一样，会觉得它们很重要，但却不会时常想到它们。如果生活中任意一方面的想法有很强的可替代性的话，此方面就更有可能被凸显出来。\n\n聚焦错觉能使人们对自己当前的幸福状态、他人的幸福感以及自己未来的幸福感判断错误。\n\n\n半身瘫痪的人一天中有多长时间情绪低落？\n\n半身瘫痪者的幸福感在大多数时候都是接近于正常水平的。想要适应一个新的环境，无论这个环境是好还是坏，在很大程度上取决于慢慢地不去想这个环境。从这个意义上来看，生活的长期状况（包括半身瘫痪和婚姻）只在部分时间会对人们的状态产生影响，即当人们关注于这些状况的时候。\n\n聚焦错觉会产生一种偏见，这种偏见会导致人们更加看好本身就能令人兴奋的事物或经历，即使这些事物或经历最终也会失去吸引力。人们忽视了时间，致使维持人们长久的注意力价值的经验很少受到关注，至少比这种经验应得到的关注要少。\n\n##### 5.4.3 千万不要忽略时间的作用\n本书中不断重复时间的重要性。将经验自我的生活描述为一系列有价值的时刻是符合逻辑的。某个生活阶段的价值（我曾称其为快乐总量）就是这一阶段所有价值的总和。不过，这不是大脑呈现各个阶段的方法。我曾提到过，记忆自我同样也会讲故事和作出选择，而且它讲的故事和作出的选择都不能恰当地表示时间。**在讲故事时，一些关键的时刻，特别是开始、高潮和结尾，代表了整个生活阶段，过程因此就被忽略掉了。**\n\n\n**示例--生活思考**\n\n> 她认为买一辆豪车会使自己更为快乐，但这其实是个情感预测错误。\n\n> 今天早上，他的车在上班途中坏掉了，因此，他的心情非常糟糕。今天并不适合问他关于工作满意度的问题\n\n> 她平时看起来都很开心，但当我们问她是否快乐时，她说自己并不快乐。这个问题肯定使她想到了自己最近离婚这件事\n\n> 买一座更大的房子可能不会使我们永远感到快乐。我们可能会因为犯聚焦错觉的错误而遭殃。\n\n> 他选择了在两座城市间之间奔波往返。这可能是一个错误想法的典型例子","tags":["系统A和系统B","快运算思考方式","慢运算思考方式"]},{"title":"渲染帧率","url":"/2023/02/24/渲染帧率/","content":"\n### 帧率（FPS）\n每秒的帧数(fps)或者说帧率表示图形处理器处理场时每秒钟能够更新的次数。高的帧率可以得到更流畅、更逼真的动画。一般来说30fps就是可以接受的，但是将性能提升至60fps则可以明显提升交互感和逼真感，但是一般来说超过75fps一般就不容易察觉到有明显的流畅度提升了。如果帧率超过屏幕刷新率只会浪费图形处理的能力，因为监视器不能以这么快的速度更新，这样超过刷新率的帧率就浪费掉了。 \n\n\n\n### 浏览器渲染帧的过程\n渲染帧是指浏览器一次完整绘制过程，帧之间的时间间隔是 DOM 视图更新的最小间隔。 由于主流的屏幕刷新率都在 60Hz，那么渲染一帧的时间就必须控制在 16ms（1000ms/60hz） 才能保证不掉帧。 也就是说每一次渲染都要在 16ms 内页面才够流畅不会有卡顿感。 这段时间内浏览器需要完成如下事情：\n1. 脚本执行（JavaScript）：脚本造成了需要重绘的改动，比如增删 DOM、请求动画等\n2. 样式计算（CSS Object Model）：级联地生成每个节点的生效样式。\n3. 布局（Layout）：计算布局，执行渲染算法\n4. 重绘（Paint）：各层分别进行绘制（比如 3D 动画）\n5. 合成（Composite）：合成各层的渲染结果\n\n### 耗时 JS 会造成丢帧\n\n```js\n// JavaScript 忙的状态（持续 5s）下每隔 1s 新增一行 DOM 内容\n// 可以观察到虽然每秒都会写一次 DOM，但在 5s 结束后才会全部渲染出来，明显耗时脚本阻塞了渲染\n<div id=\"message\"></div>\n<script>\nvar then = Date.now()\nvar i = 0\nvar el = document.getElementById('message')\nwhile (true) {\n  var now = Date.now()\n  if (now - then > 1000) {\n    if (i++ >= 5) {\n      break;\n    }\n    el.innerText += 'hello!\\n'\n    console.log(i)\n    then = now\n  }\n}\n</script>\n```\n\n### 测量渲染帧间隔 (requestAnimationFrame)\nrequestAnimationFrame 使用这个 API 可以请求浏览器在下一个渲染帧执行某个回调\n\n```js\nvar then = Date.now();\nvar count = 0;\nvar reportCount = 20;\n\nfunction nextFrame(){\n  requestAnimationFrame(function(){\n    count ++\n    if(count % reportCount === 0){\n      var time = (Date.now() - then) / count; \n      var ms = Math.round(time*1000) / 1000; // 每一帧耗时\n      var fps = Math.round(100000/ms) / 100; // 1秒钟渲染了多少帧\n      console.log(`count: ${count}\\t${ms}ms/frame\\t${fps}fps`);\n    }\n    nextFrame()\n  })\n}\nnextFrame()\n```\n优化版本：\n\n```js\nlet lastTime = performance.now()\nlet frame = 0\nlet lastFameTime = performance.now()\nlet fpsList = [];\nconst reportCount = 20;  // 每20秒上报一次\n \nfunction loop(time) {\n  let now =  performance.now()\n  let fs = (now - lastFameTime)\n  lastFameTime = now\n  let fps = Math.round(1000 / fs)\n  frame++\n  if (now > 1000 + lastTime) {\n    fps = Math.round(( frame * 1000 ) / ( now - lastTime ))\n    frame = 0\n    lastTime = now\n    addFpsPreSecond(fps);\n  }    \n  window.requestAnimationFrame(loop)\n}\nloop();\n \nfunction addFpsPreSecond (fps) {\n    fpsList.push(fps);\n    if (fpsList.length >= reportCount) {\n        const avgFps = fpsList.reduce((acc, val) => acc + val, 0) / fpsList.length;\n        fpsList = [];\n        reportAvgFps(avgFps);\n    }\n}\n \n// 进行上报\nfunction reportAvgFps (avgFps) {\n    console.log(`20s 内平均帧率为：${avgFps}`);\n}\n \n```\n","tags":["浏览器最佳渲染","游戏渲染","requestAnimationFrame"]},{"title":"vue2.5源码分析","url":"/2023/02/17/vue2-5源码分析/","content":"\n\n## 1、带着问题看书\n1. vue响应式原理，为啥修改数据视图会自动更新？\n2. 虚拟dom的概念和原理，为啥要引入vnode?\n3. 模板编译原理，vue的模板是如何生效？\n4. vue整体架构设计和项目结构？\n5. 不同的生命周期钩子之间的区别，不同的生命周期之间vue内部到底做了什么？\n6. vue提供全局的api内部原理？\n7. 过滤器实现原理？\n\n## 2、vue介绍\n### 1、什么是渐进式框架\n所谓渐进式框架（The Progressive Framework），就是把框架分层。\n\n最核心的部分是视图层渲染，然后往外是组件机制，在这个基础上再加入路由机制，再加入状态管理，最外层是构建工具。 \n\n所谓分层，就是说你既可以只用最核心的视图层渲染功能来快速开发一些需求，也可以使用一整套全家桶来开发大型应用。Vue.js有足够的灵活性来适应不同的需求，所以你可以根据自己的需求选择不同的层级。\n\n<img src=\"/img/vue1.jpeg\" style=\"max-width:95%\" />\n\n### 2、为啥要引入虚拟DOM\nVue.js引入虚拟DOM是有原因的。事实上，并不是引入虚拟DOM后，渲染速度变快了。准确地说，应该是80% 的场景下变得更快了，而剩下的20% 反而变慢了。\n\n任何技术的引入都是在解决一些问题，而通常解决一个问题的同时会引发另外一个问题，这种情况更多的是做权衡，做取舍。\n\n## 3、变化侦测\n### 1、介绍\n**从状态生成DOM，再输出到用户界面显示的一整套流程叫作渲染，应用在运行时会不断地进行重新渲染。**而响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。变化侦测是响应式系统的核心，没有它，就没有重新渲染。框架在运行时，视图也就无法随着状态的变化而变化。\n\n### 2、Object的变化侦测\n大部分人不会想到Object和Array的变化侦测采用不同的处理方式。事实上，它们的侦测方式确实不一样。\n\n#### 2.1 什么是变化侦测\nVue.js会自动通过状态生成DOM，并将其输出到页面上显示出来，这个过程叫渲染。Vue.js的渲染过程是声明式的，我们通过模板来描述状态与DOM之间的映射关系。\n\n变化侦测就是用来解决这个问题的，它分为两种类型：一种是“推”（push），另一种是“拉”（pull）。\n\nAngular和React中的变化侦测都属于“拉”，这就是说当状态发生变化时，它不知道哪个状态变了，只知道状态有可能变了，然后会发送一个信号告诉框架，框架内部收到信号后，会进行一个暴力比对来找出哪些DOM节点需要重新渲染。这在Angular中是脏检查的流程，在React中使用的是虚拟DOM。\n\n而Vue.js的变化侦测属于“推”。当状态发生变化时，Vue.js立刻就知道了，而且在一定程度上知道哪些状态变了。因此，它知道的信息更多，也就可以进行更细粒度的更新。\n\n更细粒度的更新也有一定代价，因为粒度越细，每个状态所绑定的依赖就越多，依赖追踪在内存上的开销就会越大。\n\n#### 2.2 如何追踪变化\n**两种方法可以侦测到变化：使用Object.defineProperty 和 ES6的Proxy。**\n\n\n```js\nfunction defineReactive(data, key, val){\n   Object.defineProperty(data, key, {\n      enumerable: true,\n      configurable: true,\n      get: function(){\n        return val;\n      },\n      set: function(newVal){\n        if(val !== newVal){\n           val = newVal;\n        }\n      }\n   });\n}\n```\n\n封装好之后，每当从data的key中读取数据时，get函数被触发；每当往data的key中设置数据时，set函数被触发。\n\n#### 2.3 如何依赖收集\n如果只是把Object.defineProperty进行封装，那其实并没什么实际用处，真正有用的是收集依赖。\n\n下面例子中，该模板中使用了数据name，所以name它发生变化时，要向使用了它的地方发送通知。\n\n```js\n<temple>\n <h1>{{ name }}</h1>\n</temple>\n```\n\n*在Vue.js 2.0中，模板使用数据等同于组件使用数据，所以当数据发生变化时，会将通知发送到组件，然后组件内部再通过虚拟DOM重新渲染。*\n\n对于上面的问题，我的回答是：**先收集依赖，即把用到数据name的地方收集起来，然后等属性发生变化时，把之前收集好的依赖循环触发一遍就好了。总结起来，其实就一句话，在getter中收集依赖，在setter中触发依赖。**\n\n#### 2.4 依赖收集在哪里\n思考一下，首先想到的是每个key都有一个数组，用来存储当前key的依赖。假设依赖是一个函数，保存在window.target上，现在就可以把defineReactive函数稍微改造一下：\n\n```js\nfunction defineReactive(data, key, val) {\n  const dep = []; // 新增\n  Object.defineProperty(data, key, {\n    enumerable: true,\n    configurable: true,\n    get: function() {\n      dep.push(window.target);  // 新增, window.target是啥东西？？？\n      return val;\n    },\n    set: function(newVal){\n      if(val === newVal) return;\n      // 新增\n      if(let i=0; i<dep.length; i++){\n         dep(i)[newVal, val];\n      }\n      val = newVal;\n    }\n  });\n}\n```\n这里我们新增了数组dep，用来存储被收集的依赖；然后在set被触发时，循环dep以触发收集到的依赖。\n\n但是这样写有点耦合，我们把依赖收集的代码封装成一个Dep类，它专门帮助我们管理依赖。使用这个类，我们可以收集依赖、删除依赖或者向依赖发送通知等。其代码如下：\n\n```js\nexport default class Dep {\n  constructor(){\n    this.subs = [];\n  }\n  \n  addSub(sub){\n    this.subs.push(sub);\n  }\n  \n  removeSub(sub){\n    remove(this.subs. sub);\n  }\n  \n  depend(){\n    if(window.target){\n       this.addSub(window.target);\n    }\n  }\n\n  notify(){\n    const subs = this.subs.slice();\n    for(let i=0; l=subs.length; i<l; i++){\n      subs[i].update();\n    }\n  }\n}\n\nfunction remove(arr, item){\n   if(arr.length){\n     const index = arr.indexOf(item);\n     if(index > -1){\n       return arr.splice(index, 1);\n     }\n   }\n}\n```\n改造一下defineReactive：\n\n```js\nfunction defineReactive(data, key, val){\n   let dep = new Dep();\n   Object.defineReactive(data, key, {\n     enumerable: true,\n     configurable： true,\n     get: function(){\n       dep.depend(); // 收集依赖\n       return val;\n     },\n     set: function(newVal){\n       if(val === newVal) return;\n       val = newVal;\n       dep.notfiy();\n     }\n   });\n}\n```\n\n#### 2.5 依赖是谁\n在上面的代码中，我们收集的依赖是window.target，那么它到底是什么？我们究竟要收集谁呢？\n\n收集谁，换句话说，就是当属性发生变化后，通知谁。\n\n我们要通知用到数据的地方，而使用这个数据的地方有很多，而且类型还不一样，既有可能是模板，也有可能是用户写的一个watch，这时需要抽象出一个能集中处理这些情况的类。然后，我们在依赖收集阶段只收集这个封装好的类的实例进来，通知也只通知它一个。接着，它再负责通知其他地方。所以，我们要抽象的这个东西需要先起一个好听的名字。嗯，就叫它Watcher吧。\n\n现在就可以回答上面的问题了，收集谁？Watcher！\n#### 2.6 什么是Watcher\nWatcher是一个中介的角色，数据发生变化时通知它，然后它再通知其他地方。\n\n```js\n// 这段代码表示当data.a.b.c属性发生变化时，触发第二个参数中的函数。\nvm.$watch('a.b.c', function(newVal, oldVal){\n   \n})\n```\n\n思考一下，怎么实现这个功能呢？好像只要把这个watcher实例添加到data.a.b.c属性的Dep中就行了。然后，当data.a.b.c的值发生变化时，通知Watcher。接着，Watcher再执行参数中的这个回调函数。\n\n代码如下：\n\n```js\nexport default class Watcher {\n  constructor(vm, expOrFn, cb){\n    this.vm = vm;\n    this.getter = parsePath(expOrFn); // 解析data.a.b.c\n    this.cb = cb;\n    this.value = this.get();\n  }\n\n  get(){\n    window.target = this;\n    let value = this.getter.call(this.vm, this.vm);\n    window.target = undefined;\n    return value;\n  }\n\n  update(){\n    const oldValue = this.value;\n    this.value = this.get();\n    this.cb.call(this.vm, this.value, oldValue)\n  }\n}\n\nfunction parsePath(path){\n  const bailER = /[^\\w.$]/;\n  if(bailER.test(path)){\n    return;\n  }\n  const segments = path.split('.');\n  return function (obj){\n    for(let i=0; i<segments.length; i++){\n       if(!obj) return;\n       obj = obj[segments[i]];\n    }\n    return obj;\n  }\n}\n```\n\n#### 2.7 递归侦测所有key\n现在，其实已经可以实现变化侦测的功能了，但是前面介绍的代码只能侦测数据中的某一个属性，我们希望把数据中的所有属性（包括子属性）都侦测到，所以要封装一个Observer类。这个类的作用是将一个数据内的所有属性（包括子属性）都转换成getter/setter的形式，然后去追踪它们的变化：\n\n```js\n/**\n* Observer类会附加到每一个被侦测的object上。\n* 一旦被附加上，Observer会将object的所有属性转换为getter/setter的形式\n* 来收集属性的依赖，并且当属性发生变化时会通知这些依赖\n*/\n\nexport class Observer {\n  constructor(value){\n    this.value = value;\n    if(!Array.isArray(value)){\n      this.wall(value);\n    }\n  }\n\n  walk(obj){\n    const keys = Object.keys(obj);\n    for(let i = 0; i < keys.length; i++){\n      defineReactive(obj, keys[i], obj[keys[i]]);\n    }\n  }\n}\n\nfunction defineReactive(data, key, val){\n  // 递归子属性\n   if(typeof val === 'object'){\n     new Observer(val)\n   }\n\n   let dep = new Dep();\n   Object.defineProperty(data, key, {\n      enumerable: true,\n      configruable: true,\n      get(){\n        dep.depend();\n        return val;\n      }\n      set(newVal){\n        if(val === newVal) return;\n        val = newVal;\n        dep.notfiy();\n      }\n   });\n}\n```\n\n#### 2.8 关于Object的问题\n前面介绍了Object类型数据的变化侦测原理，了解了数据的变化是通过getter/setter来追踪的。也正是由于这种追踪方式，有些语法中即便是数据发生了变化，Vue.js也追踪不到：\n\n1. 新增属性：我们在obj上面新增了name属性，Vue.js无法侦测到这个变化，所以不会向依赖发送通知\n2. 删除属性：我们在action方法中删除了obj中的name属性，而Vue.js无法侦测到这个变化，所以不会向依赖发送通知。\n\nVue.js通过Object.defineProperty来将对象的key转换成getter/setter的形式来追踪变化，但getter/setter只能追踪一个数据是否被修改，无法追踪新增属性和删除属性，所以才会导致上面例子中提到的问题。\n\n但这也是没有办法的事，因为在ES6之前，JavaScript没有提供元编程的能力，无法侦测到一个新属性被添加到了对象中，也无法侦测到一个属性从对象中删除了。为了解决这个问题，Vue.js提供了两个API——vm.$set与vm.$delete，\n\n#### 2.9 总结\n变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。\n\nObject可以通过Object.defineProperty将属性转换成getter/setter的形式来追踪变化。读取数据时会触发getter，修改数据时会触发setter。\n\n我们需要在getter中收集有哪些依赖使用了数据。当setter被触发时，去通知getter中收集的依赖数据发生了变化。\n\n收集依赖需要为依赖找一个存储依赖的地方，为此我们创建了Dep，它用来收集依赖、删除依赖和向依赖发送消息等。\n\n所谓的依赖，其实就是Watcher。只有Watcher触发的getter才会收集依赖，哪个Watcher触发了getter，就把哪个Watcher收集到Dep中。当数据发生变化时，会循环依赖列表，把所有的Watcher都通知一遍。\n\nWatcher的原理是先把自己设置到全局唯一的指定位置（例如window.target），然后读取数据。因为读取了数据，所以会触发这个数据的getter。接着，在getter中就会从全局唯一的那个位置读取当前正在读取数据的Watcher，并把这个Watcher收集到Dep中去。通过这样的方式，Watcher可以主动去订阅任意一个数据的变化。\n\n此外，我们创建了Observer类，它的作用是把一个object中的所有数据（包括子数据）都转换成响应式的，也就是它会侦测object中所有数据（包括子数据）的变化。\n\n**Data、Observer、Dep和Watcher之间的关系:**\n\n<img src=\"/img/vue2.jpeg\" style=\"max-width:95%\" />\n\nData通过Observer转换成了getter/setter的形式来追踪变化;\n\n当外界通过Watcher读取数据时，会触发getter从而将Watcher添加到依赖中;\n\n当数据发生了变化时，会触发setter，从而向Dep中的依赖（Watcher）发送通知;\n\nWatcher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。\n\n### 3、 Array的变化侦测\n#### 3.1 介绍\n这个例子使用了push方法来改变数组，并不会触发getter/setter\n\n```js\nthis.list.push(1); \n```\n\n正因为我们可以通过Array原型上的方法来改变数组的内容，所以Object那种通过getter/setter的实现方式就行不通了\n\n#### 3.2 如何追踪变化\nObject的变化是靠setter来追踪的，只要一个数据发生了变化，一定会触发setter。\n\n在ES6之前，JavaScript并没有提供元编程的能力，也就是没有提供可以拦截原型方法的能力，但是这难不倒聪明的程序员们。我们可以用自定义的方法去覆盖原生的原型方法。  \n\n我们可以用一个拦截器覆盖Array.prototype。之后，每当使用Array原型上的方法操作数组时，其实执行的都是拦截器中提供的方法，比如push方法。然后，在拦截器中使用原生Array的原型方法去操作数组。\n\n#### 3.3 拦截器\n拦截器其实就是一个和Array.prototype一样的Object，里面包含的属性一模一样，只不过这个Object中某些可以改变数组自身内容的方法是我们处理过的。\n\n我们发现Array原型中可以改变数组自身内容的方法有7个，分别是push、pop、shift、unshift、splice、sort和reverse。\n\n```js\nconst arrayProto = Array.prototype;\nexport const ArrayMethods = Object.create(arrayProto); // 新对象， 继承Array.prototype\n\n['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function(method){\n    // 缓存原始方法\n    const original = arrayProto[method];\n\n    Object.defineProperty(ArrayMethods, method, {\n        value: function mutator(...args) {\n            return original.apply(this, args);\n        },\n        enumerable: false,\n        writable: true,\n        configurable: true\n    })\n})\n```\n\n我们创建了变量arrayMethods，它继承自Array.prototype，具备其所有功能。未来，我们要使用arrayMethods去覆盖Array.prototype\n\n接下来，在arrayMethods上使用Object.defineProperty方法将那些可以改变数组自身内容的方法（push、pop、shift、unshift、splice、sort和reverse）进行封装。\n\n所以，当使用push方法的时候，其实调用的是arrayMethods.push，而arrayMethods.push是函数mutator，也就是说，实际上执行的是mutator函数。（我们就可以在mutator函数中做一些其他的事，比如说发送变化通知）\n\n最后，在mutator中执行original（它是原生Array.prototype上的方法，例如Array.prototype.push）来做它应该做的事，比如push的功能。\n\n\n#### 3.4 使用拦截器覆盖Array原型\n有了拦截器之后，想要让它生效，就需要使用它去覆盖Array.prototype。但是我们又不能直接覆盖，因为这样会污染全局的Array，这并不是我们希望看到的结果。我们希望拦截操作只针对那些被侦测了变化的数据生效，也就是说希望拦截器只覆盖那些响应式数组的原型。\n\n而将一个数据转换成响应式的，需要通过Observer，所以我们只需要在Observer中使用拦截器覆盖那些即将被转换成响应式Array类型数据的原型就好了：\n\n```js\nexport class Observer {\n  constructor(value){\n    this.value = value;\n\n    if(Array.isArray(value)){\n       value.__proto__ = ArrayMethods;\n    }else{\n      this.walk(value);\n    }\n  }\n}\n```\n通过 \\__proto__ 可以很巧妙地实现覆盖value原型的功能\n\n<img src=\"/img/vue3.png\" style=\"max-width:95%\" />\n\n#### 3.5 将拦截器方法挂载到数组的属性上\n虽然绝大多数浏览器都支持这种非标准的属性（在ES6之前并不是标准）来访问原型，但并不是所有浏览器都支持！因此，我们需要处理不能使用 \\__proto__ 的情况。 \n\nVue的做法非常粗暴，如果不能使用 \\__proto__，就直接将arrayMethods身上的这些方法设置到被侦测的数组上\n\n```js\nimport { arrayMethods } from './array';\n\nconst hasProto = '__proto__' in {};\nconst arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\nfunction protoAugment(target, src, keys){\n    target.__proto__ = src;\n}\n\nfunction copyAugment(target, src, keys){\n  for(let i=0; i<keys.length; i++){\n      const key = keys[i];\n      def(target, key, src[key]);\n  }\n}\n\nexport class Observer {\n  constructor(value){\n     this.value = value;\n     if(Array.isArray(value)){\n        const augment = hasProto ? protoAugment : copyAugment; // 增强\n        augment(value, arrayMethods, arrayKeys);\n     }else{\n         this.walk(value);\n     }\n  }\n}\n```\n\n在浏览器不支持 __proto__ 的情况下，会在数组上挂载一些方法。当用户使用这些方法时，其实执行的并不是浏览器原生提供的Array.prototype上的方法，而是拦截器中提供的方法。 \n\n因为当访问一个对象的方法时，只有其自身不存在这个方法，才会去它的原型上找这个方法。\n\n#### 3.6 如何收集依赖\n可能你也发现了，如果只有一个拦截器，其实还是什么事都做不了。为什么会这样呢？因为我们之所以创建拦截器，本质上是为了得到一种能力，一种当数组的内容发生变化时得到通知的能力。\n\n而现在我们虽然具备了这样的能力，但是通知谁呢？前面我们介绍Object时说过，答案肯定是通知Dep中的依赖（Watcher），但是依赖怎么收集呢？这就是本节要介绍的内容，如何收集数组的依赖！\n\n\n**Array在getter中收集依赖，在拦截器中触发依赖。**\n\n#### 3.7 依赖列表存在哪儿\nVue.js把Array的依赖存放在Observer中：\n\n```js\nexport class Observer {\n  constructor(value){\n     this.value = value;\n     this.dep = new Dep();\n\n     if(Array.isArray(value)){\n        const augment = hasProto ? protoAugment : copyAugment;\n        augment(value, arrayMethods, arrayKeys);\n     }else{\n        this.walk(value);\n     }\n  }\n}\n```\n\n#### 3.8 收集依赖\n把Dep实例保存在Observer的属性上之后，我们可以在getter中像下面这样访问并收集依赖：\n\n```js\nfunction defineReactive(data, key, val){\n  let childOb = observe(val); // 修改\n  let dep = new Dep(); \n  Object.defineProperty(data, key, {\n    enumerable: true,\n    configruable: true,\n    get: function(){\n      dep.depend();\n      if(childOb){\n        childOb.dep.depend();\n      }\n      return val;\n    },\n    set: function(newVal){\n      if(val === newVal) return;\n      dep.notfiy();\n      val = newVal;\n    }\n  })\n}\n\n/**\n * 尝试为value创建一个Observer实例，\n * 如果创建成功，直接返回新创建Observer实例，\n * 如果value已经存在一个Observer实例，则直接返回它\n */\nexport function observe(value, asRootData){\n  if(!isObject(value)) return;\n  let ob;\n  if(hasOwn(value, '__ob__') && value.__ob__ instanceof Observer){\n    ob = value.__ob__;\n  }else{\n    ob = new Observer(value);\n  }\n  return ob;\n}\n```\n\n#### 3.9 在拦截器中获取Observer实例\n因为Array拦截器是对原型的一种封装，所以可以在拦截器中访问到this（当前正在被操作的数组）。\n\n而dep保存在Observer中，所以需要在this上读到Observer的实例：\n\n```js\n// 工具函数\nfunction def (data, key, val, enumerable){\n  Object.defineProperty(obj, key, {\n     value: val,\n     enumerable: !!enumerable,\n     writable: true,\n     configurable: true\n  })\n}\n\nexport class Observer {\n  constructor(value){\n    this.value = value;\n    this.dep = new Dep();\n    def(value, '__ob__', this); //新增\n\n    if(Array.isArray(value)){\n       const augment = hasProto ？ protoAugment : copyAugment;\n       augment(value, arrayMethods, arrayKeys);\n    }else{\n       this.walk(value);\n    }\n  }\n}\n```\n\n所有被侦测了变化的数据身上都会有一个 \\__ob__ 属性来表示它们是响应式的。上一节中的observe函数就是通过 \\__ob__ 属性来判断：如果value是响应，如果value是响应式的，则直接返回 \\__ob__；如果不是响应式的，则使用new Observer来将数据转换成响应式数据。\n\n当value身上被标记了 \\__ob__ 之后，就可以通过value.\\__ob__ 来访问Observer实例。如果是Array拦截器，因为拦截器是原型方法，所以可以直接通过this.\\__ob__来访问Observer实例。例如：\n\n```js\n['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].\nforEach(function(method){\n  const original = arrayProto[method];\n  Object.defineProperty(arrayMethods, method, {\n    value: function muator (...args){\n      const ob = this.__ob__; // 新增\n      return original.apply(this, args);\n    },\n    enumerable: false,\n    writable: true,\n    configurable: true \n  })\n})\n```\n\n#### 3.10 向数组的依赖发送通知\n当侦测到数组发生变化时，会向依赖发送通知。此时，首先要能访问到依赖。前面已经介绍过如何在拦截器中访问Observer实例，所以这里只需要在Observer实例中拿到dep属性，然后直接发送通知就可以了：\n\n```js\n['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].\nforEach(function(method){\n  // 缓存原始方法\n  const original = arrayProto[method];\n  def(arrayMethods, method, function mutator(...args){\n      const result = original.apply(this, args);\n      const ob = this.__ob__;\n      ob.dep.notfiy(); // 通知依赖\n      return result; \n  });\n})\n```\n在上面的代码中，我们调用了ob.dep.notify()去通知依赖（Watcher）数据发生了改变。\n\n#### 3.11 侦测数组中元素的变化\n我们要在Observer中新增一些处理，让它可以将Array也转换成响应式的:\n\n```js\nexport class Observer {\n  constructor(value){\n    this.value = value;\n    def(value, '__ob__', this);\n\n    if(Array.isArray(valye)){\n      this.observeArray(value);\n    }else{\n      this.walk(value);\n    }\n  }\n  \n  // 侦测Array中每一项\n  ObserveArray(items){\n     for(let i=0, l=items.length; i<l; i++){\n       observe(item[i]);\n     }\n  }\n}\n```\n这里新增了observeArray方法，其作用是循环Array中的每一项，执行observe函数来侦测变化。前面介绍过observe函数，其实就是将数组中的每个元素都执行一遍new Observer，这很明显是一个递归的过程。\n\n现在只要将一个数据丢进去，Observer就会把这个数据的所有子数据转换成响应式的。接下来，我们介绍如何侦测数组中新增元素的变化。\n\n#### 3.12 侦测新增元素的变化\n数组中有一些方法是可以新增数组内容的，比如push，而新增的内容也需要转换成响应式来侦测变化，否则会出现修改数据时无法触发消息等问题。因此，我们必须侦测数组中新增元素的变化。\n\n**其实现方式其实并不难，只要能获取新增的元素并使用Observer来侦测它们就行。**\n\n##### 3.12.1 获取新增元素\n想要获取新增元素，我们需要在拦截器中对数组方法的类型进行判断。如果操作数组的方法是push、unshift和splice（可以新增数组元素的方法），则把参数中新增的元素拿过来，用Observer来侦测：\n\n```js\n['pop', 'push', 'shift', 'splice', 'sort', 'reverse'].\nforEach(function(method){\n  const original = arrayProto[method];\n  def(arrayMethod, method, function muator(...args){\n     const result = original.apply(this, args);\n     const ob = this.__ob__;\n     let inserted;\n     switch(method){\n         case 'push':\n         case 'unshift':\n          inserted = true;\n          break;\n         case 'splice':\n          inserted = args.slice(2);\n          break;  \n     }\n     ob.dep.notify();\n     return result;\n  });\n})\n```\n我们通过switch对method进行判断，如果method是push、unshift、splice这种可以新增数组元素的方法，那么从args中将新增元素取出来，暂存在inserted中。\n\n接下来，我们要使用Observer把inserted中的元素转换成响应式的。\n\n##### 3.12.2 使用Observer侦测新增元素\n前面介绍过Observer会将自身的实例附加到value的 \\__ob__ 属性上。所有被侦测了变化的数据都有一个 \\__ob__ 属性，数组元素也不例外。\n\n因此，我们可以在拦截器中通过this访问到 \\__ob__，然后调用 \\__ob__ 上的observeArray方法就可以了：\n\n```js\n['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].\nforEach(function(method){\n   const original = arrayProto[method];\n   def(arrayMethods, method, function mutator(...args){\n     const result = original.apply(this, args);\n     const ob = this.__ob__;\n     let inserted;\n     switch(method){\n        case 'push':\n        case 'unshift':\n          inserted = true;\n          break;\n         case 'splice':\n           inserted = args.slice(2);\n           break; \n     }\n     if(inserted) ob.observerArray(inserted); \n     ob.dep.notfiy();\n     return result;\n   })\n})\n```\n\n#### 3.15 关于Array的问题\n\n```js\nthis.list[0] = 1; //  即修改数组中第一个元素的值时，无法侦测到数组的变化\nthis.list.lengt = 0; // 这个清空数组操作也无法侦测到数组的变化，所以也不会触发re-render或watch等。\n```\n\n因为Vue.js的实现方式决定了无法对上面举的两个例子做拦截，也就没有办法响应。在ES6之前，无法做到模拟数组的原生行为，所以拦截不到也是没有办法的事情。ES6提供了元编程的能力，所以有能力拦截，我猜测未来Vue.js很有可能会使用ES6提供的Proxy来实现这部分功能，从而解决这个问题。\n\n#### 3.13 总结\nArray追踪变化的方式和Object不一样。因为它是通过方法来改变内容的，所以我们通过创建拦截器去覆盖数组原型的方式来追踪变化。\n\n为了不污染全局Array.prototype，我们在Observer中只针对那些需要侦测变化的数组使用 \\__proto__ 来覆盖原型方法，但 \\__proto__ 在ES6之前并不是标准属性，不是所有浏览器都支持它。因此，针对不支持 \\__proto__ 属性的浏览器，我们直接循环拦截器，把拦截器中的方法直接设置到数组身上来拦截Array.prototype上的原生方法。\n\nArray收集依赖的方式和Object一样，都是在getter中收集。但是由于使用依赖的位置不同，数组要在拦截器中向依赖发消息，所以依赖不能像Object那样保存在defineReactive中，而是把依赖保存在了Observer实例上。\n\n在Observer中，我们对每个侦测了变化的数据都标上印记 \\__ob__，并把this（Observer实例）保存在 \\__ob__ 上。这主要有两个作用，一方面是为了标记数据是否被侦测了变化（保证同一个数据只被侦测一次），另一方面可以很方便地通过数据取到 \\__ob__，从而拿到Observer实例上保存的依赖。当拦截到数组发生变化时，向依赖发送通知。\n\n除了侦测数组自身的变化外，数组中元素发生的变化也要侦测。我们在Observer中判断如果当前被侦测的数据是数组，则调用observeArray方法将数组中的每一个元素都转换成响应式的并侦测变化。\n\n除了侦测已有数据外，当用户使用push等方法向数组中新增数据时，新增的数据也要进行变化侦测。我们使用当前操作数组的方法来进行判断，如果是push、unshift和splice方法，则从参数中将新增数据提取出来，然后使用observeArray对新增数据进行变化侦测。\n\n由于在ES6之前，JavaScript并没有提供元编程的能力，所以对于数组类型的数据，一些语法无法追踪到变化，只能拦截原型上的方法，而无法拦截数组特有的语法，例如使用length清空数组的操作就无法拦截。\n\n### 4、变化侦测相关的API实现原理\n#### 4.1 vm.$watch\n##### 4.1.1 用法\n用于观察一个表达式或computed函数在Vue.js实例上的变化。回调函数调用时，会从参数得到新数据（new value）和旧数据（old value）。表达式只接受以点分隔的路径，例如a.b.c。如果是一个比较复杂的表达式，可以用函数代替表达式。\n\n```js\nlet unwatch = vm.$watch('a.b.c', function (newVal, oldVal) {\n    // 做点什么\n});\n\nunwatch(); // vm.$watch返回一个取消观察函数，用来停止触发回调：\n```\n\n**deep。为了发现对象内部值的变化，可以在选项参数中指定deep: true：**\n\n```js\nvm.$watch('someObj', callback, {\n  deep: true\n});\nvm.someObj.a = 12; \n// 回调函数讲被触发\n// 这里需要注意的是，监听数组的变动不需要这么做。\n```\n**immediate。在选项参数中指定immediate: true，将立即以表达式的当前值触发回调：**\n\n```js\nvm.$watch('a', callback, {\n  immediate: true\n});\n// 立即以 a 的当前值触发回调\n```\n##### 4.1.2 原理\nvm.$watch其实是对Watcher的一种封装，但vm.$watch中的参数deep和immediate是Watcher中所没有的。下面我们来看一看vm.$watch到底是怎么实现的：\n\n```js\nVue.prototype.$watch = function(expOrFn, cb, options){\n  const vm = this;\n  options = options || {};\n  const watcher = new Watcher(vm, expOrFn, cb, options);\n\n  if(options.immediate){\n      cb.call(vm, watcher.value);\n  }\n\n  return function unwatchFn(){\n     watcher.teardown();\n  }\n}\n```\n\n先执行new Watcher来实现vm.$watch的基本功能。这里有一个细节需要注意，expOrFn是支持函数的，而我们在第2章中并没有介绍。这里我们需要对Watcher进行一个简单的修改：\n\n```js\nexport default class Watcher {\n   constructor(vm, expOrFn, cb){\n     this.vm = vm;\n     if(typeof expOrFn === 'function'){\n       this.getter = expOrFn;\n     }else{\n       this.getter = parsePath(expOrFn);\n     }\n     this.cb = cb;\n     this.value = this.get();\n   }\n}\n```\n当expOrFn是函数时，会发生很神奇的事情。它不只可以动态返回数据，其中读取的所有数据也都会被Watcher观察。当expOrFn是字符串类型的keypath时，Watcher会读取这个keypath所指向的数据并观察这个数据的变化。而当expOrFn是函数时，Watcher会同时观察expOrFn函数中读取的所有Vue.js实例上的响应式数据。**也就是说，如果函数从Vue.js实例上读取了两个数据，那么Watcher会同时观察这两个数据的变化，当其中任意一个发生变化时，Watcher都会得到通知。(Vue.js中计算属性 Computed 的实现原理与expOrFn支持函数有很大的关系)**\n\n现在要在Watcher中添加该方法来实现unwatch的功能：\n\n首先，需要在Watcher中记录自己都订阅了谁，也就是watcher实例被收集进了哪些Dep里。然后当Watcher不想继续订阅这些Dep时，循环自己记录的订阅列表来通知它们（Dep）将自己从它们（Dep）的依赖列表中移除掉。\n\n```js\nexport default class Wather {\n  constructor(vm, expOrFn, cb){\n     this.vm = vm;\n     this.deps = [];\n     this.depIds = new Set();\n     if(typeof expOrFn === 'function'){\n       this.getter = expOrFn;\n     }else{\n       this.getter = parsePath(expOrFn);\n     }\n     this.cb = cb;\n     this.value = this.get();\n  }\n\n  addDep(dep){\n    const id = dep.id;\n    if(!this.depIds.has(id)){\n       this.depIds.add(id);\n       this.deps.push(id);\n       dep.addSub(this);\n    }\n  }\n\n  teardown(){\n    let i = this.deps.length;\n    while(i--){\n      this.deps[i].removeSub(this);\n    }\n  }\n}\n```\n\n执行this.depIds.add来记录当前Watcher已经订阅了这个Dep。\n\n然后执行this.deps.push(dep)记录自己都订阅了哪些Dep。\n\n最后，触发dep.addSub(this)来将自己订阅到Dep中。\n\n在Watcher中新增addDep方法后，Dep中收集依赖的逻辑也需要有所改变：\n\n```js\nlet uid = 0;\n\nexport default class Dep {\n   constructor(){\n      this.id = uid++;\n      this.subs = [];\n   }\n\n   depend(){\n     if(window.target){\n       this.addSub(window.target);  // 废弃\n       window.target.addDep(this); // 新增\n     }\n   }\n\n   removeSub(sub){\n    const index = this.subs.indexOf(sub);\n    if(index > -1){\n       return this.subs.splice(index, 1)\n    }\n   }\n\n}\n```\n\n##### 4.1.3 deep参数的实现原理\n要想实现deep的功能，其实就是除了要触发当前这个被监听数据的收集依赖的逻辑之外，还要把当前监听的这个值在内的所有子值都触发一遍收集依赖逻辑。这就可以实现当前这个依赖的所有子数据发生变化时，通知当前Watcher了。\n\n```js\nexport default class Wather {\n   constructor(vm, expOrFn, cb, options){\n     this.vm = vm;\n\n     // 新增\n     if(options){\n        this.deep = !!options.deep;\n     }else{\n        this.deep = false;\n     }\n\n     this.deps = [];\n     this.depIds = new Set();\n     if(typeof expOrFn === 'function'){\n       this.getter = expOrFn;\n     }else{\n       this.getter = parsePath(expOrFn);\n     }\n     this.cb = cb;\n     this.value = this.get();\n   }\n\n   get(){\n    window.target = this;\n    let value = this.getter.call(vm, vm);\n    if(this.deep){\n       traverse(value);\n    }\n    window.target = undefined;\n    return value\n   }\n}\n```\n\n一定要在window.target = undefined之前去触发子值的收集依赖逻辑，这样才能保证子集收集的依赖是当前这个Watcher。如果在window.target = undefined之后去触发收集依赖的逻辑，那么其实当前的Watcher并不会被收集到子值的依赖列表中，也就无法实现deep的功能。\n\n接下来，要递归value的所有子值来触发它们收集依赖的功能：\n\n```js\nconst seenObjects = new Set();\n\nexport function traverse (val){\n  _traverse(val, seenObjects);\n  seenObjects.clear();\n}\n\nfunction _traverse(val, seen){\n   let i, keys;\n   const isA = Array.isArray(val);\n   if((!isA && !isObject(val)) || Object.isFrozen(val)){\n       return;\n   }\n   if(val.__ob__){\n    const depId = val.__ob__.dep.id;\n    if(seen.has(depId)){\n      return;\n    }\n    seen.add(depId);\n   }\n\n   if(isA){\n      i = val.length;\n      while(i--) __traverse(val[i], seen);\n   }else{\n      keys = Object.keys(val);\n      i = keys.length;\n      while(i--) __traverse(val[keys[i]], seen); \n   }\n}\n```\n\n#### 4.2 vm.$set\n##### 4.2.1 用法\n```js\nvm.$set(target, key, value);\n// {Object | Array } target\n// {String | Number} key\n// {any} value\n\n// 返回值 {Function} unwatch\n```\n\n用法：在object上设置一个属性，如果object是响应式的，Vue.js会保证属性被创建后也是响应式的，并且触发视图更新。这个方法主要用来避开Vue.js不能侦测属性被添加的限制。\n\n原因：只有已经存在的属性的变化会被追踪到，新增的属性无法被追踪到。因为在ES6之前，JavaScript并没有提供元编程的能力，所以根本无法侦测object什么时候被添加了一个新属性。\n\n```js\n/**\n * 新增的这个属性也不是响应式的，Vue.js根本不知道这个obj新增了属性，\n * 就好像Vue.js无法知道我们使用array.length = 0清空了数组一样。\n */ \nvar vm = new Vue({\n    el: '#el',\n    template: '#demo-template',\n    data: {\n      obj: { }\n    },    \n    methods: {\n      action () {\n        this.obj.name = 'berwin' // \n      }\n    }\n})\n```\n\n##### 4.2.2 原理\n\n```js\nimport { set } from '../observer/index';\nVue.prototype.$set = set;\n\n// index文件\nexport function set (target, key, val){ } \n```\n\n**1、Array处理：**\n\n```js\nexport function set (target, key, val){\n  if(Array.isArray(target) && isValidArrayIndex(key)){\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val;\n  }\n}\n```\n\n如果target是数组并且key是一个有效的索引值，就先设置length属性。这样如果我们传递的索引值大于当前数组的length，就需要让target的length等于索引值。\n\n通过splice方法把val设置到target中的指定位置（参数中提供的索引值的位置）。当我们使用splice方法把val设置到target中的时候，数组拦截器会侦测到target发生了变化，并且会自动帮助我们把这个新增的val转换成响应式的。\n\n**2、key已经存在target中**\n```js\nexport function set(target, key, val){\n  if(Array.isArray(target) && isValidArrayIndex(key)){\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val;\n  }\n\n  if(key in target && !(key in Object.prototype)){\n      target[key] = val;\n      return val;\n  }\n}\n```\n\n由于key已经存在于target中，所以其实这个key已经被侦测了变化。也就是说，这种情况属于修改数据，直接用key和val改数据就好了。\n\n**3、处理新增属性**\n```js\nexport function set(target, key, val){\n  if(Array.isArray(target) && isValidArrayIndex(key)){\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val;\n  }\n\n  if(key in target && !(key in Object.prototype)){\n      target[key] = val;\n      return val;\n  }\n\n  // 新增\n  const ob = target.__ob__;\n  if(target.isVue && (ob && ob.vmCount)){\n      process.env.NODE_ENV !== 'production' && warn(\n        'Avoid adding reactive properties to a Vue instance or its root $data ' +\n        'at runtime - declare it upfront in the data option.'\n      );\n      return val\n  }\n  if(!ob){\n    target[key] = val;\n    return val;\n  }\n  defineReactive(ob.value, key, val);\n  ob.dep.notify();\n  return val;\n}\n```\n\n要处理文档中所说的“target不能是Vue.js实例或Vue.js实例的根数据对象”的情况。\n\n实现这个功能并不难，只需要使用target._isVue来判断target是不是Vue.js实例，使用ob.vmCount来判断它是不是根数据对象即可。\n\n那么，什么是根数据？this.$data就是根数据。\n\n接下来，我们处理target不是响应式的情况。如果target身上没有 \\__ob__ 属性，说明它并不是响应式的，并不需要做什么特殊处理，只需要通过key和val在target上设置就行了\n\n\n#### 4.3 vm.$delete\n##### 4.3.1 用法\n```js\nvm.$delete(target, key);\n\n// {Object | Array} target\n// {String | Numbet} key\n```\n\n删除对象的属性。如果对象是响应式的，需要确保删除能触发更新视图。这个方法主要用于避开Vue.js不能检测到属性被删除的限制，但是你应该很少会使用它。\n\n强烈不推荐这样写代码：\n\n```js\ndelete this.obj.name;\nthis.obj.__ob__.dep.notify(); // 手动向依赖发生变化通知\n```\n\n##### 4.3.2 原理\n\n```js\nimport { del } from '../observer/index';\nVue.prototype.$delete = del;\n\n// index\nexport function del (target, key){\n  const ob = target.__ob__;\n  delete target[key];\n  ob.dep.notify();\n}\n```\n\n**1、处理Array**\n\n```js\nexport function del (target, key){\n  if(Array.isArray(target) && isValidArrayIndex(key)){\n    target.splice(key, 1);\n    return;\n  }\n  const ob = (target).__ob__;\n  delete target[key];\n  ob.dep.notify();  \n}\n```\n\n只需要使用splice将参数key所指定的索引位置的元素删除即可。因为使用了splice方法，数组拦截器会自动向依赖发送通知。\n\nvm.$delete也不可以在Vue.js实例或Vue.js实例的根数据对象上使用:\n```js\nexport function del (target, key){\n   if(Array.isArray(target) && isValidArrayIndex(key)){\n      target.splice(key, 1);\n      return;\n   }\n   const ob = target.__ob__;\n\n   // 新增\n   if(target._isVue || (ob && ob.vmCount)){\n      process.env.NODE_ENV !== 'production' && warn(\n        'Avoid deleting properties on a Vue instance or its root $data ' +\n        '- just set it to null.'        \n      );\n      return;\n   }\n\n   // 如果key不是target自身属性， 则终止\n   if(!hasOwn(target, key))){\n    return;\n   }\n\n   delete target[key];\n   \n   // 如果ob不存在，则终止\n   if(!ob){\n     return;\n   }\n\n   ob.dep.notify();\n} \n```\n\n#### 4.4 总结\n待补充吧\n\n\n## 4、虚拟DOM\nVue.js 2.0引入了虚拟DOM，比Vue.js 1.0的初始渲染速度提升了2~4倍，并大大降低了内存消耗。\n\n### 1、虚拟DOM简介\n#### 1.1 虚拟DOM背景\n虚拟DOM是随着时代发展而诞生的产物。\n\n在Web早期，页面的交互效果比现在简单得多，没有很复杂的状态需要管理，也不太需要频繁地操作DOM，使用jQuery来开发就可以满足我们的需求。\n\n随着时代的发展，页面上的功能越来越多，我们需要实现的需求也越来越复杂，程序中需要维护的状态也越来越多，DOM操作也越来越频繁。\n\n**命令式操作DOM：当状态变得越来越多，DOM操作越来越频繁时，我们就会发现如果像之前那样使用jQuery来开发页面，那么代码中会有相当多的代码是在操作DOM，程序中的状态也很难管理，代码中的逻辑也很混乱。**\n\n**声明式操作DOM: 我们通过描述状态和DOM之间的映射关系是怎样的，就可以将状态渲染成视图。关于状态到视图的转换过程，框架会帮我们做，不需要我们自己手动去操作DOM。**\n\n然而通常程序在运行时，状态会不断发生变化（引起状态变化的原因有很多，有可能是用户点击了某个按钮，也可能是某个Ajax请求，这些行为都是异步发生的。理论上，所有异步行为都有可能引起状态变化）。**每当状态发生变化时，都需要重新渲染。如何确定状态中发生了什么变化以及需要在哪里更新DOM？**\n\n在这种情况下，最简单粗暴的解决方式是，既不需要关心状态发生了什么变化，也不需要关心在哪里更新DOM，我们只需要把所有DOM全删了，然后使用状态重新生成一份DOM，并将其输出到页面上显示出来就好了。\n\n但是访问DOM是非常昂贵的。按照上面说的方式做，会造成相当多的性能浪费。状态变化通常只有有限的几个节点需要重新渲染，所以我们不仅需要找出哪里需要更新，还需要尽可能少地访问DOM。\n\n业界3大框架解决方案：\n\n1. Angular中就是脏检查的流程\n2. React中使用虚拟DOM\n3. Vue.js 1.0通过细粒度的绑定\n\n\n**虚拟DOM的解决方式是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。在渲染之前，会使用新生成的虚拟节点树和上一次生成的虚拟节点树进行对比，只渲染不同的部分。**\n\n\n#### 1.2 为什么要引入虚拟DOM \n事实上，Angular和React的变化侦测有一个共同点，那就是它们都不知道哪些状态（state）变了。因此，就需要进行比较暴力的比对，React是通过虚拟DOM的比对，Angular是使用脏检查的流程。\n\nVue.js的变化侦测和它们都不一样，它在一定程度上知道具体哪些状态发生了变化，这样就可以通过更细粒度的绑定来更新视图。也就是说，在Vue.js中，当状态发生变化时，它在一定程度上知道哪些节点使用了这个状态，从而对这些节点进行更新操作，根本不需要比对。事实上，在Vue.js 1.0的时候就是这样实现的。\n\n**但是这样做其实也有一定的代价。因为粒度太细，每一个绑定都会有一个对应的watcher来观察状态的变化，这样就会有一些内存开销以及一些依赖追踪的开销。当状态被越多的节点使用时，开销就越大。对于一个大型项目来说，这个开销是非常大的。**\n\n**因此，Vue.js 2.0开始选择了一个中等粒度的解决方案，那就是引入了虚拟DOM。组件级别是一个watcher实例，就是说即便一个组件内有10个节点使用了某个状态，但其实也只有一个watcher在观察这个状态的变化。所以当这个状态发生变化时，只能通知到组件，然后组件内部通过虚拟DOM去进行比对与渲染。这是一个比较折中的方案。**\n\n**Vue.js之所以能随意调整绑定的粒度，本质上还要归功于变化侦测。**\n\n#### 1.3 vue.js中的虚拟dom\n在Vue.js中，我们使用模板来描述状态与DOM之间的映射关系。**Vue.js通过编译将模板转换成渲染函数（render），执行渲染函数就可以得到一个虚拟节点树，使用这个虚拟节点树就可以渲染页面：**\n\n<img src=\"/img/vue4.jpeg\" style=\"max-width:95%\" />\n\n由于DOM操作比较慢，所以这些DOM操作在性能上会有一定的浪费，避免这些不必要的DOM操作会提升很大一部分性能。\n\n为了避免不必要的DOM操作，虚拟DOM在虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧虚拟节点（oldVnode）做对比，找出真正需要更新的节点来进行DOM操作，从而避免操作其他无任何改动的DOM。\n\n虚拟DOM的执行流程：\n\n<img src=\"/img/vue5.jpeg\" style=\"max-width:95%\" />\n\n虚拟DOM在Vue.js中所做的事情其实并没有想象中那么复杂，它主要做了两件事：\n\n1. 提供与真实DOM节点所对应的虚拟节点vnode。\n2. 将虚拟节点vnode和旧虚拟节点oldVnode进行比对，然后更新视图\n\n#### 1.4 总结\n虚拟DOM是将状态映射成视图的众多解决方案中的一种，它的运作原理是使用状态生成虚拟节点，然后使用虚拟节点渲染视图。\n\n之所以需要先使用状态生成虚拟节点，是因为如果直接用状态生成真实DOM，会有一定程度的性能浪费。而先创建虚拟节点再渲染视图，就可以将虚拟节点缓存，然后使用新创建的虚拟节点和上一次渲染时缓存的虚拟节点进行对比，然后根据对比结果只更新需要更新的真实DOM节点，从而避免不必要的DOM操作，节省一定的性能开销。\n\nVue.js中通过模板来描述状态与视图之间的映射关系，所以它会先将模板编译成渲染函数，然后执行渲染函数生成虚拟节点，最后使用虚拟节点更新视图。\n\n因此，虚拟DOM在Vue.js中所做的事是提供虚拟节点vnode和对新旧两个vnode进行比对，并根据比对结果进行DOM操作来更新视图。\n\n\n### 2、VNode\n#### 2.1 VNode简介\n在Vue.js中存在一个VNode类，使用它可以实例化不同类型的vnode实例，而不同类型的vnode实例各自表示不同类型的DOM元素。\n\n例如，DOM元素有元素节点、文本节点和注释节点等，vnode实例也会对应着有元素节点、文本节点和注释节点等。\n\n```js\nexport default class VNode {\n  constructor(tag, data, children, text, elm, context, componentOptions, asyncFactory){\n      this.tag = tag;\n      this.data = data;\n      this.children = children;\n      this.text = text;\n      this.elm = elm;\n      this.ns = undefined;\n      this.context = context;\n      this.functionalContext = undefined;\n      this.functionalOptions = undefined;\n      this.functionalScopeId = undefined;\n      this.key = data && data.key;\n      this.componentOptions = componentOptions;\n      this.componentInstance = undefined;\n      this.parent = undefined;\n      this.raw = false;\n      this.isStatic = false;\n      this.isRootInsert = true;\n      this.isComment = false;\n      this.isCloned = false;\n      this.isOnce = false;\n      this.asyncFactory = asyncFactory;\n      this.asyncMeta = undefined;\n      this.isAsyncPlaceholder = false;\n  }\n\n  get child(){\n    return this.commponentInstance;\n  }\n}\n```\n\n简单地说，vnode可以理解成节点描述对象，它描述了应该怎样去创建真实的DOM节点。\n\nvnode表示一个真实的DOM元素，所有真实的DOM节点都使用vnode创建并插入到页面中:\n\n**Vnode --create--> DOM  --insert--> 视图**\n\n#### 2.2 VNode作用\n由于每次渲染视图时都是先创建vnode，然后使用它创建真实DOM插入到页面中，所以可以将上一次渲染视图时所创建的vnode缓存起来，之后每当需要重新渲染视图时，将新创建的vnode和上一次缓存的vnode进行对比，查看它们之间有哪些不一样的地方，找出这些不一样的地方并基于此去修改真实的DOM。\n\n**Vue.js目前对状态的侦测策略采用了中等粒度。当状态发生变化时，只通知到组件级别，然后组件内使用虚拟DOM来渲染视图。**\n\n也就是说，只要组件使用的众多状态中有一个发生了变化，那么整个组件就要重新渲染。\n\n如果组件只有一个节点发生了变化，那么重新渲染整个组件的所有节点，很明显会造成很大的性能浪费。因此，对vnode进行缓存，并将上一次缓存的vnode和当前新创建的vnode进行对比，只更新发生变化的节点就变得尤为重要。这也是vnode最重要的一个作用。\n\n#### 2.3 VNode类型\nvnode的类型有以下几种：\n1. 注释节点\n2. 文本节点\n3. 元素节点\n4. 组件节点\n5. 函数式组件\n6. 克隆节点\n\n##### 2.3.1 注释节点\n\n```html\n<!-- 注释节点 -->\n```\n\n```js\n{\n  text: '注释节点',\n  isComment: true\n}\n```\n\n##### 2.3.2 文本节点\n当文本类型的vnode被创建时，它只有一个text属性：\n\n```js\nexport function createTextVNode(val){\n  return new VNode(undefined, undefined, undefined, String(val));\n}\n\n{\n  text: 'hello world'\n}\n```\n\n##### 2.3.3 克隆节点\n克隆节点是将现有节点的属性复制到新节点中，让新创建的节点和被克隆节点的属性保持一致，从而实现克隆效果。它的作用是优化静态节点和插槽节点（slot node）。\n\n以静态节点为例，当组件内的某个状态发生变化后，当前组件会通过虚拟DOM重新渲染视图，静态节点因为它的内容不会改变，所以除了首次渲染需要执行渲染函数获取vnode之外，后续更新不需要执行渲染函数重新生成vnode。因此，这时就会使用创建克隆节点的方法将vnode克隆一份，使用克隆节点进行渲染。这样就不需要重新执行渲染函数生成新的静态节点的vnode，从而提升一定程度的性能\n\n```js\nexport function cloneVNode(vnode, depp){\n  const cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  )\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  clone.isCloned = true; // 这是克隆节点与被克隆节点的区别\n  if(deep && vnode.children){\n    cloned.children = cloneVNode(vnode.children);\n  }\n  return cloned;\n}\n```\n\n##### 2.3.4 元素节点\n元素节点通常会存在以下4种有效属性。\n1. tag：顾名思义，tag就是一个节点的名称，例如p、ul、li和div等。\n2. data：该属性包含了一些节点上的数据，比如attrs、class和style等。\n3. children：当前节点的子节点列表。\n4. context：它是当前组件的Vue.js实例。\n\n```html\n<p><span>Hello</span><span>Berwin</span></p>\n```\n\n```js\n{\n  children: [VNode, VNode],\n  context: {...},\n  data: {...},\n  tag: 'p',\n  ...\n}\n```\n\n##### 2.3.5 组件节点\n组件节点和元素节点类似，有以下两个独有的属性。\n\n1. componentOptions：顾名思义，就是组件节点的选项参数，其中包含propsData、tag和children等信息\n2. componentInstance：组件的实例，也是Vue.js的实例。事实上，在Vue.js中，每个组件都是一个Vue.js实例\n\n```js\n<child></child>\n\n// 对应vnode\n{\n   componentOptions: {...},\n   commponentInstance: {...},\n   context: {...},\n   data: {...},\n   tag: 'vue-component-child',\n   ...\n}\n```\n\n##### 2.3.6 函数式组件\n函数式组件和组件节点类似，它有两个独有的属性functionalContext和functionalOptions\n\n\n### 3、patch\n虚拟DOM最核心的部分是patch，它可以将vnode渲染成真实的DOM。\n\n之所以要这么做，主要是因为DOM操作的执行速度远不如JavaScript的运算速度快。因此，把大量的DOM操作搬运到JavaScript中，使用patching算法来计算出真正需要更新的节点，最大限度地减少DOM操作，从而显著提升性能。这本质上其实是使用JavaScript的运算成本来替换DOM操作的执行成本，而JavaScript的运算速度要比DOM快很多，这样做很划算，所以才会有虚拟DOM。\n\n#### 3.1 patch介绍\n对现有DOM进行修改需要做三件事：\n\n1. 创建新增的节点；\n2. 删除已经废弃的节点；\n3. 修改需要更新的节点。\n\n\n之所以需要通过算法来比对两个节点之间的差异，并针对不同的节点进行更新，主要是为了性能考虑。\n\n我们完全可以把整个旧节点从DOM中删除，然后使用最新的状态（state）重新生成一份全新的节点并插入到DOM中，这种方式完全可以实现功能。\n\n##### 3.1.1 新增节点\n首先，新增节点的一个很明显的场景就是，当oldVnode不存在而vnode存在时，就需要使用vnode生成真实的DOM元素并将其插入到视图当中去。\n\n1. **1、这通常会发生在首次渲染中。**因为首次渲染时，DOM中不存在任何节点，所以oldVnode是不存在的。\n<img src=\"/img/vue6.jpeg\" style=\"max-width:95%\" />\n<img src=\"/img/vue7.jpeg\" style=\"max-width:95%\" />\n\n2. **2、还有一种情况也需要新增节点。**当vnode和oldVnode完全不是同一个节点时，需要使用vnode生成真实的DOM元素并将其插入到视图当中。\n<img src=\"/img/vue8.jpeg\" style=\"max-width:95%\" />\n\n\n##### 3.1.2 删除节点\n就是当一个节点只在oldVnode中存在时，我们需要把它从DOM中删除。因为渲染视图时，需要以vnode为标准，所以vnode中不存在的节点都属于被废弃的节点，而被废弃的节点需要从DOM中删除。\n\n##### 3.1.3 更新节点\n新旧两个节点是同一个节点。当新旧两个节点是相同的节点时，我们需要对这两个节点进行比较细致的比对，然后对oldVnode在视图中所对应的真实节点进行更新。\n\n举个简单的例子，当新旧两个节点是同一个文本节点，但是两个节点的文本不一样时，我们需要重新设置oldVnode在视图中所对应的真实DOM节点的文本。\n\n<img src=\"/img/vue9.jpeg\" style=\"max-width:95%\" />\n\n##### 3.1.4 总结\n<img src=\"/img/vue10.jpeg\" style=\"max-width:95%\" />\n\n#### 3.2 创建节点\n只有三种类型的节点会被创建并插入到DOM中：元素节点、注释节点和文本节点。\n\n创建一个节点并将其渲染到视图的全过程：\n\n<img src=\"/img/vue11.jpeg\" style=\"max-width:95%\" />\n\n#### 3.2 删除节点\n\n```js\n// removeVnodes 删除一组指定的节点\nfunction removeVnodes(vnodes, startIdx, endIdx){\n  for(; startIdx <= endIdx; ++startIdx){\n    const ch = vnodes[startIdx];\n    if(isDef(ch)){\n        // removeNode 删除单个节点\n        removeNode(ch.elm);\n    }\n  }\n}\n\nconst nodeOps = {\n  removeChild(node, child){\n     node.removeChild(child);\n  }\n}\n\nfunction removeNode(el){\n   const parent = nodeOps.parentNode(el);\n   if(!isDef(parent)){\n    nodeOps.removeChild(parent, el);\n   }\n}\n```\n有同学可能会对nodeOps感到奇怪，为什么不直接使用parent.removeChild(child)删除节点，而是将这个节点操作封装成函数放在nodeOps里呢？\n\n其实这涉及跨平台渲染的知识，我们知道阿里开发的Weex可以让我们使用相同的组件模型为iOS和Android编写原生渲染的应用。也就是说，我们写的Vue.js组件可以分别在iOS和Android环境中进行原生渲染。\n\n**跨平台渲染的本质是在设计框架的时候，要让框架的渲染机制和DOM解耦。**只要把框架更新DOM时的节点操作进行封装，就可以实现跨平台渲染，在不同平台下调用节点的操作。\n\n如果我们把这些平台下节点操作的封装看成渲染引擎，那么将这些渲染引擎所提供的节点操作的API和框架的运行时对接一下，就可以实现将框架中的代码进行原生渲染的目的。\n\n\n#### 3.3 更新节点\n只有两个节点是同一个节点时，才需要更新元素节点，而更新节点并不是很暴力地使用新节点覆盖旧节点，而是通过比对找出新旧两个节点不一样的地方，针对那些不一样的地方进行更新。\n\n##### 3.3.1 静态节点\n在更新节点时，首先需要判断新旧两个虚拟节点是否是静态节点，如果是，就不需要进行更新操作，可以直接跳过更新节点的过程。\n\n**静态节点指的是那些一旦渲染到界面上之后，无论日后状态如何变化，都不会发生任何变化的节点。**\n\n```html\n<span>我是静态节点，我不需要改变</span>\n```\n\n##### 3.3.2 新虚拟节点有文本属性\n当新旧两个虚拟节点（vnode和oldVnode）不是静态节点，并且有不同的属性时，要以新虚拟节点（vnode）为准来更新视图。根据新节点（vnode）是否有text属性，更新节点可以分为两种不同的情况。\n\n简单来说，就是当新虚拟节点有文本属性，并且和旧虚拟节点的文本属性不一样时，我们可以直接把视图中的真实DOM节点的内容改成新虚拟节点的文本。\n\n##### 3.3.3 新虚拟节点无文本属性\n如果新创建的虚拟节点没有text属性，那么它就是一个元素节点。元素节点通常会有子节点，也就是children属性，但也有可能没有子节点，所以存在两种不同的情况。\n\n1. 一种情况，有children情况\n   a、如果旧虚拟节点也有children属性，那么我们要对新旧两个虚拟节点的children进行一个更详细的对比并更新。 <br>\n\n   b、如果旧虚拟节点没有children属性，那么说明旧虚拟节点要么是一个空标签，要么是有文本的文本节点。\n\n2. 二种情况，无children情况\n  当新创建的虚拟节点既没有text属性也没有children属性时，这说明这个新创建的节点是一个空节点，它下面既没有文本也没有子节点，这时如果旧虚拟节点（oldVnode）中有子节点就删除子节点，有文本就删除文本。有什么删什么，最后达到视图中是空标签的目的。\n\n\n##### 3.3.4 总结\n<img src=\"/img/vue12.jpeg\" style=\"max-width:95%\" />\n\n<img src=\"/img/vue13.jpeg\" style=\"max-width:95%\" />\n\n#### 3.4 更新子节点策略\n之前我们详细讨论了更新节点的过程，其中讨论了当新节点的子节点和旧节点的子节点都存在并且不相同时，会进行子节点的更新操作。但我们并没有详细讨论子节点是如何更新的。\n\n更新子节点大概可以分为4种操作：更新节点、新增节点、删除节点、移动节点位置。\n\n##### 3.4.1 创建子节点\n最上面的DOM节点是视图中的真实DOM节点。左下角的节点是新创建的虚拟节点。 右下角的节点是旧的虚拟节点。\n\n<img src=\"/img/vue14.jpeg\" style=\"max-width:95%\" />\n\n上图已经对前两个子节点进行了更新，当前正在处理第三个子节点。当在右下角的虚拟子节点中找不到与左下角的第三个节点相同的节点时，证明它是新增节点，这时候需要创建节点并插入到真实DOM中，插入的位置是所有未处理节点的前面，也就是虚线所指定的位置。\n\n下图插入到未处理节点的前面：\n<img src=\"/img/vue15.jpeg\" style=\"max-width:95%\" />\n\n下图插入到已处理节点的后面：\n<img src=\"/img/vue16.jpeg\" style=\"max-width:95%\" />\n\n可能你现在又有疑问了，节点插入进真实DOM中后，真实DOM中的节点越来越多，为什么没看见删除节点的逻辑？ 关于删除节点的逻辑，我们将在后面详细介绍\n\n##### 3.4.2 更新子节点\n两个节点是同一个节点并且位置相同，这种情况下只需要进行更新节点的操作即可\n\n<img src=\"/img/vue17.jpeg\" style=\"max-width:95%\" />\n\n##### 3.4.3 移动子节点\n移动节点通常发生在newChildren中的某个节点和oldChildren中的某个节点是同一个节点，但是位置不同，所以在真实的DOM中需要将这个节点的位置以新虚拟节点的位置为基准进行移动。\n\n<img src=\"/img/vue18.jpeg\" style=\"max-width:95%\" />\n\n上图表示正在处理第三个节点，这时在oldChildren中找到的相同节点是第四个节点。由于位置不同，所以需要移动节点，移动节点的位置是所有未处理节点的最前面。本例中，将第四个节点移动到所有未处理节点的最前面，就是将节点从第四个变成了第三个。\n\n节点更新并且移动完位置后，开始进行下一轮循环，也就是开始处理newChildren中的第四个节点。\n\n关于怎么分辨哪些节点是处理过的，哪些节点是未处理的，我们将在后面章节详细讨论\n\n##### 3.4.4 删除子节点\n删除子节点，本质上是删除那些oldChildren中存在但newChildren中不存在的节点\n\n当newChildren中的所有节点都被循环了一遍后，也就是循环结束后，如果oldChildren中还有剩余的没有被处理的节点，那么这些节点就是被废弃、需要删除的节点。\n\n##### 3.4.5 优化策略\n通常情况下，并不是所有子节点的位置都会发生移动，一个列表中总有几个节点的位置是不变的。针对这些位置不变的或者说位置可以预测的节点，我们不需要循环来查找，因为我们有一个更快捷的查找方式\n\n只需要尝试使用相同位置的两个节点来比对是否是同一个节点：如果恰巧是同一个节点，直接就可以进入更新节点的操作；如果尝试失败了，再用循环的方式来查找节点。\n\n这样做可以很大程度地避免循环oldChildren来查找节点，从而使执行速度得到很大的提升。\n\n如果我们把这种很快速的查找节点的方式称为快捷查找，那么它共有4种查找方式，分别是：\n\n1. 新前（newChildren中所有未处理的第一个节点）与 旧前（oldChildren中所有未处理的第一个节点）\n2. 新后（newChildren中所有未处理的最后一个节点）与 旧后（oldChildren中所有未处理的最后一个节点）\n3. 新后 与 旧前\n4. 新前 与 旧后\n\n\n###### 1、新前和旧前\n顾名思义，“新前”与“旧前”的意思就是尝试使用“新前”这个节点与“旧前”这个节点对比，对比它们俩是不是同一个节点。如果是同一个节点，则说明我们不费吹灰之力就在oldChildren中找到了这个虚拟节点，然后使用7.4节中介绍的更新节点操作将它们俩进行对比并更新视图\n\n<img src=\"/img/vue20.jpeg\" style=\"max-width:95%\" />\n\n由于“新前”与“旧前”的位置相同，所以并不需要执行移动节点的操作，只需要更新节点即可。\n\n\n###### 2、新后和旧后\n当“新前”与“旧前”对比后发现不是同一个节点，这时可以尝试用“新后”与“旧后”的方式来比对它们俩是否是同一个节点。\n\n<img src=\"/img/vue21.jpeg\" style=\"max-width:95%\" />\n\n由于“新后”与“旧后”这两个节点的位置相同，所以只需要执行更新节点的操作即可，不需要执行移动节点的操作。\n\n###### 3、新后和旧前\n“新后”与“旧前”的意思是使用“新后”这个节点与“旧前”这个节点进行对比，通过对比来分辨它们俩是不是同一个节点。如果是同一个节点，就对比它们俩并更新视图：\n\n<img src=\"/img/vue22.jpeg\" style=\"max-width:95%\" />\n\n如果“新后”与“旧前”是同一个节点，那么由于它们的位置不同，所以除了更新节点外，还需要执行移动节点的操作：\n\n<img src=\"/img/vue23.jpeg\" style=\"max-width:95%\" />\n\n当“新后”与“旧前”是同一个节点时，在真实DOM中除了做更新操作外，还需要将节点移动到oldChildren中所有未处理节点的最后面。\n\n你可能对为什么移动到oldChildren中所有未处理节点的最后面感到困惑，接下来我们会详细介绍为什么移动到这个位置。\n\n更新节点是以新虚拟节点为基准，子节点也不例外，所以在图7-21中，因为“新后”这个节点是最后一个节点，所以真实DOM中将节点移动到最后不难理解，让我们感到困惑的是为什么移动到oldChildren中所有未处理节点的最后面。\n\n这里我们举个例子，如下图：\n\n<img src=\"/img/vue24.jpeg\" style=\"max-width:95%\" />\n\n当真实DOM子节点左右两侧已经有节点被更新，只有中间这部分节点未处理时，“新后”这个节点是未处理节点中的最后一个节点，所以真实DOM节点移动位置时，需要移动到oldChildren中所有未处理节点的最后面。只有移动到未处理节点的最后面，它的位置才与“新后”这个节点的位置相同。\n\n如果对比之后发现这两个节点也不是同一个节点，则继续尝试对比“新前”与“旧后”是否是同一个节点。\n\n###### 4、新前和旧后\n“新前”与“旧后”的意思是使用“新前”与“旧后”这两个节点进行对比，对比它们是否是同一个节点，如果是同一个节点，则进行更新节点的操作。\n\n<img src=\"/img/vue25.jpeg\" style=\"max-width:95%\" />\n\n由于“新前”与“旧后”这两个节点的位置不同，所以除了更新节点的操作外，还需要进行移动节点的操作：\n\n<img src=\"/img/vue26.jpeg\" style=\"max-width:95%\" />\n\n从上图中可以看出，当“新前”与“旧后”是同一个节点时，在真实DOM中除了做更新操作外，还需要将节点移动到oldChildren中所有未处理节点的最前面。\n\n将节点移动到oldChildren中所有未处理节点的最前面的原因，与前面介绍的“新后”与“旧前”的逻辑是一样的， 如下图：\n\n<img src=\"/img/vue27.jpeg\" style=\"max-width:95%\" />\n\n如上图所示，当真实的DOM节点中已经有节点被更新，并且更新到第二个节点时，我们发现oldChildren中对应的节点在第三个的位置上，这时需要将“旧后”这个节点更新并移动到第二个的位置上，所以只需要将节点移动到所有未处理节点的最前面，就能实现移动到第二个位置的目的。\n\n也就是说，已更新过的节点都不用管。因为更新过的节点无论是节点的内容或者节点的位置，都是正确的，更新完后面就不需要再进行更改了。所以，我们只需要在所有未更新的节点区间内进行移动和更新操作即可。\n\n如果前面这4种方式对比之后都没找到相同的节点，这时再通过循环的方式去oldChildren中详细找一圈，看看能否找到。\n\n大部分情况下，通过前面这4种方式就可以找到相同的节点，所以节省了很多次循环操作。\n\n\n###### 5、哪些节点是未处理过的\n那么，怎样实现从两边向中间循环呢？\n\n首先，我们先准备4个变量：oldStartIdx、oldEndIdx、newStartIdx和newEndIdx。\n\n这4个变量分别表示oldChildren的开始位置的下标（oldStartIdx）和结束位置的下标（oldEndIdx），以及newChildren的开始位置的下标（newStartIdx）和结束位置的下标（newEndIdx）。\n\n在循环体内，每处理一个节点，就将下标向指定的方向移动一个位置，通常情况下是对新旧两个节点进行更新操作，就相当于一次性处理两个节点，将新旧两个节点的下标都向指定方向移动一个位置。\n\n当开始位置大于等于结束位置时，说明所有节点都遍历过了，则结束循环：\n\n```js\nwhile(oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx){\n  // todo\n}\n```\n\n\n###### 6、小结\n更新子节点的整体流程：\n\n<img src=\"/img/vue19.jpeg\" style=\"width:120%\" />\n\n\n名称解释：\n\n1. oldStartVnode：oldChildren中所有未处理的第一个节点，与前文中提到的“旧前”是同一个节点。\n2. oldEndVnode：oldChildren中所有未处理的最后一个节点，与前文中提到的“旧后”是同一个节点。\n3. newStartVnode：newChildren中所有未处理的第一个节点，与前文中提到的“新前”是同一个节点。\n4. newEndVnode：newChildren中所有未处理的最后一个节点，与前文中提到的“新后”是同一个节点。\n\n在Vue.js的模板中，渲染列表时可以为节点设置一个属性key，这个属性可以标示一个节点的唯一ID。Vue.js官方非常推荐在渲染列表时使用这个属性，我也非常推荐使用它，为什么呢？\n\n在更新子节点时，需要在oldChildren中循环去找一个节点。但是如果我们在模板中渲染列表时，为子节点设置了属性key，那么在上图中建立key与index索引的对应关系时，就生成了一个key对应着一个节点下标这样一个对象。也就是说，**如果在节点上设置了属性key，那么在oldChildren中找相同节点时，可以直接通过key拿到下标，从而获取节点。这样，我们根本不需要通过循环来查找节点。**\n\n\n\n##### 3.4.6 总结\n本章中，我们介绍了虚拟DOM中最关键的部分：patch。\n\n通过patch可以对比新旧两个虚拟DOM，从而只针对发生了变化的节点进行更新视图的操作。本章详细介绍了如何对比新旧两个节点以及更新视图的过程。\n\n## 5、模板编译\n### 1、介绍\n我们平时使用Vue.js进行开发时，会经常使用模板。模板赋予我们很多强大的能力，例如可以在模板中访问变量。\n\n但在Vue.js中创建HTML并不是只有模板这一种途径，我们既可以手动写渲染函数来创建HTML，也可以在Vue.js中使用JSX来创建HTML。\n\n**渲染函数是创建HTML最原始的方法。模板最终会通过编译转换成渲染函数，渲染函数执行后，会得到一份vnode用于虚拟DOM渲染。所以模板编译其实是配合虚拟DOM进行渲染，**这也是本书先介绍虚拟DOM后介绍模板编译的原因。\n\n### 2、模板编译原理\n模板编译在整个渲染过程中的位置：\n\n<img src=\"/img/vue28.jpeg\" style=\"width:90%\" />\n\nVue.js提供了模板语法，允许我们声明式地描述状态和DOM之间的绑定关系，然后通过模板来生成真实DOM并将其呈现在用户界面上。\n\n在底层实现上，Vue.js会将模板编译成虚拟DOM渲染函数。当应用内部的状态发生变化时，Vue.js可以结合响应式系统，聪明地找出最小数量的组件进行重新渲染以及最少量地进行DOM操作。\n\n#### 2.1 概念\n\n模板编译的主要目标就是生成渲染函数，如下图所示。**而渲染函数的作用是每次执行它，它就会使用当前最新的状态生成一份新的vnode，然后使用这个vnode进行渲染。**\n\n<img src=\"/img/vue29.jpeg\" style=\"width:90%\" />\n\n#### 2.2 模板编译 --> 渲染函数\n将模板编译成渲染函数可以分两个步骤，先将模板解析成AST（Abstract Syntax Tree，抽象语法树），然后再使用AST生成渲染函数。\n\n但是由于静态节点不需要总是重新渲染，所以在生成AST之后、生成渲染函数之前这个阶段，需要做一个操作，那就是遍历一遍AST，给所有静态节点做一个标记，这样在虚拟DOM中更新节点时，如果发现节点有这个标记，就不会重新渲染它。\n\n所以，在大体逻辑上，模板编译分三部分内容：\n\n1. 将模板解析为AST    --> 解析器\n2. 遍历AST标记静态节点 --> 优化器\n3. 使用AST生成渲染函数 --> 代码生成器\n\n<img src=\"/img/vue30.jpeg\" style=\"width:90%\" />\n\n#### 2.3 解析器\n解析器的作用前面已经提到过，其目标很明确，只实现一个功能，那就是将模板解析成AST。\n\n在解析器内部，分成了很多小解析器，其中包括过滤器解析器、文本解析器和HTML解析器。然后通过一条主线将这些解析器组装在一起。\n\nAST其实和vnode有点类似，都是使用JavaScript中的对象来表示节点。\n\n#### 2.4 优化器\n优化器的目标是遍历AST，检测出所有静态子树（永远都不会发生变化的DOM节点）并给其打标记。\n\n当AST中的静态子树被打上标记后，每次重新渲染时，就不需要为打上标记的静态节点创建新的虚拟节点，而是直接克隆已存在的虚拟节点。在虚拟DOM的更新操作中，如果发现两个节点是同一个节点，正常情况下会对这两个节点进行更新，但是如果这两个节点是静态节点，则可以直接跳过更新节点的流程。\n\n\n#### 2.5 代码生成器\n\n1、模板\n\n```html\n<p title=\"Brewin\" @click=\"c\">1</p>\n```\n\n2、生成后的代码字符串\n\n```js\n`with(this){return _c('p',{attrs:{\"title\":\"Berwin\"},on:{\"click\":c}},[_v(\"1\")])}`\n\n// 格式化后\nwith(this){\n  return _c(\n    'p',\n    {\n      attrs:{\"title\":\"Berwin\"},\n      on:{\"click\":c}\n    },\n    [_v(\"1\")]\n  )\n}\n```\n这样一个代码字符串最终导出到外界使用时，会将代码字符串放到函数里，这个函数叫作渲染函数。\n\n\n```js\nconst code = `with(this){return 'Hello Berwin'}`\nconst hello = new Function(code)\n  \nhello()\n// \"Hello Berwin\"\n```\n**渲染函数的作用是创建vnode。渲染函数之所以可以生成vnode，是因为代码字符串中会有很多函数调用（例如，上面生成的代码字符串中有两个函数调用 _c和 _v），这些函数是虚拟DOM提供的创建vnode的方法。vnode有很多种类型，不同的类型对应不同的创建方法，所以代码字符串中的 _c和 _v其实都是创建vnode的方法，只是创建的vnode的类型不同。例如，_c可以创建元素类型的vnode，而 _v可以创建文本类型的vnode。**\n\n### 3、解析器\n#### 3.1 解析器作用\n\n\n解析器要实现的功能是将模板解析成AST。\n\n其实AST并不是什么很神奇的东西，不要被它的名字吓倒。它只是用JavaScript中的对象来描述一个节点，一个对象表示一个节点，对象中的属性用来保存节点所需的各种数据。\n\n```html\n<div>\n  <p>{{name}}</p>\n</div>\n```\n\nAST\n\n```js\n{\n  tag: \"div\"\n  type: 1,\n  staticRoot: false,\n  static: false,\n  plain: true,\n  parent: undefined,\n  attrsList: [],\n  attrsMap: {},\n  children: [\n    {\n      tag: \"p\"\n      type: 1,\n      staticRoot: false,\n      static: false,\n      plain: true,\n      parent: {tag: \"div\", ...},\n      attrsList: [],\n      attrsMap: {},\n      children: [{\n        type: 2,\n        text: \"{{name}}\",\n        static: false,\n        expression: \"_s(name)\"\n      }]\n    }\n  ]\n}\n```\n\n#### 3.2 解析器内部运行原理\n解析器内部也分了好几个子解析器，比如HTML解析器、文本解析器以及过滤器解析器，其中最主要的是HTML解析器。顾名思义，HTML解析器的作用是解析HTML，它在解析HTML的过程中会不断触发各种钩子函数。这些钩子函数包括开始标签钩子函数、结束标签钩子函数、文本钩子函数以及注释钩子函数。\n\n伪代码：\n```js\nparseHTML(template, {\n  start(tag, attrs, unary){\n    // 每当解析到标签的开始位置时，就会触发这个钩子函数\n  },\n  end(){\n    //  每当解析到标签的结束位置时，就会触发这个钩子函数\n  },\n  chars(text){\n    //  每当解析到文本时，就会触发这个钩子函数\n  },\n  comment(text){\n    //  每当解析到注释时，就会触发这个钩子函数\n  }\n})\n```\n\n```html\n<div><p>我是berwin</p></div>\n```\n当上面这个模板被HTML解析器解析时，所触发的钩子函数依次是：start、start、chars、end和end。\n\n也就是说，解析器其实是从前向后解析的。解析到 <div\\> 时，会触发一个标签开始的钩子函数start；然后解析到 <p\\> 时，又触发一次钩子函数start；接着解析到我是Berwin这行文本，此时触发了文本钩子函数chars；然后解析到 </p\\>，触发了标签结束的钩子函数end；接着继续解析到 </div\\>，此时又触发一次标签结束的钩子函数end，解析结束。\n\n因此，我们可以在钩子函数中构建AST节点。在start钩子函数中构建元素类型的节点，在chars钩子函数中构建文本类型的节点，在comment钩子函数中构建注释类型的节点。\n\n```js\nfunction createASTElement (tag, attrs, parent ){\n    return {\n      type: 1,\n      tag,\n      attrsList: attrs,\n      parent,\n      children: []\n    }\n}\n\nparseHTML(template, {\n  start(tag, attrs, unary){\n     let element = createASTElement(tag, attrs, currentParent);\n  },\n  chars(text){\n    let element = {\n      type: 3,\n      text\n    }\n  },\n  comment(text){\n    let element = {\n      type: 3,\n      text,\n      isComment: true\n    }\n  }\n})\n```\n\n\n基于HTML解析器的逻辑，我们可以在每次触发钩子函数start时，把当前构建的节点推入栈中；每当触发钩子函数end时，就从栈中弹出一个节点。\n\n这样就可以保证每当触发钩子函数start时，栈的最后一个节点就是当前正在构建的节点的父节点，如下图：\n\n<img src=\"/img/vue31.jpeg\" style=\"width:90%\" />\n\n假如有个模板：\n```html\n<div>\n  <h1>我是Berwin</h1>\n  <p>我今年23岁</p>\n</div>\n```\n\n上面模板解析成AST的过程如下：\n\n<img src=\"/img/vue32.jpeg\" style=\"width:90%\" />\n<img src=\"/img/vue33.jpeg\" style=\"width:90%\" />\n\n❶ 模板的开始位置是div的开始标签，于是会触发钩子函数start。start触发后，会先构建一个div节点。此时发现栈是空的，这说明div节点是根节点，因为它没有父节点。最后，将div节点推入栈中，并将模板字符串中的div开始标签从模板中截取掉。\n\n❷ 这时模板的开始位置是一些空格，这些空格会触发文本节点的钩子函数，在钩子函数里会忽略这些空格。同时会在模板中将这些空格截取掉。\n\n❸ 这时模板的开始位置是h1的开始标签，于是会触发钩子函数start。与前面流程一样，start触发后，会先构建一个h1节点。此时发现栈的最后一个节点是div节点，这说明h1节点的父节点是div，于是将h1添加到div的子节点中，并且将h1节点推入栈中，同时从模板中将h1的开始标签截取掉。\n\n❹ 这时模板的开始位置是一段文本，于是会触发钩子函数chars。chars触发后，会先构建一个文本节点，此时发现栈中的最后一个节点是h1，这说明文本节点的父节点是h1，于是将文本节点添加到h1节点的子节点中。由于文本节点没有子节点，所以文本节点不会被推入栈中。最后，将文本从模板中截取掉。\n\n❺ 这时模板的开始位置是h1结束标签，于是会触发钩子函数end。end触发后，会把栈中最后一个节点弹出来。\n\n❻ 与第 ❷ 步一样，这时模板的开始位置是一些空格，这些空格会触发文本节点的钩子函数，在钩子函数里会忽略这些空格。同时会在模板中将这些空格截取掉。\n\n❼ 这时模板的开始位置是p开始标签，于是会触发钩子函数start。start触发后，会先构建一个p节点。由于第 ❺ 步已经从栈中弹出了一个节点，所以此时栈中的最后一个节点是div，这说明p节点的父节点是div。于是将p推入div的子节点中，最后将p推入到栈中，并将p的开始标签从模板中截取掉。\n\n❽ 这时模板的开始位置又是一段文本，于是会触发钩子函数chars。当chars触发后，会先构建一个文本节点，此时发现栈中的最后一个节点是p节点，这说明文本节点的父节点是p节点。于是将文本节点推入p节点的子节点中，并将文本从模板中截取掉。\n\n❾ 这时模板的开始位置是p的结束标签，于是会触发钩子函数end。当end触发后，会从栈中弹出一个节点出来，也就是把p标签从栈中弹出来，并将p的结束标签从模板中截取掉。\n\n❿ 与第 ❷ 步和第 ❻ 步一样，这时模板的开始位置是一些空格，这些空格会触发文本节点的钩子函数并且在钩子函数里会忽略这些空格。同时会在模板中将这些空格截取掉。\n\n⓫ 这时模板的开始位置是div的结束标签，于是会触发钩子函数end。其逻辑与之前一样，把栈中的最后一个节点弹出来，也就是把div弹了出来，并将div的结束标签从模板中截取掉。\n\n⓬ 这时模板已经被截取空了，也就说明HTML解析器已经运行完毕。这时我们会发现栈已经空了，但是我们得到了一个完整的带层级关系的AST语法树。这个AST中清晰写明了每个节点的父节点、子节点及其节点类型。\n\n\n\n#### 3.3 HTML解析器\n我们发现构建AST非常依赖HTML解析器所执行的钩子函数以及钩子函数中所提供的参数，你一定会非常好奇HTML解析器是如何解析模板的。\n\n##### 3.3.1 运行原理\n事实上，解析HTML模板的过程就是循环的过程，简单来说就是用HTML模板字符串来循环，每轮循环都从HTML模板中截取一小段字符串，然后重复以上过程，直到HTML模板被截成一个空字符串时结束循环，解析完毕（如上图所示）。\n\n```js\nfunction parseHTML(html, options) {\n  while (html) {\n    // 截取模版字符串并触发钩子函数\n    // todo...\n  }\n}\n```\n\nHTML模板：\n\n```js\n`<div>\n  <p>{{name}}</p>\n</div>`\n```\n\n第一轮循环时，截取一段字符串<div\\>, 切触发钩子函数start, 截取后的结果为：\n\n```js\n`\n  <p>{{name}}</p>\n</div>`\n```\n\n第二轮循环时，截取出一段字符串\n\n```js\n`\n  `\n```\n\n并且触发钩子函数chars，截取后的结果为：\n\n```js\n`<p>{{name}}</p>\n</div>`\n```\n\n第三轮循环时，截取出一段字符串 <p\\>，并且触发钩子函数start，截取后的结果为：\n\n```js\n`{{name}}</p>\n</div>`\n```\n\n第四轮循环时，截取出一段字符串 {{name}}，并且触发钩子函数chars，截取后的结果为：\n\n```js\n`</p>\n</div>`\n```\n\n第五轮循环时，截取出一段字符串 </p\\>，并且触发钩子函数end，截取后的结果为：\n\n```js\n`\n</div>`\n```\n\n第六轮循环时，截取出一段字符串：\n\n```js\n`\n`\n```\n\n并且触发钩子函数chars，截取后的结果为：\n\n```js\n`</div>`\n```\n\n第七轮循环时，截取出一段字符串 </div\\>，并且触发钩子函数end，截取后的结果为：\n\n```js\n``\n```\n\n这些被截取的片段分很多种类型，示例如下:\n\n● 开始标签，例如 <div\\>。\n\n● 结束标签，例如 </div\\>。\n\n● HTML注释，例如 <!-- 我是注释 --\\>。\n\n● DOCTYPE，例如 <!DOCTYPE html\\>。\n\n● 条件注释，例如 <!--[if !IE]>--\\>我是注释<!--<![endif]--\\>。\n\n● 文本，例如我是Berwin。\n\n\n\n##### 3.3.2 截取开始标签\n如何确定模板是不是以开始标签开头？\n\n在HTML解析器中，想分辨出模板是否以开始标签开头并不难，我们需要先判断HTML模板是不是以 < 开头。\n\n如何使用正则表达式来匹配模板以开始标签开头？我们看下面的代码：\n\n```js\nconst ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`;\nconst startTagOpen = new RegExp(`^<${qnameCapture}`);\n\n// 以开始标签开始的模板\n'<div></div>'.match(startTagOpen); // [\"div\", \"div\", index: 0, input: \"<div></div>\"]\n\n// 以结束标签开始的模板\n'</div><div>我是Berwin</div>'.match(startTagOpen); // null\n\n// 以文本开始的模板\n'我是Berwin</p>'.match(startTagOpen); // null\n```\n通过上面的例子可以看到，只有 '<div\\></div\\>' 可以成功匹配，而以 </div\\> 开头的或者以文本开头的模板都无法成功匹配。\n\n当完成上面的解析后，我们可以得到这样一个数据结构：\n\n```js\nconst start = '<div></div>'.match(startTagOpen)\nif (start) {\n  const match = {\n    tagName: start[1],\n    attrs: []\n  }\n}\n```\n\n前面解析开始标签时，我们将其拆解成了三个部分，分别是标签名、属性和结尾。我相信你已经对开始标签的解析有了一个清晰的认识，接下来看一下Vue.js中真实的代码是什么样的：\n\n```js\n  const ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*'\n  const qnameCapture = `((?:${ncname}\\\\:)?${ncname})`\n  const startTagOpen = new RegExp(`^<${qnameCapture}`)\n  const startTagClose = /^\\s*(\\/?)>/\n  \n  function advance (n) {\n    html = html.substring(n)\n  }\n  \n  function parseStartTag () {\n    // 解析标签名，判断模板是否符合开始标签的特征\n    const start = html.match(startTagOpen)\n    if (start) {\n      const match = {\n        tagName: start[1],\n        attrs: []\n      }\n      advance(start[0].length)\n  \n      // 解析标签属性\n      let end, attr\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length)\n        match.attrs.push(attr)\n      }\n  \n      // 判断该标签是否是自闭合标签\n      if (end) {\n        match.unarySlash = end[1]\n        advance(end[0].length)\n        return match\n      }\n    }\n  }\n```\n上面的代码是Vue.js中解析开始标签的源码，这段代码中的html变量是HTML模板。\n\n\n##### 3.3.3 截取结束标签\n如果HTML模板的第一个字符不是 <，那么一定不是结束标签。只有HTML模板的第一个字符是 \\< 时，我们才需要进一步确认它到底是不是结束标签。\n\n进一步确认时，我们只需要判断剩余HTML模板的开始位置是否符合正则表达式中定义的规则即可：\n\n```js\n  const ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*'\n  const qnameCapture = `((?:${ncname}\\\\:)?${ncname})`\n  const endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`)\n  \n  const endTagMatch = '</div>'.match(endTag)\n  const endTagMatch2 = '<div>'.match(endTag)\n  \n  console.log(endTagMatch) // [\"</div>\", \"div\", index: 0, input: \"</div>\"]\n  console.log(endTagMatch2) // null\n```\n\n而Vue.js中相关源码被精简后如下：\n\n```js\n  const endTagMatch = html.match(endTag)\n  if (endTagMatch) {\n    html = html.substring(endTagMatch[0].length)\n    options.end(endTagMatch[1])\n    continue\n  }\n```\n\n\n##### 3.3.4 截取注释\n分辨模板是否已经截取到注释的原理与开始标签和结束标签相同，先判断剩余HTML模板的第一个字符是不是 \\<，如果是，再用正则表达式来进一步匹配：\n\n```js\n  const comment = /^<!--/\n  if (comment.test(html)) {\n    const commentEnd = html.indexOf('-->')\n  \n    if (commentEnd >= 0) {\n      if (options.shouldKeepComment) {\n        options.comment(html.substring(4, commentEnd))\n      }\n      html = html.substring(commentEnd + 3)\n      continue\n    }\n  }\n```\n\n##### 3.3.5 截取条件注释\n截取条件注释的原理与截取注释非常相似，如果模板的第一个字符是 <，并且符合我们事先用正则表达式定义好的规则，就说明需要进行条件注释的截取操作。\n\n```js\n  const conditionalComment = /^<!\\[/\n  if (conditionalComment.test(html)) {\n    const conditionalEnd = html.indexOf(']>')\n  \n    if (conditionalEnd >= 0) {\n      html = html.substring(conditionalEnd + 2)\n      continue\n    }\n  }\n```\n\n举个例子:\n\n```js\n  const conditionalComment = /^<!\\[/\n  let html = '<![if !IE]><link href=\"non-ie.css\" rel=\"stylesheet\"><![endif]>'\n  if (conditionalComment.test(html)) {\n    const conditionalEnd = html.indexOf(']>')\n    if (conditionalEnd >= 0) {\n      html = html.substring(conditionalEnd + 2)\n    }\n  }\n  \n  console.log(html) // '<link href=\"non-ie.css\" rel=\"stylesheet\"><![endif]>'\n```\n\n通过这个逻辑可以发现，在Vue.js中条件注释其实没有用，写了也会被截取掉，通俗一点说就是写了也白写。\n\n\n##### 3.3.6 截取DOCTYPE\n\n```js\n  const doctype = /^<!DOCTYPE [^>]+>/i\n  const doctypeMatch = html.match(doctype)\n  if (doctypeMatch) {\n    html = html.substring(doctypeMatch[0].length)\n    continue\n  }\n```\n\n例子：\n\n```js\n  const doctype = /^<!DOCTYPE [^>]+>/i\n  let html = '<!DOCTYPE html><html lang=\"en\"><head></head><body></body></html>'\n  const doctypeMatch = html.match(doctype)\n  if (doctypeMatch) {\n    html = html.substring(doctypeMatch[0].length)\n  }\n  \n  console.log(html) // '<html lang=\"en\"><head></head><body></body></html>'\n```\n##### 3.3.7 截取文本\n在前面的其他标签类型中，我们都会判断剩余HTML模板的第一个字符是否是 <，如果是，再进一步确认到底是哪种类型。这是因为以 < 开头的标签类型太多了，如开始标签、结束标签和注释等。然而文本只有一种，如果HTML模板的第一个字符不是 <，那么它一定是文本了。\n\n```html\n我是文本</div>\n```\n\n上面这段HTML模板并不是以 < 开头的，所以可以断定它是以文本开头的。那么，如何从模板中将文本解析出来呢？我们只需要找到下一个 < 在什么位置，这之前的所有字符都属于文本。\n\n代码中可以这样实现：\n\n```js\n  while (html) {\n    let text\n    let textEnd = html.indexOf('<')\n  \n    // 截取文本\n    if (textEnd >= 0) {\n      text = html.substring(0, textEnd)\n      html = html.substring(textEnd)\n    }\n  \n    // 如果模板中找不到 <，就说明整个模板都是文本\n    if (textEnd < 0) {\n      text = html\n      html = ''\n    }\n  \n    // 触发钩子函数\n    if (options.chars && text) {\n      options.chars(text)\n    }\n  }\n```\n\n如果 < 是文本的一部分，该如何处理：\n\n```html\n<我<是文本</div>\n```\n\n```js\n  while (html) {\n    let text, rest, next\n    let textEnd = html.indexOf('<')\n  \n    // 截取文本\n    if (textEnd >= 0) {\n      rest = html.slice(textEnd)\n      while (\n        !endTag.test(rest) &&\n        !startTagOpen.test(rest) &&\n        !comment.test(rest) &&\n        !conditionalComment.test(rest)\n      ) {\n        // 如果'<'在纯文本中，将它视为纯文本对待\n        next = rest.indexOf('<', 1)\n        if (next < 0) break\n        textEnd += next\n        rest = html.slice(textEnd)\n      }\n      text = html.substring(0, textEnd)\n      html = html.substring(textEnd)\n    }\n  \n    // 如果模板中找不到 <，那么说明整个模板都是文本\n    if (textEnd < 0) {\n      text = html\n      html = ''\n    }\n  \n    // 触发钩子函数\n    if (options.chars && text) {\n      options.chars(text)\n    }\n  }\n```\n\n上面的代码中，endTag、startTagOpen、comment和conditionalComment都是正则表达式，分别匹配结束标签、开始标签、注释和条件注释。\n\n##### 3.3.8 纯文本内容元素的处理\n什么是纯文本内容元素呢？script、style和textarea这三种元素叫作纯文本内容元素。解析它们的时候，会把这三种标签内包含的所有内容都当作文本处理。\n\n前面介绍开始标签、结束标签、文本、注释的截取时，其实都是默认当前需要截取的元素的父级元素不是纯文本内容元素。事实上，如果要截取元素的父级元素是纯文本内容元素的话，处理逻辑将完全不一样。\n\n```js\n  while (html) {\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      // 父元素为正常元素的处理逻辑\n      // todo\n    } else {\n      // 父元素为script、style、textarea的处理逻辑\n      const stackedTag = lastTag.toLowerCase()\n      const reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'))\n      const rest = html.replace(reStackedTag, function (all, text) {\n        if (options.chars) {\n          options.chars(text)\n        }\n        return ''\n      })\n      html = rest\n      options.end(stackedTag)\n    }\n  }\n```\n\n在上面的代码中，lastTag表示父元素。可以看到，在while中，首先进行判断，如果父元素不存在或者不是纯文本内容元素，那么进行正常的处理逻辑，也就是前面介绍的逻辑。\n\n而当父元素是script这种纯文本内容元素时，会进入到else这个语句里面。由于纯文本内容元素都被视作文本处理，所以我们的处理逻辑就变得很简单，只需要把这些文本截取出来并触发钩子函数chars，然后再将结束标签截取出来并触发钩子函数end。\n\n\n假如我们现在有这样一个模板：\n\n```xml\n  <div id=\"el\">\n    <script>console.log(1)</script>\n  </div>\n```\n\n当解析到script中的内容时，模板是下面的样子：\n\n```xml\nconsole.log(1)</script>\n</div>\n```\n\n钩子函数chars的参数为script中的所有内容，本例中大概是下面的样子：\n\n```js\nchars('console.log(1)')\n```\n\n处理后的剩余模板如下：\n\n```xml\n</div>\n```\n\n##### 3.3.9 使用栈维护DOM层级\n在前面几节中，我们并没有介绍HTML解析器内部其实也有一个栈来维护DOM层级关系，其逻辑与9.2.1节相同：就是每解析到开始标签，就向栈中推进去一个；每解析到标签结束，就弹出来一个。因此，想取到父元素并不难，只需要拿到栈中的最后一项即可。\n\n同时，HTML解析器中的栈还有另一个作用，它可以检测出HTML标签是否正确闭合。例如：\n\n```xml\n<div><p></div>\n```\n\n在上面的代码中，p标签忘记写结束标签，那么当HTML解析器解析到div的结束标签时，栈顶的元素却是p标签。这个时候从栈顶向栈底循环找到div标签，发现在找到div标签之前遇到的所有其他标签都忘记写闭合标签，此时Vue.js会在非生产环境下的控制台中打印警告提示。\n\n##### 3.3.10 整体逻辑\n前面我们把开始标签、结束标签、注释、文本、纯文本内容元素等的截取方式拆分开，单独进行了详细介绍。本节中，我们就来介绍如何将这些解析方式组装起来完成HTML解析器的功能。\n\n首先，HTML解析器是一个函数。就像9.2节介绍的那样，HTML解析器最终的目的是实现这样的功能：\n\n```js\n  parseHTML(template, {\n    start (tag, attrs, unary) {\n      // 每当解析到标签的开始位置时，触发该函数\n    },\n    end () {\n      // 每当解析到标签的结束位置时，触发该函数\n    },\n    chars (text) {\n      // 每当解析到文本时，触发该函数\n    },\n    comment (text) {\n      // 每当解析到注释时，触发该函数\n    }\n  })\n```\n\n**文本解析器原理**\n文本解析器的作用是解析文本。你可能会觉得很奇怪，文本不是在HTML解析器中被解析出来了么？准确地说，文本解析器是对HTML解析器解析出来的文本进行二次加工。为什么要进行二次加工？\n\n**文本其实分两种类型，一种是纯文本，另一种是带变量的文本。**\n\n```xml\nHello World\n\nHello {{ name }}\n```\n\n而在构建文本类型的AST时，纯文本和带变量的文本是不同的处理方式。如果是带变量的文本，我们需要借助文本解析器对它进行二次加工，其代码如下：\n\n```js\npaseHTML(template, {\n   start(tag, attrs, unary){\n\n   },\n   end(){\n\n   },\n   chars(text){\n      text = text.trim();\n      if(text){\n        const children = currentParent.children;\n        let expression;\n        if(expression == parseText(text)){\n            children.push({\n              type: 2,\n              expression,\n              text\n            })\n        }else{\n            children.push({\n              type: 3,\n              text\n            })\n        }\n      }\n   },\n   comment(text){\n\n   }\n})\n```\n\n```js\n\"hello {{name}}\"\n```\n解析之后，得到expression变量为：\n\n```js\n\"hello \"+_s(name)\n```\n\n_s其实是下面这个toString函数的别名：\n\n```js\nfunction toString(val){\n  return val == null \n         ? '' \n         : typeof val === 'object'\n           ? JSON.stringify(val, null, 2) : String(val)\n}\n```\n\n假设当前上下文中有一个变量name，其值为Berwin，那么expression中的内容被执行时，它的内容是不是就是Hello Berwin了？\n\n举个例子：\n\n```js\nlet obj = {name: 'Berwin'};\nwith(obj){\n  funciton toString(val){\n    return val == null \n           ? '' \n           : typeof val === 'object'\n             ? JSON.stringify(val, null, 2) : String(val)\n  }\n  console.log(\"Hello \"+toString(name));  // \"Hello Berwin\"\n}\n```\n\n在文本解析器中，**第一步要做的事情就是使用正则表达式来判断文本是否为带变量的文本，也就是检查文本中是否包含 {{xxx}} 这样的语法。如果是纯文本，则直接返回undefined；如果是带变量的文本，再进行二次加工。**所以我们的代码是这样的：\n\n```js\nfunction parseText (text){\n  const tagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g\n  if(!tagRE(text)){\n     return;\n  }\n}\n```\n\n一个解决思路是使用正则表达式匹配出文本中的变量，先把变量左边的文本添加到数组中，然后把变量改成 _s(x)这样的形式也添加到数组中。如果变量后面还有变量，则重复以上动作，直到所有变量都添加到数组中。如果最后一个变量的后面有文本，就将它添加到数组中。\n\n这时我们其实已经有一个数组，数组元素的顺序和文本的顺序是一致的，此时将这些数组元素用+连起来变成字符串，就可以得到最终想要的效果:\n\n<img src=\"/img/vue34.jpeg\" style=\"width:90%\" />\n\n具体实现代码如下：\n\n```js\nfunction parseText(text){\n  const tagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g\n  if(!tagRE.test(text)) return;\n\n  const tokens = [];\n  let lastIndex = tagRE.lastIndex = 0;\n  let match, index;\n  while((match=tagRE.exec(text))){\n     index = match.index;\n     // 先把 {{  前边的文本添到tokens中\n     if(index > lastIndex){\n        tokens.push(JSON.stringify(text.slice(lastIndex, index)))\n     }\n\n     // 把变量改成_s(x)这样的形式也添加到数组中\n     tokens.push(`_s(${match[1].trim()})`);\n\n     // 设置lastIndex来保证下一轮循环时，正则表达式不再重复匹配已经解析过文本\n     lastIndex = index + match[0].length;\n\n     // 当所有的变量都处理完毕后，如果最后一个变量右边还有文本，就讲文本添加数组中\n     if(lastIndex < text.length){\n       tokens.push(JSON.stringify(text.slice(lastIndex))\n     }\n\n     return tokens.join('+');\n  }\n}\n```\n\n这段代码有一个很关键的地方在lastIndex：每处理完一个变量后，会重新设置lastIndex的位置，这样可以保证如果后面还有其他变量，那么在下一轮循环时可以从lastIndex的位置开始向后匹配，而lastIndex之前的文本将不再被匹配。\n\n**总结**\n解析器的作用是通过模板得到AST（抽象语法树）。\n\n生成AST的过程需要借助HTML解析器，当HTML解析器触发不同的钩子函数时，我们可以构建出不同的节点。\n\n随后，我们可以通过栈来得到当前正在构建的节点的父节点，然后将构建出的节点添加到父节点的下面。\n\n最终，当HTML解析器运行完毕后，我们就可以得到一个完整的带DOM层级关系的AST。\n\nHTML解析器的内部原理是一小段一小段地截取模板字符串，每截取一小段字符串，就会根据截取出来的字符串类型触发不同的钩子函数，直到模板字符串截空停止运行。\n\n文本分两种类型，不带变量的纯文本和带变量的文本，后者需要使用文本解析器进行二次加工。\n\n\n\n### 4、优化器\n解析器的作用是将HTML模板解析成AST，而优化器的作用是在AST中找出静态子树并打上标记。\n\n静态子树指的是那些在AST中永远都不会发生变化的节点。例如，一个纯文本节点就是静态子树，而带变量的文本节点就不是静态子树，因为它会随着变量的变化而变化。\n\n标记静态子树有两点好处：\n\n  ● 每次重新渲染时，不需要为静态子树创建新节点；\n\n  ● 在虚拟DOM中打补丁（patching）的过程可以跳过。\n\n每次重新渲染时，不需要为静态子树创建新节点，是什么意思呢？\n\n前面介绍虚拟DOM时，我们说每次重新渲染都会使用最新的状态生成一份全新的VNode与旧的VNode进行对比。而在生成VNode的过程中，如果发现一个节点被标记为静态子树，那么除了首次渲染会生成节点之外，在重新渲染时并不会生成新的子节点树，而是克隆已存在的静态子树。\n\n在虚拟DOM中打补丁的过程可以被跳过，又是什么意思？\n\n我们介绍了如果两个节点都是静态子树，就不需要进行对比与更新DOM的操作，直接跳过。因为静态子树是不可变的，不需要对比就知道它不可能发生变化。此外，直接跳过后续的各种对比可以节省JavaScript的运算成本。\n\n优化器的内部实现主要分为两个步骤：\n\n(1) 在AST中找出所有静态节点并打上标记；\n\n(2) 在AST中找出所有静态根节点并打上标记。\n\n先标记所有静态节点，再标记所有静态根节点。那么，什么是静态节点？像下面这样永远都不会发生变化的节点属于静态节点：\n\n```html\n<p>我是静态节点</p>\n```\n\n落到AST中，静态节点指static为true节点\n\n```js\n  {\n    type: 1,\n    tag: 'p',\n    staticRoot: false,\n    static: true,\n    ……\n  }\n```\n\n什么是静态根节点？如果一个节点下面的所有子节点都是静态节点，并且它的父级是动态节点，那么它就是静态根节点。下面模板中的ul就属于静态根节点：\n\n```html\n  <ul>\n    <li>我是静态节点，我不需要发生变化</li>\n    <li>我是静态节点2，我不需要发生变化</li>\n    <li>我是静态节点3，我不需要发生变化</li>\n  </ul>\n```\n\n落到AST中， 静态根节点指staticRoot属性为true\n\n```js\n  {\n    type: 1,\n    tag: 'ul',\n    staticRoot: true,\n    static: true,\n    ……\n  }\n```\n\n举个例子：\n\n```html\n<div id=\"el\">Hello {{name}}</div>\n```\n\n如果我们有上面这样一个模板，它转换成AST之后是下面的样子：\n\n```js\n01  {\n02    'type': 1,\n03    'tag': 'div',\n04    'attrsList': [\n05      {\n06        'name': 'id',\n07        'value': 'el'\n08      }\n09    ],\n10    'attrsMap': {\n11      'id': 'el'\n12    },\n13    'children': [\n14      {\n15        'type':2,\n16        'expression':'\"Hello \"+_s(name)',\n17        'text':'Hello {{name}}'\n18      }\n19    ],\n20    'plain': false,\n21    'attrs': [\n22      {\n23        'name': 'id',\n24        'value': '\"el\"'\n25      }\n26    ]\n27  }\n```\n\n经过优化器优化后，AST如下：\n\n```js\n01  {\n02    'type': 1,\n03    'tag': 'div',\n04    'attrsList': [\n05      {\n06        'name': 'id',\n07        'value': 'el'\n08      }\n09    ],\n10    'attrsMap': {\n11      'id': 'el'\n12    },\n13    'children': [\n14      {\n15        'type': 2,\n16        'expression': '\"Hello \"+_s(name)',\n17        'text': 'Hello {{name}}',\n18        'static': false\n19      }\n20    ],\n21    'plain': false,\n22    'attrs': [\n23      {\n24        'name': 'id',\n25        'value': '\"el\"'\n26      }\n27    ],\n28    'static': false,\n29    'staticRoot': false\n30  }\n```\n\n#### 4.1 找出所有静态节点并标记\n找出所有静态子节点并不难，我们只需要从根节点开始，先判断根节点是不是静态根节点，再用相同的方式处理子节点，接着用同样的方式去处理子节点的子节点，直到所有节点都被处理之后程序结束，这个过程叫作递归。\n\n```js\n  function markStatic (node) {\n    node.static = isStatic(node)\n    if (node.type === 1) {\n      for (let i = 0, l = node.children.length; i < l; i++) {\n        const child = node.children[i]\n        markStatic(child)\n      }\n    }\n  }\n```\n\nisStatic方法如下：\n\n```js\n  function isStatic (node) {\n    if (node.type === 2) { // 带变量的动态文本节点\n      return false\n    }\n    if (node.type === 3) { // 不带变量的纯文本节点\n      return true\n    }\n    return !!(node.pre || (\n      !node.hasBindings && // 没有动态绑定\n      !node.if && !node.for && // 没有v-if或v-for或v-else\n      !isBuiltInTag(node.tag) && // 不是内置标签\n      isPlatformReservedTag(node.tag) && // 不是组件\n      !isDirectChildOfTemplateFor(node) &&\n      Object.keys(node).every(isStaticKey)\n    ))\n  }\n```\ntype的取值及其说明：\n\n1、type = 1 为 元素节点\n\n2、type = 2 为 带变量的动态文本节点\n\n3、type = 3 为 不带变量的纯文本阶段\n\n当type等于1时，说明节点是元素节点。当一个节点是元素节点时，想分辨出它是否是静态节点，就会稍微有点复杂。\n\n首先，如果元素节点使用了指令v-pre，那么可以直接断定它是一个静态节点\n\n其次，如果元素节点没有使用指令v-pre，那么它必须同时满足以下条件才会被认为是一个静态节点。\n  \n  ● 不能使用动态绑定语法，也就是说标签上不能有以v-、@、:开头的属性。\n  \n  ● 不能使用v-if、v-for或者v-else指令。\n  \n  ● 不能是内置标签，也就是说标签名不能是slot或者component。\n  \n  ● 不能是组件，即标签名必须是保留标签，例如<div\\></div\\>是保留标签，而<list\\></list\\>不是保留标签。\n  \n  ● 当前节点的父节点不能是带v-for指令的template标签。\n  \n  ● 节点中不存在动态节点才会有的属性。\n\n\n我们已经可以判断一个节点是否是静态节点，并且可以通过递归的方式来标记子节点是否是静态节点。\n\n但是这里会遇到一个问题，递归是从上向下依次标记的，如果父节点被标记为静态节点之后，子节点却被标记为动态节点，这时就会发生矛盾。因为静态子树中不应该只有它自己是静态节点，静态子树的所有子节点应该都是静态节点。\n\n```js\n  function markStatic (node) {\n    node.static = isStatic(node)\n    if (node.type === 1) {\n      for (let i = 0, l = node.children.length; i < l; i++) {\n        const child = node.children[i]\n        markStatic(child)\n  \n        // 新增代码\n        if (!child.static) {\n          node.static = false\n        }\n      }\n    }\n  }\n```\n\n\n#### 4.2 找出所有静态根节点并标记\n\n\n#### 4.3 总结\n优化器的作用是在AST中找出静态子树并打上标记，这样做有两个好处：\n\n● 每次重新渲染时，不需要为静态子树创建新节点；\n\n● 在虚拟DOM中打补丁的过程可以跳过。\n\n通过递归的方式从上向下标记静态节点时，如果一个节点被标记为静态节点，但它的子节点却被标记为动态节点，就说明该节点不是静态节点，可以将它改为动态节点。静态节点的特征是它的子节点必须是静态节点。\n\n标记完静态节点之后需要标记静态根节点，其标记方式也是使用递归的方式从上向下寻找，在寻找的过程中遇到的第一个静态节点就为静态根节点，同时不再向下继续查找。\n\n但有两种情况比较特殊：一种是如果一个静态根节点的子节点只有一个文本节点，那么不会将它标记成静态根节点，即便它也属于静态根节点；另一种是如果找到的静态根节点是一个没有子节点的静态节点，那么也不会将它标记为静态根节点。因为这两种情况下，优化成本大于收益。\n\n\n\n\n### 5、代码生成器\n代码生成器是模板编译的最后一步，它的作用是将AST转换成渲染函数中的内容，这个内容可以称为代码字符串。\n\n代码字符串可以被包装在函数中执行，这个函数就是我们通常所说的渲染函数。\n\n本章中，我们主要讨论如何使用AST生成代码字符串。\n\n假设现在有这样一个简单的模板：\n\n```xml\n<div id=\"el\">Hello {{name}}</div>\n```\n\n它转换成AST并且经过优化器的优化之后是下面的样子：\n\n```js\n  {\n    'type': 1,\n    'tag': 'div',\n    'attrsList': [\n      {\n        'name': 'id',\n        'value': 'el'\n      }\n    ],\n    'attrsMap': {\n      'id': 'el'\n    },\n    'children': [\n      {\n        'type': 2,\n        'expression': '\"Hello \"+_s(name)',\n        'text': 'Hello {{name}}',\n        'static': false\n      }\n    ],\n    'plain': false,\n    'attrs': [\n      {\n        'name': 'id',\n        'value': '\"el\"'\n      }\n    ],\n    'static': false,\n    'staticRoot': false\n  }\n```\n\n代码生成器可以通过上面这个AST来生成代码字符串，生成后的代码字符串是这样的：\n\n```js\n'with(this){return _c(\"div\",{attrs:{\"id\":\"el\"}},[_v(\"Hello \"+_s(name))])}'\n\n// 格式化之后\n  with (this) {\n    return _c(\n      \"div\",\n      {\n        attrs:{\"id\": \"el\"}\n      },\n      [\n        _v(\"Hello \"+_s(name))\n      ]\n    )\n  }\n```\n\n仔细观察生成后的代码字符串，我们会发现，**这其实是一个嵌套的函数调用。函数_c的参数中执行了函数 _v，而函数 _v的参数中又执行了函数 _s。**\n\n_c其实是createElement的别名。createElement是虚拟DOM中所提供的方法，它的作用是创建虚拟节点，有三个参数，分别是：\n\n● 标签名\n\n● 一个包含模板相关属性的数据对象\n\n● 子节点列表\n\n调用createElement方法，我们可以得到一个VNode。\n\n这也就知道了渲染函数可以生成VNode的原因：渲染函数其实是执行了createElement，而createElement可以创建一个VNode。\n\n#### 5.1 通过AST生成代码字符串 \n生成代码字符串是一个递归的过程，从顶向下依次处理每一个AST节点\n\n节点有三种类型，分别对应三种不同的创建方法与别名：\n\n<img src=\"/img/vue35.jpeg\" style=\"max-width:95%\" />\n\n例如：\n\n```html\n  <div id=\"el\">\n    <div>\n      <p>Hello {{name}}</p>\n    </div>\n  </div>\n```\n\n生成代码字符串：\n\n```js\n_c('div',\n   {attrs:{\"id\":\"el\"}},\n   [_c('div',[_c('p',[_v(\"Hello \"+_s(name))])])]\n   )\n```\n\n<img src=\"/img/vue36.jpeg\" style=\"max-width:95%\" />\n\n当递归结束时，我们就可以得到一个完整的代码字符串。这段代码字符串会被包裹在with语句中，其伪代码如下：\n\n```js\n`with(this){return ${code}}`\n```\n\n#### 5.2 代码生成器的原理\n##### 5.2.1 元素节点\n生成元素节点，其实就是生成一个 _c的函数调用字符串，相关代码如下：\n\n```js\n  function genElement (el, state) {\n    // 如果el.plain是true，则说明节点没有属性\n    const data = el.plain ? undefined : genData(el, state)\n  \n    const children = genChildren(el, state)\n    code = `_c('${el.tag}'${\n      data ? `,${data}` : '' // data\n    }${\n      children ? `,${children}` : '' // children\n    })`\n    return code\n  }\n\n  function genData (el: ASTElement, state: CodegenState): string {\n    let data = '{'\n    // key\n    if (el.key) {\n      data += `key:${el.key},`\n    }\n    // ref\n    if (el.ref) {\n      data += `ref:${el.ref},`\n    }\n    // pre\n    if (el.pre) {\n      data += `pre:true,`\n    }\n    // 类似的还有很多种情况\n    data = data.replace(/,$/, '') + '}'\n    return data\n  }\n\n  function genChildren (el, state) {\n    const children = el.children\n    if (children.length) {\n      return `[${children.map(c => genNode(c, state)).join(',')}]`\n    }\n  }\n  \n  function genNode (node, state) {\n    if (node.type === 1) {\n      return genElement(node, state)\n    } if (node.type === 3 && node.isComment) {\n      return genComment(node)\n    } else {\n      return genText(node)\n    }\n  }\n```\n\n代码中el的plain属性是在编译时发现的。如果节点没有属性，就会把plain设置为true。\n\n这里我们可以通过plain来判断是否需要获取节点的属性数据。代码中的主要逻辑是用genData和genChildren分别获取data和children，然后将它们分别拼到字符串中指定的位置，最后把拼好的 \"_c(tagName, data, children)\"返回，这样一个元素节点的代码字符串就生成好了。\n\n##### 5.2.2 文本节点\n生成文本节点很简单，我们只需要把文本放在 _v这个函数的参数中即可：\n\n```js\n  function genText (text) {\n    return `_v(${text.type === 2\n      ? text.expression\n      : JSON.stringify(text.text)\n    })`\n  }\n```\n如果是动态文本，则使用expression；如果是静态文本，则使用text。\n\n你可能会问，为什么text需要使用JSON.stringify方法？\n\n这是因为expression中的文本是这样的：\n\n```js\n'\"Hello \"+_s(name)'\n```\n\n而text中的文本是这样的：\n\n```js\n\"Hello Berwin\"\n```\n\n而我们希望静态文本是这样的：\n\n```js\n'\"Hello Berwin\"'\n```\n\n所以静态文本需要使用JSON.stringify方法。因为JSON.stringify可以给文本包装一层字符串\n\n##### 5.2.3 注释节点\n注释节点与文本节点相同，只需要把文本放在 _e的参数中即可，其代码如下：\n\n```js\n  function genComment (comment) {\n    return `_e(${JSON.stringify(comment.text)})`\n  }\n```\n\n#### 5.3 总结\n了解了代码生成器其实就是字符串拼接的过程。通过递归AST来生成字符串，最先生成根节点，然后在子节点字符串生成后，将其拼接在根节点的参数中，子节点的子节点拼接在子节点的参数中，这样一层一层地拼接，直到最后拼接成完整的字符串。\n\n最后，我们介绍了当字符串拼接好后，会将字符串拼在with中返回给调用者。\n\n\n## 6、整体流程\n### 1、架构设计和项目结构\n不同的Vue.js构建版本的区别：\n\n<img src=\"/img/vue37.jpeg\" style=\"width:90%\" />\n\n• 完整版：构建后的文件同时包含编译器和运行时。\n\n• 编译器：负责将模板字符串编译成JavaScript渲染函数，这部分内容在第三篇中介绍过。\n\n• 运行时：负责创建Vue.js实例，渲染视图和使用虚拟DOM实现重新渲染，基本上包含除编译器外的所有部分。\n\n• UMD：UMD版本的文件可以通过 <script\\> 标签直接在浏览器中使用, 就是运行时+编译器的UMD版本。\n\n• CommonJS：CommonJS版本用来配合较旧的打包工具，比如Browserify或webpack 1，这些打包工具的默认文件（pkg.main）只包含运行时的CommonJS版本（vue.runtime.common.js）。\n\n\n• ES Module：ES Module版本用来配合现代打包工具，比如webpack 2或Rollup，这些打包工具的默认文件（pkg.module）只包含运行时的ES Module版本（vue.runtime.esm.js）。\n\n\n**运行时+编译器 与 只包含运行时区别：**\n\n如果需要在客户端编译模板（比如传入一个字符串给template选项，或挂载到一个元素上并以其DOM内部的HTML作为模板），那么需要用到编译器，因此需要完整版：\n\n```js\n  // 需要编译器\n  new Vue({\n    template: '<div>{{ hi }}</div>'\n  })\n  \n  // 不需要编译器\n  new Vue({\n    render (h) {\n      return h('div', this.hi)\n    }\n  })\n```\n\n当使用vue-loader或vueify的时候，*.vue文件内部的模板会在构建时预编译成JavaScript。所以，最终打包完成的文件实际上是不需要编译器的，只需要引入运行时版本即可。\n\n由于运行时版本的体积比完整版要小30%左右，所以应该尽可能使用运行时版本。如果仍然希望使用完整版，则需要在打包工具里配置一个别名。\n\n```js\n  module.exports = {\n    // ……\n    resolve: {\n      alias: {\n        'vue$': 'vue/dist/vue.esm.js'  // 'vue/dist/vue.common.js' for webpack 1\n      }\n    }\n  }\n```\n\nCommonJS和ES Module版本用于打包工具，因此Vue.js不提供压缩后的版本，需要自行将最终的包进行压缩。此外，这两个版本同时保留原始的process.env.NODE_ENV检测，来决定它们应该在什么模式下运行。我们应该使用适当的打包工具配置来替换这些环境变量，以便控制Vue.js所运行的模式。把process.env.NODE_ENV替换为字符串字面量，同时让UglifyJS之类的压缩工具完全删除仅供开发环境的代码块，从而减少最终文件的大小。\n\n在webpack中，我们使用DefinePlugin：\n\n```js\n  new webpack.DefinePlugin({\n    'process.env': {\n      NODE_ENV: '\"production\"'\n    }\n  })\n```\n\n#### 1.1 架构设计\n\n<img src=\"/img/vue38.jpeg\" style=\"width:90%\" />\n\n最顶层是入口，也可以叫作出口。对于构建工具和Vue.js的使用者来说，这是入口；对于Vue.js自身来说，这是出口。在构建文件时，不同平台的构建文件会选择不同的入口进行构建操作。\n\n从整体结构上看，下面三层的代码是与平台无关的核心代码，上面三层是与平台相关的代码。因此，整个程序结构还可以用另一种表现形式来展现:\n\n<img src=\"/img/vue39.jpeg\" style=\"width:90%\" />\n\n\n#### 1.2 总结\n在架构设计中，我们介绍了Vue.js在大体上可以分三部分：核心代码、跨平台相关与公用工具函数。核心代码包含原型方法和全局API，它们可以在各个平台下运行，而跨平台相关的部分更多的是渲染相关的功能，不同平台下的渲染API是不同的。以Web平台为例，Web页面中的渲染操作就是操作DOM，所以在跨平台的Web环境下对DOM操作的API进行了封装，这个封装主要与虚拟DOM对接，而虚拟DOM中所使用的各种节点操作其实是调用跨平台层封装的API接口。而Weex平台对节点的操作与Web平台并不相同。\n\n### 2、实例方法和全局API的实现原理\n上一章介绍了Vue.js内部的整体结构，知道了它会向构造函数添加一些属性和方法。本章中，我们将详细介绍它的实例方法和全局API的实现原理。\n\n```js\n  import { initMixin } from './init'\n  import { stateMixin } from './state'\n  import { renderMixin } from './render'\n  import { eventsMixin } from './events'\n  import { lifecycleMixin } from './lifecycle'\n  import { warn } from '../util/index'\n  \n  function Vue (options) {\n    if (process.env.NODE_ENV !== 'production' &&\n      !(this instanceof Vue)\n    ) {\n      warn('Vue is a constructor and should be called with the `new` keyword')\n    }\n    this._init(options)\n  }\n  \n  initMixin(Vue)\n  stateMixin(Vue)\n  eventsMixin(Vue)\n  lifecycleMixin(Vue)\n  renderMixin(Vue)\n  \n  export default Vue\n```\n\n其中定义了Vue构造函数，然后分别调用了initMixin、stateMixin、eventsMixin、lifecycleMixin和renderMixin这5个函数，并将Vue构造函数当作参数传给了这5个函数。\n\n这5个函数的作用就是向Vue的原型中挂载方法，以函数initMixin为例，它的实现方式是这样的：\n\n```js\nexport function initMixin(Vue){\n  Vue.prototype._init = function(options){\n    // ...\n  }\n}\n```\n\n#### 2.1 数据相关的实例方法\n与数据相关的实例方法有3个，分别是vm.$watch、vm.$set和vm.$delete，它们是在stateMixin中挂载到Vue的原型上的，代码如下：\n\n```js\n  import {\n    set,\n    del\n  } from '../observer/index'\n  \n  export function stateMixin (Vue) {\n    Vue.prototype.$set = set\n    Vue.prototype.$delete = del\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\n      // todo\n    }\n  }\n```\n\n可以看到，当stateMixin被调用时，会向Vue构造函数的prototype属性挂载上面说的3个与数据相关的实例方法。\n\n#### 2.2 事件相关的实例方法\n与事件相关的实例方法有4个，分别是：vm.$on、vm.$once、vm.$off和vm.$emit。这4个方法是在eventsMixin中挂载到Vue构造函数的prototype属性中的，其代码如下：\n\n```js\nexport function eventsMixin (Vue) {\n  Vue.prototype.$on = function (event, fn) {\n    // 做点什么\n  }\n\n  Vue.prototype.$once = function (event, fn) {\n    // 做点什么\n  }\n\n  Vue.prototype.$off = function (event, fn) {\n    // 做点什么\n  }\n\n  Vue.prototype.$emit = function (event) {\n    // 做点什么\n  }\n}\n```\n\n##### 2.2.1 vm.$on\n\n使用：监听当前实例上的自定义事件，事件可以由vm.$emit触发。回调函数会接收所有传入事件所触发的函数的额外参数。\n\n```js\nvm.$on('test', function (msg) {\n  console.log(msg)\n})\nvm.$emit('test', 'hi')\n// => \"hi\"\n```\n\n原理：\n\n```js\nVue.prototype.$on = function (event, fn) {\n  const vm = this\n  if (Array.isArray(event)) {\n    for (let i = 0, l = event.length; i < l; i++) {\n      this.$on(event[i], fn)\n    }\n  } else {\n    (vm._events[event] || (vm._events[event] = [])).push(fn)\n  }\n  return vm\n}\n```\n\nvm._events是一个对象，用来存储事件。在代码中，我们使用事件名（event）从vm._events中取出事件列表，如果列表不存在，则使用空数组初始化，然后再将回调函数添加到事件列表中。\n\nvm._events是哪儿来的？事实上，在执行new Vue()时，Vue会执行this._init方法进行一系列初始化操作，其中就会在Vue.js的实例上创建一个 _events属性，用来存储事件。\n\n```js\nvm._events = Object.create(null)\n```\n\n##### 2.2.2 vm.$off\n使用：移除自定义事件监听器\n\n  ● 如果没有提供参数，则移除所有的事件监听器。\n\n  ● 如果只提供了事件，则移除该事件所有的监听器。\n\n  ● 如果同时提供了事件与回调，则只移除这个回调的监听器。\n\n\n原理：\n\n1、首先，我们需要处理没有提供参数的情况，此时需要移除所有事件的监听器，其代码如下：\n\n```js\nVue.prototype.$off = function (event, fn) {\n  const vm = this\n  // 移除所有事件的监听器\n  if (!arguments.length) {\n    vm._events = Object.create(null)\n    return vm\n  }\n  return vm\n\n  // event支持数组\n  if(Array.isArray(event)){\n    for(let i=0; l=event.length; i<l; i++){\n       this.$off(event[i], fn);\n    }\n    return vm;\n  }\n  return vm;\n}\n```\n\n2、接下来，我们需要处理第二种条件：如果只提供了事件名，则移除该事件所有的监听器。实现这个功能并不复杂，我们只需要从this._events中将event重置为空即可。\n\n```js\nVue.prototype.$off = function (event, fn) {\n  const vm = this\n\n  // todo: 上面已实现代码\n\n  // 新增代码\n  const cbs = vm._events[event]\n  if (!cbs) {\n    return vm\n  }\n  // 移除该事件的所有监听器\n  if (arguments.length === 1) {\n    vm._events[event] = null\n    return vm\n  }\n  return vm\n}\n```\n\n3、接下来处理最后一种情况：如果同时提供了事件与回调，那么只移除这个回调的监听器。实现这个功能并不复杂，只需要使用参数中提供的事件名从vm._events上取出事件列表，然后从列表中找到与参数中提供的回调函数相同的那个函数，并将它从列表中移除。综合上面2种情况其代码如下：\n\n```js\n  Vue.prototype.$off = function (event, fn) {\n    const vm = this\n    // 移除所有事件监听器\n    if (!arguments.length) {\n      vm._events = Object.create(null)\n      return vm\n    }\n  \n    // event支持数组\n    if (Array.isArray(event)) {\n      for (let i = 0, l = event.length; i < l; i++) {\n        this.$off(event[i], fn)\n      }\n      return vm\n    }\n  \n    const cbs = vm._events[event]\n    if (!cbs) {\n      return vm\n    }\n    // 移除该事件的所有监听器\n    if (arguments.length === 1) {\n      vm._events[event] = null\n      return vm\n    }\n  \n    // 新增代码\n    // 只移除与fn相同的监听器\n    if (fn) {\n      const cbs = vm._events[event]\n      let cb\n      let i = cbs.length\n      while (i--) {\n        cb = cbs[i]\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i, 1)\n          break\n        }\n      }\n    }\n    return vm\n  }\n```\n\n\n##### 2.2.3 vm.$once\n使用：监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。\n\n原理：我们知道vm.$once和vm.$on的区别是vm.$once只能被触发一次，所以实现这个功能的一个思路是：在vm.$once中调用vm.$on来实现监听自定义事件的功能，当自定义事件触发后会执行拦截器，将监听器从事件列表中移除。\n\n```js\nVue.prototype.$once = function (event, fn) {\n  const vm = this\n  function on () {\n    vm.$off(event, on)\n    fn.apply(vm, arguments)\n  }\n  on.fn = fn\n  vm.$on(event, on)\n  return vm\n}\n```\n\n##### 2.2.4 vm.$emit\n使用：触发当前实例上的事件。附加参数都会传给监听器回调。\n\n\n原理：\n\n```js\nVue.prototype.$emit = function (event) {\n  const vm = this\n  let cbs = vm._events[event]\n  if (cbs) {\n    const args = toArray(arguments, 1)\n    for (let i = 0, l = cbs.length; i < l; i++) {\n      try {\n        cbs[i].apply(vm, args)\n      } catch (e) {\n        handleError(e, vm, `event handler for \"${event}\"`)\n      }\n    }\n  }\n  return vm\n}\n```\n\n这里我们使用event从vm._events中取出事件监听器回调函数列表，并将其赋值给变量cbs。如果cbs存在，则循环它，依次调用每一个监听器回调并将所有参数传给监听器回调。toArray的作用是将类似于数组的数据转换成真正的数组，它的第二个参数是起始位置。也就是说，args是一个数组，里面包含除第一个参数之外的所有参数。\n\n\n#### 2.3 生命周期相关的实例方法\n与生命周期相关的实例方法有4个，分别是vm.$mount、vm.$forceUpdate、vm.$nextTick和vm.$destroy。其中有两个方法是从lifecycleMixin中挂载到Vue构造函数的prototype属性上的，分别是vm.$forceUpdate和vm.$destroy。lifecycleMixin的代码如下：\n\n```js\nexport function lifecycleMixin (Vue) {\n  Vue.prototype.$forceUpdate = function () {\n    // 做点什么\n  }\n\n  Vue.prototype.$destroy = function () {\n    // 做点什么\n  }\n}\n```\n\nvm.$nextTick方法是从renderMixin中挂载到Vue构造函数的prototype属性上的。renderMixin的代码如下：\n\n```js\nexport function renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    // 做点什么\n  }\n}\n```\n\n而vm.$mount方法则是在跨平台的代码中挂载到Vue构造函数的prototype属性上的。\n\n##### 2.3.1 vm.$forceUpdate\nvm.$forceUpdate()的作用是迫使Vue.js实例重新渲染。注意它仅仅影响实例本身以及插入插槽内容的子组件，而不是所有子组件。\n\n我们只需要执行实例watcher的update方法，就可以让实例重新渲染。Vue.js的每一个实例都有一个watcher。第5章介绍虚拟DOM时提到，当状态发生变化时，会通知到组件级别，然后组件内部使用虚拟DOM进行更详细的重新渲染操作。事实上，组件就是Vue.js实例，所以组件级别的watcher和Vue.js实例上的watcher说的是同一个watcher。\n\n```js\nVue.prototype.$forceUpdate = function () {\n  const vm = this\n  if (vm._watcher) {\n    vm._watcher.update()\n  }\n}\n```\n\nvm._watcher就是Vue.js实例的watcher，每当组件内依赖的数据发生变化时，都会自动触发Vue.js实例中 _watcher的update方法。\n\n重新渲染的实现原理并不难，Vue.js的自动渲染通过变化侦测来侦测数据，即当数据发生变化时，Vue.js实例重新渲染。而vm.$forceUpdate是手动通知Vue.js实例重新渲染。\n\n\n##### 2.3.2 vm.$destroy\nvm.$destroy的作用是完全销毁一个实例，它会清理该实例与其他实例的连接，并解绑其全部指令及监听器，同时会触发beforeDestroy和destroyed的钩子函数。\n\n这个方法并不是很常用，大部分场景下并不需要销毁组件，只需要使用v-if或者v-for等指令以数据驱动的方式控制子组件的生命周期即可。\n\n\n完整的代码如下：\n\n```js\nVue.prototype.$destroy = function () {\n  const vm = this\n  if (vm._isBeingDestroyed) {\n    return\n  }\n  callHook(vm, 'beforeDestroy')\n  vm._isBeingDestroyed = true\n\n  // 删除自己与父级之间的连接\n  const parent = vm.$parent\n  if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n    remove(parent.$children, vm)\n  }\n  // 从watcher监听的所有状态的依赖列表中移除watcher\n  if (vm._watcher) {\n    vm._watcher.teardown()\n  }\n  let i = vm._watchers.length\n  while (i--) {\n    vm._watchers[i].teardown()\n  }\n  vm._isDestroyed = true\n  // 在vnode树上触发destroy钩子函数解绑指令\n  vm.__patch__(vm._vnode, null)\n  // 触发destroyed钩子函数\n  callHook(vm, 'destroyed')\n  // 移除所有的事件监听器\n  vm.$off()\n}\n```\n\n\n##### 2.3.3 vm.$nextTick\nnextTick接收一个回调函数作为参数，它的作用是将回调延迟到下次DOM更新周期之后执行。它与全局方法Vue.nextTick一样，不同的是回调的this自动绑定到调用它的实例上。\n\n我们在开发项目时会遇到一种场景：当更新了状态（数据）后，需要对新DOM做一些操作，但是这时我们其实获取不到更新后的DOM，因为还没有重新渲染。这个时候我们需要使用nextTick方法。\n\n```js\nnew Vue({\n  // ……\n  methods: {\n    // ……\n    example: function () {\n      // 修改数据\n      this.message = 'changed'\n      // DOM还没有更新\n      this.$nextTick(function () {\n        // DOM现在更新了\n        // this绑定到当前实例\n        this.doSomethingElse()\n      })\n    }\n  }\n})\n```\n\n**在Vue.js中，当状态发生变化时，watcher会得到通知，然后触发虚拟DOM的渲染流程。而watcher触发渲染这个操作并不是同步的，而是异步的。Vue.js中有一个队列，每当需要渲染时，会将watcher推送到这个队列中，在下一次事件循环中再让watcher触发渲染的流程。**\n\n**1、为什么Vue.js使用异步更新队列?**\n我们知道Vue.js 2.0开始使用虚拟DOM进行渲染，变化侦测的通知只发送到组件，组件内用到的所有状态的变化都会通知到同一个watcher，然后虚拟DOM会对整个组件进行“比对（diff）”并更改DOM。**也就是说，如果在同一轮事件循环中有两个数据发生了变化，那么组件的watcher会收到两份通知，从而进行两次渲染。事实上，并不需要渲染两次，虚拟DOM会对整个组件进行渲染，所以只需要等所有状态都修改完毕后，一次性将整个组件的DOM渲染到最新即可。**\n\n要解决这个问题，**Vue.js的实现方式是将收到通知的watcher实例添加到队列中缓存起来，并且在添加到队列之前检查其中是否已经存在相同的watcher，只有不存在时，才将watcher实例添加到队列中。然后在下一次事件循环（event loop）中，Vue.js会让队列中的watcher触发渲染流程并清空队列。这样就可以保证即便在同一事件循环中有两个状态发生改变，watcher最后也只执行一次渲染流程。**\n\n\n**2、什么是事件循环？**\n我们都知道JavaScript是一门单线程且非阻塞的脚本语言，这意味着JavaScript代码在执行的任何时候都只有一个主线程来处理所有任务。而非阻塞是指当代码需要处理异步任务时，主线程会挂起（pending）这个任务，当异步任务处理完毕后，主线程再根据一定规则去执行相应回调。\n\n事实上，**当任务处理完毕后，JavaScript会将这个事件加入一个队列中，我们称这个队列为事件队列。被放入事件队列中的事件不会立刻执行其回调，而是等待当前执行栈中的所有任务执行完毕后，主线程会去查找事件队列中是否有任务。**\n\n异步任务有两种类型：微任务（microtask）和宏任务（macrotask）。不同类型的任务会被分配到不同的任务队列中。\n\n**当执行栈中的所有任务都执行完毕后，会去检查微任务队列中是否有事件存在，如果存在，则会依次执行微任务队列中事件对应的回调，直到为空。然后去宏任务队列中取出一个事件，把对应的回调加入当前执行栈，当执行栈中的所有任务都执行完毕后，检查微任务队列中是否有事件存在。无限重复此过程，就形成了一个无限循环，这个循环就叫作事件循环。**\n\n微任务：\n\n1. Promise.then\n2. MutationObserver\n3. Object.observe\n4. process.nextTick\n\n\n宏任务：\n\n1. setTimeout\n2. setInterval\n3. setImmediate\n4. messageChannel\n5. requestAnimationFrame\n6. I/O\n7. UI rendering(交互渲染)\n\n**3、什么是执行栈？**\n当我们执行一个方法时，JavaScript会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中有这个方法的私有作用域、上层作用域的指向、方法的参数、私有作用域中定义的变量以及this对象。这个执行环境会被添加到一个栈中，这个栈就是执行栈。\n\n如果在这个方法的代码中执行到了一行函数调用语句，那么JavaScript会生成这个函数的执行环境并将其添加到执行栈中，然后进入这个执行环境继续执行其中的代码。执行完毕并返回结果后，JavaScript会退出执行环境并把这个执行环境从栈中销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。这个执行环境的栈就是执行栈。\n\nsetTimeout属于宏任务，使用它注册的回调会加入到宏任务中。宏任务的执行要比微任务晚，所以即便是先注册，也是先更新DOM后执行setTimeout中设置的回调。\n\nvm.$nextTick的实现原理：\n\n```js\nimport { nextTick } from '../util/index'\n\nVue.prototype.$nextTick = function (fn) {\n  return nextTick(fn, this)\n}\n```\n\n<img src=\"/img/vue40.jpeg\" style=\"max-width:95%\" />\n\n\n最终完整的代码如下：\n\n```js\n  const callbacks = []\n  let pending = false\n  \n  function flushCallbacks () {\n    pending = false\n    const copies = callbacks.slice(0)\n    callbacks.length = 0\n    for (let i = 0; i < copies.length; i++) {\n      copies[i]()\n    }\n  }\n  \n  let microTimerFunc\n  let macroTimerFunc\n  let useMacroTask = false\n  \n  if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n    macroTimerFunc = () => {\n      setImmediate(flushCallbacks)\n    }\n  } else if (typeof MessageChannel !== 'undefined' && (\n    isNative(MessageChannel) ||\n    MessageChannel.toString() === '[object MessageChannelConstructor]'\n  )) {\n    const channel = new MessageChannel()\n    const port = channel.port2\n    channel.port1.onmessage = flushCallbacks\n    macroTimerFunc = () => {\n      port.postMessage(1)\n    }\n  } else {\n    macroTimerFunc = () => {\n      setTimeout(flushCallbacks, 0)\n    }\n  }\n  \n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    const p = Promise.resolve()\n    microTimerFunc = () => {\n      p.then(flushCallbacks)\n    }\n  } else {\n    microTimerFunc = macroTimerFunc\n  }\n  \n  // 新增了withMacroTask函数，它的作用是给回调函数做一层包装，\n  // 保证在整个回调函数执行过程中，如果修改了状态（数据），\n  // 那么更新DOM的操作会被推到宏任务队列中。\n  // 也就是说，更新DOM的执行时间会晚于回调函数的执行时间。\n  export function withMacroTask (fn) {\n    return fn._withTask || (fn._withTask = function () {\n      useMacroTask = true\n      const res = fn.apply(null, arguments)\n      useMacroTask = false\n      return res\n    })\n  }\n  \n  export function nextTick (cb, ctx) {\n    let _resolve\n    callbacks.push(() => {\n      if (cb) {\n        cb.call(ctx)\n      } else if (_resolve) {\n        _resolve(ctx)\n      }\n    })\n    if (!pending) {\n      pending = true\n      if (useMacroTask) {\n        macroTimerFunc()\n      } else {\n        microTimerFunc()\n      }\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(resolve => {\n        _resolve = resolve\n      })\n    }\n  }\n```\n\n##### 2.3.4 vm.$mount\n我们并不常用这个方法，其原因是如果在实例化Vue.js时设置了el选项，会自动把Vue.js实例挂载到DOM元素上。但理解这个方法却非常重要，因为无论我们在实例化Vue.js时是否设置了el选项，想让Vue.js实例具有关联的DOM元素，只有使用vm.$mount方法这一种途径。\n\n使用示例：\n\n```js\nlet MyComponent = Vue.extend({\n  template: '<div>Hello!</div>'\n})\n\n// 创建并挂载到#app（会替换#app）\nnew MyComponent().$mount('#app')\n\n// 创建并挂载到#app（会替换#app）\nnew MyComponent({ el: '#app' })\n\n// 或者，在文档之外渲染并且随后挂载\nvar component = new MyComponent().$mount()\ndocument.getElementById('app').appendChild(component.$el)\n```\n\n在不同的构建版本中，vm.$mount的表现都不一样。其差异主要体现在完整版（vue.js）和只包含运行时版本（vue.runtime.js）之间。\n\n完整版和只包含运行时版本之间的差异在于是否有编译器，而是否有编译器的差异主要在于vm.$mount方法的表现形式。在只包含运行时的构建版本中，vm.$mount的作用如前面介绍的那样。而在完整的构建版本中，vm.$mount的作用会稍有不同，它首先会检查template或el选项所提供的模板是否已经转换成渲染函数（render函数）。如果没有，则立即进入编译过程，将模板编译成渲染函数，完成之后再进入挂载与渲染的流程中。\n\n**1、首先，来看完整版vm.$mount的实现代码：**\n\n```js\n// 通过函数劫持，可以在原始功能之上新增一些其他功能\n\nconst mount = Vue.prototype.$mount\nVue.prototype.$mount = function (el) {\n  // 做些什么\n  el = el && el.query(el);\n  return mount.call(this, el)\n}\n\nfunction query (el) {\n  if (typeof el === 'string') {\n    const selected = document.querySelector(el)\n    if (!selected) {\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n```\n\n我们将Vue原型上的 $mount方法保存在mount中，以便后续使用。然后Vue原型上的 $mount方法被一个新的方法覆盖了。新方法中会调用原始的方法，这种做法通常被称为函数劫持。\n\n\n接下来，将实现完整版vm.$mount中最主要的功能：编译器。\n\n首先判断Vue.js实例中是否存在渲染函数，只有不存在时，才会将模板编译成渲染函数。其代码如下：\n\n```js\nconst mount = Vue.prototype.$mount\nVue.prototype.$mount = function (el) {\n  el = el && query(el)\n\n  const options = this.$options\n  if (!options.render) {\n    // 将模板编译成渲染函数并赋值给options.render\n  }\n\n  return mount.call(this, el)\n}\n```\n\n在实例化Vue.js时，会有一个初始化流程，其中会向Vue.js实例上新增一些方法，这里的this.$options就是其中之一，它可以访问到实例化Vue.js时用户设置的一些参数，例如template和render。\n\n关于这一点，Vue.js在官方文档的template选项中也给出了相应的提示。如果没有render选项，那么需要获取模板并将模板编译成渲染函数（render函数）赋值给render选项。\n\n\n我们先介绍获取模板相关的逻辑，代码如下:\n\n```js\nconst mount = Vue.prototype.$mount\nVue.prototype.$mount = function (el) {\n  el = el && query(el)\n\n  const options = this.$options\n  if (!options.render) {\n    // 新增获取模板相关逻辑\n    let template = options.template\n    if (template) {\n       if (typeof template === 'string') {\n           if (template.charAt(0) === '#') {\n             template = idToTemplate(template)\n           }\n       }else if (template.nodeType){\n           template = template.innerHTML\n       }else{\n           if (process.env.NODE_ENV !== 'production') {\n             warn('invalid template option:' + template, this)\n           }\n           return this\n       }\n\n    } else if (el) {\n      // 如果没取到template，说明用户没有设置template选项，\n      // 那么使用getOuterHTML方法从用户提供的el选项中获取模板\n      template = getOuterHTML(el)\n    }\n    \n    // 新增编码相关逻辑\n    if(template){\n       const { render } = compileToFunctions(\n          template,\n          {\n            ...\n          },\n          this\n       )\n       options.render = render\n    }\n  }\n\n  return mount.call(this, el)\n}\n\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    const container = document.createElement('div')\n    container.appendChild(el.cloneNode(true))\n    return container.innerHTML\n  }\n}\n\n// idToTemplate方法使用选择符获取DOM元素之后，将它的innerHTML作为模板\nfunction idToTemplate (id) {\n  const el = query(id)\n  return el && el.innerHTML\n}\n```\n\n结合前面的代码，整体逻辑是，如果用户没有通过template选项设置模板，那么会从el选项中获取HTML字符串当作模板。如果用户提供了template选项，那么需要对它进一步解析，因为这个选项支持很多种使用方式。template选项可以直接设置成字符串模板，也可以设置为以#开头的选择符，还可以设置成DOM元素。\n\n\n将模板编译成代码字符串并将代码字符串转换成渲染函数的过程是在compileToFunctions函数中完成的，该函数的内部实现如下：\n\n```js\nfunction compileToFunctions (template, options, vm) {\n  options = extend({}, options)\n\n  // 检查缓存\n  const key = options.delimiters\n    ? String(options.delimiters) + template\n    : template\n  if (cache[key]) {\n    return cache[key]\n  }\n\n  // 编译\n  const compiled = compile(template, options)\n\n  // 将代码字符串转换为函数\n  const res = {}\n  res.render = createFunction(compiled.render)\n\n  return (cache[key] = res)\n}\n\nfunction createFunction (code) {\n  return new Function(code)\n}\n```\n\n ●  1、首先，将options属性混合到空对象中，其目的是让options成为可选参数。\n\n ●  2、接下来，检查缓存中是否已经存在编译后的模板。如果模板已经被编译，就会直接返回缓存中的结果，不会重复编译，保证不做无用功来提升性能。\n\n ●  3、然后调用compile函数来编译模板。这部分内容就是第三篇中介绍的，将模板编译成代码字符串并存储在compiled中的render属性中，此时该属性中保存的内容类似下面这样：\n\n```js\n'with(this){return _c(\"div\",{attrs:{\"id\":\"el\"}},[_v(\"Hello \"+_s(name))])}'\n```\n\n\n ●  4、接下来，调用createFunction函数将代码字符串转换为函数。其实现原理相当简单，使用new Function(code)就可以完成。\n\n```js\nconst code = 'console.log(\"Hello Berwin\")'\nconst render = new Function(code)\nrender() // Hello Berwin\n```\n\n ●  5、最后，将渲染函数返回给调用方。\n\n**2、只包含运行时版本的vm.$mount的实现原理：**\n下面代码可以看到，$mount方法将ID转换为DOM元素后，使用mountComponent函数将Vue.js实例挂载到DOM元素上。事实上，将实例挂载到DOM元素上指的是将模板渲染到指定的DOM元素中，而且是持续性的，以后当数据（状态）发生变化时，依然可以渲染到指定的DOM元素中。\n\n实现这个功能需要开启watcher。watcher将持续观察模板中用到的所有数据（状态），当这些数据（状态）被修改时它将得到通知，从而进行渲染操作。这个过程会持续到实例被销毁。\n\n```js\nVue.prototype.$mount = function (el) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el);\n}\n\nexport function mountComponent (vm, el) {\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode\n    if (process.env.NODE_ENV !== 'production') {\n      // 在开发环境下发出警告\n    }\n  }\n  // 触发生命周期钩子\n  callHook(vm, 'beforeMount')\n\n  // 挂载\n  vm._watcher = new Watcher(vm, () => {\n    vm._update(vm._render())\n  }, noop)\n\n  // 触发生命周期钩子\n  callHook(vm, 'mounted')\n  return vm\n}\n```\n\nvm._update(vm._render()) 的作用是先调用渲染函数得到一份最新的VNode节点树，然后通过 _update方法对最新的VNode和上一次渲染用到的旧VNode进行对比并更新DOM节点。简单来说，就是执行了渲染操作。\n\n下面我们来回顾一下watcher观察数据的过程：\n\n状态通过Observer转换成响应式之后，每当触发getter时，会从全局的某个属性中获取watcher实例并将它添加到数据的依赖列表中。watcher在读取数据之前，会先将自己设置到全局的某个属性中。而数据被读取会触发getter，所以会将watcher收集到依赖列表中。收集好依赖后，当数据发生变化时，会向依赖列表中的watcher发送通知。\n\n由于Watcher的第二个参数支持函数，所以当watcher执行函数时，函数中所读取的数据都将会触发getter去全局找到watcher并将其收集到函数的依赖列表中。也就是说，函数中读取的所有数据都将被watcher观察。这些数据中的任何一个发生变化时，watcher都将得到通知。\n\n得出了这个结论后，有什么用呢？当数据发生变化时，watcher会一次又一次地执行函数进入渲染流程，如此反复，这个过程会持续到实例被销毁。\n\n挂载完毕后，会触发mounted钩子函数。\n\n\n\n\n#### 2.4 全局API的实现原理\n\n全局API和实例方法不同，后者是在Vue的原型上挂载方法，也就是在Vue.prototype上挂载方法，而前者是直接在Vue上挂载方法。\n\n```js\nVue.extend = function (extendOptions) {\n  // 做点什么\n}\n```\n\n##### 2.4.1 Vue.extend\n\n用法：使用基础Vue构造器创建一个“子类”，其参数是一个包含“组件选项”的对象。\n\n```js\n<div id=\"mount-point\"></div>\n// 创建构造器\nvar Profile = Vue.extend({\n  template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',\n  data: function () {\n    return {\n      firstName: 'Walter',\n      lastName: 'White',\n      alias: 'Heisenberg'\n    }\n  }\n})\n// 创建Profile实例，并挂载到一个元素上\nnew Profile().$mount('#mount-point')\n```\n\n原理：\n\n为了性能考虑，我们在Vue.extend方法内首先增加了缓存策略。反复调用Vue.extend其实应该返回同一个结果。只要返回结果是固定的，就可以将计算结果缓存，再次调用extend方法时，只需要从缓存中取出结果即可。\n\n完整代码如下：\n\n```js\nlet cid = 1\n\nVue.extend = function (extendOptions) {\n  extendOptions = extendOptions || {}\n  const Super = this\n  const SuperId = Super.cid\n  const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})\n  if (cachedCtors[SuperId]) {\n    return cachedCtors[SuperId]\n  }\n  const name = extendOptions.name || Super.options.name\n  if (process.env.NODE_ENV !== 'production') {\n    if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n      warn(\n        'Invalid component name: \"' + name + '\". Component names ' +\n        'can only contain alphanumeric characters and the hyphen, ' +\n        'and must start with a letter.'\n      )\n    }\n  }\n  const Sub = function VueComponent (options) {\n    this._init(options)\n  }\n  Sub.prototype = Object.create(Super.prototype)\n  Sub.prototype.constructor = Sub\n  Sub.cid = cid++\n\n  Sub.options = mergeOptions(\n    Super.options,\n    extendOptions\n  )\n  Sub['super'] = Super\n\n  if (Sub.options.props) {\n    initProps(Sub)\n  }\n\n  if (Sub.options.computed) {\n    initComputed(Sub)\n  }\n\n  Sub.extend = Super.extend\n  Sub.mixin = Super.mixin\n  Sub.use = Super.use\n\n  // ASSET_TYPES = ['component', 'directive', 'filter']\n  ASSET_TYPES.forEach(function (type) {\n    Sub[type] = Super[type]\n  })\n\n  if (name) {\n    Sub.options.components[name] = Sub\n  }\n\n  Sub.superOptions = Super.options\n  Sub.extendOptions = extendOptions\n  Sub.sealedOptions = extend({}, Sub.options)\n\n  // 缓存构造函数\n  cachedCtors[SuperId] = Sub\n  return Sub\n}\n```\n\n总体来讲，其实就是创建了一个Sub函数并继承了父级。如果直接使用Vue.extend，则Sub继承于Vue构造函数。\n\n##### 2.4.2 Vue.nextTick\n\n用法：在下次DOM更新循环结束之后执行延迟回调，修改数据之后立即使用这个方法获取更新后的DOM。\n\n```js\n// 修改数据\nvm.msg = 'Hello'\n// DOM还没有更新\nVue.nextTick(function () {\n// DOM更新了\n})\n\n// 作为一个Promise使用（这是Vue.js 2.1.0版本新增的）\nVue.nextTick()\n.then(function () {\n  // DOM更新了\n})\n```\n\n原理:\n\n```js\nimport { nextTick } from '../util/index'\n\nVue.nextTick = nextTick\n```\n\n##### 2.4.3 Vue.set\n\n用法：设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开Vue不能检测属性被添加的限制。\n\n注意　对象不能是Vue.js实例或者Vue.js实例的根数据对象。\n\n```js\n// target {object|arrary}\n// key {string|number}\n// value {any}\nVue.set(target, key , value);\n```\nVue.set与vm.$set的实现原理相同。\n\n##### 2.4.4 Vue.delete\n\n用法：删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开Vue.js不能检测到属性被删除的限制。\n\n```js\nVue.delete(target, key)\n```\n\n##### 2.4.5 Vue.directive\n\n用法：注册或获取全局指令。\n\n```js\n// 注册\nVue.directive('my-directive', {\n  bind: function () {},\n  inserted: function () {},\n  update: function () {},\n  componentUpdated: function () {},\n  unbind: function () {}\n})\n\n// 注册（指令函数）\nVue.directive('my-directive', function () {\n  // 这里将会被bind和update调用\n})\n\n// getter方法，返回已注册的指令\nlet myDirective = Vue.directive('my-directive')\n```\n\n**除了核心功能默认内置的指令外（v-model和v-show），Vue.js也允许注册自定义指令。虽然代码复用和抽象的主要形式是组件，但是有些情况下，仍然需要对普通DOM元素进行底层操作，这时就会用到自定义指令。**\n\n原理：\n\n```js\n// 用于保存指令的位置\nVue.options = Object.create(null)\nVue.options['directives'] = Object.create(null)\n\nVue.directive = function (id, definition) {\n  if (!definition) {\n    return this.options['directives'][id]\n  } else {\n    if (typeof definition === 'function') {\n      definition = { bind: definition, update: definition }\n    }\n    this.options['directives'][id] = definition\n    return definition\n  }\n}\n```\n##### 2.4.6 Vue.filter\n\n用法：注册或获取全局过滤器。\n\n```js\n// 注册\nVue.filter('my-filter', function (value) {\n  // 返回处理后的值\n})\n\n// getter方法，返回已注册的过滤器\nvar myFilter = Vue.filter('my-filter')\n```\n\n```html\n<!-- 在双花括号中 -->\n{{ message | capitalize }}\n\n<!-- 在v-bind中 -->\n<div v-bind:id=\"rawId | formatId\"></div>\n```\n\n原理：\n\n```js\nVue.options['filters'] = Object.create(null)\n\nVue.filter = function (id, definition) {\n  if (!definition) {\n    return this.options['filters'][id]\n  } else {\n    this.options['filters'][id] = definition\n    return definition\n  }\n}\n```\n\n##### 2.4.7 Vue.component\n用法：注册或获取全局组件。注册组件时，还会自动使用给定的id设置组件的名称。相关代码如下：\n\n```js\n// 注册组件，传入一个扩展过的构造器\nVue.component('my-component', Vue.extend({ /* ... */ }))\n\n// 注册组件，传入一个选项对象（自动调用Vue.extend）\nVue.component('my-component', { /* ... */ })\n\n// 获取注册的组件（始终返回构造器）\nvar MyComponent = Vue.component('my-component')\n```\n\n我们在使用Vue.js开发项目时，会经常与组件打交道。在编写组件库时，也经常会用到Vue.component方法。因此，理解组件的注册原理非常重要。\n\n\n你会发现Vue.directive、Vue.filter和Vue.component这三个方法的实现方式非常相似，代码很多都是重复的。但是为了方便理解，这里我将这三个方法分别拆开单独介绍。事实上，在Vue.js的源码中，这三个方法是放在一起实现的:\n\n```js\nVue.options = Object.create(null)\nASSET_TYPES = ['component', 'directive', 'filter']\nASSET_TYPES.forEach(type => {\n  Vue.options[type + 's'] = Object.create(null)\n})\nASSET_TYPES.forEach(type => {\n  Vue[type] = function (id, definition) {\n    if (!definition) {\n      return this.options[type + 's'][id]\n    } else {\n      if (type === 'component' && isPlainObject(definition)) {\n        definition.name = definition.name || id\n        definition = Vue.extend(definition)\n      }\n      if (type === 'directive' && typeof definition === 'function') {\n        definition = { bind: definition, update: definition }\n      }\n      this.options[type + 's'][id] = definition\n      return definition\n    }\n  }\n})\n```\n\n##### 2.4.8 Vue.use\n用法：安装Vue.js插件。如果插件是一个对象，必须提供install方法。如果插件是一个函数，它会被作为install方法。调用install方法时，会将Vue作为参数传入。install方法被同一个插件多次调用时，插件也只会被安装一次。\n\n原理：\n\nVue.use的作用是注册插件，此时只需要调用install方法并将Vue作为参数传入即可。但在细节上其实有两部分逻辑需要处理：一部分是插件的类型，可以是install方法，也可以是一个包含install方法的对象；另一部分逻辑是插件只能被安装一次，保证插件列表中不能有重复的插件。其代码如下：\n\n```js\nVue.use = function (plugin) {\n  const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))\n  if (installedPlugins.indexOf(plugin) > -1) {\n    return this\n  }\n\n  // 其他参数\n  const args = toArray(arguments, 1)\n  // 将Vue添加到args列表的最前面\n  args.unshift(this) \n  if (typeof plugin.install === 'function') {\n    plugin.install.apply(plugin, args)\n  } else if (typeof plugin === 'function') {\n    plugin.apply(null, args)\n  }\n  installedPlugins.push(plugin)\n  return this\n}\n```\n\n##### 2.4.9 Vue.mixin\n用法：全局注册一个混入（mixin），影响注册之后创建的每个Vue.js实例。插件作者可以使用混入向组件注入自定义行为（例如：监听生命周期钩子）。不推荐在应用代码中使用。\n\n```js\n// 为自定义的选项myOption注入一个处理器\nVue.mixin({\n  created: function () {\n    var myOption = this.$options.myOption\n    if (myOption) {\n      console.log(myOption)\n    }\n  }\n})\n  \nnew Vue({\n  myOption: 'hello!'\n})\n// => \"hello!\"\n```\n\n原理：Vue.mixin方法注册后，会影响之后创建的每个Vue.js实例，因为该方法会更改Vue.options属性。\n\n```js\nimport { mergeOptions } from '../util/index'\n\nexport function initMixin (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin)\n    return this\n  }\n}\n```\n\n因为mixin方法修改了Vue.options属性，而之后创建的每个实例都会用到该属性，所以会影响创建的每个实例。但也正是因为有影响，所以mixin在某些场景下才堪称神器。\n\n##### 2.4.10 Vue.compile\n用法：编译模板字符串并返回包含渲染函数的对象。只在完整版中才有效。\n\n```js\nvar res = Vue.compile('<div><span>{{ msg }}</span></div>')\n\nnew Vue({\n  data: {\n    msg: 'hello'\n  },\n  render: res.render\n})\n```\n\n与vm.$mount类似，Vue.compile方法只存在于完整版中。\n\n原理：\n\nVue.compile = compileToFunctions\n\n\n##### 2.4.11 Vue.version\n用法：\n```js\nvar version = Number(Vue.version.split('.')[0])\n\nif (version === 2) {\n  // Vue.js v2.x.x\n} else if (version === 3) {\n  // Vue.js v3.x.x\n} else {\n  // 其他\n}\n```\n\n##### 2.4.12 总结\n我们详细介绍了Vue.js的实例方法和全局API的实现原理。它们的区别在于：实例方法是Vue.prototype上的方法，而全局API是Vue.js上的方法。\n\n实例方法又分为数据、事件和生命周期这三个类型。\n\n\n### 3、生命周期\n每个Vue.js实例在创建时都要经过一系列初始化，例如设置数据监听、编译模板、将实例挂载到DOM并在数据变化时更新DOM等。同时，也会运行一些叫作生命周期钩子的函数，这给了我们在不同阶段添加自定义代码的机会。\n\n#### 3.1 生命周期示意图\n\n初始化阶段（部分版本有模版编译）、挂载阶段、更新阶段、卸载阶段\n\n<img src=\"/img/vue41.jpeg\" style=\"max-width:95%\" />\n\n##### 3.1.1 初始化\nnew Vue()到created之间的阶段叫作初始化阶段\n\n这个阶段的主要目的是在Vue.js实例上初始化一些属性、事件以及响应式数据，如props、methods、data、computed、watch、provide和inject等。\n\n\n##### 3.1.2 模版编译\n在created钩子函数与beforeMount钩子函数之间的阶段是模板编译阶段。\n\n这个阶段的主要目的是将模板编译为渲染函数，只存在于完整版中。如果在只包含运行时的构建版本中执行new Vue()，则不会存在这个阶段。\n\n当使用vue-loader或vueify时，*.vue文件内部的模板会在构建时预编译成JavaScript，所以最终打好的包里是不需要编译器的，用运行时版本即可。由于模板这时已经预编译成了渲染函数，所以在生命周期中并不存在模板编译阶段，初始化阶段的下一个生命周期直接是挂载阶段\n\n\n##### 3.1.3 挂载阶段\nbeforeMount钩子函数到mounted钩子函数之间是挂载阶段。\n\n在这个阶段，Vue.js会将其实例挂载到DOM元素上，通俗地讲，就是将模板渲染到指定的DOM元素中。在挂载的过程中，Vue.js会开启Watcher来持续追踪依赖的变化。\n\n在已挂载状态下，Vue.js仍会持续追踪状态的变化。当数据（状态）发生变化时，Watcher会通知虚拟DOM重新渲染视图，并且会在渲染视图前触发beforeUpdate钩子函数，渲染完毕后触发updated钩子函数。\n\n通常，在运行时的大部分时间下，Vue.js处于已挂载状态，每当状态发生变化时，Vue.js都会通知组件使用虚拟DOM重新渲染，也就是我们常说的响应式。这个状态会持续到组件被销毁。\n\n##### 3.1.4 卸载阶段\n在这个阶段，Vue.js会将自身从父组件中删除，取消实例上所有依赖的追踪并且移除所有的事件监听器。\n\n\n#### 3.2 从源码角度了解生命周期\nnew Vue()被调用时发生了什么？\n\n想要了解new Vue()被调用时发生了什么，我们需要知道在Vue构造函数中实现了哪些逻辑。前面介绍过，当new Vue()被调用时，会首先进行一些初始化操作，然后进入模板编译阶段，最后进入挂载阶段。\n\n```js\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue)\n      !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n\nexport default Vue\n```\n\n**_init方法的定义**\n\n```js\nimport { initMixin } from './init'\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n\n// 通过调用initMixin方法将 _init挂载到Vue构造函数的原型上\ninitMixin(Vue)\n\nexport default Vue\n\n\n// init.js文件\nexport function initMixin(Vue){\n  Vue.prototype._init = function(options){\n\n  }\n}\n```\n\n**_init方法的内部原理**\n\n当new Vue()执行后，触发的一系列初始化流程都是在 _init方法中启动的。_init的实现如下：\n\n```js\nVue.prototype._init = function (options) {\n  vm.$options = mergeOptions(\n    resolveConstructorOptions(vm.constructor),\n    options || {},\n    vm\n  )\n  initLifecycle(vm)\n  initEvents(vm)\n  initRender(vm)\n  callHook(vm, 'beforeCreate')\n  initInjections(vm) // 在data/props前初始化inject\n  initState(vm)\n  initProvide(vm) // 在data/props后初始化provide\n  callHook(vm, 'created')\n\n  // 如果用户在实例化Vue.js时传递了el选项，则自动开启模板编译阶段与挂载阶段\n  // 如果没有传递el选项，则不进入下一个生命周期流程\n  // 用户需要执行vm.$mount方法，手动开启模板编译阶段与挂载阶段\n\n  if (vm.$options.el) {\n    vm.$mount(vm.$options.el)\n  }\n}\n```\n\n<img src=\"/img/vue42.jpeg\" style=\"max-width:95%\" />\n\n**callHook函数的内部原理**\n\nVue.js通过callHook函数来触发生命周期钩子。我们需要理解callHook所实现的功能。callHook的作用是触发用户设置的生命周期钩子，而用户设置的生命周期钩子会在执行new Vue()时通过参数传递给Vue.js。也就是说，可以在Vue.js的构造函数中通过options参数得到用户设置的生命周期钩子。\n\nvue生命周期：\n\n● beforeCreate\n\n● created\n\n● beforeMount\n\n● mounted\n\n● beforeUpdate\n\n● updated\n\n● beforeDestroy\n\n● destroyed\n\n● activated\n\n● deactivated\n\n● errorCaptured\n\n通过vm.$options.created获取的是一个数组，数组中包含了钩子函数，例如：\n\n```js\nconsole.log(vm.$options.created); // [fn] 数组\n```\n\n原因：Vue.mixin和用户在实例化Vue.js时，如果设置了同一个生命周期钩子，那么在触发生命周期时，需要同时触发这两个函数。而转换成数组后，可以在同一个生命周期钩子列表中保存多个生命周期钩子。\n\n举个例子：使用Vue.mixin设置生命周期钩子mounted之后，在执行new Vue()时，会在参数中也设置一个生命周期钩子mounted，这时vm.$options.mounted是一个数组，里面包含两个生命周期钩子。\n\n```js\nexport function callHook (vm, hook) {\n  const handlers = vm.$options[hook]\n  if (handlers) {\n    for (let i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm)\n      } catch (e) {\n        handleError(e, vm, `${hook} hook`)\n      }\n    }\n  }\n}\n```\n\n这里使用try...catch语句捕获钩子函数内发生的错误，并使用handleError处理错误。handleError会依次执行父组件的errorCaptured钩子函数与全局的config.errorHandler，这也是为什么生命周期钩子errorCaptured可以捕获子孙组件的错误。关于handleError与生命周期钩子errorCaptured，我们会在随后的内容中详细介绍。\n\n#### 3.3 errorCaptured与错误处理\nerrorCaptured钩子函数的作用是捕获来自子孙组件的错误，此钩子函数会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。然后此钩子函数可以返回false，阻止该错误继续向上传播。\n\n传播规则如下：\n1. 默认情况下，如果全局的config.errorHandler被定义，那么所有的错误都会发送给它，这样这些错误可以在单个位置报告给分析服务。\n\n2. 如果一个组件继承的链路或其父级从属链路中存在多个errorCaptured钩子，则它们将会被相同的错误逐个唤起。\n\n3. 如果errorCaptured钩子函数自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的config.errorHandler。\n\n4. 一个errorCaptured钩子函数能够返回false来阻止错误继续向上传播。这本质上是说“这个错误已经被搞定，应该被忽略”。它会阻止其他被这个错误唤起的errorCaptured钩子函数和全局的config.errorHandler。\n\n\nhandleError函数的实现原理并不复杂。根据前面的传播规则，我们先实现第一个需求：将所有错误发送给config.errorHandler。相关代码如下：\n\n```js\nexport function handleError (err, vm, info) {\n  globalHandleError(err, vm, info)\n}\n\nfunction globalHandleError (err, vm, info) {\n  // 这里的config.errorHandler就是Vue.config.errorHandler\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info)\n    } catch (e) {\n      logError(e)\n    }\n  }\n  logError(err)\n}\n\nfunction logError (err) {\n  console.error(err)\n}\n```\n\n接下来实现第二个功能：如果一个组件继承的链路或其父级从属链路中存在多个errorCaptured钩子函数，则它们将会被相同的错误逐个唤起。\n\n```js\nexport function handleError (err, vm, info) {\n  if (vm) {\n    let cur = vm\n    while ((cur = cur.$parent)) {\n      const hooks = cur.$options.errorCaptured\n      if (hooks) {\n        for (let i = 0; i < hooks.length; i++) {\n          hooks[i].call(cur, err, vm, info)\n        }\n      }\n    }\n  }\n  globalHandleError(err, vm, info)\n}\n```\n\n自底向上的每一层都会读出当前层组件的errorCaptured钩子函数列表，并依次执行列表中的每一个钩子函数。当组件循环到根组件时，从属链路中的多个errorCaptured钩子函数就都被触发完了。此时，我们就不难理解为什么errorCaptured可以捕获来自子孙组件抛出的错误了。\n\n\n我们实现第三个功能：如果errorCaptured钩子函数自身抛出了一个错误，那么这个新错误和原本被捕获的错误都会发送给全局的config.errorHandler。\n\n```js\nexport function handleError (err, vm, info) {\n  if (vm) {\n    let cur = vm\n    while ((cur = cur.$parent)) {\n      const hooks = cur.$options.errorCaptured\n      if (hooks) {\n        for (let i = 0; i < hooks.length; i++) {\n          try {\n            hooks[i].call(cur, err, vm, info)\n          } catch (e) {\n            globalHandleError(e, cur, 'errorCaptured hook')\n          }\n        }\n      }\n    }\n  }\n  globalHandleError(err, vm, info)\n}\n```\n\n接下来实现最后一个功能：一个errorCaptured钩子函数能够返回false来阻止错误继续向上传播。它会阻止其他被这个错误唤起的errorCaptured钩子函数和全局的config.errorHandler。\n\n```js\nexport function handleError (err, vm, info) {\n  if (vm) {\n    let cur = vm\n    while ((cur = cur.$parent)) {\n      const hooks = cur.$options.errorCaptured\n      if (hooks) {\n        for (let i = 0; i < hooks.length; i++) {\n          try {\n            const capture = hooks[i].call(cur, err, vm, info) === false\n            if (capture) return\n          } catch (e) {\n            globalHandleError(e, cur, 'errorCaptured hook')\n          }\n        }\n      }\n    }\n  }\n  globalHandleError(err, vm, info)\n}\n```\n\n因为一旦钩子函数返回了false，handleError函数将会执行return语句终止程序执行，所以错误向上传递和全局的config.errorHandler都会被停止。\n\n#### 3.4 初始化实例属性\n在Vue.js的整个生命周期中，初始化实例属性是第一步。需要实例化的属性既有Vue.js内部需要用到的属性（例如vm._watcher），也有提供给外部使用的属性（例如vm.$parent）。\n\n**以 $ 开头的属性是提供给用户使用的外部属性，以 _ 开头的属性是提供给内部使用的内部属性。**\n\nVue.js通过initLifecycle函数向实例中挂载属性，该函数接收Vue.js实例作为参数。所以在函数中，我们只需要向Vue.js实例设置属性即可达到向Vue.js实例挂载属性的目的。代码如下：\n\n```js\nexport function initLifecycle (vm) {\n  const options = vm.$options\n\n  // 找出第一个非抽象父类\n  let parent = options.parent\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent\n    }\n    parent.$children.push(vm)\n  }\n\n  vm.$parent = parent\n  vm.$root = parent ? parent.$root : vm\n\n  vm.$children = []\n  vm.$refs = {}\n\n  vm._watcher = null\n  vm._isDestroyed = false\n  vm._isBeingDestroyed = false\n}\n```\n\n稍微有点复杂的是vm.$parent属性，它需要找到第一个非抽象类型的父级，所以代码中会进行判断：如果当前组件不是抽象组件并且存在父级，那么需要通过while来自底向上循环；如果父级是抽象类，那么继续向上，直到遇到第一个非抽象类的父级时，将它赋值给vm.$parent属性。\n\n最后一个值得注意的属性是vm.$root，它表示当前组件树的根Vue.js实例。这个属性的实现原理很巧妙，也很好理解。如果当前组件没有父组件，那么它自己其实就是根组件，它的 $root属性是它自己，而它的子组件的vm.$root属性是沿用父级的$root，所以其直接子组件的 $root属性还是它，其孙组件的 $root属性沿用其直接子组件中的 $root属性，以此类推。因此，我们会发现这其实是自顶向下将根组件的 $root依次传递给每一个子组件的过程。\n\n\n注意　在真实的Vue.js源码中，内部属性有更多。因为本书介绍的内容没有使用那么多属性，所以为了方便理解，上面代码中并没有给出所有属性\n\n#### 3.5 初始化事件\n初始化事件是指将父组件在模板中使用的v-on注册的事件添加到子组件的事件系统（Vue.js的事件系统）中。\n\n我们都知道，在Vue.js中，父组件可以在使用子组件的地方用v-on来监听子组件触发的事件。\n\n```js\n  <div id=\"counter-event-example\">\n    <p>{{ total }}</p>\n    <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n    <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n  </div>\n  \n  // 注册子组件\n  Vue.component('button-counter', {\n    template: '<button v-on:click=\"incrementCounter\">{{ counter }}</button>',\n    data: function () {\n      return {\n        counter: 0\n      }\n    },\n    methods: {\n      incrementCounter: function () {\n        this.counter += 1\n        this.$emit('increment')\n      }\n    },\n  })\n  \n  // 父组件\n  new Vue({\n    el: '#counter-event-example',\n    data: {\n      total: 0\n    },\n    methods: {\n      incrementTotal: function () {\n        this.total += 1\n      }\n    }\n  })\n```\n\n父组件的模板里使用v-on监听子组件中触发的increment事件，并在子组件中使用this.$emit触发该事件。\n\n对于这个问题，我们需要先简单介绍一下模板编译和虚拟DOM。在模板编译阶段，可以得到某个标签上的所有属性，其中就包括使用v-on或@注册的事件。在模板编译阶段，我们会将整个模板编译成渲染函数，而渲染函数其实就是一些嵌套在一起的创建元素节点的函数。创建元素节点的函数是这样的：_c(tagName, data,children)。当渲染流程启动时，渲染函数会被执行并生成一份VNode，随后虚拟DOM会使用VNode进行对比与渲染。在这个过程中会创建一些元素，但此时会判断当前这个标签究竟是真的标签还是一个组件：如果是组件标签，那么会将子组件实例化并给它传递一些参数，其中就包括父组件在模板中使用v-on注册在子组件标签上的事件；如果是平台标签，则创建元素并插入到DOM中，同时会将标签上使用v-on注册的事件注册到浏览器事件中。\n\n简单来说，如果v-on写在组件标签上，那么这个事件会注册到子组件Vue.js事件系统中；如果是写在平台标签上，例如div，那么事件会被注册到浏览器事件中。\n\n\n**原理：**\n\nVue.js通过initEvents函数来执行初始化事件相关的逻辑，其代码如下：\n\n```js\nexport function initEvents (vm) {\n  vm._events = Object.create(null)\n  // 初始化父组件附加的事件\n  const listeners = vm.$options._parentListeners\n  if (listeners) {\n    updateComponentListeners(vm, listeners)\n  }\n}\n```\n\n首先在vm上新增 _events属性并将它初始化为空对象，用来存储事件。事实上，所有使用vm.$on注册的事件监听器都会保存到vm._events属性中。\n\n在模板编译阶段，当模板解析到组件标签时，会实例化子组件，同时将标签上注册的事件解析成object并通过参数传递给子组件。所以当子组件被实例化时，可以在参数中获取父组件向自己注册的事件，这些事件最终会被保存在vm.$options._parentListeners中。\n\n用前面的例子中举例，vm.$options._parentListeners是下面的样子：\n\n```js\n{increment: function () {}}\n```\n\n通过前面的代码可以看到，如果vm.$options._parentListeners不为空，则调用updateComponentListeners方法，将父组件向子组件注册的事件注册到子组件实例中。\n\nupdateComponentListeners的逻辑很简单，只需要循环vm.$options._parentListeners并使用vm.$on把事件都注册到this._events中即可。updateComponentListeners函数的源码如下：\n\n```js\nlet target\n\nfunction add (event, fn, once) {\n  if (once) {\n    target.$once(event, fn)\n  } else {\n    target.$on(event, fn)\n  }\n}\n\nfunction remove (event, fn) {\n  target.$off(event, fn)\n}\n\nexport function updateComponentListeners (vm, listeners, oldListeners) {\n  target = vm\n  updateListeners(listeners, oldListeners || {}, add, remove, vm)\n}\n```\n\n其中封装了add和remove这两个函数，用来新增和删除事件。此外，还通过updateListeners函数对比listeners和oldListeners的不同，并调用参数中提供的add和remove进行相应的注册事件和卸载事件的操作。它的实现思路并不复杂：如果listeners对象中存在某个key（也就是事件名）在oldListeners中不存在，那么说明这个事件是需要新增的事件；反过来，如果oldListeners中存在某些key（事件名）在listeners中不存在，那么说明这个事件是需要从事件系统中移除的。\n\nupdateListeners代码如下：\n\n```js\nexport function updateListeners (on, oldOn, add, remove, vm) {\n  let name, cur, old, event\n  for (name in on) {\n    cur = on[name]\n    old = oldOn[name]\n    event = normalizeEvent(name)\n    if (isUndef(cur)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        `Invalid handler for event \"${event.name}\": got ` + String(cur),\n        vm\n      )\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur)\n      }\n      add(event.name, cur, event.once, event.capture, event.passive)\n    } else if (cur !== old) {\n      old.fns = cur\n      on[name] = old\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name)\n      remove(event.name, oldOn[name], event.capture)\n    }\n  }\n}\n```\n\n在循环on的过程中，有如下三个判断。\n\n● 判断事件名对应的值是否是undefined或null，如果是，则在控制台触发警告。\n\n● 判断该事件名在oldOn中是否存在，如果不存在，则调用add注册事件。\n\n● 如果事件名在on和oldOn中都存在，但是它们并不相同，则将事件回调替换成on中的回调，并且把on中的回调引用指向真实的事件系统中注册的事件，也就是oldOn中对应的事件。\n\n`注意:代码中的isUndef函数用于判断传入的参数是否为undefined或null`\n\n代码中还有normalizeEvent函数，它的作用是什么呢？\n\nVue.js的模板中支持事件修饰符，例如capture、once和passive等，如果我们在模板中注册事件时使用了事件修饰符，那么在模板编译阶段解析标签上的属性时，会将这些修饰符改成对应的符号加在事件名的前面，例如 <child v-on:increment.once=\"a\"\\></child>。此时vm.$options._parentListeners是下面的样子：\n\n```js\n{~increment: function () {}}\n```\n\n可以看到，事件名的前面新增了一个~符号，这说明该事件的事件修饰符是once，我们通过这样的方式来分辨当前事件是否使用了事件修饰符。而normalizeEvent函数的作用是将事件修饰符解析出来，其代码如下：\n\n```js\nconst normalizeEvent = name => {\n  const passive = name.charAt(0) === '&'\n  name = passive ? name.slice(1) : name\n  \n  const once = name.charAt(0) === '~'\n  name = once ? name.slice(1) : name\n  \n  const capture = name.charAt(0) === '!'\n  name = capture ? name.slice(1) : name\n  return {\n    name,\n    once,\n    capture,\n    passive\n  }\n})\n```\n\n\n\n#### 3.6 初始化inject\ninject和provide通常是成对出现的\n\n##### 3.6.1 provide/inject的使用方式\n说明　provide和inject主要为高阶插件/组件库提供用例，并不推荐直接用于程序代码中。\n\ninject和provide选项需要一起使用，它们允许祖先组件向其所有子孙后代注入依赖，并在其上下游关系成立的时间里始终生效（不论组件层次有多深）。如果你熟悉React，会发现这与它的上下文特性很相似。\n\ninject选项应该是一个字符串数组或对象，其中对象的key是本地的绑定名，value是一个key（字符串或Symbol）或对象，用来在可用的注入内容中搜索。\n\n如果是对象，那么它有如下两个属性。\n\n  ● name：它是在可用的注入内容中用来搜索的key（字符串或 Symbol）。\n\n  ● default：它是在降级情况下使用的value\n\n\n`说明　可用的注入内容指的是祖先组件通过provide注入了内容，子孙组件可以通过inject获取祖先组件注入的内容。`\n\n```js\n// 父组件\nVue.component('parent-component', {\n  provide: {\n    message: 'Hello, inject!'\n  },\n  template: '<div><child-component></child-component></div>'\n});\n\n// 子组件\nVue.component('child-component', {\n  inject: ['message'],\n  created() {\n    console.log(this.message); // 访问注入的值\n  },\n  template: '<div>{{ message }}</div>'\n});\n```\n\n如果使用ES2015 Symbol作为key，则provide函数和inject对象如下所示：\n\n```js\nconst s = Symbol()\nconst Provider = {\n  provide () {\n    return {\n      [s]: 'foo'\n    }\n  }\n}\n\nconst Child = {\n  inject: { s },\n  // ……\n}\n```\n\n##### 3.6.2 inject的内部原理\n虽然inject和provide是成对出现的，但是二者在内部的实现是分开处理的，先处理inject后处理provide。**inject在data/props之前初始化，而provide在data/props后面初始化。这样做的目的是让用户可以在data/props中使用inject所注入的内容。也就是说，可以让data/props依赖inject，所以需要将初始化inject放在初始化data/props的前面。**\n\n初始化inject的方法叫作initInjections，其代码如下：\n\n```js\nexport function initInjections (vm) {\n  const result = resolveInject(vm.$options.inject, vm)\n  if (result) {\n    observerState.shouldConvert = false\n    Object.keys(result).forEach(key => {\n      defineReactive(vm, key, result[key])\n    })\n    observerState.shouldConvert = true\n  }\n}\n```\n\n其中，resolveInject函数的作用是通过用户配置的inject，自底向上搜索可用的注入内容，并将搜索结果返回。\n\nresolveInject代码：\n\n```js\nexport function resolveInject (inject, vm) {\n  if (inject) {\n    const result = Object.create(null)\n    const keys = hasSymbol\n      ? Reflect.ownKeys(inject).filter(key => {\n        return Object.getOwnPropertyDescriptor(inject, key).enumerable\n      })\n      : Object.keys(inject)\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i]\n      const provideKey = inject[key].from\n      let source = vm\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey]\n          break\n        }\n        source = source.$parent\n      }\n      if (!source) {\n        if ('default' in inject[key]) {\n          const provideDefault = inject[key].default\n          result[key] = typeof provideDefault === 'function'\n            ? provideDefault.call(vm)\n            : provideDefault\n        } else if (process.env.NODE_ENV !== 'production') {\n          warn(`Injection \"${key}\" not found`, vm)\n        }\n      }\n    }\n    return result\n  }\n}\n```\n\n例如，用户设置的inject是这样的：\n\n```js\n{\n  inject: [foo]\n}\n```\n\n它被规格化之后是下面这样的：\n\n```js\n{\n  inject: {\n    foo: {\n      from: 'foo'\n    }\n  }\n}\n```\n\n不论是数组形式还是对象中使用from属性的形式，本质上其实是让用户设置原属性名与当前组件中的属性名。如果用户设置的是数组，那么就认为用户是让两个属性名保持一致。\n\n\n\n#### 3.7 初始化状态\n当我们使用Vue.js开发应用时，经常会使用一些状态，例如props、methods、data、computed和watch。在Vue.js内部，这些状态在使用之前需要进行初始化。\n\ninitState函数的代码：\n\n```js\nexport function initState (vm) {\n  vm._watchers = []\n  const opts = vm.$options\n  if (opts.props) initProps(vm, opts.props)\n  if (opts.methods) initMethods(vm, opts.methods)\n  if (opts.data) {\n    initData(vm)\n  } else {\n    // observe函数的作用是将数据转换为响应式的。\n    observe(vm._data = {}, true /* asRootData */)\n  }\n  if (opts.computed) initComputed(vm, opts.computed)\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch)\n  }\n}\n```\n\n如果你足够细心，就会发现初始化的顺序其实是精心安排的。先初始化props，后初始化data，这样就可以在data中使用props中的数据了。在watch中既可以观察props，也可以观察data，因为它是最后被初始化的。\n\n初始化状态可以分为5个子项，分别是初始化props、初始化methods、初始化data、初始化computed和初始化watch:\n\n<img src=\"/img/vue44.jpeg\" style=\"max-width:95%\" />\n\n##### 3.7.1 初始化props\nprops的实现原理大体上是这样的：父组件提供数据，子组件通过props字段选择自己需要哪些内容，Vue.js内部通过子组件的props选项将需要的数据筛选出来之后添加到子组件的上下文中。\n\n```js\nfunction initProps (vm, propsOptions) {\n  const propsData = vm.$options.propsData || {}\n  const props = vm._props = {}\n  // 缓存props的key\n  const keys = vm.$options._propKeys = []\n  const isRoot = !vm.$parent\n  // root实例的props属性应该被转换成响应式数据\n  if (!isRoot) {\n    toggleObserving(false)\n  }\n  for (const key in propsOptions) {\n    keys.push(key)\n    const value = validateProp(key, propsOptions, propsData, vm)\n    defineReactive(props, key, value)\n    if (!(key in vm)) {\n      proxy(vm, `_props`, key)\n    }\n  }\n  toggleObserving(true)\n}\n```\n\nvalidateProp代码：\n\n```js\nexport function validateProp (key, propOptions, propsData, vm) {\n  const prop = propOptions[key]\n  const absent = !hasOwn(propsData, key)\n  let value = propsData[key]\n  // 处理布尔类型的props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true\n    }\n  }\n  // 检查默认值\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key)\n    // 因为默认值是新的数据，所以需要将它转换成响应式的\n    const prevShouldConvert = observerState.shouldConvert\n    observerState.shouldConvert = true\n    observe(value)\n    observerState.shouldConvert = prevShouldConvert\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent)\n  }\n  return value\n}\n```\n\nassertProp函数的代码如下：\n\n```js\n  function assertProp (prop, name, value, vm, absent) {\n    if (prop.required && absent) {\n      warn(\n        'Missing required prop: \"' + name + '\"',\n        vm\n      )\n      return\n    }\n    if (value == null && !prop.required) {\n      return\n    }\n    let type = prop.type\n    let valid = !type || type === true\n    const expectedTypes = []\n    if (type) {\n      if (!Array.isArray(type)) {\n        type = [type]\n      }\n      for (let i = 0; i < type.length && !valid; i++) {\n        const assertedType = assertType(value, type[i])\n        expectedTypes.push(assertedType.expectedType || '')\n        valid = assertedType.valid\n      }\n    }\n    if (!valid) {\n      warn(\n        `Invalid prop: type check failed for prop \"${name}\".` +\n        ` Expected ${expectedTypes.map(capitalize).join(', ')}` +\n        `, got ${toRawType(value)}.`,\n        vm\n      )\n      return\n    }\n    const validator = prop.validator\n    if (validator) {\n      if (!validator(value)) {\n        warn(\n          'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n          vm\n        )\n      }\n    }\n  }\n```\n\n\n##### 3.7.2 初始化methods\n初始化methods时，只需要循环选项中的methods对象，并将每个属性依次挂载到vm上即可，相关代码如下：\n\n```js\nfunction initMethods (vm, methods) {\n  const props = vm.$options.props\n  for (const key in methods) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n          warn(\n          `Method \"${key}\" has an undefined value in the component definition. ` +\n          `Did you reference the function correctly?`,\n          vm\n      )\n    }\n    if (props && hasOwn(props, key)) {\n      warn(\n        `Method \"${key}\" has already been defined as a prop.`,\n        vm\n      )\n    }\n    if ((key in vm) && isReserved(key)) {\n      warn(\n        `Method \"${key}\" conflicts with an existing Vue instance method. ` +\n        `Avoid defining component methods that start with _ or $.`\n      )\n    }\n  }\n  vm[key] = methods[key] == null ? noop : bind(methods[key], vm)\n}\n}\n```\n\n当methods的某个方法只有key没有value时，会在控制台发出警告。如果methods中的某个方法已经在props中声明过了，会在控制台发出警告。如果methods中的某个方法已经存在于vm中，并且方法名是以 $ 或 _ 开头的，也会在控制台发出警告。这里isReserved函数的作用是判断字符串是否是以 $ 或 _ 开头。\n\n将方法赋值到vm中很简单，详见initMethods方法的最后一行代码。其中会判断方法（methods[key]）是否存在：如果不存在，则将noop赋值到vm[key] 中；如果存在，则将该方法通过bind改写它的this后，再赋值到vm[key] 中。\n\n这样，我们就可以通过vm.x访问到methods中的x方法了\n\n\n##### 3.7.3 初始化data\n简单来说，data中的数据最终会保存到vm._data中。然后在vm上设置一个代理，使得通过vm.x可以访问到vm._data中的x属性。最后由于这些数据并不是响应式数据，所以需要调用observe函数将data转换成响应式数据。于是，data就完成了初始化。\n\n```js\nfunction initData (vm) {\n  let data = vm.$options.data\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {}\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    )\n  }\n  // 将data代理到Vue.js实例上\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  const methods = vm.$options.methods\n  let i = keys.length\n  while (i--) {\n    const key = keys[i]\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          `Method \"${key}\" has already been defined as a data property.`,\n          vm\n        )\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        `The data property \"${key}\" is already declared as a prop. ` +\n        `Use prop default value instead.`,\n        vm\n      )\n    } else if (!isReserved(key)) {\n      proxy(vm, `_data`, key)\n    }\n  }\n  // 观察数据\n  observe(data, true /* asRootData */)\n}\n```\n\n**如果data中的某个key与methods发生了重复，依然会将data代理到实例中，但如果与props发生了重复，则不会将data代理到实例中。**\n\n代码中调用了proxy函数实现代理功能。该函数的作用是在第一个参数上设置一个属性名为第三个参数的属性。这个属性的修改和获取操作实际上针对的是与第二个参数相同属性名的属性。proxy的代码如下：\n\n```js\nconst sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n}\n\nexport function proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  }\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition)\n}\n```\n\n##### 3.7.4 初始化computed\n大家肯定对计算属性computed不陌生，在实际项目中我们会经常用它。但对于刚入门的新手来说，它不是很好理解，它和watch到底有哪些不同呢？\n\n**我们知道计算属性的结果会被缓存，且只有在计算属性所依赖的响应式属性或者说计算属性的返回值发生变化时才会重新计算。那么，如何知道计算属性的返回值是否发生了变化？这其实是结合Watcher的dirty属性来分辨的：当dirty属性为true时，说明需要重新计算“计算属性”的返回值；当dirty属性为false时，说明计算属性的值并没有变，不需要重新计算。**\n\n当计算属性中的内容发生变化后，计算属性的Watcher与组件的Watcher都会得到通知。计算属性的Watcher会将自己的dirty属性设置为true，当下一次读取计算属性时，就会重新计算一次值。然后组件的Watcher也会得到通知，从而执行render函数进行重新渲染的操作。由于要重新执行render函数，所以会重新读取计算属性的值，这时候计算属性的Watcher已经把自己的dirty属性设置为true，所以会重新计算一次计算属性的值，用于本次渲染。\n\n计算属性的内部原理，在模板中使用了一个数据渲染视图时，如果这个数据恰好是计算属性，那么读取数据这个操作其实会触发计算属性的getter方法（初始化计算属性时在vm上设置的getter方法）：\n\n<img src=\"/img/vue45.jpeg\" style=\"max-width:95%\" />\n\n\n这个getter方法被触发时会做两件事。\n  \n  ● 计算当前计算属性的值，此时会使用Watcher去观察计算属性中用到的所有其他数据的变化。同时将计算属性的Watcher的dirty属性设置为false，这样再次读取计算属性时将不再重新计算，除非计算属性所依赖的数据发生了变化。\n\n  ● 当计算属性中用到的数据发生变化时，将得到通知从而进行重新渲染操作。\n\n**说明　计算属性的一个特点是有缓存。计算属性函数所依赖的数据在没有发生变化的情况下，会反复读取计算属性，而计算属性函数并不会反复执行。**\n\n\ncomputed具体实现代码：\n\n```js\nconst computedWatcherOptions = { lazy: true }\n\nfunction initComputed (vm, computed) {\n  // Object.create(null)创建出来的对象没有原型，它不存在 __proto__ 属性。\n  const watchers = vm._computedWatchers = Object.create(null)\n  // 计算属性在SSR环境中，只是一个普通的getter方法\n  const isSSR = isServerRendering()\n\n  for (const key in computed) {\n    const userDef = computed[key]\n    const getter = typeof userDef === 'function' ? userDef : userDef.get\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\n      warn(\n        `Getter is missing for computed property \"${key}\".`,\n        vm\n      )\n    }\n  \n    // 在非SSR环境中，为计算属性创建内部观察器\n    if (!isSSR) {\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      )\n    }\n\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef)\n    } else if (process.env.NODE_ENV !== 'production') {\n      if (key in vm.$data) {\n        warn(`The computed property \"${key}\" is already defined in data.`, vm)\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn(`The computed property \"${key}\" is already defined as a prop.`, vm)\n      }\n    }\n  }\n}\n```\n\n**但在Vue.js中，只有与data和props重名时，才会打印警告。如果与methods重名，并不会在控制台打印警告。所以如果与methods重名，计算属性会悄悄失效，我们在开发过程中应该尽量避免这种情况。**\n\n还需要说明一下defineComputed函数:\n\n```js\nconst sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n}\n  \nexport function defineComputed (target, key, userDef) {\n  const shouldCache = !isServerRendering()\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache\n      ? createComputedGetter(key)\n      : userDef\n    sharedPropertyDefinition.set = noop\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? shouldCache && userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n      sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        `Computed property \"${key}\" was assigned to but it has no setter.`,\n        this\n      )\n    }\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition)\n}\n```\n\n**然后函数中声明了变量shouldCache，它的作用是判断computed是否应该有缓存。这里调用isServerRendering函数来判断当前环境是否是服务端渲染环境。因此，变量shouldCache只有在非服务端渲染环境下才为true。也就是说，只有在非服务端渲染环境下，计算属性才有缓存。**\n\n通过前面的介绍，我们发现计算属性的缓存与响应式功能主要在于是否将getter方法设置为createComputedGetter函数执行后的返回结果。下面我们介绍createComputedGetter函数是如何实现缓存以及响应式功能的，其代码如下：\n\n```js\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    const watcher = this._computedWatchers && this._computedWatchers[key]\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate()\n      }\n      if (Dep.target) {\n        watcher.depend()\n      }\n      return watcher.value\n    }\n  }\n}\n```\n\n如果watcher存在，那么判断watcher.dirty是否为true。前面我们介绍，watcher.dirty属性用于标识计算属性的返回值是否有变化，如果它为true，说明计算属性所依赖的状态发生了变化，它的返回值有可能也会有变化，所以需要重新计算得出最新的结果。\n\n计算属性的缓存就是通过这个判断来实现的。每当计算属性所依赖的状态发生变化时，会将watcher.dirty设置为true，这样当下一次读取计算属性时，会发现watcher.dirty为true，此时会重新计算返回值，否则就直接使用之前的计算结果。\n\n第2章介绍Watcher时，并没有介绍其depend与evaluate方法。事实上，其中定义了depend与evaluate方法专门用于实现计算属性相关的功能,代码如下：\n\n```js\n  export default class Watcher {\n    constructor (vm, expOrFn, cb, options) {\n      // 隐藏无关代码\n  \n      if (options) {\n        this.lazy = !!options.lazy\n      } else {\n        this.lazy = false\n      }\n  \n      this.dirty = this.lazy\n  \n      this.value = this.lazy\n        ? undefined\n        : this.get()\n    }\n  \n    evaluate () {\n      this.value = this.get()\n      this.dirty = false\n    }\n  \n    depend () {\n      let i = this.deps.length\n      while (i--) {\n        this.deps[i].depend()\n      }\n    }\n  }\n```\n\n##### 3.7.5 初始化watch\n初始化状态的最后一步是初始化watch。在initState函数的最后，有这样一行代码：\n\n```js\nif (opts.watch && opts.watch !== nativeWatch) {\n  initWatch(vm, opts.watch)\n}\n```\n\n是因为Firefox浏览器中的Object.prototype上有一个watch方法。当用户没有设置watch时，在Firefox浏览器下的opts.watch将是Object.prototype.watch函数，所以通过这样的语句可以避免这种问题。\n\n\n使用方法：\n\n```js\n  var vm = new Vue({\n    data: {\n      a: 1,\n      b: 2,\n      c: 3,\n      d: 4,\n      e: {\n        f: {\n          g: 5\n        }\n      }\n    },\n    watch: {\n      a: function (val, oldVal) {\n        console.log('new: %s, old: %s', val, oldVal)\n      },\n      // 方法名\n      b: 'someMethod',\n      // 深度watcher\n      c: {\n        handler: function (val, oldVal) { /* ... */ },\n        deep: true\n      },\n      // 该回调将会在侦听开始之后被立即调用\n      d: {\n        handler: function (val, oldVal) { /* ... */ },\n        immediate: true\n      },\n      e: [\n        function handle1 (val, oldVal) { /* ... */ },\n        function handle2 (val, oldVal) { /* ... */ }\n      ],\n      // watch vm.e.f's value: {g: 5}\n      'e.f': function (val, oldVal) { /* ... */ }\n    }\n  })\n  vm.a = 2 // => new: 2, old: 1\n```\n\n由于watch选项的值同时支持字符串、函数、对象和数组类型，不同的类型有不同的用法，所以在调用vm.$watch之前需要对这些类型做一些适配。initWatch函数的代码如下:\n\n```js\nfunction initWatch (vm, watch) {\n  for (const key in watch) {\n    const handler = watch[key]\n    if (Array.isArray(handler)) {\n      for (let i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i])\n      }\n    } else {\n      createWatcher(vm, key, handler)\n    }\n  }\n}\n```\n\ncreateWatcher函数主要负责处理其他类型的handler并调用vm.$watch创建Watcher观察表达式，其代码如下：\n\n```js\nfunction createWatcher (vm, expOrFn, handler, options) {\n  if (isPlainObject(handler)) {\n    options = handler\n    handler = handler.handler\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler]\n  }\n  return vm.$watch(expOrFn, handler, options)\n}\n```\n\n##### 3.7.6 初始化provide\n初始化provide时，只需要将provide选项添加到vm._provided即可，相关代码如下：\n\n```js\nexport function initProvide (vm) {\n  const provide = vm.$options.provide\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide\n  }\n}\n```\n\n##### 3.7.7 总结 （new Vue()背后）\n\n本章详细介绍了new Vue()被执行时Vue.js的背后发生了什么。\n\nVue.js的整体生命周期可以分为4个阶段：初始化阶段、模板编译阶段、挂载阶段和卸载阶段。初始化阶段结束后，会触发created钩子函数。在created钩子函数与beforeMount钩子函数之间的这个阶段是模板编译阶段，这个阶段在不同的构建版本中不一定存在。挂载阶段在beforeMount钩子函数与mounted期间。挂载完毕后，Vue.js处于已挂载阶段。已挂载阶段会持续追踪状态的变化，当数据（状态）发生变化时，Watcher会通知虚拟DOM重新渲染视图。在渲染视图前触发beforeUpdate钩子函数，渲染完毕后触发updated钩子函数。当vm.$destroy被调用时，组件进入卸载阶段。卸载前会触发beforeDestroy钩子函数，卸载后会触发destroyed钩子函数。\n\nnew Vue()被执行后，Vue.js进入初始化阶段，然后选择性进入模板编译与挂载阶段。\n\n在初始化阶段，会分别初始化实例属性、事件、provide/inject以及状态等，其中状态又包含props、methods、data、computed与watch。\n\n### 4、指令的奥秘\n#### 4.1 简介\n指令（directive）是Vue.js提供的带有v-前缀的特殊特性。指令属性的值预期是单个JavaScript表达式。指令的职责是，当表达式的值改变时，将其产生的连带影响响应式地作用于DOM。\n\n除了自定义指令外，Vue.js还内置了一些常用指令，例如v-if和v-for等。有些内置指令的实现原理与自定义指令不同，它们提供的功能很难用自定义指令实现。\n\n#### 4.2 指令原理\n在模板解析阶段，我们在将指令解析到AST，然后使用AST生成代码字符串的过程中实现某些内置指令的功能，最后在虚拟DOM渲染的过程中触发自定义指令的钩子函数使指令生效。\n\n下图给出了让指令生效的全过程。在模板解析阶段，会将节点上的指令解析出来并添加到AST的directives属性中。\n\n<img src=\"/img/vue43.jpeg\" style=\"max-width:95%\" />\n\n随后directives数据会传递到VNode中，接着就可以通过vnode.data.directives获取一个节点所绑定的指令。\n\n最后，当虚拟DOM进行修补时，会根据节点的对比结果触发一些钩子函数。更新指令的程序会监听create、update和destroy钩子函数，并在这三个钩子函数触发时对VNode和oldVNode进行对比，最终根据对比结果触发指令的钩子函数。（使用自定义指令时，可以监听5种钩子函数：bind、inserted、update、componentUpdated与unbind）\n\n##### 4.2.1 v-if指令的原理概述\n有一些内置指令是在模板编译阶段实现的。在代码生成时，通过生成一个特殊的代码字符串来实现指令的功能。\n\n```xml\n<li v-if=\"has\">if</li>\n<li v-else>else</li>\n```\n\n在模板编译的代码生成阶段会生成这样的代码字符串：\n\n```js\n(has)\n  ? _c('li',[_v(\"if\")])\n  : _c('li',[_v(\"else\")])\n```\n\n这样一段代码字符串在最终被执行时，会根据has变量的值来选择创建哪个节点。我们发现v-if的内部原理其实和自定义指令不一样。 \n\n##### 4.2.2 v-for指令的原理概述\nv-for指令也是在模板编译的代码生成阶段实现的。\n\n```xml\n<li v-for=\"(item, index) in list\">v-for {{index}}</li>\n```\n\n在模板编译阶段会生成这样的代码字符串：\n\n```js\n_l((list), function (item, index) {\n  return _c('li', [\n    _v(\"v-for \" + _s(index))\n  ])\n})\n```\n\n其中，_l是函数renderList的别名。当执行这段代码字符串时，_l函数会循环变量list并依次调用第二个参数所传递的函数。同时，会传递两个参数：item和index。此外，当 _c函数被调用时，会执行 _v函数创建一个文本节点。\n\n可以发现，v-for指令的实现原理和自定义指令也不一样。\n\n##### 4.2.3 v-on指令\n它用在普通元素上时，可以监听原生DOM事件；用在自定义元素组件上时，可以监听子组件触发的自定义事件。\n\n例如，在模板中注册一个点击事件：\n\n```js\n<button v-on:click=\"doThat\">我是按钮</button>\n```\n\n在最终生成的VNode中，我们可以通过vnode.data.on读出下面的事件对象：\n\n```js\n{\n  click: function () {}\n}\n```\n\n事件绑定相关的处理逻辑分别设置了create与update钩子函数，也就是说在修补的过程中，每当一个DOM元素被创建或更新时，都会触发事件绑定相关的处理逻辑。\n\n事件绑定相关的处理逻辑是一个叫updateDOMListeners的函数，而create与update钩子函数执行的都是这个函数。其代码如下：\n\n```js\nlet target\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  const on = vnode.data.on || {}\n  const oldOn = oldVnode.data.on || {}\n  target = vnode.elm\n  // normalizeEvents 可以对特殊情况下的事件对象做一些特殊处理。\n  normalizeEvents(on)\n  // 该方法的作用是对比on与oldOn，\n  // 然后根据对比结果调用add方法或remove方法执行对应的绑定事件或解绑事件等\n  updateListeners(on, oldOn, add, remove, vnode.context)\n  target = undefined\n}\n```\n\n这个函数接收两个参数：oldVnode与vnode。我们可以通过对比两个VNode中的事件对象，来决定绑定原生DOM事件还是解绑原生DOM事件。\n\n那么，add和remove方法是如何绑定与解绑DOM原生事件的呢？\n\n浏览器提供了一个绑定事件的API，叫作node.addEventListener，我相信大家都不陌生。add方法的代码如下：\n\n```js\nfunction add (event, handler, once, capture, passive) {\n  handler = withMacroTask(handler)\n  // \n  if (once) handler = createOnceHandler(handler, event, capture)\n  target.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { capture, passive }\n      : capture\n  )\n}\n```\n\n事件监听器使用withMacroTask包了一层，并且如果v-on使用了once修饰符，那么会使用高阶函数createOnceHandler实现once的功能。\n\nwithMacroTask函数的作用是给回调函数做一层包装，当事件触发时，如果因为回调中修改了数据而触发更新DOM的操作，那么该更新操作会被推送到宏任务（macrotask）的任务队列中。\n\n前面说过，createOnceHandler函数可以实现once的功能，那么它是如何做到的呢？其代码如下：\n\n```js\nfunction createOnceHandler (handler, event, capture) {\n  const _target = target // 在闭包中保存当前目标元素\n  return function onceHandler () {\n    const res = handler.apply(null, arguments)\n    if (res !== null) {\n      remove(event, onceHandler, capture, _target)\n    }\n  }\n}\n```\n\n可以看到，这个createOnceHandler函数就是一个普通的once实现。执行该函数后，会返回函数onceHandler。当执行onceHandler时，会执行handler函数，并执行remove函数来解绑事件，使事件只能被执行一次。\n\nremove方法比add方法简单，它只需要调用浏览器提供的removeEventListener方法将事件解绑即可，其代码如下：\n\n```js\nfunction remove (event, handler, capture, _target) {\n  (_target || target).removeEventListener(\n    event,\n    handler._withTask || handler,\n    capture\n  )\n}\n```\n\n#### 4.3 自定义指令的内部原理\n我们知道，虚拟DOM通过算法对比两个VNode之间的差异并更新真实的DOM节点。在更新真实的DOM节点时，有可能是创建新的节点，或者更新一个已有的节点，还有可能是删除一个节点等。虚拟DOM在渲染时，除了更新DOM内容外，还会触发钩子函数。例如，在更新节点时，除了更新节点的内容外，还会触发update钩子函数。这是因为标签上通常会绑定一些指令、事件或属性，这些内容也需要在更新节点时同步被更新。因此，事件、指令、属性等相关处理逻辑只需要监听钩子函数，在钩子函数触发时执行相关处理逻辑即可实现功能。\n\n指令的处理逻辑分别监听了create、update与destroy，其代码如下：\n\n```js\nexport default {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode)\n  }\n}\n```\n\n虚拟DOM在触发钩子函数时，上面代码中对应的函数会被执行。但无论哪个钩子函数被触发，最终都会执行一个叫作updateDirectives的函数。从代码中可以得知，指令相关的处理逻辑都在updateDirectives函数中实现，该函数的代码如下：\n\n```js\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode)\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  // 判断虚拟节点是否是一个新创建的节点。\n  const isCreate = oldVnode === emptyNode\n  \n  // 当新虚拟节点不存在而旧虚拟节点存在时为真。\n  const isDestroy = vnode === emptyNode\n  \n  // 旧的指令集合，指oldVnode中保存的指令。\n  const oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context)\n  \n  // 新的指令集合，指vnode中保存的指令\n  const newDirs = normalizeDirectives(vnode.data.directives, vnode.context)\n  \n  // 其中保存需要触发inserted指令钩子函数的指令列表。\n  const dirsWithInsert = []\n\n  // 其中保存需要触发componentUpdated钩子函数的指令列表。\n  const dirsWithPostpatch = []\n\n  let key, oldDir, dir\n  for (key in newDirs) {\n    oldDir = oldDirs[key]\n    dir = newDirs[key]\n    if (!oldDir) {\n      // 新指令，触发bind\n      callHook(dir, 'bind', vnode, oldVnode)\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir)\n      }\n    } else {\n      // 指令已存在，触发update\n      dir.oldValue = oldDir.value\n      callHook(dir, 'update', vnode, oldVnode)\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir)\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    const callInsert = () => {\n      for (let i = 0; i < dirsWithInsert.length; i++) {\n        callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode)\n      }\n    }\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert)\n    } else {\n      callInsert()\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', () => {\n      for (let i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode)\n      }\n    })\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // 指令不再存在，触发unbind\n        callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy)\n      }\n    }\n  }\n}\n```\n\n这里通过normalizeDirectives函数将模板中使用的指令从用户注册的自定义指令集合中取出来，最终取到的值为：\n\n```js\n{\n  v-focus: {\n    def: {inserted: ?},\n    modifiers: {},\n    name: \"focus\",\n    rawName: \"v-focus\"\n  }\n}\n```\n\n自定义指令的代码为：\n\n```js\nVue.directive('focus', {\n  inserted: function (el) {\n    el.focus()\n  }\n})\n```\n\n最后，介绍一下callHook函数是如何执行指令的钩子函数的，其代码如下：\n\n```js\n// dir：指令对象。\n// hook：将要触发的钩子函数名\n// vnode：新虚拟节点\n// oldVnode：旧虚拟节点\n// isDestroy：当新虚拟节点不存在而旧虚拟节点存在时为真\nfunction callHook (dir, hook, vnode, oldVnode, isDestroy) {\n  const fn = dir.def && dir.def[hook]\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy)\n    } catch (e) {\n      handleError(e, vnode.context, `directive ${dir.name} ${hook} hook`)\n    }\n  }\n}\n```\n\n#### 4.4 虚拟DOM钩子函数\n下表给出了虚拟DOM在渲染时会触发的所有钩子函数以及每个钩子函数的触发时机。\n\n**虚拟DOM在渲染时会触发的所有钩子函数及其触发时机：**\n\n<img src=\"/img/vue46.jpeg\" style=\"max-width:95%\" />\n\n\n### 5、过滤器的奥秘\nVue.js允许我们自定义过滤器来格式化文本。它可以用在两个地方：双花括号插值和v-bind表达式（后者从2.1.0+ 开始支持）。它应该被添加在JavaScript表达式的尾部，由“管道”符号指示：\n\n```js\n<!-- 在双花括号中 -->\n{{ message | capitalize }}\n\n<!-- 在v-bind中 -->\n<div v-bind:id=\"rawId | formatId\"></div>\n```\n\n我们可以在一个组件的选项中定义本地的过滤器：\n\n```js\nfilters: {\n  capitalize: function (value) {\n    if (!value) return ''\n    value = value.toString()\n    return value.charAt(0).toUpperCase() + value.slice(1)\n  }\n}\n```\n\n或者在创建Vue.js实例之前全局定义过滤器：\n\n```js\nVue.filter('capitalize', function (value) {\n  if (!value) return ''\n  value = value.toString()\n  return value.charAt(0).toUpperCase() + value.slice(1)\n})\n\nnew Vue({\n  // ……\n})\n```\n\n过滤器可以串联，下例中，filterA被定义为接收单个参数的过滤器函数，表达式message的值将作为参数传入到filterA过滤器函数中。然后继续调用同样被定义为接收单个参数的过滤器函数filterB，将过滤器函数filterA的执行结果当作参数传递给filterB函数:\n\n```js\n {{ message | filterA | filterB }}\n```\n\n过滤器是JavaScript函数，因此可以接收参数:\n\n```js\n{{ message | filterA('arg1', arg2) }}\n```\n\n这里，filterA被定义为接收三个参数的过滤器函数。其中message的值作为第一个参数，普通字符串 'arg1' 作为第二个参数，表达式arg2的值作为第三个参数。\n\n#### 5.1 过滤器原理概述\n\n```js\n{{ message | capitalize }}\n\n// 过滤器在模板编译阶段会编译成下面的样子\n\n_s(_f(\"capitalize\")(message))\n```\n\n其中 _f函数是resolveFilter的别名，其作用是从this.$options.filters中找出注册的过滤器并返回。因此，上面例子中的 _f(\"capitalize\") 与this.$options.filters['capitalize']相同。而this.$options.filters['capitalize'] 就是我们注册的capitalize过滤器函数：\n\n```js\nfilters: {\n  capitalize: function (value) {\n    if (!value) return ''\n    value = value.toString()\n    return value.charAt(0).toUpperCase() + value.slice(1)\n  }\n}\n```\n\n_s函数不陌生，第9章中介绍过，它是toString函数的别名。toString函数的代码如下：\n\n```js\nfunction toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n```\n\n简单来说，其实就是执行了capitalize过滤器函数并把message当作参数传递进去，接着将capitalize过滤器处理后的结果当作参数传递给toString函数。最终toString函数执行后的结果会保存到VNode中的text属性中。换句话说，这个返回结果直接被拿去渲染视图了。\n\n\n##### 5.1.1 串联过滤器\n\n```js\n{{ message | capitalize | suffix }}\n```\n\n我们定义的本地过滤器如下：\n\n```js\nfilters: {\n  capitalize: function (value) {\n    if (!value) return ''\n    value = value.toString()\n    return value.charAt(0).toUpperCase() + value.slice(1)\n  },\n  suffix: function (value, symbol = '~') {\n    if (!value) return ''\n    return value + symbol\n  }\n}\n```\n\n最终在模板编译阶段会编译成下面的样子：\n\n```js\n_s(_f(\"suffix\")(_f(\"capitalize\")(message)))\n```\n\n##### 5.1.2 滤器接收参数\n\n```js\n{{message|capitalize|suffix('!')}}\n```\n\n设置了参数的过滤器最终被编译后变成这样：\n\n```js\n_s(_f(\"suffix\")(_f(\"capitalize\")(message),'!'))\n```\n\n##### 5.1.3 resolveFilter的内部原理\n\n_f函数是resolveFilter函数的别名。resolveFilter函数的代码如下：\n\n```js\nimport { identity, resolveAsset } from 'core/util/index'\n  \nexport function resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n// 返回相同值\nexport const identity = _ => _\n```\n\n现在我们比较关心resolveAsset函数如何查找过滤器，其代码如下：\n\n```js\nexport function resolveAsset (options, type, id, warnMissing) {\n  if (typeof id !== 'string') {\n    return\n  }\n  const assets = options[type]\n  // 先检查本地注册的变动\n  if (hasOwn(assets, id)) return assets[id]\n  const camelizedId = camelize(id)\n  if (hasOwn(assets, camelizedId)) return assets[camelizedId]\n  const PascalCaseId = capitalize(camelizedId)\n  if (hasOwn(assets, PascalCaseId)) return assets[PascalCaseId]\n  // 检查原型链\n  const res = assets[id] || assets[camelizedId] || assets[PascalCaseId]\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    )\n  }\n  return res\n}\n```\n\n#### 5.2 解析过滤器\n现在我们已经了解了过滤器内部是如何执行的，但是并不了解模板中的过滤器语法是如何编译成过滤器函数来调用表达式的。例如下面的过滤器：\n\n```js\n{{ message | capitalize }}\n\n// 我们并不清楚它是如何被编译成下面这个样子的：\n_s(_f(\"capitalize\")(message))\n```\n\n在Vue.js内部，src/compiler/parser/filter-parser.js文件中提供了一个parseFilters函数，专门用来解析过滤器，它可以将模板过滤器解析成过滤器函数调用表达式。这个逻辑并不复杂，我们只需要在解析出过滤器列表后，循环过滤器列表并拼接一个字符串即可。其代码如下：\n\n```js\nexport function parseFilters (exp) {\n  let filters = exp.split('|')\n  let expression = filters.shift().trim()\n  let i\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i].trim())\n    }\n  }\n\n  return expression\n}\n\n// exp 表达式\n// filter 过滤器\nfunction wrapFilter (exp, filter) {\n  const i = filter.indexOf('(')\n  if (i < 0) {\n    // _f: resolveFilter\n    return `_f(\"${filter}\")(${exp})`\n  } else {\n    const name = filter.slice(0, i)\n    const args = filter.slice(i + 1)\n    return `_f(\"${name}\")(${exp},${args}`\n  }\n}\n  \n// 测试\n\nparseFilters(`message | capitalize`)\n// _f(\"capitalize\")(message)\n\nparseFilters(`message | filterA | filterB`)\n// _f(\"filterB\")(_f(\"filterA\")(message))\n\nparseFilters(`message | filterA('arg1', arg2)`)\n// _f(\"filterA\")(message,'arg1', arg2)\n```\n\n#### 5.3 总结\n过滤器的原理是：在编译阶段将过滤器编译成函数调用，串联的过滤器编译后是一个嵌套的函数调用，前一个过滤器函数的执行结果是后一个过滤器函数的参数。\n\n编译后的 _f函数是resolveFilter函数的别名，resolveFilter函数的作用是找到对应的过滤器并返回。\n\n最后，介绍了在模板编译过程中过滤器是如何被编译成过滤器函数调用的。简单来说，编译过滤器的过程也分两步：解析和拼接字符串。\n\n### 6、最佳实践\n#### 6.1　为列表渲染设置属性key\n我们在介绍虚拟DOM时提到，在更新子节点时，需要从旧虚拟节点列表中查找与新虚拟节点相同的节点进行更新。如果这个查找过程设置了属性key，那么查找速度会快很多。所以无论何时，建议大家尽可能地在使用v-for时提供key，除非遍历输出的DOM内容非常简单，或者是刻意依赖默认行为以获取性能上的提升\n\n```js\n<div v-for=\"item in items\" :key=\"item.id\">\n  <!-- 内容 -->\n</div>\n```\n#### 6.2　在v-if/v-if-else/v-else中使用key\n如果一组v-if+v-else的元素类型相同，最好使用属性key（比如两个 <div\\> 元素）。\n\n在第15章中，我们简单介绍了v-if指令在编译后是下面的样子：\n\n```js\n  (has)\n    ? _c('li',[_v(\"if\")])\n    : _c('li',[_v(\"else\")])\n```\n\n所以当状态发生变化时，生成的虚拟节点既有可能是v-if上的虚拟节点，也有可能是v-else上的虚拟节点。\n\n**默认情况下，Vue.js会尽可能高效地更新DOM。这意味着，当它在相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素移除，然后在同一位置添加一个新元素。如果本不相同的元素被识别为相同，则会出现意料之外的副作用。**\n\n**如果添加了属性key，那么在比对虚拟DOM时，则会认为它们是两个不同的节点，于是会将旧元素移除并在相同的位置添加一个新元素，从而避免意料之外的副作用。**\n\n推荐做法：\n\n```js\n<div\n  v-if=\"error\"\n  key=\"search-status\"\n>\n  错误：{{ error }}\n</div>\n<div\n  v-else\n  key=\"search-results\"\n>\n  {{ results }}\n</div>\n```\n\n\n#### 6.3 路由切换组件不变\n在使用Vue.js开发项目时，最常遇到的一个典型问题就是，当页面切换到同一个路由但不同参数的地址时，组件的生命周期钩子并不会重新触发。\n\n```js\nconst routes = [\n  {\n    path: '/detail/:id',\n    name: 'detail',\n    component: Detail\n  }\n]\n```\n\n当我们从路由/detail/1切换到/detail/2时，组件是不会发生任何变化的。\n\n这是因为vue-router会识别出两个路由使用的是同一个组件从而进行复用，并不会重新创建组件，因此组件的生命周期钩子自然也不会被触发。\n\n**组件本质上是一个映射关系，所以先销毁再重建一个相同的组件会存在很大程度上的性能浪费，复用组件才是正确的选择。但是这也意味着组件的生命周期钩子不会再被调用。**\n\n我相信大家都遇到过这个场景，下面总结了3个方法来解决这个问题。\n\n##### 6.3.1 路由导航守卫beforeRouteUpdate\nvue-router提供了导航守卫beforeRouteUpdate，该守卫在当前路由改变且组件被复用时调用，所以可以在组件内定义路由导航守卫来解决这个问题。\n\n组件的生命周期钩子虽然不会重新触发，但是路由提供的beforeRouteUpdate守卫可以被触发。因此，只需要把每次切换路由时需要执行的逻辑放到beforeRouteUpdate守卫中即可。例如，在beforeRouteUpdate守卫中发送请求拉取数据，更新状态并重新渲染视图。这种方式是我最推荐的一种方式\n\n##### 6.3.2 观察 $route对象的变化\n\n路由：/user?id=4&page=2。\n\n```js\n  const User = {\n    template: '...',\n    watch: {\n      '$route.query.id' () {\n        // 请求个人描述信息\n      },\n      '$route.query.page' () {\n        // 请求列表\n      }\n    }\n  }\n```\n\n##### 6.3.3 为router-view组件添加属性key\n这种做法非常取巧，非常“暴力”，但非常有效。它本质上是利用虚拟DOM在渲染时通过key来对比两个节点是否相同的原理。通过给router-view组件设置key，可以使每次切换路由时的key都不一样，让虚拟DOM认为router-view组件是一个新节点，从而先销毁组件，然后再重新创建新组件。即使是相同的组件，但是如果url变了，key就变了，Vue.js就会重新创建这个组件。\n\n因为组件是新创建的，所以组件内的生命周期会重复触发\n\n```js\n<router-view :key=\"$route.fullPath\"></router-view>\n```\n\n这种方式的坏处很明显，每次切换路由组件时都会被销毁并且重新创建，非常浪费性能。其优点更明显，简单粗暴，改动小。为router-view组件设置了key之后，立刻就可以看到问题被解决了。\n\n#### 6.4 为所有路由统一添加query\n如果路由上的query中有一些是从上游链路上传下来的，那么需要在应用的任何路由中携带，但是在所有跳转路由的地方都设置一遍会非常麻烦。例如，在应用中的所有路由上都加上参数：https://berwin.me/a?referer=hao360cn和https://berwin.me/b?referer=hao360cn。\n\n\n##### 6.4.1 使用全局守卫beforeEach\n事实上，全局守卫beforeEach并不具备修改query的能力，但可以在其中使用next方法来中断当前导航，并切换到新导航，添加一些新query进去。\n\n当然，单单这样做会出问题，因为在进入新导航后，依然会被全局守卫beforeEach拦截，然后再次开启新导航，从而导致无限循环。解决办法是在beforeEach中判断这个全局添加的参数在路由对象中是否存在，如果存在，则不开启新导航：\n\n```js\nconst query = {referer: 'hao360cn'}\nrouter.beforeEach((to, from, next) => {\n  to.query.referer\n    ? next()\n    : next({...to, query: {...to.query, ...query}})\n})\n```\n\n##### 6.4.2 使用函数劫持\n这种方式的原理是：通过拦截router.history.transitionTo方法，在vue-router内部在切换路由之前将参数添加到query中。其使用方式如下：\n\n```js\nconst query = {referer: 'hao360cn'}\nconst transitionTo = router.history.transitionTo\n\nrouter.history.transitionTo = function (location, onComplete, onAbort) {\n  location = typeof location === 'object'\n    ? {...location, query: {...location.query, ...query}}\n    : {path: location, query}\n\n  transitionTo.call(router.history, location, onComplete, onAbort)\n}\n```\n\n代码中，先将vue-router内部的router.history.transitionTo方法缓存到变量transitionTo中。随后使用一个新的函数重写router.history.transitionTo方法，通过在函数中修改参数来达到全局添加query参数的目的。当执行缓存的原始方法时，将修改后的参数传递进去即可。\n\n#### 6.5 区分Vuex与props的使用边界\n通常，在项目开发中，业务组件会使用Vuex维护状态，使用不同组件统一操作Vuex中的状态。这样不论是父子组件间的通信还是兄弟组件间的通信，都很容易。\n\n对于通用组件，我会使用props以及事件进行父子组件间的通信（通用组件不需要兄弟组件间的通信）。这样做是因为通用组件会拿到各个业务组件中使用，它要与业务解耦，所以需要使用props获取状态。\n\n#### 6.6 避免v-if和v-for一起使用\nVue.js官方强烈建议不要把v-if和v-for同时用在同一个元素上。\n\n通常，我们在下面两种常见的情况下，会倾向于不同的做法。\n\n● 为了过滤一个列表中的项目（比如v-for=\"user in users\" v-if=\"user.isActive\"），请将users替换为一个计算属性（比如activeUsers），让它返回过滤后的列表。\n\n● 为了避免渲染本应该被隐藏的列表（比如v-for=\"user in users\" v-if=\"shouldShow-Users\"），请将v-if移动至容器元素上（比如ul和ol）。\n\n\n\n对于第一种情况，Vue.js官方给出的解释是：**当Vue.js处理指令时，v-for比v-if具有更高的优先级，所以即使我们只渲染出列表中的一小部分元素，也得在每次重渲染的时候遍历整个列表，而不考虑活跃用户是否发生了变化。**通过将列表更换为在一个计算属性上遍历并过滤掉不需要渲染的数据，我们将会获得如下好处。\n\n1. 过滤后的列表只会在数组发生相关变化时才被重新运算，过滤更高效。\n2. 使用v-for=\"user in activeUsers\"之后，我们在渲染时只遍历活跃用户，渲染更高效。\n3. 解耦渲染层的逻辑，可维护性（对逻辑的更改和扩展）更强。\n\n```js\n  <ul>\n    <li\n      v-for=\"user in users\"\n      v-if=\"user.isActive\"\n      :key=\"user.id\"\n    >\n      {{ user.name }}\n    </li>\n  </ul>\n```\n\n优化为：\n\n```js\n<ul>\n  <li\n    v-for=\"user in activeUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n\ncomputed: {\n  activeUsers: function () {\n    return this.users.filter(function (user) {\n      return user.isActive\n    })\n  }\n}\n```\n\n对于第二种情况，官方解释是为了获得同样的好处，可以把：\n\n```js\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"shouldShowUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n优化为：\n\n```js\n<ul v-if=\"shouldShowUsers\">\n  <li\n    v-for=\"user in users\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n#### 6.7 为组件样式设置作用域\n对于应用来说，最佳实践是只有顶级App组件和布局组件中的样式可以是全局的，其他所有组件都应该是有作用域的。\n\n#### 6.8 避免在scoped中使用元素选择器\n在scoped样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。\n\n为了给样式设置作用域，Vue.js会为元素添加一个独一无二的特性，例如data-v-f3f3eg9。然后修改选择器，使得在匹配选择器的元素中，只有带这个特性的才会真正生效（比如button[data-v-f3f3eg9]）。\n\n\n#### 6.9 避免隐性的父子组件通信\n我们应该优先通过prop和事件进行父子组件之间的通信，而不是使用this.$parent或改变prop。\n\n一个理想的Vue.js应用是“prop向下传递，事件向上传递”。遵循这一约定会让你的组件更容易理解。然而，在一些边界情况下，prop的变更或this.$parent能够简化两个深度耦合的组件。\n\n问题在于，这种做法在很多简单的场景下可能会更方便。但要注意，不要为了一时方便（少写代码）而牺牲数据流向的简洁性（易于理解）。\n\n\n#### 6.10 模板中简单的表达式\n组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法\n\n复杂的表达式会让模板变得不是那么声明式。我们应该尽量描述理应出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。\n\n```js\n  {{\n    fullName.split(' ').map(function (word) {\n      return word[0].toUpperCase() + word.slice(1)\n    }).join(' ')\n  }}\n```\n\n优化为\n\n```js\n  <!-- 在模板中 -->\n  {{ normalizedFullName }}\n\n\n  // 复杂表达式已经移入一个计算属性\n  computed: {\n    normalizedFullName: function () {\n      return this.fullName.split(' ').map(function (word) {\n        return word[0].toUpperCase() + word.slice(1)\n      }).join(' ')\n    }\n  }\n```\n\n#### 6.11 简单的计算属性\n应该把复杂的计算属性分隔为尽可能多更简单的属性。简单、命名得当的计算属性具有以下特点。\n\n● 易于测试：当每个计算属性都包含一个非常简单且很少依赖的表达式时，撰写测试以确保其正确工作会更加容易\n\n● 易于阅读：简化计算属性要求你为每一个值都起一个描述性的名称，即便它不可复用。这使得开发者更容易专注在代码上并搞清楚发生了什么。\n\n● 更好地“拥抱变化”：任何能够命名的值都可能用在视图上。举个例子，我们可能打算展示一个信息，告诉用户他们存了多少钱；也可能打算计算税费，但是可能会分开展现，而不是作为总价的一部分。\n\n较小的、专注的计算属性减少了信息使用时的假设性限制，所以需求变更时也不需要那么多重构了。\n\n\n```js\ncomputed: {\n  price: function () {\n    var basePrice = this.manufactureCost / (1 - this.profitMargin)\n    return (\n      basePrice -\n      basePrice * (this.discountPercent || 0)\n    )\n  }\n}\n```\n\n优化为：\n\n```js\ncomputed: {\n  basePrice: function () {\n    return this.manufactureCost / (1 - this.profitMargin)\n  },\n  discount: function () {\n    return this.basePrice * (this.discountPercent || 0)\n  },\n  finalPrice: function () {\n    return this.basePrice - this.discount\n  }\n}\n```\n\n","tags":["vue2.5.2"]},{"title":"axios源码分析","url":"/2022/11/28/axios源码分析/","content":"\n## xhr、ajax、axios和fetch区别\n1. xhr: 现代浏览器，最开始与服务器交换数据，都是通过XMLHttpRequest对象。它可以使用JSON、XML、HTML和text文本等格式发送和接收数据。\n2. ajax: 为了方便操作dom并避免一些浏览器兼容问题，产生了jquery， 它里面的AJAX请求也兼容了不同的浏览器，可以直接使用.get、.pist。它就是对XMLHttpRequest对象的一层封装\n3. Axios是一个基于promise的HTTP库，可以用在浏览器和 node.js 中。它本质也是对原生XMLHttpRequest的封装，只不过它是Promise的实现版本，符合最新的ES规范。\n4. Fetch API提供了一个 JavaScript 接口，用于访问和操作HTTP管道的部分，例如请求和响应。它还提供了一个全局fetch()方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源\n\n\n## axios的特性\n1. 基于Promise\n2. 支持浏览器和nodejs环境\n3. 可添加请求、响应拦截器和转换请求和响应数据\n4. 请求可以取消、中断\n5. 自动转换JSON数据\n6. 客户端支持方法XSRF\n\n## 带着问题去看代码\n1. axios拦截器执行顺序？\n\n\n## 源码分析\n### 1、源码目录结构\n```js\n├── /lib/                          // 项目源码目\n  └── /adapters/                     // 定义发送请求的适配器\n      ├── http.js                       // node环境http对象\n      ├── xhr.js                        // 浏览器环境XML对象\n  └── /cancel/                       // 定义取消请求功能\n  └── /helpers/                      // 一些辅助方法\n  └── /core/                         // 一些核心功能\n      ├──Axios.js                      // axios实例构造函数                 \n      ├── createError.js               // 抛出错误\n      ├── dispatchRequest.js           // 用来调用http请求适配器方法发送请求\n      ├── InterceptorManager.js        // 拦截器管理器\n      ├── mergeConfig.js               // 合并参数\n      ├── settle.js                    // 根据http响应状态，改变Promise的状态\n      ├── transformData.js             // 转数据格式\n └── axios.js                        // 入口，创建构造函数\n └── defaults.js                     // 默认配置\n └── utils.js                        // 公用工具函数\n```\n\n### 2、入口文件/lib/axios.js \n```js\nfunction createInstance(defaultConfig) {\n  // 根据默认配置构建个上下文对象，包括默认配置和请求、响应拦截器对象\n  const context = new Axios(defaultConfig);\n\n  // 创建实例 bind后返回的是一个函数，并且上下文指向context\n  const instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  // \n  utils.extend(instance, Axios.prototype, context, {allOwnKeys: true});\n\n  // Copy context to instance\n  // \n  utils.extend(instance, context, null, {allOwnKeys: true});\n\n  // Factory for creating new instances\n  // \n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\nconst axios = createInstance(defaults);\n\n// ...\n// ...\n\n\naxios.default = axios;\n\n// this module should only have a default export\nexport default axios\n```\n\n### 3. Axios.prototype.request\n```js\nclass Axios {\n  constructor(instanceConfig) {\n    this.defaults = instanceConfig;\n    this.interceptors = {\n      request: new InterceptorManager(),\n      response: new InterceptorManager()\n    };\n  }\n\n  request(configOrUrl, config) {\n    // 代码\n    // ...\n    // ...\n    const requestInterceptorChain = [];\n    let synchronousRequestInterceptors = true;\n    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n        return;\n      }\n\n      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n      \n      // 后添加的请求拦截器保存在数组的前面\n      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    const responseInterceptorChain = [];\n    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n\n      // 后添加的响应拦截器保存在数组的后面\n      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    let promise;\n    let i = 0;\n    let len;\n\n    if (!synchronousRequestInterceptors) {\n      const chain = [dispatchRequest.bind(this), undefined];\n      chain.unshift.apply(chain, requestInterceptorChain);\n      chain.push.apply(chain, responseInterceptorChain);\n      len = chain.length;\n\n      promise = Promise.resolve(config);\n\n      while (i < len) {\n        promise = promise.then(chain[i++], chain[i++]);\n      }\n\n      return promise;\n    }\n\n    len = requestInterceptorChain.length;\n\n    let newConfig = config;\n\n    i = 0;\n\n    while (i < len) {\n      const onFulfilled = requestInterceptorChain[i++];\n      const onRejected = requestInterceptorChain[i++];\n      try {\n        newConfig = onFulfilled(newConfig);\n      } catch (error) {\n        onRejected.call(this, error);\n        break;\n      }\n    }\n\n    try {\n      promise = dispatchRequest.call(this, newConfig);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    i = 0;\n    len = responseInterceptorChain.length;\n     \n    // 通过promise的then()串连起所有的请求拦截器/请求方法/响应拦截器\n    while (i < len) {\n      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n    }\n\n    return promise;    \n  }\n}\nexport default Axios;\n```\n\n### 4. 拦截器实现\n```js\nclass InterceptorManager {\n  constructor() {\n    this.handlers = [];\n  }\n  // 添加拦截器 添加成功和失败回调方法\n  use(fulfilled, rejected, options) {\n    this.handlers.push({\n      fulfilled,\n      rejected,\n      synchronous: options ? options.synchronous : false,\n      runWhen: options ? options.runWhen : null\n    });\n    return this.handlers.length - 1;\n  }\n\n  // 注销指定拦截器\n  eject(id) {\n    if (this.handlers[id]) {\n      this.handlers[id] = null;\n    }\n  }\n\n  // 注销所有的拦截器\n  clear() {\n    if (this.handlers) {\n      this.handlers = [];\n    }\n  }\n  // 遍历执行\n  forEach(fn) {\n    utils.forEach(this.handlers, function forEachHandler(h) {\n      if (h !== null) {\n        fn(h);\n      }\n    });\n  }\n}\n\nexport default InterceptorManager;\n```\n\n<img src=\"/img/axios1.png\" width=\"90%\" />\n\n**由于请求的发送需要在请求拦截器之后，在响应拦截器之前，所以数组先放入request，接着在数组的前后分别加入请求和响应拦截器，由于加入请求拦截器的方法是unshift，所以最后通过promise进行请求的链式调用的时候，我们可以看到执行顺序是从左往右的，所以最后注册的请求拦截器会最先执行，而响应拦截的执行顺序和注册顺序是一样的。**\n\n### 5、dispatchRequest\n\n我们进入到核心请求方法dispatchRequest中\n\n```js\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new CanceledError(null, config);\n  }\n}\n\n\nexport default function dispatchRequest(config) {\n  // 请求取消请求\n  throwIfCancellationRequested(config);\n  \n  // 请求头\n  config.headers = AxiosHeaders.from(config.headers);\n\n  // 转换数据\n  config.data = transformData.call(\n    config,\n    config.transformRequest\n  );\n\n  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {\n    config.headers.setContentType('application/x-www-form-urlencoded', false);\n  }\n   \n  // 适配器\n  const adapter = adapters.getAdapter(config.adapter || defaults.adapter);\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // 转换响应头数据\n    response.data = transformData.call(\n      config,\n      config.transformResponse,\n      response\n    );\n\n    response.headers = AxiosHeaders.from(response.headers);\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n       // 转换响应头数据\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          config.transformResponse,\n          reason.response\n        );\n        reason.response.headers = AxiosHeaders.from(reason.response.headers);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n}\n```\n\n### 6、适配器adapter\n```js\nfunction getDefaultAdapter() {\n  var adapter;\n  // 判断XMLHttpRequest对象是否存在 存在则代表为浏览器环境\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n    // node环境 使用原生http发起请求\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n```\n\n### 7、axios主动取消请求\n\n**终止一个尚未完成的网络请求, status状态为canceled**\n\n1、使用axios\n\n```js\nimport { CancelToken } from axios;\n\n// source为一个对象 结构为 { token, cancel }\n// token用来表示某个请求，是个promise\n// cancel是一个函数，当被调用时，则取消token注入的那个请求\nconst source = CancelToken.source();\n\naxios\n    .get('/user', {\n        // 将token注入此次请求\n        cancelToken: source.token, \n    })\n    .catch(function (thrown) {\n        // 判断是否是因为主动取消而导致的\n        if (axios.isCancel(thrown)) {\n            console.log('主动取消', thrown.message);\n        } else {\n            console.error(thrown);\n        }\n    });\n\n// 这里调用cancel方法，则会中断该请求 无论请求是否成功返回\nsource.cancel('我主动取消请求')\n\n\n/**\n * 方法二\n * let cancel = null;\n * axios\n    .get('/user', {\n        cancelToken: new CancelToken(function executor(c){\n            cancel = c;\n        }) \n    })\n * cancel('我主动取消请求')\n * /\n```\n\n\n2、CancelToken构造函数\n\n```js\nclass CancelToken {\n  constructor(executor) {\n    if (typeof executor !== 'function') {\n      throw new TypeError('executor must be a function.');\n    }\n\n    let resolvePromise;\n\n    this.promise = new Promise(function promiseExecutor(resolve) {\n     // 把resolve方法提出来 当resolvePromise执行时，this.promise状态会变为fulfilled\n      resolvePromise = resolve;\n    });\n\n    const token = this;\n\n   \n    this.promise.then(cancel => {\n      if (!token._listeners) return;\n\n      let i = token._listeners.length;\n\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n      token._listeners = null;\n    });\n\n    \n    this.promise.then = onfulfilled => {\n      let _resolve;\n      const promise = new Promise(resolve => {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n\n      return promise;\n    };\n\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n\n      token.reason = new CanceledError(message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason) {\n      throw this.reason;\n    }\n  }\n\n  /**\n   * Subscribe to the cancel signal\n   */\n\n  subscribe(listener) {\n    if (this.reason) {\n      listener(this.reason);\n      return;\n    }\n\n    if (this._listeners) {\n      this._listeners.push(listener);\n    } else {\n      this._listeners = [listener];\n    }\n  }\n\n  /**\n   * Unsubscribe from the cancel signal\n   */\n\n  unsubscribe(listener) {\n    if (!this._listeners) {\n      return;\n    }\n    const index = this._listeners.indexOf(listener);\n    if (index !== -1) {\n      this._listeners.splice(index, 1);\n    }\n  }\n\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let cancel;\n    const token = new CancelToken(function executor(c) {\n      cancel = c;\n    });\n    return {\n      token,\n      cancel\n    };\n  }\n}\n\nexport default CancelToken;\n```\n\n\n3、请求中是如何处理的cancel\n```js\n// 订阅\nif (config.cancelToken || config.signal) {\n  // Handle cancellation\n  // eslint-disable-next-line func-names\n  onCanceled = cancel => {\n    if (!request) {\n      return;\n    }\n    reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);\n    request.abort();\n    request = null;\n  };\n\n  config.cancelToken && config.cancelToken.subscribe(onCanceled);\n  if (config.signal) {\n    config.signal.aborted \n           ? onCanceled() \n           : config.signal.addEventListener('abort', onCanceled);\n  }\n}\n\n\n// 取消订阅\nlet onCanceled;\nfunction done() {\n  if (config.cancelToken) {\n    config.cancelToken.unsubscribe(onCanceled);\n  }\n\n  if (config.signal) {\n    config.signal.removeEventListener('abort', onCanceled);\n  }\n}\n```\n\n\n<img src=\"/img/axios2.png\" width=\"90%\" />\n\n<br />\n\n[文章来源于](https://juejin.cn/post/7016255507392364557)\n\n[class static静态方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/static)","tags":["axios"]},{"title":"学习File、Blob、FileReader、ArrayBuffer和Base64","url":"/2022/10/24/学习File、Blob、FileReader、ArrayBuffer和Base64/","content":"\n## Blob\nBlob 全称为 binary large object ，即二进制大对象。blob对象本质上是js中的一个对象，里面可以储存大量的二进制编码格式的数据。Blob 对象一个不可修改，从Blob中读取内容的唯一方法是使用 FileReader。\n\n### 1. 实例属性和方法\n```js\n// 属性\n1. Blob.prototype.size //只读\n2. Blob.prototype.type //只读\n\n// 方法\nBlob.prototype.arrayBuffer() // 返回一个 promise，其会兑现一个包含 Blob 所有内容的二进制格式的 ArrayBuffer\n\nBlob.prototype.slice() // 返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据。\n\nBlob.prototype.stream() // 返回一个能读取 Blob 内容的 ReadableStream。\n\nBlob.prototype.text() // 返回一个 promise，其会兑现一个包含 Blob 所有内容的 UTF-8 格式的字符串。\n```\n\n### 2、创建\n```js\n//  type：默认值为 ''，表示将会被放入到 blob 中的数组内容的 MIME 类型\nconst obj = {hello: 'world'};\nconst blob = new Blob(\n    [JSON.stringify(obj, null, 2)], \n    {type : 'application/json'}\n);\n```\n<img src=\"/img/blob1.png\" width=\"90%\" />\n\n\n### 3、读取\n```js\nconst reader = new FileReader();\nreader.addEventListener('loadend', () => {\n   // reader.result 包含被转化为类型化数组的 blob 中的内容\n   console.log(reader.result);\n});\nreader.readAsText(blob);\n```\n\n[Blob相关文档]((https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)\n\n\n## File\nFile 对象是特殊类型的 Blob\n\n在 JavaScript 中，主要有两种方法来获取 File 对象：\n1. 1）<input\\> 元素上选择文件后返回的 FileList 对象；\n2. 2）文件拖放操作生成的 DataTransfer 对象；\n\n```js\n/*\n<input type=\"file\" name=\"\" id=\"fileId\">\n<script>\n let file = document.getElementById(\"fileId\");\n file.onchange = function(e){\n    console.log(e.target.files);\n }\n</script>\n*/\n\n// 属性和方法\nname: \"CI流程.md\"\nsize: 1356\ntype: \"text/markdown\"\n```\n\n## FileReader\n通过上面我都知道了blob是不可修改也是无法读取里面的内容的。无法读取里面的内容肯定是不可行的。所以Filereader就提供了读取blob里面内容的方法。\n\nFileReader 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，\n使用 File 或 Blob 对象指定要读取的文件或数据。\n\n### 1、实例属性和方法\n```js\nlet reader = new FileReader();\n\n// 属性\nreader.error \n\nreader.readyState // 0:EMPTY 1:LOADING 2:DONE\n\nreader.result  // 文件的内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作。\n\n// 事件处理\nreader.onabort  // 该事件在读取操作被中断时触发。\n\nreader.onload  // 该事件在读取操作完成时触发。 \n\n\n// 方法\nreader.readAsArrayBuffer() //开始读取指定的 Blob中的内容，一旦完成，result 属性中保存的将是被读取文件的 ArrayBuffer 数据对象\n\nreader.readAsText() // 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个字符串以表示所读取的文件内容。\n\nreader.readAsDataURL() // 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL 格式的 Base64 字符串以表示所读取文件的内容。\n```\n\n### 2、将文件读取为base64\n```js\n<input type=\"file\" name=\"\" id=\"fileId\">\n<script>\n let file = document.getElementById(\"fileId\");\n file.onchange = function(e){\n    let file = e.target.files[0];\n    let reader = new FileReader();\n    reader.readAsDataURL(file);\n    reader.onload = function (e) {\n        console.log(e.target.result);\n    }\n }\n</script>\n```\n\n### 3、将blob对象读出来\n```js\n<script>\n  const obj = {hello: 'world'};\n  const blob = new Blob(\n      [JSON.stringify(obj, null, 2)], \n      {type : 'application/json'}\n  );\n  let render = new FileReader();\n  render.readAsText(blob);\n  render.onload = (e) => {\n      console.log(e.target.result); //  {\"hello\": \"world\"}\n  }\n</script>\n```\n\n[FileReader相关文档](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader)\n\n## ArrayBuffer\nArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。\n\n它是一个字节数组，通常在其他语言中称为“byte array”。\n\n你不能直接操作 ArrayBuffer 的内容，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。\n\n<img src=\"/img/blob3.png\" width=\"90%\" />\n\n### 1、创建buffer\n```js\nconst buffer = new ArrayBuffer(8);\n```\n\n### 2、TypedArray读写buffer\n```js\nlet buffer = new ArrayBuffer(8);\nlet wrapBuffer = new Int8Array(buffer);\n```\n\n### 3、DataView读写buffer\n```js\nlet buffer = new ArrayBuffer(8);\nlet wrapBuffer = new DataView(buffer);\nconsole.log(wrapBuffer.getInt8());\nwrapBuffer.setInt(0, 100);\nconsole.log(wrapBuffer.getInt8());\n```\n\n\n[ArrayBuffer相关文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)\n\n## Object URL\n它是一个用来表示File Object 或Blob Object 的URL\n```js\n    <input type=\"file\" name=\"\" id=\"fileId\">\n    <script>\n     let file = document.getElementById(\"fileId\");\n     file.onchange = function(e){\n       let file = e.target.files[0];\n       console.log(URL.createObjectURL(file))\n        // blob:http://127.0.0.1:5500/57c6bf38-c83c-4f1b-a936-da9bf00d9ecf\n     }\n    </script>\n```\n\n[URL参考文档](https://developer.mozilla.org/zh-CN/docs/Web/API/URL/URL)\n\n## base64\n在 JavaScript 中，有两个函数被分别用来处理解码和编码 base64 字符串：\n\n1. btoa()：编码，从一个字符串或者二进制数据编码一个 Base64 字符串；\n2. atob()：解码，解码一个 Base64 字符串。\n\n```js\nbtoa('java')     // 编码  'amF2YQ=='\natob('amF2YQ==') // 解码  java\n```\n\n### 使用场景\n1. 将canvas画布内容生成base64的图片；\n2. 将获取的图片文件，生成base64图片。\n\n## Blob与其他类型关系\n<img src=\"/img/blob2.png\" width=\"90%\" />\n\n<br />\n[文章来源](https://blog.csdn.net/qq_35577655/article/details/127169333)\n","tags":["Blob","FileReader","ArrayBuffer","Base64"]},{"title":"ES5和ES6以及ES7+","url":"/2022/10/24/ES5和ES6以及ES7/","content":"\n## 一、ES5\nECMAScript 5 于 2009 年 12 月发布的，内容主要包括严格模式、JSON 对象、新增 Object 接口、新增 Array 接口和 Function.prototype.bind 等。可以认为 ECMAScript 5 规范的推出在原来没有规范的 JavaScript 语法上添加了有限的限制标准，其中最重要的一条可能就是严格模式的推出。\n\n### 1. 严格模式\n* 未声明的全局变量赋值会抛出 ReferenceError，而不是默认去创建一个全局变量\n* 默认支持的糟糕特性都会被禁用，使用 with、eval 等语句执行会抛出 SyntaxError\n* 限制了函数中 arguments 使用，arguments.callee( ) 和 arguments.caller( ) 调用会提示 Uncaught ReferenceError\n* 函数 arguments 严格定义为参数，不能与形参绑定\n\n### 2. Object\n* getPrototypeOf，返回一个对象的原型\n* getOwnPropertyDescriptor，返回某个对象自有属性的属性描述符\n* getOwnPropertyNames，返回一个数组，包括对象所有自由属性名称集合（包括不可枚举的属性）\n* hasOwnProperty，给定属性存在于对象实例中，返回 true\n* isPrototypeOf，在原型链中出现过的原型，返回 true\n* create，创建一个拥有指定原型和若干指定属性的对象\n* defineProperty，为对象定义一个新属性，或者修改已有的属性，并对属性重新设置 getter 和 setter，这里可以被用作数据绑定的对象劫持用途\n* defineProperties，在一个对象上添加或修改一个或者多个自有属性，与 defineProperty 类\n* seal，锁定对象，阻止修改现有属性的特性，并阻止添加新属性，但是可以修改已有属性的值\n* freeze，冻结对象，阻止对对象的一切操作和更改，冻结对象将变成只读\n* preventExtensions，让一个对象变得不可以扩展，也就是不能再添加新的属性\n* keys，返回一个由给定对象的所有可以枚举自身属性的属性名组成的数组\n\n\n### 3. Array\n* Array.isArray，确定某个值到底是不是数组，不管它在哪个全局执行环境中创建\n* push，接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度\n* pop，在数组尾部移除最后一项，减少数组的 length 值，然后返回移除的项\n* shift，移除数组中的第一项并返回该项，同时将数组长度减 1\n* unshift，在数组前端添加任意个项，并返回新数组的长度\n* reverse，反转数组项的顺序，返回排序后的数组\n* sort，默认情况下，按升序排序数组项，返回排序后的数组\n* concat，创建当前数组的一个副本，将接收到的参数添加到这个副本的末尾，返回新构建的数组\n* join，用指定的字符拼接数组，返回拼接好的字符串\n* slice，基于当前数组中的一个或多个创建一个新数组，不影响原始数组\n* splice，根据传入参数不同，可以删除、插入、替换数组元素，返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回空数组\n* indexOf，返回根据给定元素找到的第一个索引值，如果不存在则返回 -1\n* lastIndexOf，返回指定元素在数组中的最后一个索引值，如果不存在则返回 -1\n* every ，对数组中的每一项运行给定函数 ，如果该函数对每一项都返回 true，则返回 true\n* filter，对数组中的每一项运行给定函数 ，返回该函数会返回 true 的项组成的数组\n* forEach，对数组中的每一项运行给定函数，没有返回值\n* map，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组\n* some，对数组中的每一项运行给定函数，如果函数对任一项返回 true，则返回 true\n* reduce，接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终缩减为一个值\n\n### 4. String\n* charAt，访问字符串中特定字符，返回给定位置的字符\n* charCodeAt，访问字符串中特定字符，返回给定位置的字符的字符编码\n* concat，将一个或多个字符串拼接起来，返回拼接得到的新字符串\n* match，查找匹配的字符串，返回一个数组\n* search，查找匹配的字符串，返回匹配项的索引，没有找到，返回 -1\n* replace，替换字符串\n* split，基于指定的分隔符将一个字符串分割成多个字符串，将结果放在一个数组中，并返回\n* trim，创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果\n* localeCompare，比较两个字符串\n* slice，返回被操作字符串的一个子字符串\n* substr，返回被操作字符串的一个子字符串\n* substring，返回被操作字符串的一个子字符串\n\n\n### 5. Function\n* arguments.callee，该属性是一个指针，指向拥有这个 arguments 对象的函数\n* arguments.caller，该属性保存着调用当前函数的函数的引用\n* apply，在特定的作用域中调用函数，第一个参数是在其中运行函数的作用域，第二个是参数数组\n* call，在特定的作用域中调用函数，第一个参数是在其中运行函数的作用域，其余参数直接传递给函数\n* bind，创建一个函数的实例，其 this 值会被绑定到传给 bind 函数的值\n\n\n### 6. JSON\n* JSON.parse，解析字符串为 JSON 对象\n* JSON.stringify，解析 JSON 对象为字符串\n* JSON.valueOf，获取某个JSON 对象中的值\n* JSON.toString，被调用时，会调用 Object 原型上的 toString 方法，会获的 JSON 对象的值并转为字符串，如果没有具体的值，则返回原型数组\n\n\n### 7. 其他\n* Date.now，返回当前时间戳\n* Number.prototype.toFixed，按照指定的小数位返回数值的字符串表示\n\n## 二、ES6\nECMAScript 6 于 2015 年 6 月 17 日正式发布，也被命名为 ECMAScript 2015。ES6 借鉴了 ES5 和其他语言的特性，并在此基础上进行了补充和增强，使得 JavaScript 语言规范更加高效、严谨、完善。\n\n例如，字符串模板、集合、箭头函数、Promise、for...of 等均是借鉴其他语言的优秀特性而增加的功能点。class 类和 import/export 模块规范则可以认为是对原有标准缺失的补充。迭代器、生成器、解构赋值、函数参数等都可以认为是对原有标准特性的增强。\n\n\n### 1. let、const\n对于跨级作用域变量声明关键字 let、const，在使用时有几个需要注意的地方:\n 1. let 和 const 都只能作为块级作用域变量的声明，且只能在块作用域内生效，块内声明的变量无法在块级外层 引用\n 2. 使用 const 声明的变量必须进行初始化赋值，而且一旦赋值就不能再进行二次修改赋值\n 3. 使用 let 和 const 在全局作用域下声明的变量不会作为属性添加到全局作用域对象里面\n\nlet 和 const 使用场景的区别：\n 1. 模块内不变的引用和常量，一般使用 const 定义\n 2. 可变的变量或引用使用 let 声明\n 3. var 仅用于声明函数整个作用域内需要使用的变量\n\n### 2. 字符串模板\n如果没有字符串模板，我们依然需要像以前一样借助“字符串+操作符” 拼接或数组 join 方法来连接多个字符串变量。\n**需要注意的是，字符串模板不会压缩内部的换行与空格，而是按照原有的格式输出，只将变量内容填充替换掉。**\n\n### 3. 解构赋值\n解构赋值主要分为数组解构和对象解构：\n```js\nlet [a, b, c] = [1, 2]\nlet {one, two, three} = {two:2, three: 3, one: 1}\n\n[a, b] = [b, a] // 交换a、b 变量的值\nconsole.log(c) // undefined\n```\n数组解构是严格按照数组下标依次对应顺序赋值的，如果复制的常量个数不够，则对应下标的变量默认为 undefined；如果常量个数超出，则多余的会被舍弃，所以顺序很重要。\n\n对象的解构赋值是根据对象引用的键名来赋值的，可以无视顺序。\n\n### 4. 数组的新特性\n```js\nconst arr = [1, 2, 3]\nconst newArr = [...arr]  //[1, 2, 3]\n```\n注意：这里 **... 进行的数组复制是浅拷贝**。\n\n**ES6 数组的新增方法：**\n1. Array.from，用于将类数组对象（包括 [array-like object] 和可遍历对象）转化为真正的数组\n2. Array.of，可以将传入的一组参数值转换为数组\n3. Array.prototype.copyWithin，可以在当前数组内部将指定位置的数组项复制到其他位置，然后返回当前数组，使用 copyWithin 方法会修改当前数组\n4. Array.prototype.fill，使用给定值，填充一个数组，会改变原来的数组\n5. Array.prototype.find，用于找出第一个符合条件的数组元素，有点类似于 filter\n6. Array.prototype.findIndex，用来返回某个特定数组元素在数组中的位置\n7. Array.prototype.entries，对数组中键值对进行遍历\n8. Array.prototype.keys，对数组键名进行遍历\n9. Array.prototype.values，对数组键值进行遍历\n10. for...of 循环进行遍历\n11. Array.prototype[Symbol.iterator]，用来获取遍历数组对象的迭代器\n\n\n### 5. 增强对象\n在 ES6 中，对象的使用变得更加方便了，可以在定义对象时通过属性简写、遍历作为属性名或省略对象函数属性的书写等方式来提高编码的效率：\n```js\nconst name = 'xixi'\nconst people = {\n    name,\n    [getKey('family')]: 'zhang',\n    sayHi() {\n        console.log(`Hello ${this.name} ${this.family}`)\n    }\n}\n\npeople.sayHi() // Hello xixi zhang\n\nfunction getKey(key) {\n    return key\n}\n```\n\n### 6. 函数参数\nES6 对函数参数进行了新的设计，主要添加了默认参数、不定参数和扩展参数：\n```js\n// 默认参数\nfunction sayHi(name = 'xixi') {\n    console.log(`Hello ${name}`)\n}\nsayHi() // Hello xixi\n\n// 不定参数\nfunction sayHi(...name) {\n    console.log(name.reduce((a, b) => `Hello ${a} ${b}`))\n}\nsayHi('xixi', 'zhang') // Hello xixi zhang\n\n// 扩展参数\nlet name = ['xixi', 'zhang']\nfunction sayHi(name1, name2) {\n    console.log(`Hello ${name1} ${name2}`)\n}\nsayHi(...name) // Hello xixi zhang\n```\n**不定参数和扩展参数可以认为恰好是相反的两个模式，不定参数是使用数组来表示多个参数，扩展参数则是将多个参数映射到一个数组。**\n\n需要注意：不定参数的 ... 和数组复制的 ... 是有区别的，不定参数可以使用函数的形参来表示所有的参数组成的列表。以前的 arguments 变量也有类似的作用，但是 arguments 不是真正的数组，除了存放参数的列表外，arguments 还有 length 属性，严格来说 arguments 是一个类数组对象，而不定参数则是一个完全的数组，这也是不定参数相对于 arguments 的优势，更加方便我们使用，所以建议使用不定参数来代替 arguments。\n\n### 6. 箭头函数\n```js\n// 箭头函数\n[1, 2, 3].forEach(x => x*x)\n\n(() => {\n    console.log('Hello xixi')\n})()\n```\n箭头函数没有完整的执行上下文，因此其 this 和外层的 this 相同，可以理解为它的执行上下文只有变量对象和作用域链，没有 this 值。\n\n在 JavaScript 中，代码的执行上下文由变量对象、作用域链和 this 值组成，但箭头函数与外层执行上下文共享 this 值，如果需要创建具有独立上下文的函数，就不要使用箭头函数。\n\n### 7. class\n基本上，ES6 中的 class 可以看做是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰，更像面向对象变成的语法而已。\n\n```js\nclass Animal {\n    constructor() {\n\n    }\n}\n\nclass People extends Animal {\n    constructor(contents = {}) {\n        super(); // 调用父类的 constructor方法， 且可以向父类的构造函数传达参数\n        this.name = contents.name\n        this.family = contents.family\n    }\n    sayHi() {\n        console.log(`Hello ${this.name} ${this.family}`)\n    }\n}\n\nlet me = new People({\n    name: 'xixi',\n    family: 'zhang'\n})\n\nme.sayHi() //Hello xixi zhang\n```\n\n### 9. 模块 module\nES6 引入了模块引用规范，这也是之前语言标准上没有的，这样现有的 JavaScript 模块化规范又多了一种选择：import/export\n\n```js\nimport { sayHi } from './people'\nexport sayHi\n```\n\n### 10. 集合类型 Map + Set + WeakMap + WeakSet\n#### Set\nSet 本身是一个构造函数 ，用来生成 Set 数据结构，Set 类似于数组（但它不是数组），Set 的成员的值都是唯一的，没有重复的值，也常用它来去重（不可以传递对象）。像 Set 加入值的时候，不会发生类型转换，所以 5 和 “5” 是两个不同的值。\n```js\nconst arr = new Set([1, 2, 3, 4, 5, 5, 5, 5])\n\nconsole.log(arr)  //[1, 2, 3, 4, 5]\nconsole.log(arr.size)  //5\n```\n\n#### WeakSet\nWeakSet 结构与 Set 类似，也是不重复的值的集合，但是，它与 Set 有两个区别：\n1. 第一，WeakSet 的成员只能是对象，而不能是其他类型的值。\n2. 第二，WeakSet 中的对象都是弱引用，即垃圾回收机制 不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不在引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象是否还存在于 WeakSet 中。因此 ES6 规定 WeakSet 不可遍历。\n\n#### Map\n传统的 JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是只能用字符串当做键，这给它的使用带来了很大的限制，而 ES6 提供了 Map 数据结构，它类似于对象，也是键值对的集合，但是“键” 的范围不限于字符串，各种类型的值（包括对象）都可以当做键。也就是说，Object 结构提供了“字符串-值”的对应，Map 结构提供了“值-值”的对应，是一种更完善的 Hash 结构实现。Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。\n\n操作方法：\n1. set(key, value)，设置 key 所对应的键值，返回整个 Map 结构 ，如果 key 已经有值，则键值会被更新，否则就生成该键\n2. get(key)，读取 key 对应的键值，如果在好不到 key，则返回 undefined\n\n遍历方法：\n1. keys()，返回键名的遍历器\n2. values()，返回键值的遍历器\n3. entries()，返回所有成员的遍历器\n4. forEach()，遍历 Map 的所有成员\n\n#### WeakMap\nWeakMap 结构与 Map 结构类似，也用于生成键值对的集合，但 WeakMap 与 Map 有两个个区别：\n\n1. WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名\n2. WeakMap 的键名所指向的对象不计入垃圾回收机制。它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内，因此，只要所引用的对象的其他引用被清除了，垃圾回收机制就会释放该对象所占用的内存。也就是说， 一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。基本上，如果要想对象中添加数据又不想干扰垃圾回收机制，便可以使用 WeakMap。一个典型的应用场景是，在网页的 DOM 元素上添加数据时就可以使用 WeakMap 结构，当该 DOM 元素被清除，其对应的 WeakMap 记录就会自动被移除。\n\n\n注意：WeakMap 的专用场景就是它的键所对应的对象可能会在将来消失，WeakMap 结构有助于防止内存泄露。但是，WeakMap 弱引用的只是键名而不是键值，键值依然是正常引用的。\n\n### 11. Symbol 类型\nES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值，它是 JavaScript 语言的第 7 种数据类型，前 6 种分别是：Undefined、Null、Boolean、String、Number 和 Object。\n\nSymbol 值通过 Symbol 函数生成，一般作为属性键值，并且能避免对象属性键的命名冲突。也就是说，对象的属性名现在可以有两种类型：一种是原来就有的字符串，另一种就是新增的 Symbol 类型。只要属性名属于 Symbol 类型，就是独一无二的，可以保证不会与其他属性名产生冲突。\n```js\nlet s = Symbol('foo')\ntypeof s  //\"symbol\"\n```\n\nSymbol 函数前不能使用 new 命令，否则会报错，这是因为生产的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。\n\n**Symbol 函数的参数只表示对当前 Symbol 值的描述，因此相同参数的 Symbol 函数的返回值是不相等的。**\n\nSymbol 值作为对象属性名时不能使用点运算符：\n```js\nlet s = Symbol()\n\nlet obj = {\n    [s]: function() {\n        console.log('Hello')\n    }\n}\n\nobj[s]()  // 'Hello'\n```\n\n### 12. Promise\nPromise 代表一个异步操作的执行返回状态，这个执行返回状态在 Promise 对象创建时是未知的，它允许为异步操作的成功或失败指定处理方法。\n\n####  Promise 的状态有三种\n1. Fulfilled，表示 Promise 执行成功\n2. Rejected，表示 Promise 执行失败\n3. Pending，表示 Promise 正在执行中\n\n####  Promise 对象有两个特点\n1. 对象的状态不受外界影响\n2. 一旦状态改变就不会再变，任何时候都可以得到这个结果\n\n#### 缺点\n1. 无法取消 Promise，一旦新建它就会立即执行，无法中途取消\n2. 如果不设置回调函数，Promise 内部抛出的错误不会反应到外部\n3. 当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚开始还是即将完成）\n\n\n#### 用法\n```js\nvar promise = new Promise(function(resolve, reject) {\n    // ... some code\n\n    if ( /*异步操作成功*/ ) {\n        resolve(value)\n    } else {\n        reject(error)\n    }\n})\n\npromise.then(function(value) {\n    // success\n}, function(error) {\n    // failure\n})\n```\n\n#### 实例方法\n1. Promise.prototype.then()，为 Promise 实例添加状态改变时的回调函数，返回一个新的 Promise 实例\n2. Promise.prototype.catch()，用于指定发生错误时的回调函数，返回一个新的 Promise 实例\n3. Promise.prototype.done()，总是处于回调链的尾端，保证捕捉到任何可能出现的错误\n4. Promise.prototype.finally()，用于指定不管 Promise 对象最后状态如何都会执行的操作。\n\nfinally 与 done 的最大区别在于：finally 接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。\n\n####  Promise 对象方法\n1. Promise.all()，将多个 Promise 实例包装成一个新的 Promise 实例。\n   1. 第一，只有 p1，p2，p3 的状态都编程 Fulfilled，p 的状态才会变成 Fulfilled，此时p1，p2，p3 的返回值组成一个数组，传递给 p 的回调函数。\n   2. 第二，只要 p1，p2，p3 中有一个被 Rejected，p 的状态就变成 Rejected，此时第一个被 Rejected 的实例的返回值会传递给 p 的回调函数\n2. Promise.race()，将多个 Promise 实例包装成一个新的 Promise 实例。\n   1. 只要 p1，p2，p3 中有一个实例率先改变状态，p 的状态就跟着改变，那个率先改变的 Promise 实例的返回值就传递给 p 的回调函数。\n3. Promise.resolve()，将现有对象转为 Promise 对象，状态为 Resolved\n4. Promise.reject()，将现有对象转为 Promise 对象，状态为 Rejected\n\n\n### 13. Proxy\nProxy 用于修改某些操作的默认行为，可以用来拦截某个对象的属性访问方法，然后重载对象的 “ . ” 运算符。\n\nProxy 可以理解成在目标对象前架设一个“拦截”层，外界对该对象的访问都必须先通过这层拦截，因此提供了一种机制可以对外界的访问进行过滤和改写。\n```js\nlet object = new Proxy({}, {\n    get: function(target, key, receiver) {\n        console.log(`getting ${key}`)\n        return Reflect.get(target, key, receiver)\n    },\n    set: function(target, key, value, receiver) {\n        console.log(`setting ${key}`)\n        return Reflect.set(target, key, value, receiver)\n    }\n})\n\n// 对比 Object.defineProperty\nlet object = {},\n    value\n\nObject.defineProperty(object, 'value', {\n    get: function() {\n        console.log('getting value')\n        return value\n    },\n    set: function(newValue) {\n        value = newValue\n        console.log('setting: ' + newValue)\n    },\n    enumerable: true,\n    configurable: true\n})\n```\n\n### 14. Reflect\nReflect 对象的设计目的有以下几个：\n\n第一，将 Object 对象的一些明显属于语言内部的方法（如 Object.defineProperty）放到 Reflect 对象上，现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来新的方法只在 Reflect 对象上部署。也就是说，从 Reflect 对象上可以获得语言内部的方法。\n\n第二，修改某些 Object 方法的返回结果，让其变得更加合理。\n\n第三，让 Object 操作都编程函数行为，某些 Object 操作是命令式，比如 name in obj 和 delete obj [name]，而 Reflect.has(obj, name) 和 Reflect.deleteProperty(obj, name) 让它们变成了函数行为。\n\n第四，Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法，这就是 Proxy 对象可以方便的调用对应的 Reflect 方法来完成默认行为，作为修改行为的基础。也就是说，无论 Proxy 怎么修改默认行为，我们总可以在 Reflect 上获取到默认行为。\n\n## 三、ES7+\n2016 年，ECMAScript 7（或称为 ECMAScript 2016） 正式发布，整体来说，在 ES6 的版本逐渐稳定后，后期版本添加的主要内容已经不是太多了。\n\n### 1. Array.prototype.includes\n这个数组方法主要用来判断数组中是否包含某个元素\n```js\nlet num = [1, 2, 3, 4, 5]\n\nconsole.log(num.includes(1))  // true\n```\n\n### 2. 异步函数 async/await\nasync 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\n\n#### 基本用法\n```js\nfunction timeout(ms) {\n    return new Promise(resolve => {\n        setTimeout(resolve, ms)\n    })\n}\n\nasync function asyncPrint(value, ms) {\n    await timeout(ms)\n    console.log(value)\n}\n\nasyncPrint('Hello', 300)\n```\n\n\nasync 函数返回一个 Promise 对象，async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数：\n```js\nasync function f() {\n    return 'Hello'\n}\nf().then(v => console.log(v))  // 'Hello'\n```\n\n\nasync 函数内部抛出错误会导致返回的 Promise 对象变成 rejected 状态，抛出的错误对象会被 catch 方法回调函数接受到：\n```js\nasync function f() {\n    throw new Error('出错了')\n}\n\nf().then(\n    v => console.log(v),\n    e => console.log(1+e)\n)   // ‘1Error: 出错了’\n```\n正常情况下，await 命令后面是一个 Promise 对象，如果不是，会被转为一个立即 resolve 的 Promise 对象。\n\nawait 命令后面的 Promise 对象如果变成 rejected 状态，则 reject 的参数会被 catch 方法的回调函数接收到。\n\n只要一个 await 语句后面的 Promise 变成 rejected，那么整个 async 函数都会被中断执行。\n\n#### 注意\nawait 命令后面的 Promise 对象的运行结果可能是 rejected，最好把 await 命令放在 try...catch 中。\n\n多个 await 命令后面的异步操作如果不存在继发关系，最好让它们同时触发。\n\nawait 命令只能用在 async 函数中，如果用在普通函数中就会报错。\n\n\n### 3. Object.values()\n\n### 4. Object.entries()\n```js\nconst exampleObj = {a: 1, b: 2, c: 3, d:4};\nconsole.log(Object.entries(exampleObj));\n// [[\"a\", 1], [\"b\", 2], [\"c\", 3], [\"d\", 4]];\n\n// Usually used with for\nfor (const [key, value] of Object.entries(exampleObj)) {\n  console.log(`key: ${key}, value: ${value}`);\n}\n// key: a, value: 1\n// key: b, value: 2\n// key: c, value: 3\n// key: d, value: 4\n```\n\n### 5. Array.prototype.flat() & Array.prototype.flatMap()\n```js\nconst arr2 = [1, 2, [3, 4, [5, 6]]];\narr2.flat(); // [1, 2, 3, 4, [5, 6]]\narr2.flat(2); // [1, 2, 3, 4, 5, 6]\n\n\nlet arr = [\"早安\", \"\", \"今天天氣不錯\"]\narr.map(s => s.split(''))\n// [[\"早\", \"安\"], [\"\"], [\"今\", \"天\", \"天\", \"氣\", \"不\", \"錯\"]]\n\narr.flatMap(s => s.split(''));\n// [\"早\", \"安\", \"\", \"今\", \"天\", \"天\", \"氣\", \"不\", \"錯\"]\n\n```\n\n### 6. Promise.allSettled()\n\n### 7. 可选链接？\n```js\nconst username = user?.info?.name;\n\nconst username = user?.name || 'guest';\n```\n\n### 8. 循环等待\n```js\n// 符合预期 (如果你想连续执行await调用，请使用for循环(或任何没有回调的循环)。)\nasync function process(array) {\n  for (const i of array) {\n    await doSomething(i);\n  }\n}\n\n// 不符合预期 (永远不要和forEach一起使用await，而是使用for循环(或任何没有回调的循环)。)\nasync function process(array) {\n  array.forEach(async i => {\n    await doSomething(i);\n  });\n}\n```\n\n\n\nES9 增加了异步迭代器，允许 await 与 for of 循环一起使用，逐步执行异步操作。\n```js\nasync function process(array) {\n  for await (const i of array) {\n    doSomething(i);\n  }\n}\n```\n\n<br/>\n[文章来源](https://zhuanlan.zhihu.com/p/531959101)","tags":["ES5","ES6","ES7"]},{"title":"即兴表达","url":"/2022/10/09/即兴表达/","content":"\n## 第一篇，即兴表达的基本素质养成\n### 1、三思三定\n即兴表达并不意味着漫无目的地呈现你的观点，想要成就一次成功的即兴表达，势必先思考清楚即兴表达的目的、内容及如何组织内容，即从三个角度来确定你所要表达的内容。这个过程我们将其简称为“三思三定”\n#### 一 “思”：即兴表达的目的是什么？\n即兴表达的第一步，就是要想清楚，你所要实现的目的是什么，并且这一目的一定得是基于对方的，这样才会对表达产生积极正面的效果。\n\n#### 二 “思”：基于确定的目的，对方需要知道哪些内容？\n假设你的目的是“让上司批准这个项目的预算”。基于这个目的，就需要找到领导所关注的点。需要让上司知道的内容有三点：\n\n1．这个项目能给公司带来哪些好处？\n\n2．与同行的其他公司相比，我们公司做这个项目有多紧迫？\n\n3．如果拿到预算，你会如何花这些钱、如何监控财务？\n\n无论你遇到的即兴表达有无明确的主题，在任何一次即兴演讲之前，一定要先基于对方的角度，思考你要实现的目的。目的明确后，内容往往也会鱼贯而出，与目的珠联璧合了。\n\n#### 三 “思”：在这次即兴表达中，你想传达出一种什么样的感觉？\n比如，你想表达出一种急迫、气愤、惋惜、激动或是真诚的感觉。\n\n#### 三定：定话题、定观点、定框架\n定话题，即对应“三思”中的目的，基于目的，就确定了即兴表达的话题。\n\n定观点，即对应“三思”中的内容，将对方需要了解的内容概括成观点。\n\n定框架，即确定观点的排列顺序，即使内容是一样的，排列顺序不同，表达的效果也会有所不同。\n\n\n#### 重点\n**没有目的就不要去探讨内容，目的比内容更重要**\n\n\n### 2、绿灯思维：让你成为受欢迎的表达者\n#### 何为绿灯思维？\n所谓“事实”，即当下发生的事情的客观情况；而“故事情节”，指的则是每一个人对这个事实的演绎。实际上，在许多场景中，我们所表达的并不是事实，而是我们对事实的演绎。\n\n人们所演绎的故事情节又分为两种：当所演绎的故事情节让我们离目标越来越近，那就是绿灯思维；但如果所演绎的故事情节让我们不知不觉地离目标越来越远，便是红灯思维。\n\n#### 绿灯思维和红灯思维案例\n1. 情境1：针对同一事实的观点表达\n  1. 事实：三年前学习的技术，今天已经过时了。 如果你想表达的目的是：“希望我们能跟上社会的节奏。”\n  2. 红灯思维：社会变化太快了，所以再怎么学也会被淘汰。\n  3. 绿灯思维：社会变化太快了，所以我们不仅要学习，而且要学得快。\n\n2. 情境2：针对他人做法的观点表达。\n  1. 事实：假设你有一个同事老王，他这个月迟到了三次。 如果你想表达的目的是：“期望老王未来可以守时，尽量不要迟到。”\n  2. 红灯思维：唉呀！老王的时间观念越来越差了，开会一直都不准点！\n  3. 绿灯思维：老王最近有些变化，可能是我们对他的关注不太够，我觉得接下来我们要多关注一下他。\n\n3. 情境3：针对对方需求的观点表达。\n  1. 事实：假设你给客户写好几版方案，每完成一版方案，客户总会变动和修改。在这一案例中，客户的需求随时在改变，这是一种事实。\n  2. 红灯思维：“所以嘛，方案不用写得太完整，说不定明天客户的需求又改变了！”实际上，这一句话对于方案的推进无济于事。\n  3. 绿灯思维：写方案前要深入探求客户的需求，帮客户想清楚，这样我们写的方案可能会更有效。\n\n#### 重点\n**而具备绿灯思维的重要的前提条件就是：你看到了一个现象、一个事实，你必须在一瞬间反应出自己所期望达成的目标是什么。**\n\n\n### 3、同频思维：让你成为受信赖的倾听者\n你除了清晰、准确、精辟地表达出自己的观点，更重要的是要在别人表达观点时，认真地去倾听，让对方感受到你对他的尊重。只有这样，对方才能更有耐心地倾听你的表达，更容易去理解、认同你，你才会成为一个更值得对方信赖的人。\n\n正如我们经常听到一种批评：“你说得太多了。”但我们从未听过一种批评：“你听得太多了。”\n\n因此，学会去倾听，也是即兴表达中一项重要的技能。\n\n\n#### 第一个层面：身体的倾听\n因此，真正的沟通高手，一定会有意识地观察并小幅度地模仿对方的某些动作。对方拿起杯子喝水时，他们也会下意识地拿起杯子喝一口；对方朝门口看了一眼，他们也会顺着对方的目光方向望一下；对方停顿了，他们也会自然地放慢语速。这种由肢体语言传达出来的同频率的感觉，正是理性倾听和感性倾听的基础\n\n\n#### 第二个层面：理性的倾听\n理性倾听又叫思维倾听，想要呈现出思维上的倾听，需要掌握一个重要的小技巧——回应对方的最后一句话。\n\n需要注意的是，回应对方的最后一句话，并不是鹦鹉学舌，而是在一些特别的时刻，比如对方在说重要的事情或是说得特别陶醉的时候，见缝插针地回应对方的最后一句话。\n\n#### 第三个层面：感性的倾听\n感性倾听，即我们通常提到的共情。对于对方所表达的内容，我们需要展现出一点点的共情力。\n\n例如日常沟通中把孩子内心那一刻的想法说出来，会让孩子觉得原来爸爸是懂他的。而这个“懂”的层面，不仅仅是思维层面上的“懂”，更是对他的感性层面的“懂”，而这也是倾听的最高境界，会迅速赢得对方的好感。\n\n**如果给“感性倾听”换个比较专业的说法，这就叫“翻译对方的感受”。**\n\n### 表达心法：从业余到高手的三个阶段\n#### 一、好奇阶段：萌发兴趣，逐步构建信心\n好奇心和信心是开始任何一项学习的前提条件。\n如同挑选孩子兴趣班的第一个老师，往往不挑最厉害的，而要挑最有趣的。\n#### 二、孤独阶段：坚持并忍受枯燥的练习\n只有耐得住寂寞，忍得了枯燥，才能真正沉下心来，做好一件事。\n\n#### 三、刻意练习阶段：掌握正确方法\n“一万个小时的锤炼是任何人从平凡者变成世界级大师的必要条件。”这就是广为流传的“一万小时定律”。\n\n但并不是所有人只要付出一万个小时就都能成为高手。如果只是重复地、机械式地练习，一万个小时顶多能让你变成个熟练工。真正的高手，一定是善用模型，进行有目的且刻意的练习，这样才能实现真正的蜕变。\n\n#### 即兴表达3句心法\n##### 第一句：“表达是一门遗憾的艺术。”\n再优秀的即兴表达高手，都难免会在表达过后留有遗憾。所以，无须纠结与自责，而应把这一次的遗憾当作下一次进步的开始，不断滋养自己的信心，完成高手进阶的第一阶段。\n\n在学习和练习的过程中，如果碰到困难，要有效地做好自己的心理建设。\n##### 第二句：“没有高级的技巧，只有基础的技能。”\n在成为表达高手的路上，要的是扎实，而不是讨巧。耐得住孤独\n\n职业选手和业余选手最大的区别是：职业选手能把最基础的技能练到炉火纯青；而业余选手往往在技能还不夯实时，就急于学习更多看似高级的技巧。\n\n尽管基础的技能总是简单的，但一定要练到极致，才能让技能长在你的身体里。\n\n##### 第三句：“高手都在学习套路，而新手都在寻找捷径。”\n**刻意练习=大量的套路+有意为之+及时反馈。**\n\n《刻意练习》这本书改变了许多人对于练习的看法。练习并不是简单地重复，而是要总结出套路，并针对套路有意为之，然后寻求及时的反馈。\n\n课后练习比听课更重要，刻意的练习比纯粹的练习更重要。\n## 第二篇，即兴表达思维训练\n### 1、观点提炼法：让表达不在滥竽充数\n#### 什么是观点？\n1. 观察事情时所处的立场和出发点；\n2. 从一定的利益出发所形成的的对事物活问题的看法。\n\n#### 观点的分类\n##### 一类是真理型观点\n类似于“太阳每天东升西落”。 没有人会不认同，但也不会对听众产生影响。\n##### 二是思考型观点\n思考型观点是带有自己立场和见解的，虽然观点不一定正确，但是抛出后却能引发听众的兴趣，便于展开讨论。\n\n**要放下追求观点完全正确的执念。观点就是用来质疑和讨论的，这才是它的生命力所在。**\n\n#### 如何提炼观点（以滥竽充数的典故来分析）？\n##### 思路一：多立场分析\n如果从南郭处士的主人公角度分析，没有真才实学，混得过一时，却混不过一世，从而提炼出的观点是“要有真本事，不能滥竽充数”。\n\n但站在国王的角度，可以反思一个问题，之所以有这样的庸人存在，是因为群体演奏时，责任是共担的，激励是平均的，机制有漏洞才让庸人有机可乘。因此，从管理者的角度进行分析，我们可以提炼出这样的观点：“在管理中，要多质疑机制，少质疑人，才可能解决根本的问题。”\n##### 思路二：逆出发点分析\n继续以“滥竽充数”为例，我们默认的出发点是这种行为不可取，但假设我们对出发点做个逆向思考——如果这个典故是值得学习的，那它有没有值得学习的地方呢？\n\n仔细分析，不难发现南郭处士善于寻找机会缺口，无论是进入还是退出，他都能准确判断，迅速行动。因此，我们可以提炼出这样一个观点：“时代总在变化，你不要试图占据全阶段的红利，懂得放弃和懂得把握同样重要。”\n\n##### 思路三：条件假设推理分析\n比如，“南郭处士是靠蒙混过关混进去的”是原始前提，但增加一个新的条件项，假设他进入乐队后十分努力，主动向大师学习，没过多久，他也成了奏乐高手。至此，我们便可以提炼出一个新的观点：“成功，有时候是因为能力，但最初可能是因为勇气。”\n\n可见，增加一个假设条件，整个推理就完全不同了。\n\n#### 评价一个观点好坏的标准\n* 一、一个好的观点往往不能立即被认同，更不能被所有人认同；\n* 二、一个好的观点，会让人想多了解一些、多问一些；\n* 三、一个好的观点往往挑战了默认的前提假设；\n* 四、一个好的观点，可以引出一系列新的问题。\n\n### 2、数学思维法：让观点更有生命力\n#### 一、一维、二维和多维观点\n一维观点：管理者只有具备较强的统筹能力，才不会让自己身陷琐事而不能自拔”。这就是典型的一维观点。一维观点通常用来表达一个高度概念化的东西，上述句子就可以浓缩为一个概念——“统筹”。\n\n二维观点：管理者除了要具有较强的沟通能力，还要具有抽象化的能力，这样才不会总是陷于烦琐的事务之中”。这句话就属于典型的二维观点，包含“沟通”和“抽象化”两个要素。\n\n在即兴表达中，表达者更多呈现的是二维观点，因为二维观点既不会显得过于单一，亦不会造成受众理解的困难，更重要的是具有讨论和辨证的空间。\n\n#### 二、以数轴框架图呈现二维观点\n##### 数轴框架1：时间管理要分轻重缓急\n\n##### 数轴框架2：幸福就是既懂得享受现在，又会规划未来\n<img src=\"/img/jxyj1.jpeg\" style=\"max-width:95%\" />\n\n##### 数轴框架3：真正的学习者，既有丰富的知识储备，又会运用思维进行思考\n\n#### 三、以公式呈现多维观点\n一旦你要表达的观点包含三个或三个以上的要素，就不要奢望用语言就能清晰地描述各要素间的逻辑顺序与主次关系。表达多维观点的诀窍是：尝试用公式来进行表达。\n\n人生成就=思维方式×热情×能力。并且对这三项要素进行了分数界定，思维方式是-100～100分，热情和能力是0～100分。这样，就可以让受众清晰地感知三个要素之间的逻辑顺序和主次关系了。\n\n管理能力=（沟通能力+抽象化能力）×人际关系。这样，就清楚明了地呈现出人际关系对于沟通能力和抽象化能力的放大作用。\n\n通常，当各要素之间具有正相关性时，就会运用“乘”和“加”；当各要素之间具有负相关性时，就会运用“减”和“除”，当然“除”一般用得不多。\n\n> **总之，在即兴表达输出观点时，运用数学思维可以帮助我们理清思路，清晰呈现观点。\n具体而言，一是运用数轴框架图，来清晰表达二维观点；二是运用公式表达法，来呈现多维观点中各要素的逻辑顺序和主次关系。**\n### 3、散点联想法：让你学会借题发挥\n#### 借物发挥\n一个气球之所以可以飞得起来，不在于它的外观有多漂亮，也不在于它的形状和颜色，而在于气球里面充的是什么气体。一个再漂亮的气球，如果里面充的不是氢气，它也不会飞起来。其实，家庭也一样。\n\n一个家庭是否美满幸福并不在于房子有多大，车子有多豪华，而在于家庭内部是否有着和谐的气氛。如同一个气球，它能飞得起来在于里面充的气体，而不在于气球的外观。\n\n所以，我觉得家庭幸福应该着重于内在的家庭氛围。\n#### 借人发挥\n借人与借物有个区别：借物时，你完全可以凭借你的才情，对一个事情进行任何的诠释，毕竟你在诠释一个物时，只需要考虑如何自圆其说便好；而借人发挥时，你却不能擅自对他人做定论，否则多少会带着妄评别人的嫌疑。\n\n大家更喜欢的表达，是以小见大型，不是以大见大型。\n#### 借势发挥\n\n#### 借景发挥\n\n### 4、扩句成篇法：让你永不担心词穷\n#### 一、举例法\n1. 情境1：表扬和赞美时\n\n上司夸赞下属：“小王，昨天你对客户的服务特别细心。”在大多数场景中，我们对对方的表扬大都点到为止，当对方满怀期待地想听你继续说点什么时，你却在此处戛然而止。不妨举个具体的例子：“小王，你的细心真的让我刮目相看，昨天那件事情，如果是我，可能不会想到，要在那个关键时候给客户递一张纸。”\n\n2. 发表观点时。\n在发表观点时，我们经常陷入干巴巴的窘境，话说得并无问题，但却只是道理的拼凑和堆砌，听众很容易走神。如何解决这个问题呢？给你分享一个小妙招：说出三个字——“我记得…… 用例子来说明”\n#### 二、金字塔思维\n所谓“金字塔思维”，即表达时先说处于金字塔尖的结论，再逐级向下展开金字塔的各个层级，说明支撑结论的各个小论点以及论据。\n<img src=\"/img/jxyj2.jpeg\" style=\"max-width:95%\" />\n\n1. 情境1：即兴演讲。\n人生处处是考场。（结论）\n\n在家庭中，你的父母、配偶就是你最直接的考官。（论点1）\n\n在职场中，上司每天都在对你进行无声的观察。（论点2）\n\n在社交场合中，哪怕你参加的只是朋友的一个聚会，你的表现也会在别人心中留下印象分。（论点3）\n\n因此，人生处处是考场。甚至人生的考场比学生的考场更为严格，因为学生考场上的考官是大家看得见的，但人生中的考官却是看不见又无处不在的。（总结陈述）\n\n2. 情境2：会议发言。\n\n#### 三、重新定义法\n在日常表达场景中，大家都会更喜欢说话有深度、观点新颖的人。做到说话有深度，其实并不是一件很难的事情，只要掌握一个技巧——重新定义法。重新定义法具体分为两种：\n\n一是重新定义关键词。\n\n二是重新定义规则。\n\n从讨论“对错”的跑道，换到讨论“动机”的跑道。比如，本来大家在讨论一个观点的对错，有人突然说了一句：“我觉得这个观点的对错并不重要。重要的是，我们要清楚这个观点产生的动机是什么。”\n\n##### 情境1：发表见解时。\n有人把起跑线理解成孩子的能力，所以总用这句话对付孩子，今天要求他学这，明天要求他学那，而作为父母的自己呢，却不怎么长进。\n\n我觉得孩子的起跑线就是父母。所以我想，以后，我们能不能多用这句话来要求一下自己：为了不让孩子输在起跑线上，我们多看点书，多争取一点机会。一位有见识的父母，也许更能培养一位有见识的孩子。\n\n以上这段发言，也许并非真理，但观点的可辩性，才是观点的生命力。\n\n\n孤独是什么？孤独是每一个人都会有的一种体验，即使你经历过万众瞩目的时刻，即使你功成名就，但在夜深人静时或者某一个不为人知的时刻，难免会感受到一种深深的孤独。\n\n那真正的智慧是什么呢？真正的智慧是学会向内看，而非局限于繁忙而嘈杂的外界。\n\n当你学会与孤独相处的时候，其实你就比别人获得了更多向内看的机会，这就是我为什么说学会与孤独相处也是一种智慧。\n##### 情境2：规避不必要的风险。\n举个例子，“是否支持女性自主中止妊娠的权利”在美国一直都是热门的议题，几乎所有政治人物都被要求表态，无论支持哪一方，都会失去另外一边的选票。如果你既想回应大众，又不想得罪立场不同的选民，就需要重新定义的思维了。\n\n重新定义，不是纯粹的耍滑头，而是辨证地、充分地、角度全面地表达出自己的观点。\n#### 四、对比法\n金钱有时候会成为罪恶的帮凶，当然我并不是告诉你金钱是罪恶的，我们会发现其实钱不是万能的，但事实上没有钱却万万不能，所以我从来没有说金钱本身就是罪恶，我只是说它有可能成为罪恶的帮凶。\n\n\n### 5、逆向思维法：让你令人印象深刻\n按照以往的经验，在成年人之间的交流中，最容易让人印象深刻的往往就是故事中的冲突点。因此，一个故事中一定要有冲突，比如行为上、价值观上、观点上的冲突等，最后还要有某些人因为这个冲突发生了某些转变。没有冲突的故事，充其量只是一件平铺直叙的事情而已。\n\n所谓逆向思维，即提出与当下的主流思想部分或者完全相反的观点。\n\n逆向思维，带来的不仅是看待事物的不同角度，更会让人拥有更为广阔的想象空间。\n\n实际上，当你提出相反观点的那一刻，无须去验证观点的对错，就已经给别人留下深刻的颠覆性印象，让别人期待跌宕起伏的思想碰撞了。\n\n例如：老板要感恩员工（主流思想都任务员工要感恩老板，因为老板提供了就业岗位）。不要觉得你是一个企业的老板，这个企业要是没有了员工，就什么也不是。平台成就了员工，员工也成就了平台，最终才成就了老板\n\n#### 第一种：完全逆向思维\n对\"纸上谈兵\"进行完全逆向思维\n\n各位，我觉得“纸上谈兵”其实也是有好处的，一个人要先学会“纸上谈兵”，才能去“沙场点兵”。（抛出逆向思维的观点）\n\n为什么“纸上谈兵”也是有好处的呢？因为“纸上谈兵”让我们学会了分析，让我们不必以试错的代价去替代分析！如果不做分析，直接到战场上去试错，试错的代价很可能是我们所想不到甚至无力承受的。\n\n所以一个管理者、一个策划者一定要先学会“纸上谈兵”，去周密地计划，以最小的成本和代价去发现错误、纠正错误、规避掉错误，然后再去“沙场点兵”。\n\n所以我的建议是大家不要讨厌“纸上谈兵”，不要总觉得它是个贬义词，我们甚至要有意识地培养自己“纸上谈兵”的能力！（证明观点的成立）\n\n#### 第二种：颠倒顺序的逆向思维\n比如，大家都听过“选择大于努力”这句话，颠倒一下前后顺序，就变成了“努力大于选择”。如果你讲大家耳熟能详的句子，换种顺序表达出相反的意思，自然会让受众产生耳目一新的感觉。\n\n我想和大家分享一个观点，“努力大于选择”。当然我并不是想告诉别人不用选择，也不是想告诉别人努力可以决定一切。（对比法，排除歧义）\n\n比如，一个人大学刚毕业的前两三年会觉得“选择大于努力”，因为这个时候他对各个行业都不太了解，需要有些经历才能做出最好的选择。因此，在大学毕业前两三年的确是“选择大于努力”，选择一个好的公司、选择一个好的上司、选择一份好的职业会对人生产生重大的影响，避免少走弯路！\n\n可是一个人如果毕业了五年，甚至十年，依然相信“选择大于努力”，那么他这辈子很可能永远在忙于选择，却没有为选择付出过真正的努力，最终很可能一事无成！\n\n所以，这件事情要分时间而定！我认为一个人毕业后的前两三年，“选择大于努力”是对的，但当一个人毕业了五年之后、十年之后，我想他更应该相信“努力大于选择”。（金字塔法，分论点证明总论点）\n\n**在以上这段表达中，在证明你的观点时，其实并不需要让别人百分之百地信服，而是要让受众感受到，你所提出的这种可能性是存在的。这也会令人印象深刻，引发对方的进一步思考。**\n\n#### 总结\n逆向思维具体有两种，第一种是完全逆向思维，可以给对方带来颠覆性的思想体验；第二种是颠倒顺序的逆向思维，可以在原有的角度之外，找到更多令人意想不到的角度。\n\n逆向思维并不是让你去反驳别人，去站在对方的对立面，而是去发现一些新的观点和新的角度。要记住，逆向思维永远只是手段，手段永远服务于目标！逆向思维可以帮助你更好地实现表达的目标。如果你只是想运用逆向思维去展现自己的与众不同，便是误入了逆向思维的歧途。因为，真正的沟通表达高手，是不会让自己成为一个事事与别人针锋相对的人的。\n\n## 第三篇，即兴表达的结构\n### 标题和开场\n甲说，“针对这件事情，我来谈一谈吧”；乙说，“接下来，我来说几句吧”。如果轮到你时，你是以这样的方式开场，“针对这件事情，我想谈一个词语”。这个词语就是你即兴表达的标题，再借由这一词语展开，是不是瞬间给人带来耳目一新的感觉？\n\n当别人都觉得即兴表达不需要标题，但你却为即兴表达赋予一个标题，就会引起大家足够的注意力和兴趣。\n\n#### 技巧一：数字法\n比如，针对“一个人如何进行创新型思考”这一即兴话题，我分享的主题是“三胡一无”，即胡说八道、胡思乱想、胡言乱语以及无中生有。像这样把你想讲的主题以数字概括出来，这就叫数字法。\n\n#### 技巧二：谐音法\n“‘胜者为王’这一词语，想必大家并不陌生，但我今天与大家分享的主题‘剩者为王’，不是胜利的‘胜’，而是剩余的‘剩’，只有最后剩下来、坚持到最后的人才可能成为王。”\n\n#### 技巧三：对比法\n比如，针对“自律才是最大的自由”这一主题，“自律”和“自由”即是对比；再如，“利他才是最好的利己”这一主题，“利他”和“利己”即形成对比；又如，主题“其实严肃也是一种爱”，即把“严肃”和“爱”以对比的方式联系了起来。对比法，会在标题内部形成一种形象上的张力，容易抓住受众的注意力\n\n### 问题讨论型的结构\n问题—原因—解决方案。如果遵循这一结构进行表达，具体可分为三个步骤。\n\n第一步：将问题阐述一遍，明确界定责任。 最重要的是正视问题，而非为自己辩解；\n\n第二步：分析产生问题的原因。切记永远不要摆出一副自己很无辜的样子；\n\n第三步：给予解决方案。 解决方案切记不可超过三条，并且最好是说出就立马可以做到的，这样会让对方觉得他的问题被重视了。\n\n\n问题和错误并不可怕，只要你活学活用“问题—原因—解决方案”这一表达结构，将问题和错误进行适当且合理的处理，就能借此获得别人更多的信任。\n\n### 演讲发表型的结构\n**演讲发表型的表达结构为：钩子—要点—论证结构体—呼吁行动。**\n\n钩子，即用一句话让对方对你接下来的表达充满期待，把人们的注意力吸引过来。\n\n要点，即用一句话概括你接下来所表达内容的要点，言简意赅。\n\n论证结构体，即举例论证上述要点的正确性，需要注意的是，例子不要超过三个。\n\n呼吁行动，即用一句话发出邀请，请对方参与进来。\n\n#### 情境一：演讲动员\n我非常期待看到你们这一次的表现。（钩子）\n\n这是我们与这个客户建立关系的绝佳机会，而且也是建立行业影响力的机会。（要点）\n\n这一次他们总经理会在，而且据我了解，他会全程参与整个会议。同时，这次会议还邀请了他们的供应商和兄弟公司一起参加。（论证结构体）\n\n所以我希望这一次我们精诚协作，帮我们的好产品拿下市场。（呼吁行动）\n\n#### 情境一：代表发言\n我参加我家孩子的幼儿园毕业典礼比参加我自己的大学毕业典礼更激动。（钩子）\n\n我觉得今天的典礼意味着我们的下一代已经优秀地完成了融入社会的第一课。（要点）\n\n这里有几件小事，想和大家分享一下。第一件事是我家孩子有一次错拿了小朋友的玩具，第二天不仅主动将玩具还给了小朋友，还给小朋友带了几颗糖果表达歉意。我觉得这代表他学会了和朋友相处。第二件事是我家孩子经常对我说：“老师很辛苦，老师特别地疼他们。”我觉得这代表孩子们学会了感恩。第三件事是我们的孩子学会了集体生活。（论证结构体）\n\n当然，今天我们的孩子毕业了，幼儿园毕业代表他们完成了人生的第一步。我希望我们在座的所有家长，今后依然可以继续保持交流。我们家长之间要保持交流，我们和老师之间也要保持交流，所有的老师都是我们孩子的启蒙老师。（呼吁行动）\n\n#### 情境三：项目汇报\n\n我相信今天在座的领导对这个项目都非常感兴趣。（钩子）\n\n我想告诉在座领导一个好消息，这个项目的进展非常顺利！（要点）\n\n我们不仅在项目中跟供应商保持了很好的关系，也与上游的资源、下游的资源保持了很好的关系。同时，我们在项目中极大地提升了团队的协作能力。（论证结构体）\n\n接下来我们会再接再厉，也希望在座的领导能够继续支持我们。（呼吁行动）\n\n#### 情境四：总结陈述\n我完全同意今天会议上所达成的所有共识。（钩子）\n\n我们需要进一步加强合作。（要点）\n\n我们要从以下几个方面继续深化我们的合作……（论证结构体）\n\n所以，我想从明天开始，我们可以立即着手做……（呼吁行动）\n\n#### 情境五：获奖感言\n今天这个奖我领得特别开心，当然也有一点点小小的惭愧。（钩子）\n\n因为我团队的所有成员才是成功最核心的因素。（要点）\n\n虽然我们的团队很小，但是我们的团队很有凝聚力，这是第一。我们的团队内部大家能够互相帮忙、互相支持、互相理解、互相补位，这是第二。（论证结构体）\n\n我希望这个奖，能带给我们团队进一步的鞭策力量。接下来我们也愿意跟其他团队一起合作，把我们的公司带到一个新的高度。（呼吁行动）\n\n#### 总结\n第一步：拟一句开场语作为钩子，吸引人们的注意力。\n\n第二步：概括要点，呈现出表达的核心内容。\n\n第三步：举出几个例子，形成论证结构体，来论证要点。\n\n第四步：呈现下一步的行动与计划，呼吁行动\n\n### 正式仪式型的结构\n比如，职场工作中，公司的产品发布会、颁奖会、联欢会、客户答谢会以及同事离职时的告别会；日常生活中，亲朋好友的婚礼、同学聚会、孩子的毕业典礼、家庭聚餐等\n\n感谢，即感谢当下的人或者事，比如感谢主持人的邀请、感谢主办方的邀请以及感谢今天在座的各位，需要注意要兼顾现场的不同群体。\n\n总分总回顾，即针对某一个主题，回顾一下过去发生的事情，注意此时要去讲故事，而不是去讲事情，回顾时需要运用总分总这一结构，即大结构中嵌套着小结构。\n\n愿景，即针对今天的主题对于在座的人表达一下你的祝贺、祝愿以及你对未来的畅想等。\n\n**所以感谢聚焦的是现在，回顾谈的就是过去，而愿景指的就是未来，这样就形成了一个完整的时间线结构。**\n\n#### 情境一、同学聚会\n非常感谢大家给我这个发言的机会，当然也要感谢我们的班长以及几位热心的老同学组织了这一场活动，如果没有他们，我们今天根本没有机会重逢。（感谢）\n\n20年过去了，我们在自己的工作和生活上都有了巨大的变化，但同学之间的感情还是一样淳朴。今天早上我们在校园参观的时候，我想起了很多往事……（回顾）\n\n祝愿同学们身体健康，不管我们的事业怎么样，我想健康很重要，希望再过20年，我们还能够有机会再相聚。（愿景）\n\n#### 情境二：朋友婚礼\n感谢婚礼主持人给我一个发言的机会，当然也要感谢我的好兄弟以及美丽的新娘。（感谢）\n\n我跟小陈认识有十五年的时间了，有些时候跟朋友在一起没有话说会显得很尴尬，可是我和小陈，即使我们不说话在一起坐一个下午，也不会觉得有任何的尴尬。因为任何时候你和他在一起，都会觉得很安心，他是一个让别人觉得特别靠谱的人。（回顾之总述）\n\n比如有次…… 还有一次……（回顾之分述）\n\n所以，我觉得能做他的朋友真的很幸运，我相信我们的新娘子天天跟这样靠谱的人在一起，一定也会觉得特别开心。（回顾之总述）\n\n最后祝福我的兄弟新婚快乐、百年好合、早生贵子，也祝福在座的所有亲朋好友幸福快乐！（愿景）\n\n#### 总结\n第一步：感谢。具体可以按照“过去—现在—未来”时间线结构，依次对过去出现过的、今天到场的、未来可能出现的人或事物表示感谢；或运用正反结构，对帮助过我的人表示感谢，甚至，对过去伤害过我的人也表示感谢。\n\n第二步：总分总回顾。注意在列举具体的例子时，切忌平铺直叙，而要用故事的冲突和转折给人们留下更深的印象。\n\n第三步：愿景。表达出良好的愿望，从而烘托出氛围、制造出感觉。\n\n\n### 总结和结尾的结构\n即兴表达的结尾和主题演讲的结尾是截然不同的。主题演讲的结尾可以将主题升华到一定的高度，去号召、去呼吁。但这种方式对于即兴表达的场景显然是不适用的，即兴表达有着自己的结尾方式。\n\n#### 方式一：感谢总结作为结尾\n泛泛的感谢是无效的，只有尽可能具体的感谢才能让对方印象深刻。\n\n一是行为上的感谢。\n\n二是观点上的感谢\n\n三是去感谢那些容易被忽视的人\n\n#### 方式二：概括总结作为结尾\n一是理性概括\n\n\n二是感性概括。\n你在一段讲话的结尾可以这样说：“如果用一个颜色来形容我今天的感受，我觉得这个颜色是绿色。绿色带给人希望，而且绿色是生长和发展的象征。今天的活动刷新了我的很多认知，让我感觉成长了许多。”\n\n#### 方式三：留下活口作为结尾\n为了下次会谈做好铺垫，留下口子\n#### 方式四：以金句或者俗语作为结尾\n\n## 第四篇，即兴表达的场景应用\n###  即兴演讲：黄金三圈让表达直击人心\n\n<img src=\"/img/jxbd1.jpeg\" style=\"max-width:95%\" />\n\n最外圈：what，即“是什么”。\n\n中间圈：how，即“如何做”。\n\n最里圈：why，即“为什么”“意义是什么”。\n\n在日常生活中，大部分人都会清楚自己在做什么，即“what”；其中，会有一部分更厉害的人，经常思考如何把正在做的事情做得更好，这就进入到了“how”的层面；但只有很少一部分的人，会经常质询自己，我为什么要做这件事，我做这件事的意义是什么，继而上升至“why”的层次。\n\n一般我们在表达时，习惯由外向内表达——先说外层的what，再说中层的how，但很少涉及内层的why。因为外层的what最显而易见，表达者说得轻松，受众也容易接受。\n\n我观察了几乎所有的演讲高手，仔细研究后发现，他们都有一个共同点——表达时按照与惯例相反的方式进行，由内向外进行表达，即先说内层的why，再说中层的how，最后说外层的what。\n\n\n比如，一个普通的销售人员即兴介绍一款最新一代的苹果手机，一般会按照由外向内的逻辑，这样进行介绍：\n\n这是我们最新一代的苹果手机，双摄像头，玻璃背板，全屏显示。（what）\n\n这款手机设计精美，界面友好，系统流畅，使用简单。（how）\n\n……（why或是不说why）\n\n\n再来看看，乔布斯在新品发布会上，是如何介绍最新一代的苹果手机的：\n\n我们存在的价值，就是改变这个世界，为了突破和创新，我们永远在用不同的方式思考，我们要改变普通人的生活。（why）\n\n我们觉得一个好的产品要设计精美，界面友好，极致简单。（how）\n\n这就是我们最新的iPhone。（what）\n\n#### 人的三层脑（由内向外）\n##### 一、爬虫类脑，也叫本能脑\n这一层大脑的进化已经超过一亿年，它毫无情感，只为了生命最原始的意义——生存。因此，它的主要功能就是逃跑和战斗，并负责一些本能生存动作，如睡眠、呼吸。\n\n遇到紧急情况时，爬虫类脑的第一反应就是跑或躲，因为它要保证生命尽可能地延续。可见，在紧急情况下，爬虫类脑掌握着行为的第一指挥权，也正是因为这样，有些人特别容易在紧急状态下失去理智。\n\n##### 二、哺乳类脑，也叫边缘系统\n哺乳类脑是行为和决策中心，负责感知情感、意义和价值，爱、恨、情、仇都集中在这一区域，对应why的层面。比如，哺乳类动物会养育下一代，就是因为哺乳类脑的情感因素。\n\n\n##### 三、最新的大脑——大脑皮层，也叫新皮质\n这一层的大脑还在不断进化，是神经元细胞最密集的地方。该区域负责人类的智力，理性、图形、语言、逻辑思考全由它掌控。这一层大脑让我们理解了“这个世界是什么样的？”“世界的本源是什么？”“我们从哪里来？”等诸多问题，并为此做出界定与回答。\n\n#### 从内向外打动人\n客户皱着眉头沉默了好久，思考后才说：“你的数据和逻辑都对，方案我也理解了。但我总觉得没有足够打动我，似乎缺了点什么，但缺什么我也说不上来。”\n\n但当你了解了人脑的构造机制，了解了三层脑的理论后，就会发现，客户之所以会觉得你的方案欠缺点什么，是因为你没有由内而外地打动他负责行为决策的中心——掌管情感的哺乳类脑。这也正是演讲高手会先表达why的原因，首要的是去触动受众的情绪和情感。\n\n教育孩子也可以使用这一套路。父母会要求孩子做什么或是不要做什么，但通常并不奏效，因为这只涉及了what的层面；更有效的说服方式是告诉孩子做与不做背后的原因，只有表达出why的深层次原因，才能触及孩子的内心。\n\n### 讲述故事：汉堡原则让听众欲罢不能\n故事是人类文明发展的重要推动力。教育的基础、宗教的基础，都来源于一个又一个故事。学会讲一个好故事，以及讲好一个故事，一直都是一项重要的能力。\n\n**讲的是不是一个好故事，这是价值观层面的选择，因为不同的人对好故事的判断不同。但能不能讲好一个故事，就是一种技能的表现了。**\n\n\n讲故事首先需要引发听众的兴趣，这实质上是要调动起听众大脑的兴趣。\n\n#### 人的大脑有一个特征——适应性反应，包括倦怠反应和知觉整体性\n##### 1．倦怠反应\n最浅显的感受，就是如果你一直盯着某一个字看，时间久了，就会觉得这个字怪怪的，仿佛是从来没见过的错别字，而且盯得越久，陌生感越强烈，这就是倦怠反应的具体表现。\n##### 2．知觉整体性\n人会根据自己的知识经验，习惯性地对刺激物进行加工处理，让知觉保持完备，这就是知觉整体性。**大脑尤其需要这种整体性，一旦面对有所缺失的东西，它就会非常难受。**\n\n只要抓住了事物的特点和关键部分，不管人物的比例是否正确、线条粗细如何，都会让人一眼就看出画的是什么，因为观者大脑会自动将有缺漏的细节补上。\n\n那么如何利用大脑的这一特性来引发听众的兴趣呢？\n\n但是，当缺口很大时，你想把这个缺口补齐的欲望反而没那么强烈了，因为补齐这么大的缺口需要调用太多的大脑资源了。\n\n因此，让大脑有兴趣的基本逻辑就是千万不要给大脑留下一大片的无知区域，而要留下最重要的一个小“坑”，让大脑被这个小“坑”调动起来。\n\n#### 汉堡原则\n运用汉堡原则讲述故事的具体方法是，先讲述上面的一片面包，再讲述下面的一片面包，留出中间最想抖出的那块肉，便形成一个“坑”了。这类似于作文里的倒叙手法，但不是一开始就倒叙，而是先讲开头，讲到关键环节暂停，然后再倒叙。关键点是留出中间最精彩的部分，即你最想让对方参与思考的部分，便能成功引起对方的兴趣了。\n\n在汉堡原则中，《狼来了》这个故事应该有三层。\n\n第一层——面包：\n\n一个村庄的后山上，经常有狼出没。所以村民们一致约定，有危险就求救，大家都要上去帮忙。这是一群善良又朴实的村民，每一次，他们都能齐心协力把狼赶跑。\n\n第二层——面包：\n\n放羊娃有一天放羊的时候，狼一下子闯进了羊群。放羊娃害怕极了，拼命地向村民们喊：“狼来了！狼来了！快救命呀！狼来了！”可是，大家都不理睬他，没有人去帮他，结果，放羊娃的许多羊都被狼咬死了。\n\n上下两层面包分别对应前置情境与后置结果，两者之间有落差、有对比，就形成了冲突。一个故事一定要有冲突。原版《狼来了》的故事，只是按照第一次、第二次、第三次的顺序发展来讲述故事，缺少了冲突，因而故事呈现的张力不够。但你作为讲故事的人，要学会在这个故事中设计出冲突。\n\n\n### 高质量提问：喂养机会，饿死问题\n人们的思维模式就会陷入“向问题要答案”的惯性之中。\n\n但是，这个时代出现的新变化，让我们有必要反思一下这种思维惯性。\n\n1．信息太多，知识存量在不断变大。一个人即使学到博士阶段，所学的知识也不能用一辈子。\n\n2．搜索工具发达，人们找到答案的速度和质量，会因为技术的智能化而不断趋于同一水平。\n\n3．越是确定的答案，越容易被快速变化的环境所挑战。因为每一个答案，本质上都是基于过去的经验。\n\n**即兴表达中，会提问将成为比找到答案更可贵的能力。只有真正学会了、学懂了，才能提出高质量的问题。**\n\n\n我也尝试对“好问题”总结出三点自己的想法：\n\n1．一个好问题不能被立即回答，但能激发人们前进；\n\n2．一个好问题与能否得到正确答案无关；\n\n3．一个好问题处于已知和未知的边缘。\n\n\n#### 错误的提问\n老张，为什么你没有按计划实现目标？\n\n为什么桌子这么乱？\n\n事情为什么会这样？\n\n谁该为此事负责？\n\n通常在出现问题时，我们总是习惯问why或who。面对问题，我们首先想到的是分析问题，找出原因。而分析原因，最直接的提问方式就是why。\n\n可是，在现实的工作和生活中，问题和原因并不是单一对应的，我们习惯性地问why或who，常常得到一堆看似原因的回应。实质上，当你问why时，面对追责，对方大脑的第一反应不是找到真实的原因，而是做好自我保护。言下之意，人们会回答一个让自己受伤最小的答案，而并非真实的答案。\n\n上文罗列的四个问题都是错的问题，因为这些问题都在引导别人回想过去。因此，提问的正确方式是“没有问题，只有机会；没有过去，只有未来”，即多问how和what，少问why或who。这是一个有别于我们过去习惯的表达套路。\n#### 正确的提问\n老张，接下来我们可以做些什么，才能更快地赶上进度？\n\n下节课开始，我们如何分工可以让桌子更整齐呢？\n\n事已至此，接下来我们可以如何改善呢？\n\n下一次，我们该如何规避这类失误呢？\n\n从得到一堆的理由和借口，变成得到一堆的方法和可能性。问对问题，才可能得到你要的答案。先不论得到的这些方法是否有效，至少因为你问的这个问题，大家思考的方向就完全不同了。\n\n总之，提问是一种越来越值钱的能力，而最高效的提问法则是：没有问题，只有机会；没有过去，只有未来。当然，提问并不仅限于这个方法，但这却是使用频率最高的一种。\n\n\n###  表扬与批评：转变方式让对方易于接受\n#### 表扬和鼓励区别\n我们真正应该做的不是表扬，而是鼓励。\n\n所谓鼓励，就是夸奖别人的努力用功，从而给对方一种可以掌握自我的感觉。如果事情的结果取决于自己的努力，那么成败就掌握在自己的手中。实验中，被夸奖“努力”的那一组学生，所接受的就是鼓励。\n\n何为表扬？就是夸奖别人的聪明和天赋，但成功不由自己掌控。如果面对失败，他们就会觉得是因为自己不够聪明，很可能会直接放弃，因为人没有办法给自己增加天赋。而且，他们以后都不太会选择有难度的挑战，生怕失败了被人认为自己不够聪明。\n\n**简言之，鼓励通常针对态度和过程，而表扬通常针对结果和成效。**\n\n#### 鼓励案例\n\n大部分家长一般都会说“宝宝真棒”“宝宝长大了”“宝宝真厉害”，并匹配一些拥抱、亲吻的动作。但上述的表达都是评价，**我们需要做到的是“多描述，少评价”，对应的表达模型是：行为+感受+评价。**\n\n宝宝看到爸爸/妈妈下班回来，主动给爸爸/妈妈端水。（描述具体行为）\n\n爸爸/妈妈好开心。（描述感受）\n\n宝宝真棒。（针对行为进行评价）\n\n同时，“行为+感受+评价”这一表达模型，不仅适用于夸奖，也适用于批评。比如，批评孩子时，家长可以这样进行表达：\n\n刚刚爸爸/妈妈在跟叔叔聊天，你在边上一直吵，还打了叔叔一下。（行为）\n\n爸爸/妈妈真的有点生气了。（感受）\n\n我觉得你今天的表现不太好。（评价）\n\n描述行为是我们经常忽视，却十分有效的。你所描述的行为越具体，代表你对这件事、某些具体行为了解得越多，对方更能感受到你对他的关注。\n\n心理学中有一句话：“人性中最深刻的本能就是对被欣赏的渴望。”而欣赏，并不等于泛泛地表扬。我们之前做了太多泛泛的表扬，是时候转变表达方式了。\n\n总之，表扬和鼓励对别人的影响是不同的，要去“多鼓励，少表扬；多描述，少评价”。\n\n具体运用“行为+感受+评价”这一表达模型，无论是即兴的表扬还是批评，都能说到对方的心坎里去，对对方产生更为积极正面的影响。\n\n\n### 不满与异议：四个步骤缓解冲突和矛盾\n过去的工作效率来源于明确分工，今天的工作效率来源于协同合作。\n\n**面对质疑和冲突的核心原则是可以质疑事情，但不能质疑动机。**\n\n**非暴力沟通解决分歧和矛盾，这里分享给大家一个行之有效的表达模型： “事实 +感受 + 需求 + 请求”，每一个词对应一个步骤。**\n\n#### 第一步：事实\n“小王总是迟到。”这不是事实。\n\n“小王这周迟到四次了。”这是事实。\n\n所以，总结一下，事实就是，一不含形容词，二不可争辩。\n\n之所以要强调以事实开场，是因为大量的实践发现，每一次冲突的成功应对，都是以安全感为前提的。一旦让对方觉得焦虑、紧张，觉得被夸大、被误会，对方就会陷入争辩的怪圈。\n\n#### 第二步：感受\n比如：“我觉得我的字写得不好看。”这是一种评价，而不是感受。\n\n再如：“我觉得自己被打扰了”或“我觉得自己被拒绝了”，但这里的动词——“打扰”和“拒绝”，也不是感受，而是想法。\n\n表达感受的语句应该是：“我觉得被打扰了，所以我很烦躁。”“烦躁”才是确定的感受。\n\n一个人要有意识地建立起自己的感受词汇表，这是即兴表达很重要的一部分。表达需求得到满足的感受的词语有：欣慰、高兴、兴奋、满足、陶醉、幸福；表达需求没有得到满足的感受的词语有：担心、忐忑、焦虑、生气、灰心、绝望等。\n\n#### 第三步：需求\n表达需求时，不要总说“我也是为你好”，这是最没有力量的一句话，而是要表达出自己最真实的需求，且这一需求最好能凸显对方的重要性。\n\n“我很需要你早点回家，否则我一个人特别害怕，我们刚搬到这个小区，边上的邻居我一个也不认识。”这既是真实的需求，也凸显了对方的重要性。\n#### 第四步：请求\n请求一定要具体、明确，正如一句话所说：“你希望别人拉你一把，那也得告诉别人，你的手在哪。”明确的请求，就是在告诉别人：“我的手在这儿。”\n\n#### 总结\n一是以事实为着力点，不要妄加评论。诸如“你工作态度不好”“你不尊重我”等，这些都是对人的评价，而不是对事实的描述。\n\n二是以人为着力点，明确你对对方的需求与请求。不要让对方觉得自己被误解了，也不要让对方摸不着头脑，而是去具体、明确地表达出自己的需求。\n\n\n### 吸引眼球高手：吸引眼球四诀让表达一击即中\n表达是双向的，尤其在即兴表达中。你想把自己的观点、立场短时间传递给受众，就需要站在受众的角度，明确受众的诉求。**一般情况下，受众都具有四个共性。**\n\n#### 受众四个特性\n##### 第一，受众怕麻烦，不喜欢复杂的东西\n不要总想把观点表达得面面俱到，就算你讲得条理分明，受众也不一定记得住。一般在陈述中，要点尽量不要超过三点，以减少受众接受信息的压力。\n\n##### 第二，受众一定只喜欢与自己相匹配的东西\n有句话说得好：“与己有关，我才关注。”因此即兴表达的内容和观点，一定是与受众密切相关的，甚至让对方觉得你就是为他而说的。\n\n##### 第三，受众的认同带有一定的功利性\n在即兴表达时，最好将受众能得到的利益显性化地呈现出来，以满足受众追逐功利的心理。\n\n##### 第四，受众总有攀比之心\n一个对比的例子远胜一段理性的分析。\n\n#### 四个特性总结\n上述四个共性可以概括为“四化原则”：**复杂的问题简单化，简单的问题通俗化，通俗的问题利益化，利益的问题案例化。**\n\n第一句：简单来说……  （这句话一定要简单，突出受众的匹配点即可，不可贪多求全。）\n\n第二句：它特别适合像你这样…… （这句话要赞扬对方，所以你要能迅速地提炼出对方身上的闪光点，甚至让对方觉得这个产品就是为他定制的，进而凸显他的身份。）\n\n第三句：你有了它之后…… （这句话就对应利益化，让对方感受到用这个产品对他的好处。而且这个好处要和第一句话的产品特征关联起来，即用好处来证明特质的真实性。）\n\n第四句：举个例子来说…… （如果是举人的例子，最好能举一些比对方身份高一点点的人，因为人都有攀比之心。当然，别高太多，离对方太远的人往往激不起他的攀比心。）\n\n\n#### 例子\n##### A、你想通过即兴表达将保温杯销售给对方\n第一句：“简单来说，这是一个时尚又轻便的保温杯。”\n\n第二句：“它特别适合像您这样经常出差又新潮的高端商务人士。”\n\n第三句：“您有了它之后，手拿保温杯也不会降低您的时尚感，还不用担心增加行李重量。”\n\n第四句：“举个例子来说，上回我去拜访××公司，我发现柯总总随身携带这款杯子。”\n\n##### B、假设你是公司的中层干部，要为领导推荐一位新的区域总监\n第一句：“简单来说，小方是一位很有市场开拓能力，而且区域资源丰富的市场攻坚型人才。”\n\n第二句：“我觉得他特别适合战略市场的开拓，尤其对于新区域市场，虽然我们产品本身有一定优势，但市场需要从零开始。”\n\n第三句：“如果能把他吸引过来，相信不管是在市场团队内部管理上，还是外部开拓上，他都能很好地把握节奏。”\n\n第四句：“举例子来说，他在上一家公司，也是一家上市企业，刚开始负责的就是当时东南亚市场的开拓，短短三个季度，就创下竞争对手两年的营业额。”\n\n\n## 第五篇，即兴表达总结\n### 三要三不要\n#### 三要\n1. 第一个“要”：要以终为始。\n   以终为始，即在任何一次表达开始时，将表达所要达到的终点提前设置好。\n\n2. 第二个“要”：在表达中要学会接受并示弱。\n   一个真正成熟且自信的表达者，并不见得每一次都要在别人面前展现出无所不知、无所不能的一面，这样并不一定会给对方留下好印象。真正让对方感到舒服的不是展现出自己的厉害，而是呈现出自己的真实。\n\n3. 第三个“要”：表达要逻辑清晰，观点鲜明。\n   一个真正会说话的人，并不在于话的多少，而是在于观点是否精要、意思是否明了。\n\n<br />\n\n一要以终为始，这是目的；\n\n二要接受并学会示弱，这是姿态；\n\n三要逻辑清楚，观点鲜明，这是结构。\n\n#### 三不要\n**第一个“不要”：尽量不要使用否定词。**\n\n**第二个“不要”：不要打断别人说话。**\n\n**第三个“不要”：不要诿过于人。**\n所谓“诿过于人”，即在向别人提出要求时，为了显示不是自己在为难对方，往往会搬出另一个人，把责任推给他，无论这个人是真实的还是假设的。\n\n如果管理者总是把自己的想法推诿给领导：“我也不想扣你的钱，但领导说了必须得扣”“我也不想让你们加班，大家都很辛苦，但没办法，公司要求了”。实际上，这种做法只有一个结果：慢慢地让你在听众当中失去威信。因此，切记不可将为难的事情推诿给别人。\n\n### 刻意练习\n在学习过程中，切不可贪多求全，与其一下子把每个模型都运用起来，不如先针对性地练习某一种模型，再连接到不同的场景之中。当这种连接的熟练度越来越强时，你会发现练好一招胜过你会好多招。要学会把纷繁复杂的案例归纳为模式场景，总结成套路和模型，继而举一反三延展开来，并适用于多种场景。\n\n\n#### 一、确定目标，不断改进\n#### 二、训练必须专注\n\n#### 三、有及时的反馈\n\n#### 四、必须跳出舒适区\n你在进行即兴表达的练习时，起初可能会有点不太习惯。以前的表达是不假思索、脱口而出，现在却要按照套路去进行表达，而且还可能运用得不太熟练，自己都会感觉别扭。但这种别扭、麻烦的感觉，正是跳出舒适区的感觉，是成长必经的一步。\n\n","tags":["即兴表达","表达目的、内容、结构","个人成长"]},{"title":"研发效能总结","url":"/2022/09/14/研发效能总结/","content":"\n## 技术人的核心价值\n### 1、不同公司的研发核心价值\n1. 外包公司：最核心的价值不是技术，而是快速响应、资源调配、项目成本控制；\n2. **企业信息化公司：**\n   1. 第一层运用技术更好的支撑业务\n   2. 第二层用技术推动业务，用自身的业务经验服务和帮助客户\n   3. 第三层用经验积累去影响行业\n3. 解决特定场景和问题的产品公司：核心价值在于技术，专注做技术深度\n\n\n### 2、我们的核心价值是什么\n1. 一、有质量高效交付业务\n     1. 交付业务：阶段性与业务对齐产品目标\n     2. 质量和高效：用数据说明安全高效的交付需求\n2. 二、用技术影响行业， 需要持续的积累和思考\n3. 三、建技术壁垒和技术基建，确保系统稳定，业务健康和持久发展\n\n## 如何提高研发效能\n### 1、研发的流程效能：拆分阶段、发现关键问题阶段、提出方案\n1. **1）需求阶段**\n   1. 问题：需求反复、需求不清楚、需求争议\n   2. 解决方案：\n     1. 确保需求的有效期，明确业务价值和需求范围，并确保需求理解的一致性；\n     2. 需求内容，先小范围内沟通对焦；等需求讨论清晰，再拉落地相关同学参与；\n     3. 需求有争议时，为避免反复，拉上相关同学一起对焦；\n     4. 日常需求，定期排期、通晒。\n\n2. **2）研发阶段：在后面的研发的生产效能说明**\n\n3. **3）联调和测试阶段**\n    1. 问题：联调效率低、环境不可用、提测代码质量低\n    2. 解决方案：\n      1. 前后端分离，各自具备Mock的能力；\n      2. 日常环境治理，降级系统服务的依赖，确保测试环境问题；\n      3. 基准测试用例，冒烟测试，自动化脚本测试，确保提测质量。\n\n\n4. **4）上线阶段**\n   1. 问题：发布频率高、定位问题耗时、部署系统时长\n   2. 解决问题：\n     1. 对同一时间的发布系统做适当合并；\n     2. 与业务约定发布频率，控制发布周期；\n     3. 系统依赖治理，缩短部署时长；\n     4. 针对排查问题耗时，提供相应的问题排查工具。\n\n### 2、研发的生产效能\n#### 1）全链路技术规范\n<img src=\"/img/eff1.png\" height = \"auto\" width=\"90%\" />\n\n每一个过程，通过规范文档统一标准，并通过宣传和考试的方式，让大家都熟知内容。并通过典型案例通晒，强化规范内容的价值。\n\n#### 2）全链路业务可配置\n1. 页面可配置\n2. 逻辑可配置\n3. 服务&流程可配置\n\n#### 3）统一横向支撑工具\n拉通团队内部共性的支撑工具，共建一份。比如excel批量导入导出，审批流，通知工具等。\n\n#### 4）非功能性代码\n1. 应用脚手架：一键生成应用工程\n2. 代码规范的模板：错误码模板、日志模板、工程结构等\n3. 中间件\n4. 通用工具类\n5. 业务标准拦截：用户登录、服务异常、基础埋点\n6. 稳定性：限流\n\n#### 5）部署交付：部署手册指导；统一的问题排查工具\n\n#### 6）接口文档化：web层统一遵循swagger规范等\n\n#### 7）系统协作的清晰边界\n我们在落地过程中，往往会存在系统调用，系统依赖等问题，建议在启动初期，把这些关键问题定义出来，然后寻找TL或pm协调解决。\n\n\n### 3、研发的协作效能\n通过流程规范和模板，约定大家的协作模式\n#### 1）日常答疑的协作流程\n#### 2）项目过程管理\n<img src=\"/img/eff2.png\" height = \"auto\" width=\"90%\" />\n\n#### 3）日常需求排期\n1. 约定需求排期周期，固定时间，并沟通需求通过协作管理工具；\n2. 后续可通过协作管理工具，分析统计数据。\n\n### 4、研发的人员效能\n####  1）学习与培训\n1. 通过持续的学习，或借力其他团队的方式，提升技术水平；\n2. 通过沉淀团队规范，文档，案例等方案，让大家补齐知识；\n3. 通过复盘总结，沉淀典型案例，内部分享，避免重复采坑。\n   \n####  2）检查和考试\n\n## 研发效能衡量关键指标\n1. 需求交付周期，需求交付数量\n2. 代码提交量\n3. 测试阶段bug数量\n4. 线上故障和事故\n\n\n<br >\n[文章来源于](https://mp.weixin.qq.com/s/rg-NHLYljH8e6OWZpHtfmg)","tags":["个人成长","研发效能","研发流程"]},{"title":"思维的框架和方法论的学习","url":"/2022/08/07/思维的框架和方法论的学习/","content":"\n## 1、构建思维体系\n<img src=\"/img/mind1.png\" height=\"auto\" width=\"90%\" />\n\n思维方法论和思维能力框架体系构建应该包括四个方面的关键内容。其中事物认知和问题解决式思维的两条核心主线。但是思维活动本身是围绕学习，实践和复盘展开的。**学习是思维的基础，实践是思维的应用，复盘是个人思维能力的升华。**\n\n> 什么是思维？\n1. 事物认知\n2. 学习能力\n3. 解决问题\n4. 复盘能力\n\n### 1.1、学习实践复盘闭环逻辑\n<img src=\"/img/mind2.png\" height=\"auto\" width=\"90%\" />\n\n1. 第一层内循环：关键实践过程，通过事物认知归纳方法，通过方法演绎去解决问题\n2. 第二次外循环：构建学习、实践和复盘的完整闭环。 通过学习构建知识库，通过实践复盘讲知识库转化为经验模式库\n\n\n## 2、学习方法和模式\n<img src=\"/img/mind3.png\" height=\"auto\" width=\"90%\" />\n\n1. 形成知识概念： 不求甚解 ---> 学习枝干重点\n2. 知识体系化\n3. 突破关键临界点，量变到质变\n\n### 2.1、形成知识概念\n<img src=\"/img/mind4.png\" height=\"auto\" width=\"90%\" />\n\n\n### 2.2、知识体系\n<img src=\"/img/mind5.png\" height=\"auto\" width=\"90%\" />\n\n### 2.3、突破关键点\n<img src=\"/img/mind6.png\" height=\"auto\" width=\"90%\" />\n\n### 2.4、知识的广度和深度\n<img src=\"/img/mind7.png\" height=\"auto\" width=\"90%\" />\n\n沙堆模型：去海滩堆沙堆，想堆的高（深度）基座必须足够宽（宽度）\n\n\n## 3、知识库和经验模式\n### 3.1、学习实践到知识库\n<img src=\"/img/mind8.png\" height=\"auto\" width=\"90%\" />\n\n### 3.2、知识库形成经验模式\n<img src=\"/img/mind9.png\" height=\"auto\" width=\"90%\" />\n\n\n## 4、思维框架和逻辑\n<img src=\"/img/mind10.png\" height=\"auto\" width=\"90%\" />\n\n1. 主线一：事物的认知和评价\n2. 主线二：问题的分析和解决\n\n### 4.1、匹配模式\n<img src=\"/img/mind11.png\" height=\"auto\" width=\"90%\" />\n\n### 4.2、锻炼复杂模式匹配能力\n<img src=\"/img/mind12.png\" height=\"auto\" width=\"90%\" />\n*d：定义， r:解决*\n\n### 4.3.1、事物认知和分析\n<img src=\"/img/mind13.png\" height=\"auto\" width=\"90%\" />\n\n### 4.3.2、构建动静结合的分析方法\n<img src=\"/img/mind14.png\" height=\"auto\" width=\"90%\" />\n\n### 4.3.3、事物认知维度模型\n<img src=\"/img/mind15.png\" height=\"auto\" width=\"90%\" />\n\n### 4.3.4、单事物认知--分解\n<img src=\"/img/mind16.png\" height=\"auto\" width=\"90%\" />\n\n### 4.3.5、事物群认知--分类和抽象\n<img src=\"/img/mind17.png\" height=\"auto\" width=\"90%\" />\n\n### 4.4.1、问题分析解决通用模型\n<img src=\"/img/mind18.png\" height=\"auto\" width=\"90%\" />\n\n### 4.4.2、问题分析和解决--HOW类\n<img src=\"/img/mind19.png\" height=\"auto\" width=\"90%\" />\n\n### 4.4.2、问题分析和解决--HHERE类\n<img src=\"/img/mind20.png\" height=\"auto\" width=\"90%\" />\n\n## 5、总结和复盘\n<img src=\"/img/mind21.png\" height=\"auto\" width=\"90%\" />\n\n## 6、基于场景的思维选择过程\n<img src=\"/img/mind22.png\" height=\"auto\" width=\"90%\" />\n\n\n<br />\n[文章来源](https://mp.weixin.qq.com/s/ehpf9sy3TYWMWjZirkJT-g#rd)","tags":["思维框架和逻辑","学习方法论和模式","问题的分析解决","事物认知","知识库构建和方法论"]},{"title":"亚马逊逆向工作法读后感","url":"/2022/08/06/亚马逊逆向工作法读后感/","content":"\n# 上篇 亚马逊工作法\n## 1、构件：领导力准则和机制\n### 亚马逊领导力准则\n1. a. 客户至上：领导者从客户的角度出发，再逆向工作。领导者要努力赢得并维系客户的信任。领导者会关注竞争对手，但更注重客户；\n2. b. 主人翁意识：领导者是主人翁。领导者会考虑长远，不会为了短期业绩而牺牲长期价值。领导者代表整个公司行事，而不仅仅代表自己的团队。领导者绝不会说“这不是我的工作”；\n3. c. 创新和简化：领导者期望并要求自己的团队进行发明和创新，随时寻求简化的方法。领导者关注外部环境，从各处寻找新的创意，不会受“非我发明”的局限。领导者愿意为创新而可能被长期误解\n4. d、决策正确：领导者拥有卓越的判断力和敏锐的直觉。领导者寻求多种角度，努力证明自己的想法是错误的。\n5. e、好学好奇：领导者从不停止学习，永远寻求自我提升。领导者对新的可能性充满好奇，并付诸行动加以探索\n6. f、选贤育能：领导者要培养领导者，认真对待自己辅导人才的职责。领导者要为员工着想，努力创建“职业选择计划”（Career Choice）等员工发展机制。\n7. g、坚持最高标准：。领导者要不断地提高标准，激励自己的团队提供优质的产品、服务和流程。领导者要确保问题不会蔓延，彻底解决问题并确保不再发生。\n8. h、远见卓识：领导者要提出并传递能产生结果的大胆方向。领导者要换个角度思考，广泛寻求服务客户的方式。\n9. i、崇尚行动：速度对业务至关重要。决策和行动很多都是可逆的，不需要过度研究。领导者要注重有计划地冒险。\n10. j、勤俭节约：力求少投入、多产出。条件限制可以让人开动脑筋、自给自足、不断创新。增加人力、预算和固定开支并不能带来额外加分。\n11. k、赢得信任：领导者要用心倾听，坦诚交流，尊重他人。领导者要敢于自我批评，即使这样做会让自己尴尬或难堪。领导者要不迷恋自己或团队身上的香水味。\n12. l、刨根问底：领导者要深入各个环节，随时掌控细节，经常进行数据审核，在数据和客户故事（客户体验）不一致时要提出质疑。领导者要不遗漏任何工作。\n13. m、敢于谏言、服从大局：领导者不会为了保持团队和气而选择妥协。一旦做出决策，领导者就要全力以赴。\n14. n、达成业绩：领导者要关注业务的核心投入类指标，并按时保质达成业绩。即使遭遇挫折，也要迎难而上，绝不妥协。\n\n### 机制：强化领导力准则\n**只有良好的意愿没用，建立机制才有用。**”没有哪家公司依靠“我们必须加倍努力”“下次要记住……”等良好的意愿就能改进流程、解决问题或修正错误。**其原因在于，问题的产生不是因为缺乏良好的意愿。亚马逊早就意识到：如果不改变引发问题的基础条件，问题迟早会出现，甚至多次出现。**\n\n亚马逊的领导者会不遗余力地关注执行细节，不断地践行“刨根问底”这一领导力准则：“领导者要深入各个环节，随时掌控细节，经常进行数据审核，在数据和客户故事（客户体验）不一致时要提出质疑。领导者要不遗漏任何工作。”\n## 2、招聘：亚马逊独特的抬杆者流程\n所有公司碰到的问题，很多亚马逊也都碰到过。其不同之处在于，亚马逊想出了创新的、带来显著竞争优势的解决办法。亚马逊的招聘方法就是如此，抬杆者招聘流程是亚马逊最成功、可扩展、可复制、可传授的管理方法之一。\n\n### 个人偏见与紧急招聘的影响\n人们会本能地结交与自己具有相似之处的人。人们天生就喜欢录用那些与自己具有相似之处的人：教育背景、工作经历、职能专长和生活经历。这种做法显然存在问题：一、这些表面的相似之处通常与工作的业绩毫无关系；二、这种招聘往往会促使员工同质化，视野更加狭窄。\n\n紧迫性可以带来好处，因为我们会专注于那些必要的事情。但对于招聘而言（正如我们所见的莉娅和她的团队），紧迫性会催生急迫感，因而会让人走捷径，忽略必要的步骤，造成灾难性的后果。\n\n\n成功的招聘还有一大阻力：缺乏结构化的流程和培训。虽然不少知名公司也存在这个问题，但初创公司和成长型公司特别容易毫无流程地招新。一个刚任职两周的经理，可能就要马上招到10个人来组建新团队。\n\n\n随着员工数量的急剧增加，公司的创建者和早期员工往往会感到自己正在对公司失去控制——公司不再是创立之初的模样。他们回头看，意识到问题的根本原因是缺乏招聘流程或招聘流程不够清楚。他们招聘的那些人，不是体现、强化或提升公司文化，而是在改变公司的文化。\n\n### 抬杆者招聘流程\n对于高速发展的公司来说，只有良好的意愿是无法解决招聘问题的。但是，机制可以解决问题；不管公司如何发展壮大，都要保持一贯的招聘标准。\n\n亚马逊抬杆者计划的目标，是为高效而成功的招聘决策设立**可扩展、可复制的结构化流程**。同所有好的流程一样，**它也易于理解，易于传授给新人，不依赖稀缺资源（比如某个人），具有确保持续改进的反馈回路。**\n\n优秀的面试官凭借敏锐的直觉就能预判谁会成为出色的新员工，还能够克服面试过程中出现的认知偏误。但依赖几个优秀面试官的问题在于：**它不可扩展，很难传授。**他们的那些特质不具有普遍性，因此缺乏结构化的框架，就无法确保每个参与者都知道如何进行出色的面试工作。亚马逊抬杆者流程的设计目的，就是提供这种框架，最大限度地降低招聘程序的随意性，增强招聘效果。\n\n**抬杆者具体流程：**\n1. 职位描述\n2. 简历筛选\n3. 电话面试\n   * 有时候，招聘经理对候选人没有把握，也会邀请他参加轮番面试，希望这样做有助于录用决定。这种做法是错误的。大多数时候，那些“可疑”的候选人都不会被录用，而大量时间已经因此被浪费掉了。电话面试后，如果招聘经理不倾向于录用候选人，就不应该让他参加耗时费钱的轮番面试。\n4. 现场面试\n   1. a.行为面试： \n      1. **“当时是什么状况？” --> “你的任务是什么？” --> “你采取了什么行动？” --> “结果如何？”**\n      2. **“如果你被指派去做的是别的项目，而不是X项目，那X项目会有什么不同？”“X项目最艰难的抉择是什么？是谁做出的这个抉择？”**\n   2. b.抬杆者\n      1. 抬杆者会参与所有的轮番面试，确保面试流程规范，杜绝错误的录用决定。他们还要在面试过程中为其他面试官树立良好的榜样。除了完成一轮面试，抬杆者还要做的工作有：辅导其他人掌握面试技巧，在面试汇报会上提出追问性问题，确保个人偏见不会影响录用决定，决定候选人是否达到或超出公司设定的录用标准。\n      2. 招聘经理的最佳做法，是倾听、了解、偶尔发言。这种流程设计，是为了防止紧迫性和偏误对录用决定产生负面影响，以免造成时间浪费和长期痛苦。\n\n5. 书面反馈\n6. 汇报／录用会议\n   1. 每位面试官都读完所有面试反馈和评价后，就增加了四倍的信息来做决定。有了这些新增资料，他们可能会确认初步投票的结果，也可能改变投票决定。两种结果都是有效而适当的，基于新增资料改变投票决定，这没有什么可羞愧的。\n   \n7. 背景调查\n8. 录用通知\n   1. 招聘经理应该亲自发出录用通知，并向候选人推销该职位和公司。你选择了候选人，但并不意味着候选人会选择你。你必须假定：优秀的员工，其他公司（包括他现在的雇主）也会努力“追求”，随时都有失去这位候选人的风险。在他报到入职之前，一切都存在变数。\n\n\n**抬杆者招聘流程的设计目的，是最大限度地消除个人偏见，同时使招聘决策是最大化地基于数据、候选人的工作内容及其工作与领导力准则的匹配程度做出的。**\n\n\n## 3、组织：独立单线程领导模式\n### 背景\n随着我们建立新团队，负责新的产品类别、区域和职能（比如，消费电子产品和平面设计），亚马逊的组织架构也在不断地膨胀。如果公司的规模较小，只需要简单问问就能获得帮助或知晓冲突所在，因此彼此非常熟悉。而在大公司，同样的任务则会变得耗时费力。你必须弄清楚该找谁谈、他的办公室在哪里、他向谁负责。也许你可以自己搞清楚，但通常你得询问你的上司，而他又得询问他的上司或同级——每个步骤都要花时间。听取你汇报、给你调配项目资源的那个人（或他的上司）关系着你是否成功。通常，他同时在为自己的项目做着同样的事情。他绝不愿为了你而影响他的项目进展。为了某个项目，你通常得跑几次，而且往往都无功而返。\n\n**公司将解决某个问题的任务交给团队并根据结果进行评价，那这个团队就应该获得完成这个任务所需的工具和权力。**\n\n### 加强协调是错误的答案\n要解决依赖问题，通常需要协调和沟通。依赖性在不断地增强，沟通需求也在日益增加，自然就希望通过加强沟通来加快工作的进展。这些跨团队沟通方法，需要的根本不是改进——而是废除\n\n**通过api来解决团队沟通：如果我们想让亚马逊变成创建者能够创建的地方，就需要废除跨团队沟通，而不是鼓励沟通。如果你将提高跨团队沟通的效率视为一种“缺陷”，那弥补缺陷的方法就完全不同于传统的方法。他建议每个软件团队都给自己拥有的系统／服务创建应用程序接口（API）。我们要重点通过定义清晰的API进行“松散耦合”的机器交互，而不是通过电子邮件和会议进行人际交流。这样做，所有团队都将获得自由，都可以自主地行动，加速前进。**\n\n\n### 组织依赖早期解决方案\n#### 2个披萨饼团队\n团队的规模不应超过两个比萨就可喂饱的人数， 一般是10个以内。\n#### 拆解一体化组织（类似微服务）\n如果多个团队直接接入共享代码块或数据库的某个部分，他们都会慢下来。不管是改变代码的运行方式、改变数据的组织方式，还是只是使用共享代码或数据创建某个东西，只要有人做出改变，大家都会承担风险。应对这种风险，需要投入大量的时间进行协调。解决办法就是封装数据，也就是说，将某个代码块或数据库的某个部分的所有权交给某个团队。其他人想从该封闭区域获取东西，都必须通过应用程序接口（API）提交证据充分的服务请求。\n\n可以把它想象为一家餐馆。感到饥饿时，你不是直接进入餐馆的厨房点自己想吃的东西，而是请求服务员给你菜单，然后从中选择菜品。如果你想吃的东西不在菜单上，你可以询问服务员，他会把你的请求告诉厨师。不过，不能保证你能获得它。只要信息交流方式没有改变，该封闭区域内发生的一切，都完全取决于厨房的所有者——厨师团队。如果需要做出改变，所有者就会发布修改规则——新菜单——并通知所有依赖该规则的人。\n\n### 单线程领导者\n预测团队成功的最大因素，不是团队的规模是否较小，而是团队的领导者是否具有组建和管理一个专注于完成工作目标的团队的技能、威望和经验。\n\n选择了“单线程”这个计算机术语。其含义是：每次只做一件事情。\n## 4、沟通：叙述体与六页纸备忘录\n亚马逊主要采用两种叙述体文本：第一种叫作“六页纸备忘录”（six-pager），用于阐述、评议和提出各种想法、流程或业务；第二种叙述体文本是“新闻稿／常见问题”（PR/FAQ），专门用于新产品开发的“逆向工作”流程。\n\n### 停用ppt背景\n线性推进的幻灯片不太适合这种分析：幻灯片很难让人相互参考想法；文字稀少，无法充分地表达想法；视觉效果与其说给人启发，不如说让人分心。PPT没有让事情变得清楚而简单。相反，它会使讨论缺乏重要的细微差别。我们开会时，即使陈述者给出了注释、视频等支撑信息，PPT陈述也远远不能充分表达。\n\n采用PPT的真正风险，是它会影响决策：即使想法不怎么样，善于表达的陈述者也可以引领团队同意；结构混乱的陈述会让人困惑，因而讨论会变得杂乱无章、缺乏重点，本来很好的想法未能得到认真考虑；单调、乏味的陈述会麻木听众的大脑，他们会走神或开始查看电子邮件，因而错失潜藏于单调的说话声和平淡的图片之中的好想法。\n\n分析越具有因果性、多变量、比较性、证据支撑性，信息的密度越高，PPT的害处就越大。\n\n陈述者的临场表现或个人魅力有时候会无意中遮蔽关键的问题或疑虑，切换图片也会让人分散注意力。**最重要的是，我们发现，即使PPT用得再好，其传达信息的完整性和复杂度也不及叙述体备忘录。**\n\n### 如何写高效的“六页纸备忘录”\n**我们的信条：最重要的是想法，而不是陈述者**\n\n根据塔夫特的估计，人们的阅读速度要比陈述者的说话速度快三倍。也就是说，在相同的时间内，他们阅读叙述体文本所获得的信息，要比听PPT陈述多得多。因此，叙述体文本可以在更短的时间内传达更多的信息。\n\n陈述者的优势：思路更清晰\n\n我们知道，写叙述体备忘录要比做PPT更艰苦。这其实是好事。写作行为本身会迫使写作者更深入地思考、综合，而做PPT则不必如此。书面表达的想法，都经过充分的思考，尤其是整个团队都参与检查并给出反馈。将所有相关事实和重要论点组合成连贯的、易懂的文本，这是一个令人畏惧的任务——它也应该让人畏惧。\n\n**作为陈述者，我们的目标不只是介绍某个想法，还要表明这个想法是经过仔细权衡和缜密分析的。**\n\n观点有说服力，其基础是“观点、论据、结论”这六个字的写作箴言。成功的叙述体备忘录要为读者理清思路，继而创造有说服力的论证，而不是罗列一堆毫无关联的要点和图片，让听众自己去理清思路。\n\n例如，亚马逊季度业务回顾会（QBR）上的叙述体备忘录，其结构可能如下。\n* 序言\n* 信条\n* 成绩\n* 失误\n* 下季度计划\n* 职员总数\n* 盈亏报告\n* 常见问题\n* 附录（包括数据表、图像、模型等支撑性数据）\n\n\n### 如何使用备忘录高效开会\n人的阅读速度大概为每3分钟1页，因而备忘录的篇幅不能超过6页。如果会议时长为30分钟，那3页纸的备忘录更为合适。我们的目标，是留出三分之二的会议时间用于讨论与会者所读的内容。\n\n接下来，讨论开始，这意味着与会成员向陈述团队提问。他们会要求团队澄清问题、盘问意图、提供洞见、提出修改或替换建议。陈述团队为准备备忘录可谓是尽心尽力，因此与会成员有责任认真对待。毕竟，会议的重要目标，是寻求所提议的想法或问题的真相。\n## 5、逆向工作：从最佳客户体验出发\n**高效的“逆向工作”工具：先写“新闻稿”和“常见问题”，再建造产品。**\n\n正是这两大要素构建了“逆向工作”流程：从客户体验出发，然后逆向工作，写产品发布模拟“新闻稿”以及预先解答棘手问题的FAQ。\n\n\n### 模型是想法的体现\n杰夫所说的模型，是视觉化呈现，演示这个新服务在亚马逊网站的实际模样。模型必须具体化，展示从登录网页到购买的整个客户体验过程，包括页面设计、按钮、文本、点击序列等。要创建有意义的、内容翔实的模型，你必须全面考虑各个要素：这个服务将提供什么东西，客户会有何种体验，各项功能如何在网页上运行。它需要投入大量的工作全面思考业务，还需要投入更多的工作去创建和完善视觉呈现方式。\n\n与毫无模型相比，不成熟的模型的效果并没有更好，可能还会更糟糕。在杰夫看来，模型不成熟，就表明想法不成熟。他立即予以否决。\n\n### PR/FAQ的功能与益处\n“逆向工作法”的根本出发点，是从内部／公司的视角转变为客户的视角。\n\n随着时间的推移和内容的提炼，我们对PR/FAQ的规范进行了完善和标准化。PR部分的篇幅较短，通常不超过1页，FAQ部分的篇幅不超过5页，多余的篇幅或文字不会有任何奖励。其目的不是汇报你做了哪些出色的工作，而是分享你从出色的工作中所提炼出的想法。\n\n在采用PR/FAQ的初期，人们常犯的一个错误是认为写得越多越好。他们会写出长篇大论，附上一页页备忘录、图像和表格。至少从写作者的角度来看，这种做法具有一大好处：它能展现他们所做的所有工作，不用艰难地决定哪些内容重要、哪些不重要——而是交给与会者决定。然而，借用我们讨论叙述体备忘录时所用的那个术语，PR/FAQ的篇幅限制是一个“强制函数”——如我们所见，**这样做可以促进思考、提高交流效果。**\n\n书面PR/FAQ还有一大好处：团队可以真正理解那些妨碍产品可行性的制约因素和问题。此时，产品团队或领导团队就必须决定：是解决PR/FAQ暴露的那些问题和制约因素，找出提高产品推出可行性的解决方案，从而继续打造该产品，还是搁置该产品？\n\n领导层和管理团队的职责，往往不是决定要做什么，而是决定不做什么。清楚自己不做什么和清楚自己要做什么，两者往往同等重要。\n\n## 6、绩效：管理投入类而非产出类指标\n\n公司的股价是亚马逊所说的“产出类指标”。那位CEO（以及大多数公司）是无法直接控制产出类指标的。真正重要的，是关注那些最终影响股价等产出类指标的“可控的投入类指标”——你可以直接控制的那些活动。\n\n### 绩效指标的生命周期\n最初，亚马逊的零售、运营和财务团队建设业务回顾周会时，**他们会借助著名的“六西格玛”（Six Sigma）流程改进工具：DMAIC（定义—测量—分析—改进—控制）。**如果你决定采用业务回顾周会这种会议方法，我们建议你也遵循DMAIC的各个步骤。这些步骤的顺序很重要。按步骤完成绩效指标的生命周期，可以避免很多挫折和返工，有助于更快地达成目标。\n\n#### 定　义 \n首先，你需要选择和定义你希望测量的指标。指标只有选择正确，才具有明确而可行的指导作用。如果指标选得不好，结果就是陈述明显之事、泛泛而谈公司的事务。\n\n任何系统改进之前……你必须理解系统的投入类指标是如何影响产出类指标的。要得到理想的结果，你就必须改变投入类指标（可能还要改变整个系统）。这需要持久的努力、坚定的目标以及把持续改进作为运营哲学。\n\n##### 1. 飞轮：投入类指标驱动产出类指标\n下面这个草图模型受此启发，演示了可控的投入类指标如何驱动单个关键的产出类指标（增长）。在这个闭环系统中，只要对某个或所有要素注入能量，飞轮就会加速转动。\n<img src=\"/img/ymx1.jpg\" height = \"auto\" width=\"90%\" />\n\n##### 2. 选择正确而可控的投入类指标\n我们意识到，选品团队选择了错误的投入类指标（业务回顾周会表明了这一点）。于是，我们更改了指标，以反映客户需求。在多次业务回顾周会上，我们自问：“改变现有的选品绩效指标，会得到理想的产出类指标吗？”\n\n你会从中发现绩效指标的试错模式，而试错是这个过程中的重要部分。一定要不断地测试和讨论。\n\n**人们常犯的一个大错，是不开始做。大多数业务回顾周会开始时都不太理想，都需要不断地加以调整和改进。**\n \n#### 测　量\n打造收集所需指标数据的工具，这听起来比较简单，但我们发现，和选择指标本身一样，要获得正确的数据收集工具，同样需要时间和努力。\n\n在选择绩效指标和收集数据时，不可避免地存在着偏见，他会收集那些反映自己事业部积极趋势的数据。渴望成功，这是人性。\n\n在开发数据收集工具的过程中，要确保它们测量的是你认为它们要测量的东西。要“刨根问底”，要能准确地理解数据的收集方式如何有助于发现潜在的问题\n\n#### 分　析\n“碰到某个问题，最初24小时内寻找问题的真正的根本原因的可能性几乎等于零，因为每个问题背后都有一个非常有趣的故事。”\n\n只要坚持挖掘偏差产生的真正的根本原因并加以消除，最终，你就会拥有一个可预测的、可控的、可优化的流程。\n\n#### 改　进\n一旦有了健全的指标体系、理解流程运作方式的可靠工具，你就可以投入精力改进流程。例如，如果库存产品与客户浏览“页面”产品之比稳定于95%，那就要问：“我们需要做出哪些改变，才能达到98%？”\n\n实施业务回顾周会一段时间后，你可能会注意到，某个指标不再产生有用的信息。如果是这样，那就把这个指标从数据显示中删掉。\n\n#### 控　制\n这是最后一个步骤，旨在确保流程正常运转、绩效不会随时间的推移而降低。随着你从根本上加深理解业务驱动因素，业务回顾周会往往就变成基于例外的会议，而不是讨论各个绩效指标的例会。\n\n这个阶段还会出现一种情况：业务流程自动化。一旦某个流程被清楚地理解，决策逻辑被植入软件或硬件，那它就很容易自动化。\n\n### 业务回顾会议要点\n使用统一而熟悉的格式，加快理解速度。会议的目标，是讨论异常数据以及如何应对。正常状况是无须详加讨论的。\n\n业务的“主人”拥有绩效指标并负责解释异常数据。在业务回顾周会开始前，指标的“主人”应该对自己的指标有过全面而深入的分析。\n\n\n### 绩效指标解析\n**1.产出类指标表明业绩，投入类指标提供指导：**\n产出类指标（表中给出的那些数据）对于趋势原因的指示作用，远远不如投入类指标。这个图表表明，增长率下降的原因，是获得新客户的速度下降，但我们从前面那些图表中根本无法察觉到这个原因。对于规模较大的业务，如果你只关注“营收”这个产出类指标，那么，在相当长的时间内，你都不会发现新客户数量下降的影响。然而，如果你关注投入类指标——“新客户的数量”“新客户营收”“现有客户营收”等——你就可以及早发现这个信号，也就能更早地采取行动。\n\n**2.数据和客户故事结合，讲述完整的故事**\n结合客户的真实故事，数据的力量会更加强大。“刨根问底”领导力准则指出：“领导者要深入各个环节，随时掌控细节，经常进行数据审核，在数据和客户故事（客户体验）不一致时要提出质疑。领导者要不遗漏任何工作。”\n\n### 陷阱1：灾难性的会议\n学习、承担问题及解决办法的“主人翁”责任，这是业务回顾周会流程的两大目标。\n\n领导者要用心倾听，坦诚交流，尊重他人。领导者要敢于自我批评，即使这样做会让自己尴尬或难堪。领导者要不迷恋自己或团队身上的香水味。领导者要以最优标准要求自己和团队。\n\n我们变得更加成熟，赋予与会者免于恐惧的自由。他们每次提出自我批评时，我们都会给予奖赏。团队越自我解剖、自我批评，我们就越给予奖赏。如果团队想掩盖错误，没有考虑客户体验，那你可以提出刁难性的问题。\n\n### 陷阱2：遮蔽信号的噪声\n数据异常是正常的、不可避免的，这虽然听上去有些矛盾。因此，必须区分正常的异常数据（噪声）与流程的某些根本变化或缺陷（信号）。想为正常范围内的异常数据赋予意义，这种做法是浪费精力，甚至是危险的、误导性的。有人骄傲地宣称，经过不懈努力，他们的关键指标这周提升了0.1%。这种做法实在是太糟糕了，因为它没有将宝贵的时间用于更重要的事情。更糟糕的是，如果该指标下降了0.1%，你就会浪费时间去寻求根本原因，“解决”原本属于正常变化的某个问题。\n\n可控的投入类指标是测量公司满足客户利益程度的定量方法（对数据“刨根问底”）和定性方法（客户故事），而产出类指标反映的是公司期望的结果。\n\n要想每周都对你的公司加以正确评估并努力改进，你就需要愿意公开讨论失败、从失败中学习并随时寻求提升客户体验的创新方法。\n\n# 下篇 高效的创新引擎\n失败和创新是连体双胞胎。**要创新，就得实验。如果事前就知道它会有效，那就不是实验。**大型组织大都接纳创新这一理念，但不愿意遭受系列的、通向成功所需的实验失败。创新的量级和失败的量级要和组织的成长同步。否则，你的创新就不够重大，不足以驱动公司成长。\n\n“长期思维和坚持客户至上具有很好的互动性。如果我们能识别客户的某种需求，并坚信这种需求是有意义的、可持续的，那我们就愿意耐心地奋斗多年，直到交付解决办法。”**关键词是：耐心！**\n\n创新并不能解决所有的问题。差异化重要的地方，创新才会重要。公司成立初期，亚马逊数据中心采用的硬件并不是客户差异化的点——创造有吸引力的在线购书体验才是差异化。\n\n**流程可以提高成功的概率，但绝不能保证成功。**即使是最好的流程，也只能提高决策的质量——任何流程都无法替你做决策。\n\n我们的长期思维和保持耐心的创新方法——由客户需求驱动——与传统的“技能驱动”创新方法有着根本的区别。**3D效果虽然很酷，但为什么人人都需要带3D效果的手机？**\n\n### 1、电子书阅读器Kindle\n亚马逊已经到了重要的十字路口，现在必须采取行动。虽然实体媒体业务正处于增长中，但我们都清楚：随着媒体业务向数字化转型，它的受欢迎程度和重要性迟早会下降，纸质图书和DVD销量下降并被数字下载取代，这似乎只是时间问题。\n\n杰夫认为，我们必须马上行动。一旦下定决心，杰夫就会践行“崇尚行动”这一领导力准则。\n\n#### 数字化转型\n杰夫采取的第一个行动，不是决定“做什么”，而是决定“谁来做”“如何做”。这是有着重要区别的。他没有立即仓促地关注要打造什么产品，尽管这似乎是最快的方式。相反，他做出的选择表明：他认为这个商机规模很大，同样，获得成功所需要做的工作也很多、很复杂。**他首先关注的，是如何组织团队、谁是取得理想结果的正确领导者。**\n\n虽然数字化转型已经开始，但谁也无法预测数字化浪潮何时才会真正到来。谁都不想过早地进入，推出尚没有市场的产品。但谁也不想错过这波浪潮，否则就无法赶上。我们知道，我们需要弄清楚这个新范式的最佳客户体验是什么，然后创新方法以摆脱困局。\n\n一家公司如果没有或无法自我变革，主动适应和满足新的客户需求，那就注定会失败。他说：“你肯定不想成为柯达， 我们个人职业发展也是一样。\n\n**如果我们把数字媒体纳入现有的实体媒体公司，它就永远不会享有优先地位。毕竟，规模更大的业务是公司的支撑，随时都会得到最多的关注。**史蒂夫告诉我，做好数字媒体对杰夫来说至关重要，他希望史蒂夫只专注于此。史蒂夫希望我加盟，帮助他创建这家新公司。\n\n\n#### 亚马逊数字媒体与设备的启动阶段\n我们可以做快速的跟随者——也就是说，仿造其他公司的成功产品；也可以替我们的客户创造一种新产品。他说，这两种方法都会奏效，但他希望亚马逊是一家创新公司。\n\n为什么？**就数字产业而言，部分原因是：数字产业的变革速度非常快。如果采用跟随战略，等到我们建造并部署出竞争对手的服务复制品时，他们或别人早已造出更好的东西了，而我们还没有足够的时间从现有服务中获取收益，就得再打造新的复制品。**\n\n真正的创新，要为客户和股东创造更大的长期价值；真正有价值的事情，就是长期投资自己。\n\n“六页纸备忘录”和“新闻稿／常见问题”工作流程；因为我们拥有既定的工作流程。采用同样的工作流程，任何公司的团队都可以自主工作，同时又可以和公司领导者的意图保持同步。\n\n每次调整，各领导者的职责范围都会变窄，但各职位的重要性都会增加。在大多数公司，领导者的职责范围缩小，会被视为降职。事实上，很多副总裁和主管都是这样看待每次调整的。在亚马逊，这种调整不是降职，而是一种信号：我们有远见卓识，要长期投入数字媒体业务。\n\n#### 亚马逊：设备制造商\n数字媒体的价值链也有重要的区别。**在实体媒体零售业，亚马逊处于价值链的中端。我们的附加值，是通过单个网站获取并集合品类丰富的产品（数百万种），然后迅速而便宜地交付给客户获得的。**\n\n杰夫告诉史蒂夫，**这就意味着我们要远离价值链中端，大胆地走向价值链的两端：一端是内容，这里的价值创造者是书籍的作者、电影制片商、电视剧制作人、出版商、音乐家、唱片公司和电影工厂；另一端是内容的分发与消费。**对于数字媒体，这意味着要关注客户端和客户习惯用来阅读、观看和收听内容的设备，就像苹果公司的iTunes和iPod所做的那样。\n\n亚马逊的工作法，永远都是从客户出发，然后逆向工作。我们要弄清楚客户需要什么，然后问自己：“打造满足客户需求的产品，我们拥有所需的技能吗？如果没有，那怎样才能建造或获得这些技能？”为客户创造价值、与竞争对手差异化所需的技能一旦确定下来，即使缺乏技能，也没有阻挡我们实现最终的结果——开发出我们自己的设备。\n\n**为啥要自己做硬件？**\n\n第一点：我们要打造一个与阅读设备深度融合的电子书店。这种组合，是为客户创造购买和阅读图书的愉悦体验的关键所在。我们经过研究发现，依赖第三方的运营和财务风险较低，但从客户体验的角度来看，风险要高得多。如果我们从客户出发，逆向工作，那最合乎逻辑的结论是：我们需要创造自己的设备。\n\n他指出的第二点是：如果你认定公司（任何处于十字路口的公司）的生存和长期成功依赖于某种目前尚未具备的特定能力，那就得制订创建或购买这种能力的计划。我们必须弄清楚如何创建硬件设备的制造能力。如果我们想确保极好的客户体验、获得差异化的价值链客户端，那就不能把如此重要的创新外包和转让给他人。我们必须自己做。\n\n我们决定自己建造设备，还有一个原因：如果我们将工作外包，即使成功创造出第一代伟大的阅读设备，大部分知识和技术也不会为亚马逊所独有，而会积累于外包服务商。\n\n### 2、金牌会员服务Amazon Prmie\n#### 背景\n我们不应满足于零售业务的增长。这是一个迫在眉睫的问题，我们需要围绕配送服务来显著提升客户体验。我们需要一个配送服务会员计划。年底之前就要建好并推出。\n亚马逊金牌会员服务计划Prime提供了富有吸引力、改变行业规则的客户体验，因而成为亚马逊零售业增长的最大驱动力。\n你会发现，真正驱动Prime的，是我们对数据经过长达数月“刨根问底”后意识到：我们花费这9年的大部分时间和6亿美元打造的订单履行网络的能力，与我们的客户需求不相匹配。\n\n**2个选择**\n\n第一个选择，坚持到底。亚马逊仍在成长，那就让我们多年用于打造订单履行中心的投资回报最大化，然后随时加以微调和改进。\n\n第二个选择，“两日送达”、最终“一日送达”和“当日送达”会成为配送规范。因此，虽然我们打造的服务是好的，但还不够好。“我们毫不动摇地坚信，股东的长期利益同客户的利益是完全一致的。”\n\n第一个选择分析：是“技能驱动”道路——也就是说，利用公司现有的技能和资产驱动商业机会。如果选择这条道路，大多数公司的领导者可能都会受到赞扬。但其危险在于：虽然他们现在高居局部最优的位置，但因为厌恶风险而没有看见更高的山峰，其他人则会想办法登上去。\n\n我们选择的是第二条道路：因为意识到了这一点，所以我们采取了大胆的举措。我们知道，这些举措可能被华尔街的投资家和分析师误解，而且需要数年之后才会有回报。但是，如果它起作用，我们就会得到更多客户的信任，建立新的电商服务标准。杰夫坚持走这条道路，因而诞生了亚马逊金牌会员服务。**你只需要坚持那些简单易懂（但有时很难做到）的原则和流程：客户至上，鼓励长期思维、价值创新，随时关注细节。**\n\n#### 会员计划\n我们的营销、零售和财务团队制定了三条标准，所有新的营销计划都必须达到这三条标准后才能推进。\n1. 必须可负担（吸引眼球但财务不可持续的计划不予考虑）。\n2. 必须驱动正确的消费行为（换言之，必须推动客户更多地在亚马逊购物）\n3. 资金使用必须优于以前的计划，将同样的资金用于提升客户体验的活动，比如进一步降低价格、提高产品库存率。\n\n\n所谓“制度性不作为”，是指大型组织的人员善意地否决新的想法。也就是说，不要做某件事，而不是要做某件事。“制度性不作为”造成的错误，通常都是过失错误。保持现有的轨道，管理者会感到舒适和确定性——即使短期确定性的代价是未来的不稳定和价值破坏。\n\n此外，“制度性不作为”造成的错误也很难发现。大多数公司都没有工具评估不做某件事的代价。如果代价很高，等意识到也已为时已晚，无法改变。“制度性不作为”可以渗透到组织的各个层面。它会导致董事会否决重大的战略变化（想想诺基亚和微软公司错失的智能手机）。它还会驱使一线管理者让高绩效员工继续做现有的计划，而不参与那些可能会失败但未来会带来丰厚回报的高风险实验——如果管理者被调职后回报才会到来，那更是如此。\n\n#### 背后的原则和收益\n亚马逊Prime计划这个例子很好地证明：坚定地采用“客户至上”“长期思维”等领导力准则来解决问题——这里的问题是提高营收增长率——就能“解锁”巨大的价值。要做到这些，我们就必须承认：我们这些年费力建设的现有物流基础设施，虽然现在运行相当良好，但从长远来看是不足的。我们必须将决策的预期回报期，从一两个季度延长至未来的2~5年，甚至是7年。从“客户至上”和“长期思维”的角度来考虑，实施Prime计划是完全合理的。它可以满足客户长久以来的期望，同时又能为亚马逊产生远高于尽力压缩现有财政支出所获得的自由现金流。\n\n### 3、会员视频服务Prmie Video\n这个故事讲述的，是我们如何在开始时犯下大错，然后从错误中学习，最终做得很对。\n\n亚马逊坚守长期思维，包括人力资源投资。他们理解，**创新和创造新事物往往都会失败。如果你开除了那个人，也就失去了从失败中学到的经验教训。对于刚刚经历失败的领导者，杰夫会对他说：“我为什么要开除你呢？我在你身上投资了上百万美元。现在，你有责任让这些投资产生回报。弄清楚并写出你出错的地方，和公司的其他领导者分享你从中学到的经验教训。要保证不再犯同样的错误，帮助其他人避免犯这样的错误。”**\n\n我们没有控制上游端的内容开发，也没有控制下游端的回放设备。我们基本上是一个数字分销系统，没有任何独特之处或所有权，难怪我们不断地在价值链的两端——内容开发和设备配置——碰壁。我们必须掌控自己的命运。我由此得出的结论让人大吃一惊：我们必须创造自己的内容。现在，我们应该制作自己的电影和电视剧了。\n\n创建广受欢迎、成本固定的订阅服务的最大好处是：**订户一旦超过某个数量，订阅服务收入的每一块钱都是纯利润 --- 互联网盈利模式**。实现这个目标的难点是：一、获得大量的订户；二、建立必看电影和电视剧的目录。 \n\n### 4、云服务AWS\n亚马逊的企业文化要求这些新业务具有高潜力、创新和差异化，但不要求它们诞生之日就很大。即使某个业务是全新的，规模很小，我们也会意识到它具有高潜力，是我们可以创新和差异化发展的领域，我们有耐心坚持做下去。 做事要有长期思维和耐心。\n#### 背景\n**Web服务的概念验证**\n也就是在这个时候，我们后退一步，设身处地地从联营者的角度来看待这个问题。我们一直以为该计划最吸引联营者的是亚马逊的产品本身，因而忽略了他们渴望选择产品展示的外观等——比如字体大小、调色板和图像大小。结果是，他们并不想勉强使用“现有最佳”的亚马逊样式。\n\n因此，2002年3月，我们决定尝试推出一个实验性功能，改变我们同联营者分享信息的方式。联营者不再收到完全成形的产品展示，而是可以选择以XML文本格式接收产品数据。然后，联营者可以采用这些XML产品数据编写自己的软件代码，根据自己的设计标准将其并入自己的网站。我们的目的，是退出设计事务，让联营者自己创新，不受我们的约束。\n\n在此之前，亚马逊有两个客户群体——买家和卖家。现在，我们有了新的客户群体——**软件开发者**。\n\n亚马逊领导力准则“崇尚行动”：“速度对业务至关重要。决策和行动很多都是可逆的，不需要过度研究。领导者要注重有计划地冒险。” \n\n**所谓“逆向工作法”，就是从客户的角度出发，采用逐步的流程，无情地质疑设想，直到你完全清楚要创建什么。它是求真的过程。有时候，“逆向工作法”会揭露某些令人意想不到的真相。**为了急于将某个计划推向市场，有些公司会忽略真相，继续按照原有的计划创建。他们对该计划即将带来的不错收益念念不忘，因而激励团队拼命坚持。后来，他们却发现，如果花时间质疑那些设想，得到的收益会大得多。在撰写“新闻稿／常见问题”阶段改变航向，比在业务推出和运营后再改变航向的代价要小得多。“逆向工作法”可以帮助你避免产品推出后再提议大幅改变航向，其代价是非常昂贵的。\n\n领导者愿意为创新而可能被长期误解。。\n\n## 亚马逊之外的亚马逊工作法\n\n亚马逊工作法意味着必须改变做事的习惯和方式、延迟满足和坚持撑过挑战时期，但也意味着收获独特的回报。\n\n事实证明，定义亚马逊文化的基本特征、阐述领导力准则和规则化基本做法——抬杆者招聘方法、单线程领导团队、书面叙述体、逆向工作、关注投入类指标——所有这一切，对我们从事其他事业都是必要的。\n\n### 一些建议\n禁用PPT。领导团队会议不要将PPT用作讨论复杂问题的工具，要开始采用叙述体“六页纸备忘录”以及“新闻稿／常见问题”。这一点可以立即施行。当然，一定会有阻力和抱怨，但我们发现它的效果立竿见影。最终，你的领导者会说：“我们根本无法回到老一套。”\n\n确立抬杆者招聘流程。这种招聘方法已不再为亚马逊所独有，我们发现很多公司都在采用。只要培训到位，它很快就能确立。它能提高招聘流程的质量，让“轮番面试”的每个参与者都能从中学习，还能带来短期效果。它可以减少招到差劲员工的数量，因而从长远来看，可以提高每个团队以及整个公司思维和业绩的整体质量。\n\n关注可控的投入类指标。亚马逊坚持识别那些可控的、对每股自由现金流等产出类指标影响最大的指标。这个过程并不容易，因为你需要耐心试错，才能找到最能控制预期业绩的那些投入类指标。请注意：这不是说要舍弃产出类指标。亚马逊非常关心每股自由现金流。\n\n调整组织结构，建立有单线程领导者的自主团队。正如在第3章中提到的，这需要时间和精心管理，因为它肯定会引发权威、权力、管辖权和“地盘”等问题。还必须提防那些妨碍组织自主性的依赖关系和障碍。不过，这是可以做到的。先从产品开发团队做起，然后看看还有哪些部门采用自主团队的工作效果更好。\n\n改革领导者的薪酬结构，以便鼓励长期承诺和长期思维。避免太多的“特殊情况”要例外处理，要确保公司所有部门的领导者获得薪酬的方式都一致。\n\n明确表述公司文化的核心要素，比如亚马逊的长期思维、客户至上、渴望创新、运营卓越。然后，将这些要素植入公司的所有工作流程和讨论。不要想当然地认为这些要素只需要表述和展示，就能产生巨大的效果。\n\n确定一套领导力准则。必须有大家的参与和贡献。不要将这个任务交给某个团队或外包给咨询服务公司，要自己做。通过全面、细致地讨论后达成一致。要不时地重新审视这些原则，必要时做出修改。然后，同企业文化一样，要把这些领导力原则植入公司的所有工作流程，从人员招聘到产品开发。\n\n画出你的“飞轮”。什么是公司成长的驱动因素？把它们画出来，显示它们如何作用于“飞轮”。评估你的所有做法对“飞轮”的某个或多个驱动因素的积极和消极影响。","tags":["亚马逊逆向工作法","抬杆者招聘法则","叙述体与6页备忘录","飞轮指标","从客户体验出发","长期主义"]},{"title":"web开发如何保障数据接口安全","url":"/2022/07/10/web开发如何保障数据接口安全/","content":"\n### 接口数据安全介绍\n接口数据安全主要包括：**1、数据传输过程安全、2、服务端数据识别安全、3、数据存储安全**\n\n### 接口数据安全的方案\n#### 1、数据加密，防止报文明文传输\n##### 数据如何加密\n1. 对称加密：  加密和解密使用相同密钥的加密算法。简单点可以使用对称加密算法（如AES）来加解密，或者哈希算法处理（如MD5）。\n2. 非对称加密：非对称加密算法需要两个密钥（公开密钥和私有密钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。更安全的做法，就是用非对称加密算法（如RSA或者SM2），公钥加密，私钥解密。\n\n##### https加密过程\n<img src=\"/img/https.png\" style=\"max-width:95%\" />\n\n1. 客户端发起Https请求，连接到服务器的443端口。\n1. 服务器必须要有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。\n1. 服务器将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。\n1. 客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。\n1. 客户端将公钥加密后的密钥发送到服务器。\n1. 服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。\n1. 服务器将加密后的密文返回到客户端。\n1. 客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。\n\n##### 日常业务中敏感度高的接口（登录、注册、付款接口）\n日常业务呢，数据传输加密这块的话，用https就可以啦，如果安全性要求较高的，比如登陆注册这些，需要传输密码的，密码就可以使用RSA等非对称加密算法，对密码加密。如果你的业务，安全性要求很高，你可以模拟https这个流程，对报文，再做一次加解密\n#### 2、数据加签和验签\n\n##### a、什么是加签验签呢\n1. **数据加签**\n<img src=\"/img/https1.png\" style=\"max-width:95%\" />\n\n数据加签：用Hash算法（如MD5，或者SHA-256）把原始请求参数生成报文摘要，然后用私钥对这个摘要进行加密，就得到这个报文对应的数字签名sign（这个过程就是加签）。通常来说呢，请求方会把数字签名和报文原文一并发送给接收方。\n\n1. **数据验签**\n<img src=\"/img/https2.png\" style=\"max-width:95%\" />\n\n接收方拿到原始报文和数字签名（sign）后，用同一个Hash算法(比如都用MD5)从报文中生成摘要A。另外，用对方提供的公钥对数字签名进行解密，得到摘要B，对比A和B是否相同，就可以得知报文有没有被篡改过。\n\n>其实加签，我的理解的话，就是把请求参数，按照一定规则，利用hash算法+加密算法生成一个唯一标签sign。验签的话，就是把请求参数按照相同的规则处理，再用相同的hash算法，和对应的密钥解密处理，以对比这个签名是否一致\n##### b、有了https等加密数据，为什么还需要加签验签\n数据在传输过程中被加密了，理论上，即使被抓包，数据也不会被篡改。[但是https不是绝对安全的哦](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247494171&idx=1&sn=80479acae752311581258015faa41673&scene=21#wechat_redirect)，还有一个点：https加密的部分只是在外网，然后有很多服务是内网相互跳转的，加签也可以在这里保证不被中间人篡改，所以一般转账类安全性要求高的接口开发，都需要加签验签\n\n\n#### 3、token授权认证机制\n日常开发中，我们的网站或者APP，都是需要用户登录的。那么如果是非登录接口，是如何确保安全，如何确认用户身份的呢？可以使用token授权机制。\n\n##### a、token的授权认证方案\n用户在客户端输入用户名和密码，点击登录后，服务器会校验密码成功，会给客户端返回一个唯一值token，并将token以键值对的形式存放在缓存（一般是Redis）中。后续客户端对需要授权模块的所有操作都要带上这个token，服务器端接收到请求后，先进行token验证，如果token存在，才表明是合法请求\n<img src=\"/img/token.png\" style=\"max-width:95%\" />\n\n1. 用户输入用户名和密码，发起登录请求\n1. 服务端校验密码，如果校验通过，生成一个全局唯一的token。\n1. 将token存储在redis中，其中key是token，value是userId或者是用户信息，设置一个过期时间。\n1. 把这个token返回给客户端\n1. 用户发起其他业务请求时，需要带上这个token\n1. 后台服务会统一拦截接口请求，进行token有效性校验，并从中获取用户信息，供后续业务逻辑使用。如果token不存在，说明请求无效。\n\n##### b、如何保证token的安全\n1. token设置合理的有效期\n2. 使用https协议\n3. token可以再次加密\n4. 如果访问的是敏感信息，单纯加token是不够的，通常会再配置白名单\n\n#### 4、时间戳timestamp超时机制\n数据是很容易抓包的，假设我们用了https和加签，即使中间人抓到了数据报文，它也看不到真实数据。但是有些不法者，他根本不关心真实的数据，而是直接拿到抓取的数据包，进行恶意请求（比如DOS攻击），以搞垮你的系统。\n\n我们可以引入时间戳超时机制，来保证接口安全。就是：用户每次请求都带上当前时间的时间戳timestamp，服务端接收到timestamp后，解密，验签通过后，与服务器当前时间进行比对，如果时间差大于一定时间 (比如3分钟)，则认为该请求无效。\n\n#### 5、时间戳timestamp+nonce方案防止重放攻击\n时间戳超时机制也是有漏洞的，如果是在时间差内，黑客进行的重放攻击，那就不好使了。可以使用timestamp+nonce方案。\n\nnonce指唯一的随机字符串，用来标识每个被签名的请求。我们可以将每次请求的nonce参数存储到一个“set集合”中，或者可以json格式存储到数据库或缓存中。每次处理HTTP请求时，首先判断该请求的nonce参数是否在该“集合”中，如果存在则认为是非法请求。\n\n然而对服务器来说，永久保存nonce的代价是非常大的。可以结合timestamp来优化。因为timstamp参数对于超过3min的请求，都认为非法请求，所以我们只需要存储3min的nonce参数的“集合”即可。\n\n#### 6、限流机制\n如果用户本来就是就是真实用户，他恶意频繁调用接口，想搞垮你的系统呢？这种情况就需要接入限流了。\n\n常用的限流算法有令牌桶和漏桶算法。大家可以看下我的这篇文章[四种限流](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247490393&idx=1&sn=98189caa486406f8fa94d84ba0667604&chksm=cf21c470f8564d665ce04ccb9dc7502633246da87a0541b07ba4ac99423b28ce544cdd6c036b&token=162724582&lang=zh_CN&scene=21#wechat_redirect)\n#### 7、黑名单机制\n#### 8、白名单机制\n#### 9、数据脱敏掩\n对于密码，或者手机号、身份证这些敏感信息，一般都需要脱敏掩码再展示的，如果是密码，还需要加密再保存到数据库。\n\n对于手机号、身份证信息这些，日常开发中，在日志排查时，看到的都应该是掩码的。目的就是尽量不泄漏这些用户信息，虽然能看日志的只是开发和运维，但是还是需要防一下，做掩码处理。\n\n对于密码保存到数据库，我们肯定不能直接明文保存。最简单的也需要MD5处理一下再保存，Spring Security中的 BCryptPasswordEncoder也可以，它的底层是采用SHA-256 +随机盐+密钥对密码进行加密，而SHA和MD系列是一样的，都是hash摘要类的算法\n#### 10、数据参数一些合法性校验(前后端都必须做)\n接口数据的安全性保证，还需要我们的系统，有个数据合法性校验，简单来说就是参数校验，比如身份证长度，手机号长度，是否是数字等等。\n\n\n<br />\n[文章来源](https://mp.weixin.qq.com/s/xcKXtB6Ck-phhua2fY4aYw)","tags":["web安全","接口安全"]},{"title":"巨人的方法读后感","url":"/2022/07/05/巨人的方法读后感/","content":"\n## 前言\n\n我因计划不足或计划过多而错过了多少人生？\n\n我如何才能对自己好一点儿？\n\n我如何才能更好地拒绝那些干扰我的事情，更好地展开自己渴望的冒险？\n\n我怎样才能更好地重新评估自己的人生和位置，重估重要之事、世界观，以及人生轨迹？这么多问题！所有的事情都浮现在眼前！\n\n我如果拥有一个导师天团来帮助我，那么会怎么样？\n\n确切地说，我可以邀请100多位杰出人士回答这些我想问自己的问题，或者请他们引导我朝着正确的方向前进。\n\n我向世界上一些最成功的人士发了邮件，问了他们11个相同的问题。他们所在的领域颇为宽泛。我在邮件中写道：“请回答您最喜欢的3到5个问题……如果有什么打动了您，请多回答一些问题。”\n## 书中他人有意思的回答和观点\n### 1、你有没有什么离经叛道的习惯？\n1. 你一旦从一次经历中吸取了经验教训，它就很难再被称为“失败”，因为这次经历对你很有用\n\n### 2、你用什么方法重拾专注力？\n1. 游泳，水是真实的；冥想，心是真实的；与动物接触，它们也是真实的；独自在阳光下享用一顿美餐\n2. 为了避免超负荷或注意力不集中，我每天早上会花大约一个小时进行冥想。**冥想教会了我要为一天中的幸福和平静留出空间。**在压力很大时，我会尽量远离相关问题，花一些时间反思。无论遇到什么难题，我通常都会问自己：“我现在能改变现状吗？”我如果找不到能够产生积极影响的明确方法，就会继续反思。我认为在解决问题时，耐心的作用往往被低估了。\n3. 拖延和恐惧往往是我的绊脚石。当思考问题时，我倾向于从整体上看，所以经常会不知所措。如果我将其分解开来，写在纸上，半小时后再看，分解之后的东西似乎就没什么大不了。\n\n\n\n### 3、你长久以来坚持的人生准则是什么？\n1. 一定要犯新的错误\n2. 太多的人都在等待一切准备就绪，然后去做自己打算做的事情。发布相关信息并不等于采取行动，它只是廉价的空谈\n3. 如果你发现自己在进行一场公平的战斗，你的目标就定得太低了。\n4. 最重要的是，坚持终身学习，尝试新鲜事物。体育锻炼是重复的，而智力锻炼是不拘一格的\n5. 你如果想走得快，就一个人走，但你如果想走得远，就必须结伴而行\n\n\n\n\n### 4、在你的专业领域里，你都听过哪些糟糕的建议？\n1. 人们普遍认为必须同等看待对产品的所有反馈意见，不管是播客节目，还是应用程序。**不过，并非所有反馈都是平等的，也并非所有来自用户的想法都是好的！太过注意反馈会改变你对自己产品的愿景，突然，你会觉得这不再是你的产品。**\n2. “好事会降临到那些等待的人的身上。”如果我听从了这句话，声田就只能停留在一个创意上;“好事会降临到努力工作、永不放弃的人的身上。”我觉得这句话更合理。\n\n\n\n### 5、你如何拒绝不想浪费精力和时间的人和事？\n1. 在思考是否要拒绝其他人或事时，**我会先问问自己是不是出于愧疚或恐惧而答应别人**。如果是这样，那就礼貌地拒绝。\n2. 如果这件事是在明天，我会答应吗？”答应几周或几个月以后的事真是太容易了，因为你那时的日程安排现在看起来还不满。\n\n\n\n### 6、你最常当作礼物送给他人的3本书是什么？\n1. 马克·刘易斯的《欲望生物学》。**成瘾是一种短期的欲望，目标是一种长期的欲望。**\n2. 维克多·弗兰克尔的《活出生命的意义》。维克多·弗兰克尔描述了自己在纳粹集中营的生活，他爱的人都死了。通过这本书，**我明白了我们避免不了苦难，但我们可以选择如何应对苦难**\n\n\n### 7、你做过的最有价值的投资是什么？\n1. 假若你没有犯错，那就说明你研究的问题还不够难，而这就是一个大错。\n2. 我还在各种体验上花了很多钱，但很少花在物质享受上。\n3. 我发现，我越愿意慷慨分享，越能更快地通过其他方式获得回报。我坚信，自己从自由地帮助他人中得到的快乐和回报，不久之后会以其他方式带给我好运。\n\n\n### 8、有没有某个信念、行为或习惯真正改善了你的生活？\n1. 我认识的每个聪明稳重的人都喜欢行走和冥想\n2. 我强烈意识到提出正确问题的价值，尤其是最近。我们有多少次只是说些套话，浅尝辄止。深入研究，弄明白为什么某人会这样做以及他的动机是什么，这对我而言具有更多意义\n3. 我不再为未来忧虑过多。我专注于充分利用每一天，我相信它会把我带到自己向往的地方\n4. 人生的充实和贫乏与勇气的大小成正比\n\n### 9、你会给刚刚毕业的大学生什么建议？你希望他们忽略什么建议？\n1. 愿意倾听那些持不同意见的人说的话。尝试每天改变你对一件事的看法；不要害怕犯错，因为犯错正是发现更多真相和成长的机会。\n2. 宏观上要有耐心，微观上要有效率。你们不应该关心接下来的8年会怎么样，而应该强调接下来的8天会怎么样。\n3. 一定要从事你并不胜任的工作，这样你才能不可避免地学到一些东西\n4. 不要去找自己的激情所在，而要掌握一些其他人认为有价值的技能、兴趣或知识。在开始时，什么技能、兴趣或知识都无关紧要，你不必喜欢它，但必须做到最好。一旦掌握了它，你就会获得新的机会，你就可以不再做你不喜欢的事情，转而做自己喜欢的事情。如果你能继续提高自己掌握的技能，最终你就会找到自己的激情\n5. 不要相信那些大师的话，不管是营销大师还是生活大师。凡是告诉你他知道的比你多的人，大部分都是想剥夺你的权利，因为他把你放在了低位，把自己放在了高位。\n6. 成功不应以挣到多少钱来衡量。真正的成功是做你热爱的事，并以此为生。\n\n### 10、有没有某次你发自内心喜欢甚至感恩的“失败”？\n1. 人们经常说好事多磨。我喜欢这句话。它告诉我，坚韧比天赋更重要，这句话在生活中更是千真万确。\n\n\n### 11、最近有哪个100美元以内的产品带给你惊喜感吗？\n\n\n## 我自己关于十个问题的回答\n### 1、你有没有什么离经叛道的习惯？\n\n### 2、你用什么方法重拾专注力？\n1. 感觉自己无法集中精神，就去健身房或者运动场跑步，出一身酣畅淋漓的汗水\n\n### 3、你长久以来坚持的人生准则是什么？\n1. 坚持长期主义，每天都要做重要但不紧急的事情：身体、精神、智力、情感（同理心、共情能力）\n\n\n### 4、在你的专业领域里，你都听过哪些糟糕的建议？\n1. 先熟悉某个领域，再熟悉上下游全栈，最后再反哺深耕某个领域\n\n### 5、你如何拒绝不想浪费精力和时间的人和事？\n1. 如果是因为恐惧或者同情而勉强答应别人，我会礼貌而坚定的拒绝\n\n### 6、你最常当作礼物送给他人的3本书是什么？\n\n### 7、你做过的最有价值的投资是什么？\n1. 从大学开始就坚持每周2次跑步+健身，第一可以减压提高注意力，第二可以锻炼身体\n\n### 8、有没有某个信念、行为或习惯真正改善了你的生活？\n1. 自己写博客， 博客内容是系统的介绍某个技术、读书笔记、技术的查缺补漏等等， 没事就在地铁上拿起来看看\n\n### 9、你会给刚刚毕业的大学生什么建议？你希望他们忽略什么建议？\n\n### 10、有没有某次你发自内心喜欢甚至感恩的“失败”？\n\n\n### 11、最近有哪个1000人民币以内的产品带给你惊喜感吗？","tags":["个人成长","巨人的方法","方法论","做事策略"]},{"title":"git常用操作命令","url":"/2022/07/01/git常用操作命令/","content":"\n## git流程图（图片来自网络）\n<img src=\"/img/git.jpg\" height = \"auto\" align=center />\n\n\n## 工作区\n### a、删除未跟踪的文件 untracked files\n```sh\n# 查看需要删除的文件\ngit clean -nfd\n\n# 确认删除文件\ngit clean -fd\n\n# 连gitignore的untrack 文件/目录也一起删掉\n#（慎用，一般这个是用来删掉编译出来或者node_modules的之类的文件用的）\ngit clean -xfd\n```\n\n### b、删除已跟踪的文件\n```sh\ngit checkout .\n```\n\n## 暂存区\n### a、取消暂存区已缓存的内容，修改前内容还在工作区\n```sh\ngit reset HEAD\n```\n\n### b、撤销丢弃所有文件修改，内容不在工作区\n```sh\ngit reset --hard HEAD\n```\n\n## 本地仓库\n### a、回退暂存区相关文件到上一个版本，内容还在工作区\n```sh\ngit reset HEAD^ #回退所有内容到上一个版本\ngit reset HEAD^ hello.php  # 回退hello.php文件的版本到上一个版本\ngit reset commitID hello.php # 回退hello.php文件的版本到某一个版本\n```\n\n### b、回退暂存区相关文件到上一个版本，内容不在工作区\n```sh\ngit reset HEAD^ --hard\n```\n## 远程仓库\n>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进\n\n### a、撤销revert\n```sh\n# git 日志会新增一条记录\ngit revert commitID (撤销指定的版本)\ngit push\n```\n\n### b、回退reset\n```sh\n# git日志不会新增一条记录，\n# 反而会把commitID之后的日志给删掉\ngit reset commitID (HEAD指向版本)\ngit push -f #此时如果用“git push”会报错，因为我们本地库HEAD指向的版本比远程库的要旧\n```\n\n## 分支\n### 创建新的分支，且关联远程\n```sh\ngit checkout -b branch_name origin/branch_name\n```\n\n### 本地没有分支，远程有\n```sh\n#自动跟踪远程的同名分支 branch_name\ngit checkout --track origin/branch_name\n```\n\n### 本地有分支，远程没有\n```sh\ngit push --set-upstream origin branch_name\n```\n\n### 删除本地分支\n```sh\ngit branch -d branch_name\n```\n\n### 删除远程分支\n```sh\ngit branch -r -d origin/branch-name\ngit push origin :branch-name\n```\n\n### dev分支合并到prod分支\n```sh\n# 切换到prod分支\ngit checkout prod\n\n# 拉取prod最新代码\ngit pull origin prod\n\n# dev分支合并到prod\ngit merge dev\n\n# 查看状态\ngit status\n```\n\n<br>\n\n1、 [rebase 和 merge 的区别](https://mp.weixin.qq.com/s/cOXKqYw-bzX1eiwFVx6KMg)","tags":["git"]},{"title":"前端沙箱","url":"/2022/06/28/前端沙箱/","content":"\n## 什么是沙箱？\n也称作：“沙箱/沙盒/沙盘”。沙箱是一种安全机制，为运行中的程序提供隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用。沙箱能够安全的执行不受信任的代码，且不影响外部实际代码影响的独立环境。\n\n## javascript中沙箱的使用场景\n1. 在线代码编辑器：相信大家都有使用过一些在线代码编辑器，而这些代码的执行，基本都会放置在沙箱中，防止对页面本身造成影响\n2. vue 模板中表达式计算：vue 模板中表达式的计算被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不能够在模板表达式中试图访问用户定义的全局变量。\n3. vue 的服务端渲染：vue 的服务端渲染实现中，通过创建沙箱执行前端的 bundle 文件；在调用 createBundleRenderer 方法时候，允许配置 runInNewContext 为 true 或 false 的形式，判断是否传入一个新创建的 sandbox 对象以供 vm 使用\n\n\n## javascript中沙箱实现\n\n### 一、跟浏览器宿主环境一致的沙箱实现\n#### 1.构建闭包环境\n我们知道在 JavaScript 中的作用域（scope）只有全局作用域（global scope）、函数作用域（function scope）以及从 ES6 开始才有的块级作用域（block scope）。\n\n```js\n(function foo(){\n    const a = 1;\n    console.log(a);\n })();// 无法从外部访问变量 \n \n console.log(a) // 抛出错误：\"Uncaught ReferenceError: a is not defined\"\n\n (function (window) {\n    var jQuery = function (selector, context) {\n        return new jQuery.fn.init(selector, context);\n    }\n    jQuery.fn = jQuery.prototype = function () {\n        //原型上的方法，即所有jQuery对象都可以共享的方法和属性\n    }\n    jQuery.fn.init.prototype = jQuery.fn;\n    window.jQeury = window.$ = jQuery; //如果需要在外界暴露一些属性或者方法，可以将这些属性和方法加到window全局对象上去\n})(window);\n\n\n// 当将 IIFE 分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果。\nconst result = (function () {\n    const name = \"张三\";\n    return name;\n})();\n\nconsole.log(result); // \"张三\"\n```\n#### 2.原生浏览器对象模拟\n模拟原生浏览器对象的目的是为了防止闭包环境，操作原生对象，篡改污染原生环境，完成模拟浏览器对象之前我们需要先关注几个不常用的 API。\n##### eval\neval 函数可将字符串转换为代码执行，并返回一个或多个值；eval代码内部可以沿着作用域链往上找，篡改全局变量。\n```js\nconst b = eval(\"({name:'张三'})\");\nconsole.log(b.name);\nconsole.log(eval( this.window === window )); // true\n```\n\n##### new Function\nFunction构造函数创建一个新的 Function 对象。直接调用这个构造函数可用于动态创建函数。\nnew Function ([arg1[, arg2[, ...argN]],] functionBody) \n```js\nconst sum = new Function('a', 'b', 'return a + b'); \nconsole.log(sum(1, 2));//3 \n\n\nlet a = 1;\nfunction sandbox() {\n    let a = 2;\n    return new Function('return a;'); // 这里的 a 指向最上面全局作用域内的 1\n}\nconst f = sandbox();\nconsole.log(f());\n```\n\n*与 eval 不同的是 Function 创建的函数只能在全局作用域中运行，它无法访问局部闭包变量，它们总是被创建于全局环境，**因此在运行时它们只能访问全局变量和自己的局部变量，不能访问它们被 Function 构造器创建时所在的作用域的变量。**new Function()是 eval()更好替代方案。它具有卓越的性能和安全性，但仍没有解决访问全局的问题。*\n\n##### with\nwith 是 JavaScript 中一个关键字，扩展一个语句的作用域链。它允许半沙盒执行。那什么叫半沙盒？语句将某个对象添加到作用域链的顶部，如果在沙盒中有某个未使用命名空间的变量，跟作用域链中的某个属性同名，则这个变量将指向这个属性值。如果沒有同名的属性，则将拋出 ReferenceError。\n```js\n// 严格模式下以下代码运行会有问题\nfunction sandbox(o) {\n    with (o){\n        c=2;\n        d=3;\n        // 0,1,2,3\n        // 每个变量首先被认为是一个局部变量，\n        // 如果局部变量与 obj 对象的某个属性同名，则这个局部变量会指向 obj 对象属性。        \n        console.log(a,b,c,d); \n    }\n}\nconst f = {\n    a:0,\n    b:1\n}\nsandbox(f);  \nconsole.log(f); // {a: 0, b: 1}\nconsole.log(c,d); // 2,3。  c、d被泄露到window对象上\n```\n> 究其原理，with在内部使用in运算符。对于块内的每个变量访问，它都在沙盒条件下计算变量。如果条件是 true，它将从沙盒中检索变量。否则，就在全局范围内查找变量。但是 with 语句使程序在查找变量值时，都是先在指定的对象中查找。所以对于那些本来不是这个对象的属性的变量，查找起来会很慢，对于有性能要求的程序不适合（JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符）。with 也会导致数据泄漏(在非严格模式下，会自动在全局作用域创建一个全局变量)\n\n##### with + new Function\n配合 with 用法可以稍微限制沙盒作用域，先从当前的 with 提供对象查找，但是如果查找不到依然还能从更上面的作用域获取，污染或篡改全局环境\n```js\nfunction sandbox (src) {\n    src = 'with (sandbox) {' + src + '}';\n    return new Function('sandbox', src);\n}\nconst str = `\n    let a = 1; \n    window.name=\"张三\"; \n    console.log(a); // 打印：1\n`;\nsandbox(str)({});\nconsole.log(window.name);//'张三'\n```\n\n**存在的问题：**\n1. eval 是全局对象的一个函数属性，执行的代码拥有着和应用中其它正常代码一样的的权限，它能访问「执行上下文」中的局部变量，也能访问所有「全局变量」，在这个场景下，它是一个非常危险的函数\n2. 使用 Function 构造器生成的函数，并不会在创建它的上下文中创建闭包，一般在全局作用域中被创建。当运行函数的时候，只能访问自己的本地变量和全局变量，不能访问 Function 构造器被调用生成的上下文的作用域\n3. with 一样的问题，它首先会在传入的对象中查找对应的变量，如果找不到就会往更上层的全局作用域去查找，所以也避免不了污染或篡改全局环境\n\n\n##### Proxy\nES6 Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，属于一种“元编程”\n```js\nfunction evalute(code,sandbox) {\n  sandbox = sandbox || Object.create(null);\n  const fn = new Function('sandbox', `with(sandbox){return (${code})}`);\n  const proxy = new Proxy(sandbox, {\n    has(target, key) {\n      // 让动态执行的代码认为属性已存在\n      return true; \n    }\n  });\n  return fn(proxy);\n}\nevalute('1+2') // 3\nevalute('console.log(1)') // Cannot read property 'log' of undefined\n```\n我们知道无论 eval 还是 function，执行时都会把作用域一层一层向上查找，如果找不到会一直到 global，那么利用 Proxy 的原理就是，让执行了代码在 sandobx 中找的到，以达到「防逃逸」的目的。\n\n\n#### 3.iframe的沙箱环境实现\n```js\nconst parent = window;\nconst frame = document.createElement('iframe');\n\n// 限制代码 iframe 代码执行能力\nframe.sandbox = 'allow-same-origin';\n\nconst data = [1, 2, 3, 4, 5, 6];\nlet newData = [];\n\n// 当前页面给 iframe 发送消息\nframe.onload = function (e) {\n  frame.contentWindow.postMessage(data);\n};\n\ndocument.body.appendChild(frame);\n\n// iframe 接收到消息后处理\nconst code = `\n    return dataInIframe.filter((item) => item % 2 === 0)\n`;\nframe.contentWindow.addEventListener('message', function (e) {\n  const func = new frame.contentWindow.Function('dataInIframe', code);\n  // 给副页面也送消息\n  parent.postMessage(func(e.data));\n});\n\n// 父页面接收 iframe 发送过来的消息\nparent.addEventListener(\n  'message',\n  function (e) {\n    console.log('parent - message from iframe:', e.data);\n  },\n  false,\n);\n```\n### 二、nodejs中沙箱实现\n#### vm\nVM是 Node.js 默认提供的一个内建模块，VM 模块提供了一系列 API 用于在 V8 虚拟机环境中编译和运行代码。JavaScript 代码可以被编译并立即运行，或编译、保存然后再运行。\n\n```js\nconst vm = require('vm');\nconst script = new vm.Script('m + n'); // 先new一个脚本执行的容器实例\nconst sandbox = { m: 1, n: 2 }; \nconst context = new vm.createContext(sandbox); // 实例化一个执行上下文\nconst res = script.runInContext(context); // 运行\nconsole.log(res); // 打印：3\n```\n\n#### vm2\n\n\n### 总结\n运行不信任的代码是非常困难的，只依赖软件模块作为沙箱技术，防止不受信任代码用于非正当用途是不得已的决定。这可能促使云上SAAS应用的不安全，因为通过逃逸出沙箱进程多个租户间的数据可能被访问（主进程数据获取），这样你就可能可以通过session，secret等来潜入其他租户。一个更安全的选择是依赖于硬件虚拟化，比如每个租户代码在独立的docker容器或AWS Lambada Function 中执行会是更好的选择。\n\n<br/>\n\n[文章来源](https://mp.weixin.qq.com/s/c9tMAZLvA3pI40qxZ2Zv5w)","tags":["前端沙箱","eval","new Function","with","iframe","proxy","vm"]},{"title":"javascript高级程序设计读书笔记","url":"/2022/06/21/javascript高级程序设计读书笔记/","content":"\n## 一、基本概念\n任何语言的核心都必然会描述这门语言最基本的工作原理。而描述的内容通常都要涉及这门语言的**语法、操作符、数据类型、内置功能等用于构建复杂解决方案的基本概念**。\n\n### 1、语法\n####  1.1 区分大小写\nECMAScript中的一切（变量、函数名和操作符）都区分大小写。这也就意味着，变量名test和变量名Test分别表示两个不同的变量。\n\n####  1.2  标识符\n第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；\n\n#### 1.3 语句\nECMAScript中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾。**加上分号也会在某些情况下增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了。**\n\n\n### 2、数据类型\n**JS基本数据类型：String、Number、Boolean、Undefined、Null、Symbol、BigInt；Object本质上是由一组无序的名值对组成的**\n\n**ECMAScript中也有一种复杂的数据类型，即Object类型，该类型是这门语言中所有对象的基础类型。**\n\n#### 2.1 typeof操作符\n对一个值使用typeof操作符可能返回下列某个字符串：\n\n1. \"undefined\"——如果这个值未定义；\n2. \"boolean\"——如果这个值是布尔值；\n3. \"string\"——如果这个值是字符串；\n4. \"symbol\"——如果这个值是symbol；\n5. \"number\"——如果这个值是数值；\n6. \"object\"——如果这个值是对象或null；\n7. \"function\"——如果这个值是函数。\n\n#### 2.2  Undefined类型\nUndefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。 \n\n对于尚未声明过的变量，只能执行一项操作，即使用typeof操作符检测其数据类型。 \n\n\n#### 2.3  Null类型\n从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值时会返回\"object\"的原因。\n\n```js\ntypeof null // 'object'\n```\n\n尽管null和undefined有这样的关系，但它们的用途完全不同。如前所述，无论在什么情况下都没有必要把一个变量的值显式地设置为undefined，可是同样的规则对null却不适用。**换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。**\n\n\n#### 2.4 Number类型\n\n##### 2.4.1 NaN\nNaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以非数值都会导致错误，从而停止代码执行。但在ECMAScript中，任何数值除以非数值会返回NaN，因此不会影响其他代码的执行。\n\nNaN与任何值都不相等，包括NaN本身\n\n\n##### 2.4.2 数值转换\nNumber()、parseInt()和parseFloat()\n\n**Number()函数的转换规则如下:**\n1. 如果是Boolean值，true和false将分别被转换为1和0。\n2. 如果是数字值，只是简单的传入和返回\n3. 如果是null值，返回0\n4. 如果是undefined，返回NaN。\n5. 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值\n6. 如果是字符串，遵循下列规则：\n   1. 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即\"1\"会变成1, \"123\"会变成123，而\"011\"会变成11（注意：前导的零被忽略了）；\n   2.  如果字符串中包含有效的浮点格式，如\"1.1\"，则将其转换为对应的浮点数值（同样，也会忽略前导零)\n   3.  如果字符串中包含有效的十六进制格式，例如\"0xf\"，则将其转换为相同大小的十进制整数值。\n\n\n**parseInt()函数**\nparseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。\n\n1. 如果第一个字符不是数字字符或者负号，parseInt()就会返回NaN；也就是说，用parseInt()转换空字符串会返回NaN（Number()对空字符返回0）\n2. 如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符\n\n\n**不指定基数意味着让parseInt()决定如何解析输入的字符串，因此为了避免错误的解析，我们建议无论在什么情况下都明确指定基数。**\n```js\nlet num1 = parseInt(\"10\", 2) // 2 按二进制解析\nlet num1 = parseInt(\"10\", 8) // 8 按八进制解析\nlet num1 = parseInt(\"10\", 10) // 10 按十进制解析\nlet num1 = parseInt(\"10\", 16) // 16 按十六进制解析\n```\n\n\n#### 2.5 String类型\n\n##### 2.5.1 转换为字符串\n\n要把一个值转换为一个字符串有三种方式：\n 1. 第一种是使用几乎每个值都有的toString()方法；\n 2. 在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String()，这个函数能够将任何类型的值转换为字符串。String()函数遵循下列转换规则\n    1. 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果；\n    2. 如果值是null，则返回\"null\"；\n    3. 如果值是undefined，则返回\"undefined\"。\n 3. 可以使用加号操作符把它与一个字符串（\"\"）加在一起\n\n\n#### 2.6 Object类型\n对象其实就是一组数据和功能的集合。\n\n**Object类型是所有它的实例的基础。换句话说，Object类型所具有的任何属性和方法也同样存在于更具体的对象中。**\n\n##### 2.6.1 创建\n```js\nlet o = new Object();\n\nlet o = new Object; // 有效，但是不推荐\n```\n\n##### 2.6.2 Object每个实例具有以下属性和方法\n1. constructor: 保存着用于创建当前对象函数， 对应当前的例子，构造函数（constructor）就是Object;\n2. hasOwnProperty(propertyName)： 用于检查给定的属性在当前对象实例中（而不是在实例原型中）是否存在；\n3. isPrototypeOf(object): 用于检查传入的对象是否是当前对象的原型；\n4. propertyIsEnumerable(propertyName): 用于检查给定的属性是否能够使用for-in语句来枚举;\n5. toString()：返回对象的字符串表示;\n6. valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。\n\n\n### 3、操作符\n#### 3.1 一元操作符\n##### 3.1.1 递增和递减操作符\n**前置递增和递减操作时，变量的值都是在语句被求值以前改变的；后置递增和递减与前置递增和递减有一个非常重要的区别，即递增和递减操作是在包含它们的语句被求值之后才执行的**\n\n```js\n// 前置\nlet num1 = 2;\nlet num2 = 20;\nlet num3 = --num1 + num2; // 21\nlet num4 = num1 + num2; // 21\n\n// 后置\nlet num1 = 2;\nlet num2 = 20;\nlet num3 = num1-- + num2; // 22\nlet num4 = num1 + num2; // 21\n```\n\n它们不仅适用于整数，还可以用于字符串、布尔值、浮点数值和对象\n1. 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减1的操作。字符串变量变成数值变量。\n2.  在应用于对象时，先调用对象的valueOf()方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是NaN，则在调用toString()方法后再应用前述规则。对象变量变成数值变量\n\n#### 3.2 位操作符\n\n#### 3.3 乘性操作符\n##### 3.3.1  乘法\n1. 如果有一个操作数是NaN，则结果是NaN；\n2. 如果是Infinity与0相乘，则结果是NaN； \n3. 如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号；\n4. 如果是Infinity与Infinity相乘，则结果是Infinity；\n5. 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。\n\n\n##### 3.3.2 求模\n\n```js\nlet result = 26 % 5; // 1\n```\n\n求模相关规则：\n1.  如果被除数是零，则结果是零\n2.  如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则\n\n\n#### 3.4 加性操作符\n##### 3.4.1 加法\n\n相关规则：\n1. 如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于undefined和null，则分别调用String()函数并取得字符串\"undefined\"和\"null\"。\n\n\n##### 3.4.2 减法\n\n相关规则：\n1. 如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN；\n2. 如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值\n\n\n### 4、流程控制语句\n#### 4.1 do-while语句\ndo-while语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。\n\n```js\nvar i = 0;\n\ndo {\n  i += 2;\n} while (i < 10)\n```\n\n#### 4.2 for语句\n由于ECMAScript中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问到。\n\n```js\nfor (var i=0; i<10; i++){\n   alert(i);\n}\nalert(i) // 9\n```\n\nfor语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这三个表达式全部省略，就会创建一个无限循环\n\n```js\nfor (; ;){\n   // 无限循环\n}\n```\n\n#### 4.3 for-in语句\nECMAScript对象的属性没有顺序。因此，通过for-in循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异\n\n\n#### 4.4 break和continue语句\nbreak语句会立即退出循环，强制继续执行循环后面的语句。而continue语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行\n\n\n#### 4.5 with语句\nwith语句的作用是将代码的作用域设置到一个特定的对象中；定义with语句的目的主要是为了简化多次编写同一个对象的工作\n\n```js\nvar qs=location.search.substring(1);\nvar hostName=location.hostname;\nvar url=location.href;\n\n// with语句\nwith(location){\n   var qs=search.substring(1);\n   var hostName=hostname;\n   var url=href;\n}\n```\n\nwith语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location对象中是否有同名的属性。如果发现了同名属性，则以location对象属性的值作为变量的值。 如果locaion没有在window全局对象找。\n\n\n#### 4.6 switch语句\n虽然ECMAScript中的switch语句借鉴自其他语言，但这个语句也有自己的特色。首先，可以在switch语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个case的值不一定是常量，可以是变量，甚至是表达式。\n\n\nswitch语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如，字符串\"10\"不等于数值10）。\n\n```js\nswitch (\"hello\"){\n  case \"hello\":\n   alert('hello');\n   break;\n  case \"good\":\n   alert(\"good\");\n   break;\n   default:\n      alert(\"wtf\");  \n}\n\n// 另外\nlet num = 1;\nswitch (true){\n  case num < 0:\n   alert('less than 0');\n   break;\n  case num >= 0 && num <= 10:\n   alert(\"between 0 and 10\");\n   break;\n   default:\n      alert(\"more than 10\");  \n}\n```\n\n### 5、函数\n\n#### 5.1 参数\nECMAScript函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数，在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不会有什么怨言。之所以会这样，原因是ECMAScript中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任何元素，无所谓；如果包含多个元素，也没有问题。实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。\n\n**arguments对象只是与数组类似（它并不是Array的实例），因为可以使用方括号语法访问它的每一个元素（即第一个元素是arguments[0]，第二个元素是arguments[1]，以此类推），使用length属性来确定传递进来多少个参数。**\n\n\n```js\nfunction doNum(num1, num2){\n   arguments[1] = 10;\n   return arguments[0] + num2;\n}\n\ndoNum(1, 2)  // 11\n```\n每次执行这个doAdd()函数都会重写第二个参数，将第二个参数的值修改为10。因为arguments对象中的值会自动反映到对应的命名参数，所以修改arguments[1]，也就修改了num2，结果它们的值都会变成10。不过，这并不是说读取这两个值会访问相同的内存空间；它们的内存空间是独立的，但它们的值会同步。\n\n\n没有传递值的命名参数将自动被赋予undefined值。这就跟定义了变量但又没有初始化一样。例如，如果只给doAdd()函数传递了一个参数，则num2中就会保存undefined值。\n\n**重点：ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。**\n\n#### 5.2 没有重载\nECMAScript函数不能像传统意义上那样实现重载。而在其他语言（如Java）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。如前所述，ECMAScirpt函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。\n\n\n## 二、变量、作用域和内存问题\nJavaScript的变量与其他语言的变量有很大区别。JavaScript变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。尽管从某种角度看，这可能是一个既有趣又强大，同时又容易出问题的特性，\n\n\n### 1、基本类型和引用类型的值\n#### 1.1 基本类型和引用类型的值\n\n基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。\n\n引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。\n\n##### 1.1.1 动态的属性\n\n我们不能给基本类型的值添加属性，尽管这样做不会导致任何错误； \n\n```js\nlet name = 'cha';\nname.age = 12;\nconsole.log(name.age) // undefined\n```\n\n##### 1.1.2 复制变量值\n当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量，\n\n```js\nvar obj1=new Object();\nvar obj2=obj1;\nobj1.name=\"Nicholas\";\nalert(obj2.name);   //\"Nicholas\"\n```\n\n<img src=\"/img/heap.jpeg\" width=\"95%\" height=\"auto\">\n\n\n##### 1.1.3 传递参数\nECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。\n\n```js\n// 基本类型\nfunction addTen(num){\n  num += 10;\n  return num;\n}\nvar count = 20;\nvar result = addTen(count);\nconsole.log(count); // 20\nconsole.log(result); // 30\n\n/**\n * 在这个函数内部，obj和person引用的是同一个对象\n */\n\n// 引用类型\nfunction setName(obj) {\n   obj.name = 'nick';\n}\nlet person = new Object();\nsetName(person);\nconsole.log(person.name) // nick\n\n\n\n/**\n *  这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。\n *  实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了。\n *  而这个局部对象会在函数执行完毕后立即被销毁。\n **/\n\n// 引用类型\nfunction setName(obj){\n  obj.name = 'nick';\n  obj = new Object();\n  obj.name = 'greg';\n}\n\nlet person = new Object();\nsetName(person);\nconsole.log(person.name); // nick\n```\n\n关于引用类型错误的理解：\n\n因为person指向的对象在堆内存中只有一个，而且是全局对象。有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的。\n\n关于引用类型正确理解：\n\n在把person传递给setName()后，其name属性被设置为\"Nicholas\"。然后，又将一个新对象赋给变量obj，同时将其name属性设置为\"Greg\"。如果person是按引用传递的，那么person就会自动被修改为指向其name属性值为\"Greg\"的新对象。但是，当接下来再访问person.name时，显示的值仍然是\"Nicholas\"\n\n\n##### 1.1.4 检测类型\n\ntypeof操作符是确定一个变量是字符串、数值、布尔值，还是undefined的最佳工具。如果变量的值是一个对象或null，则typeof操作符会像下面例子中所示的那样返回\"object\"。\n\n所有引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回true。\n\n```js\n// 无法区分Object 和 其他类型\n{} instanceof Object // true\n[] instanceof Object // true\n[] instanceof Array // true\nnew RegExp() instanceof Object // true\nnew RegExp() instanceof RegExp // true\n```\n\n\n### 2、执行环境和作用域\n执行环境（execution context，为简单起见，有时也称为“环境”）是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。\n\n内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。\n\n#### 2.1 延长作用域链\n\n\n#### 2.2 没有块级作用域（es6 let实现）\n这里是在一个if语句中定义了变量color。如果是在C、C++或Java中，color会在if语句执行完毕后被销毁。但在JavaScript中，if语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。在使用for语句时尤其要牢记这一差异\n\n```js\nfor (var i=0; i < 10; i++){\n   doSomething(i);\n}\nalert(i);        //10\n```\n\n### 3、垃圾回收\n这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作。\n\n#### 3.1 标记清除\n\n#### 3.2 引用计数\n\n#### 3.3 性能问题\n\n#### 3.4  管理内存\n\n解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。\n\n```js\nfunction createPerson(name){\n   var localPerson=new Object();\n   localPerson.name=name;\n   return localPerson;\n}\n\n\nvar globalPerson=createPerson(\"Nicholas\");\n\n\n// 手工解除globalPerson的引用\nglobalPerson=null;\n```\n## 三、引用类型\n### 1、Object类型\n\n### 2、Array类型\n#### 2.1 创建\n\n```js\nlet color = new Array(3); // 创建包含3项数组\nlet color = new Array(\"red\"); // 创建一个包含1项， 即字符串：red\n\n// 与对象一样，在使用数组字面量表示法时，也不会调用Array构造函数\nlet color = [\"red\"];\n\n// 数组length可读可写， 可以从数组的末尾移除项或向数组中添加新项\nlet colors = ['red', 'green', 'yellow'];\ncolors.length = 2; // console.log(colors[2]) undefined\n\ncolors[colors.length] = 'yellow'; // 添加数组\ncolors.length = 4; // console.log(colors[3]) undefined\n```\n\n#### 2.2 检测数组\n\n```js\n// 方法一\narr instanceof Array\n\n// 方法二\nArray.isArray(arr)\n\n// 方法三\nObject.prototype.toString.call(arr) === '[object Array]'\n```\n\n#### 2.3 数组api\n\n**栈方法**\n\n具体说来，数组可以表现得就像栈一样，后者是一种可以限制插入和删除项的数据结构。栈是一种LIFO（Last-In-First-Out，后进先出）的数据结构，也就是最新添加的项最早被移除。push(推入最后一项) 和 pop (获取最后一项) \n\n**队列方法**\n\n队列数据结构的访问规则是FIFO（First-In-First-Out，先进先出） unshift(推入第一项) 和 pop(获取最后一项)\n\n**重排序方法**\n\nreverse()方法会反转数组项的顺序\n\n**sort()方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串**\n\n```js\n[0, 1, 5, 10, 15].sort() // [0, 1, 10, 15, 5]\n\n[0, 1, 5, 10, 15].sort(function(a,b){\n   if(a < b){\n     return -1;\n   }else if(a > b){\n     return 1;\n   }else{\n      return 0;\n   }\n})\n\n```\n\n**操作方法**\n\nconcat()方法可以基于当前数组中的所有项创建一个新数组,具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。\n\n\n**slice()：它能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。注意，slice()方法不会影响原始数组。**\n\n```js\nlet color = [1, 2, 3];\nlet color2 = color.slice(1); // color不变， color2:[2, 3]\n```\n\n\n**splice()：这个方法恐怕要算是最强大的数组方法了，它有很多种用法。splice()的主要用途是向数组的中部插入项。splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）, 且会改变原数组**\n\n1.  删除：可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。例如，splice(0,2)会删除数组中的前两项。\n2.  插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2,0, \"red\", \"green\")会从当前数组的位置2开始插入字符串\"red\"和\"green\"\n3.  替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1, \"red\", \"green\")会删除当前数组位置2的项，然后再从位置2开始插入字符串\"red\"和\"green\"\n\n```js\n// 删除\nlet color = [1, 2, 3, 4];\nlet color1 = color.splice(0, 1); // color: [2, 3, 4] color1: [1]\n\n// 插入\nlet color3 = [1,2,3,4]; \nlet color4 = color3.splice(1,0,'a', 'b'); // color3:[ 1, 'a', 'b', 2, 3, 4 ]  color4: []\n\n\n//替换\nlet color5 = [1,2,3,4]; \nlet color6 = color5.splice(1,1,'a'); // color5:[ 1, 'a', 3, 4 ] color6: [2]\n```\n\n\n**迭代方法**\n\n1.  every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。\n2.  some()： 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。 \n3.  filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。\n4.  forEach()：对数组中的每一项运行给定函数。这个方法没有返回值\n5.  map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。\n\n\n```js\n// filter\nlet num = [1, 2, 3, 4, 5];\nnum.filter((item. index, array)=>{\n   return item > 2;\n});\nconsole.log(num) // [3, 4, 5]\n\n// map\nlet num1 = [1, 2, 3, 4, 5];\nnum1.map((item. index, array)=>{\n   return item *2;\n});\nconsole.log(num1) // [2, 4, 6, 8, 10]\n```\n\n\n**归并方法**\n\nreduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。\n\n```js\n// 数组之和\nlet values = [1, 2, 3, 4, 5];\n// 累积器，它在每次回调执行时记录累积的结果\n// 当前值、\n// 当前项的索引\n// 数组对象\nlet sum = values.reduce((acc, cur, index, array)=>{\n   console.log(acc, cur, index, array); // acc ==> 0 1 3 6 10 15\n   return acc + cur;\n}, 0);  // 0为acc的初始值， 如果未设置则为空\n\nconsole.log(sum) // 15\n```\n\n### 3、Date类型\nECMAScript中的Date类型是在早期Java中的java.util.Date类基础上构建的。为此，Date类型使用自UTC（Coordinated Universal Time，国际协调时间）1970年1月1日午夜（零时）开始经过的毫秒数来保存日期。在使用这种数据存储格式的条件下，Date类型保存的日期能够精确到1970年1月1日之前或之后的100000000年。\n\n#### 3.1 Date.now()\nECMAScript 5添加了Date.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。\n\n```js\n//取得开始时间\nvar start=Date.now();\n\n\n//调用函数\ndoSomething();\n\n\n//取得停止时间\nvar stop=Date.now(),\n    result=stop - start;\n```\n\n支持Date.now()方法的浏览器包括IE9+、Firefox 3+、Safari 3+、Opera 10.5和Chrome。在不支持它的浏览器中，使用+操作符获取Date对象的时间戳，也可以达到同样的目的。\n\n```js\n//取得开始时间\nvar start=+new Date();\n\n\n//调用函数\ndoSomething();\n//取得停止时间\nvar stop=+new Date(),\n    result=stop - start;\n```\n\n#### 3.2 继承\n与其他引用类型一样，Date类型也重写了**toLocaleString()、toString()和valueOf()**方法；但这些方法返回的值与其他类型中的方法不同。Date类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM或PM，但不会包含时区信息（当然，具体的格式会因浏览器而异）。而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0到23）表示。下面给出了在不同浏览器中调用toLocaleString()和toString()方法，输出PST（Pacific Standard Time，太平洋标准时间）时间2007年2月1日午夜零时的结果。\n\n### 4、RegExp类型\n#### 4.1 RegExp类型\n\n```js\nlet expression = /pattern/flags;\n```\n\n其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。正则表达式的匹配模式支持下列3个标志。\n\ng：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；\n\ni：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；\n\nm：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。\n\n\n**与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：**\n\n```js\n( [ { \\ ^ $ | ) ? * + . ] } \n```\n\n#### 4.2 RegExp实例属性\n\nglobal：布尔值，表示是否设置了g标志。\n\nignoreCase：布尔值，表示是否设置了i标志。\n\nlastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。\n\nmultiline：布尔值，表示是否设置了m标志。\n\nsource：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。\n\n```js\nlet pattern1 = /\\[bc\\]at/i\nconsole.log(pattern1.global); // false\nconsole.log(pattern1.ignoreCase); // true\n\n\nlet pattern2 = new RegExp(\"\\\\[bc\\\\]at\", \"i\");\nconsole.log(pattern2.global); // false\nconsole.log(pattern2.ignoreCase); // true\n```\n\n#### 4.3 RegExp实例方法\n\nexec()\n\n```js\n// 待补充\n```\n\ntest()\n\n```js\nlet text = \"000-00-0000\";\nlet pattern = /\\d{3}-\\d{2}-\\d{4}/;\npattern.test(text) // true\n```\n\n\n### 5、Function类型\n函数实际上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。\n\n```js\n// 创建函数方法一\nfunction sum (num1, num2){\n   return num1 + num2;\n}\n\n// 创建函数方法二\nlet sum = function (num1, num2) {\n    return num1 + num2;  \n}\n\n/**\n *\n * 从技术角度讲，这是一个函数表达式。但是，我们不推荐读者使用这种方法定义函数，\n * 因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串），\n * 从而影响性能。不过，这种语法对于理解“函数是对象，函数名是指针”的概念倒是非常直观的。\n * */\n\n// 创建函数方法三，不推荐\nlet sum = new Function(\"num1\", \"num2\", \"return num1 + num2\"); \n```\n\n#### 5.1 没有重载\n这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。**在创建第二个函数时，实际上覆盖了引用第一个函数的变量addSomeNumber。**\n\n```js\nfunction addSomeNumber(num){\n    return num+100;\n}\n\nfunction addSomeNumber(num) {\n    return num+200;\n}\n\nvar result=addSomeNumber(100); //300\n```\n\n#### 5.2 函数声明和函数表达式\n解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。**解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。**\n\n```js\n/**\n * 因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升\n * （function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。\n */\n\nalert(sum(10, 10));\nfunction sum (num1, num2){\n   return num1 + num2;\n}\n```\n\n```js\n/**\n * 在执行到函数所在的语句之前，变量sum中不会保存有对函数的引用；\n */ \nalert(sum(10, 10));\nlet sum = function (num1, num2){\n   return num1 + num2;\n}\n```\n\n#### 5.3 作为值的函数\n\n#### 5.4 函数内部属性\n在函数内部，有两个特殊的对象：arguments和this。其中，arguments在第3章曾经介绍过，它是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。请看下面这个非常经典的阶乘函数。\n\n```js\nfunction factorial(num){\n  if(num <= 1){\n   return 1;\n  }else {\n   return num * arguments.callee(num - 1);\n  }\n}\n```\n\nthis的指向：由于在调用函数之前，this的值并不确定，因此this可能会在代码执行过程中引用不同的对象。\n\n```js\nwindow.color = 'red';\nlet o = {color: 'blue'};\n\nfunction sayColor(){\n   console.log(this.color);\n}\nsayColor(); // red\n\n\no.sayColor = sayColor;\no.sayColor(); // blue\n```\n\n#### 5.5 函数的属性和方法\nECMAScript中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length和prototype。其中，length属性表示函数希望接收的命名参数的个数。\n\n**在ECMAScript核心所定义的全部属性中，最耐人寻味的就要数prototype属性了。对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的（第6章将详细介绍）。在ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。**\n\n\n##### 5.1.1 call 和 apply\n\n每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。\n\n```js\n// apply\nfunction sum(num1, num2){\n   return num1 + num2;\n}\n\n/**\n *  callSum1()在执行sum()函数时传入了this作为this值\n   （因为是在全局作用域中调用的，所以传入的就是window对象）和arguments对象\n */ \nfunction callSum1(num1, num2){\n   return sum.apply(this, arguments);\n}\n\nfunction callSum2(num1, num2){\n   return sum.apply(this, [num1, num2]);\n}\n\ncallSum1(10, 10);  // 20\ncallSum2(10, 10);  // 20\n\n\n/**\n * 除了参数传递，最主要的是对象冒充（扩充函数作用域）\n */ \nwindow.color = 'red';\nlet o = {\n   color: 'blue'\n}\n\nfunction sayColor(){\n   console.log(this.color);\n}\n\nsayColor(); // red\n\nsayColor.call(window) // red\nsayColor.call(o) // blue\n```\n\n##### 5.1.2 bind\nECMAScript 5还定义了一个方法：bind()。这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。\n\n```js\nwindow.color = 'red';\nlet o = {\n   color: 'blue'\n}\nfunction sayColor(){\n   console.log(this.color);\n}\nlet a = sayColor.bind(o);\na() // blue\n```\n\n### 6、基本包装类型\n为了便于操作基本类型值，ECMAScript还提供了3个特殊的引用类型：Boolean、Number和String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。\n\n```js\nlet s1 = 'some text';\nlet s2 = s1.subString(2);\n```\n我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。\n其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。**当第二行代码访问s1时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理：**\n\n(1) 创建String类型的一个实例；\n\n(2) 在实例上调用指定的方法；\n\n(3) 销毁这个实例。\n\n```js\nvar s1=new String(\"some text\");\nvar s2=s1.substring(2);\ns1=null;\n```\n\n**引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。**\n\n```js\nvar s1=\"some text\";\ns1.color=\"red\";\nalert(s1.color);    //undefined\n```\n\nObject构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。\n\n```js\nvar obj=new Object(\"some text\");\nalert(obj instanceof String);    //true\nalert(obj instanceof Object);    //true\n```\n\n使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。 \n在下面例子中，变量number中保存的是基本类型的值25，而变量obj中保存的是Number的实例。\n\n```js\nvar value=\"25\";\nvar number=Number(value);   //转型函数\nalert(typeof number);          //\"number\"\n\n\nvar obj=new Number(value); //构造函数\nalert(typeof obj);              //\"object\"\n```\n#### 6.1 Boolean类型\n\n#### 6.2 Number类型\n具体来讲，就是在使用typeof和instanceof操作符测试基本类型数值与引用类型数值时，得到的结果完全不同。\n\n```js\nvar numberObject=new Number(10);\nvar numberValue=10;\nalert(typeof numberObject);    //\"object\"\nalert(typeof numberValue);     //\"number\"\nalert(numberObject instanceof Number);   //true\nalert(numberValue instanceof Number);    //false\n```\n\n#### 6.3 String类型\n\n### 7、单体内置对象\n由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。\n意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。前面我们已经介绍了大多数内置对象，例如Object、Array和String。ECMA-262还定义了两个单体内置对象：Global和Math。\n\n#### 7.1 Global对象\n所有在全局作用域中定义的属性和函数，都是Global对象的属性。本书前面介绍过的那些函数，诸如isNaN()、isFinite()、parseInt()以及parseFloat()，实际上全都是Global对象的方法。除此之外，Global对象还包含其他一些方法：\n\n1. URI编码方法：encodeURI()和encodeURIComponent()\n\n**encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。**\n\n**一般来说，我们使用encodeURIComponent()方法的时候要比使用encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础URI进行编码。**\n\n1. eval()方法\n\n2. Global对象的属性\n   \n3. window对象\nECMAScript虽然没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window对象的属性\n\nJavaScript中的window对象除了扮演ECMAScript规定的Global对象的角色外，还承担了很多别的任务。第8章在讨论浏览器对象模型时将详细介绍window对象.\n\n#### 7.2 Math对象\n1. min()和max()方法\n\n```js\nvar values=[1, 2, 3, 4, 5, 6, 7, 8];\nvar max=Math.max.apply(Math, values);\n```\n\n2.  Math.ceil()执行向上舍入\n3.  Math.floor()执行向下舍入\n4.  Math.round()执行标准舍入\n\n\n### 8、总结\n**Object是一个基础类型，其他所有类型都从Object继承了基本的行为**\n\n**函数实际上是Function类型的实例，因此函数也是对象；而这一点正是JavaScript最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。**\n\n在所有代码执行之前，作用域中就已经存在两个内置对象：Global和Math。在大多数ECMAScript实现中都不能直接访问Global对象；不过，Web浏览器实现了承担该角色的window对象。\n\n\n\n## 四、面向对象程序设计（重要知识点）\n### 1、理解对象\n早期的JavaScript开发人员经常使用这个模式创建新对象。几年后，对象字面量成为创建这种对象的首选模式。\n\n```js\n let person = new Object();\n person.name = 'fc';\n person.sayName = function (){};\n\n// 字面量\nlet person={\n    name: \"fc\",\n    sayName: function(){}\n};\n```\n\n#### 1.1 属性类型\n\n1. 数据属性\n要修改属性默认的特性，必须使用ECMAScript 5的Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。\n\n```js\nlet person = {};\nObject.defineProperty(person, 'name', { \n    configurable: false, // 无法删除对象属性\n    value: 'fc',\n    writable: false, // 无法修改对象属性的值\n    enumerable: true, // 表示能通过for-in循环返回属性\n})\n```\n\n2. 访问器属性\n访问器属性不包含数据值；它们包含一对儿getter和setter函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。\n\n不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了getter函数的属性会抛出错误。类似地，只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，而在严格模式下会抛出错误。\n\n\n#### 1.2 Object.definePropert\n```js\nlet person = {\n   name: 'fc',\n   say: 1\n};\nObject.defineProperty(person, 'year', { \n    get: function() {\n       return this.name;\n    },\n    set: function(newValue) {\n        if(newValue > 38){\n          this.say = 2;\n          this.name = 'fc1';\n        }\n    }\n})\nperson.year = 39;\n```\n\n#### 1.3 Object.getOwnPropertyDescriptor\n这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable和value。\n\n\n\n### 2、创建对象\n虽然Object构造函数或对象字面量都可以用来创建单个对象，**但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。**为解决这个问题，人们开始使用工厂模式的一种变体。\n\n#### 2.1 工厂模式\n\n```js\nfunction createPerson(name, age, job){\n   let o = new Object();\n   o.name = name;\n   o.age = age;\n   o.job = job;\n   o.sayName = function (){\n      return this.name;\n   }\n   return o;\n}\n\nlet p1 = createPerson('f', 12, 'sf');\nlet p2 = createPerson('a', 13, 'sf');\n```\n\n可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。**工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）**\n\n\n#### 2.2 构造函数模式\n\n```js\n// 按照惯例，构造函数始终都应该以一个大写字母开头\nfunction Person(name, age, job){\n   this.name = name;\n   this.age = age;\n   this.job = job;\n   this.sayName = function (){\n      console.log(this.name);\n   }\n}\n\nlet p1 = new Person('f', 12, 'sf');\nlet p2 = new Person('fc', 13, 'sf')\n```\n\n##### 2.2.1 构造函数模式和工厂模式区别\n\n1. 没显示地创建对象\n2. 直接将属性和方法赋给this对象\n3. 没有return语句\n\n\n**创建Person新实例，必须使用new操作符。调用构造函数会经历一下4个步骤：**\n\n1. 创建一个新对象\n2. 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）\n3. 执行构造函数的代码（为这个新对象添加属性）\n4. 返回新对象\n\n##### 2.2.2 constructor\n\n```js\n// p1和p2分别保存着Person的一个不同的实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person\np1.constructor == Person // true\np2.constructor == Person // true\n```\n\n##### 2.2.3 instanceof\n```js\nalert(p1 instanceof Object);   //true\nalert(p2 instanceof Person);   //true\nalert(p1 instanceof Object);   //true\nalert(p2 instanceof Person);   //true\n```\n\n创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。在这个例子中，p1和p2之所以同时是Object的实例，是因为所有对象均继承自Object。\n\n\n##### 2.2.4 将构造函数当作函数\n构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过new操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过new操作符来调用，那它跟普通函数也不会有什么两样。\n\n```js\n// 当做构造函数使用\nlet p1 = new Person('f', 12, 'sf');\np1.sayName(); // f\n\n// 当做普通函数使用\nPerson('Greg', 12, 'sf'); // 添加到window\nwindow.sayName() // Greg\n\n// 在另一个对象作用域调用(call/apply)\nlet o = {};\nPerson.call(o, 'frany', 24, 'sf');\no.sayName(); // frany\n```\n\n##### 2.2.5 构造函数的问题\n1. 每个方法都要在每个实例上重新创建一遍。在前面的例子中，p1和p2都有一个名为sayName()方法。\n\n```js\nfunction Person(name, age, job){\n   this.name=name;\n   this.age=age;\n   this.job=job;\n   this.sayName=new Function(\"alert(this.name)\"); // 与声明函数在逻辑上是等价的\n}\n\nconsole.log(p1.sayName == p2.sayName) // false, 不同实例上的同名函数是不相等的\n```\n\n```js\nfunction Person(name, age, job){\n   this.name=name;\n   this.age=age;\n   this.job=job;\n   this.sayName=sayName;\n}\n\nfunction sayName(){\n  this.name = name;\n}\n\nconsole.log(p1.sayName == p2.sayName) // true, 但是多了全局对象，没有封装性\n```\n#### 2.3 原型模式\n我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是**包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。**\n\n```js\nfunction Person() {\n\n}\nPerson.prototype.name = 'Greg';\nPerson.prototype.age = 24;\nPerson.prototype.job = 'software engineer';\nPerson.prototype.sayName = function (){\n   console.log(this.name);\n}\n\nlet p1 = new Person();\np1.sayName(); // Greg \n\nlet p2 = new Person();\np2.sayName(); //Greg\n\n// 但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。\n// 换句话说，p1和p2访问的都是同一组属性和同一个sayName()函数。\nconsole.log(p1.sayName == p2.sayName) //true\n```\n\n##### 2.3.1 理解原型对象\n在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性是一个指向prototype属性所在函数的指针。就拿前面的例子来说，Person.prototype.constructor指向Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。\n\n使用hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。\n\n```js\nfunction Person() {\n\n}\nPerson.prototype.name = 'Greg';\nPerson.prototype.age = 24;\nPerson.prototype.job = 'software engineer';\nPerson.prototype.sayName = function (){\n   console.log(this.name);\n}\n\nlet p1 = new Person();\n\nconsole.log(p1.hasOwnProperty('name')); // false\n\np1.name = 'fr'; \nconsole.log(p1.hasOwnProperty('name')); // true\n\ndelete p1.name;\nconsole.log(p1.name); // Greg\nconsole.log(p1.hasOwnProperty('name')); // false\n```\n\n<img src=\"/img/prototype.jpeg\" width=\"95%\">\n\n\n##### 2.3.2 原型与in操作符\n有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独使用时，in操作符会在通过对象能够访问给定属性时返回true，**无论该属性存在于实例中还是原型中。**\n\n```js\n// 判断属性是否在原型中\nfunction hasPrototypeProperty(object, name) {\n   return !(object.hasOwnProperty(name)) && (name in object);\n}\n```\n\n要取得对象上**所有可枚举的实例属性**，可以使用ECMAScript 5的Object.keys()方法。\n\n```js\nfunction Person() {\n\n}\nPerson.prototype.name = 'Greg';\nPerson.prototype.age = 24;\nPerson.prototype.job = 'software engineer';\nPerson.prototype.sayName = function (){\n   console.log(this.name);\n}\n\nObject.keys(Person.prototype); // name, age, job, sayName\n\n// 如果你想要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。\nObject.getOwnPropertyNames(Person.prototype); // constructor, name, age, job, sayName\n\nlet p1 = new Person(); \np1.name = 'f';\np1.age = 12;\n\nObject.keys(p1); // 只显示实例属性 name, age \n```\n##### 2.3.3 更简单的原型语法\n\nconstructor属性不再指向Person了。前面曾经介绍过，每创建一个函数，就会同时创建它的prototype对象，这个对象也会自动获得constructor属性。而我们在这里使用的语法，**本质上完全重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性（指向Object构造函数），不再指向Person函数。** 此时，尽管instanceof操作符还能返回正确的结果，但通过constructor已经无法确定对象的类型了。\n\n```js\nfunction Person(name, age, job){\n    this.name = name;\n    this.age = age;\n    this.job = job;\n}\n// 注意：重写了prototype对象\nPerson.prototype = {\n   // constructor: Person,  重新设置constructor指向，但是有个问题？\n   say: function(){\n      console.log(`name:${this.name}; age:${this.age}; job: ${this.job}`);\n   }\n}\n\nlet p1 = new Person('fc', 12, 'SE');\n\np1 instanceof Person // true\np1 instanceof Object // true\np1.constructor == Person // false\np1.constructor == Object // true\n```\n\n以这种方式重设constructor属性会导致它的[[Enumerable]]特性被设置为true。默认情况下，原生的constructor属性是不可枚举的，因此如果你使用兼容ECMAScript 5的JavaScript引擎，可以试一试Object.defineProperty()。\n\n```js\n//重设构造函数，只适用于ECMAScript 5兼容的浏览器\nObject.defineProperty(Person.prototype, \"constructor\", {\n   enumerable: false,\n   value: Person\n});\n```\n\n##### 2.3.4 原型的动态性\n由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。\n\n原因可以归结为实例与原型之间的松散连接关系。当我们调用p1.say()时，首先会在实例中搜索名为say的属性，在没找到的情况下，会继续搜索原型。因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的say属性并返回保存在那里的函数。\n\n```js\nfunction Person(){}\n\nlet p1 = new Person();\n\nPerson.prototype.say = function(){\n   console.log('hi');\n}\n\np1.say(); // hi\n```\n\n如果重写原型对象呢？\n\n```js\nfunction Person(){\n\n}\n\nlet p1 = new Person();\n\n// 注意， 这里是重写了Person.prototype对象!!\nPerson.prototype = {\n   constructor: Person,\n   name: 'fc',\n   age: 12,\n   job: 'se',\n   sayName: function(){\n      console.log(this.name);\n   }\n}\n/**\n * Error原因是重写了原型对象。 \n * 实例中的指针仅指向原型(Person.prototype)，\n * 而不在指向构造函数（Person）\n */\np1.sayName() // Error\n```\n\n调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。请记住：实例中的指针仅指向原型，而不指向构造函数。\n\n<img src=\"/img/prototype1.jpeg\" width=\"95%\">\n\n从上图可见，重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。\n\n\n\n##### 2.3.5 原生对象的原型\n原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。例如，在Array.prototype中可以找到sort()方法，而在String.prototype中可以找到substring()方法。\n\n通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。\n\n尽管可以这样做，但我们不推荐在产品化的程序中修改原生对象的原型。如果因某个实现中缺少某个方法，就在原生对象的原型中添加这个方法，那么当在另一个支持该方法的实现中运行代码时，就可能会导致命名冲突。而且，这样做也可能会意外地重写原生方法。\n\n##### 2.3.6 原型对象的问题\n原型模式的最大问题是由其共享的本性所导致的。\n\n原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，对于包含引用类型值的属性来说，问题就比较突出了。\n\n```js\nfunction Person(){\n\n}\n\nPerson.prototype = {\n   constructor: Person,\n   name: 'fc',\n   age: 12,\n   friends: ['Greg', 'simon'],\n   sayName: function(){\n      console.log(this.name);\n   }\n}\n\nlet p1 = new Person();\nlet p2 = new Person();\n\np1.friends.push('Franky');\n\np1.friends // ['Greg', 'simon', 'Franky']\np2.friends // ['Greg', 'simon', 'Franky']\np1.friends === p2.friends // true\n```\n\n**由于friends数组存在于Person.prototype而非p1中，所以刚刚提到的修改也会通过p2.friends（与p1.friends指向同一个数组）反映出来。**\n\n### 3、继承\n许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，在ECMAScript中无法实现接口继承。**ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。**\n\n#### 3.1 原型链继承\nECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。**其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。**\n\n构造函数、原型、实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针\n\n```js\n// 原型链继承模型如下：\n\n// 父类\nfunction SuperType(){\n   this.property = true;\n}\n\nSuperType.prototype.getSuperValue = function (){\n   return this.property;\n}\n\n// 子类\nfunction SubType(){\n  this.subproperty = false;\n}\n\n/**\n * 继承是通过创建SuperType的实例,\n * 并将该实例赋给SubType.prototype实现的\n */\nSubType.prototype = new SuperType(); \n\nSubType.prototype.getSubValue = function (){\n   return this.subproperty;\n}\n\n// 实例\nlet instance = new SubType();\nconsole.log(instance.getSuperValue());  // true  继承父类方法\nconsole.log(instance.getSubValue());   // false\n```\n\n**原型链继承实现的本质是重写原型对象，代之以一个新类型的实例。**换句话说，原来存在于SuperType的实例中的所有属性和方法，现在也存在于SubType.prototype中了。\n\n原型链继承实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于SuperType的实例中的所有属性和方法，现在也存在于SubType.prototype中了。\n\n<img src=\"/img/prototype2.jpeg\" width=\"95%\" height=\"auto\">\n\n调用instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索SubType.prototype;3）搜索SuperType.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。\n\n\n##### 3.1.1 对象默认的原型\n**我们知道，所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。**\n所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。\n\n<img src=\"/img/prototype3.jpeg\" width=\"95%\" height=\"auto\">\n\nSubType继承了SuperType，而SuperType继承了Object。当调用instance.toString()时，实际上调用的是保存在Object.prototype中的那个方法\n\n##### 3.1.2 原型和实例的关系\n```js\n// 1、instanceof\ninstance instanceof Object // true\ninstance instanceof SuperType // true\ninstance instanceof SubType // true\n\n\n// 2、isPrototypeOf()\nObject.prototype.isPrototypeOf(instance) // true\nSuperType.prototype.isPrototypeOf(instance) // true\nSubType.prototype.isPrototypeOf(instance) // true\n```\n\n##### 3.1.3 谨慎地定义方法\n```js\n// 1、覆盖父类的方法和属性\n// todo\n\n\n// 2、使用字面量穿件原型链，会重写原型链\nfunction SuperType(){\n   this.property = true;\n}\nSuperType.prototype.getSuperValue = function (){\n   return this.property;\n}\n\n\nfunction SubType(){\n  this.subproperty = false;\n}\nSubType.prototype = {\n   getSubValue: function (){\n      return this.subproperty;\n   },\n   otherMethod: function(){\n      return false;\n   }\n}\n\nlet instance = new SubType();\nconsole.log(instance.getSuperValue()); // error\n```\n\n以上代码展示了刚刚把SuperType的实例赋值给原型，紧接着又将原型替换成一个对象字面量而导致的问题。由于现在的原型包含的是一个Object的实例，而非SuperType的实例，因此我们设想中的原型链已经被切断——SubType和SuperType之间已经没有关系了。\n\n##### 3.1.4 原型链的问题\n问题一：原型中包含引用类型值（数组）的原型属性会被所有实例共享。想必大家还记得，我们前面介绍过包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。**于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。** （这里需要仔细思考下）\n\n问题二：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。\n\n```js\nfunction SuperType(){\n  this.colors = ['red', 'green'];\n}\n\nfunction SubType(){\n\n}\n\n// SubType原型属性 继承 SuperType实例属性 （这是重点)\nSubType.prototype = new SuperType();\n\nlet instance1 = new SubType();\ninstance1.colors.push('blue');\nconsole.log(instance1.colors); // ['red', 'green', 'blue']\n\nlet instance2 = new SubType();\nconsole.log(instance2.colors); // ['red', 'green', 'blue']\n```\n\n#### 3.2 借用构造函数继承（call/apply）\n**在解决原型中包含引用类型值所带来问题的过程中**，开发人员开始使用一种叫做借用构造函数的技术（有时候也叫做伪造对象或经典继承）。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。\n\n```js\nfunction SuperType(){\n   this.colors = ['red', 'green', 'yellow'];\n}\n\nfunction SubType(){\n   // SubType 继承 SuperType\n   SuperType.call(this);\n}\n\nlet instance1 = new SubType();\ninstance1.colors.push('black'); //['red', 'green', 'yellow', 'black']\n\nlet instance2 = new SubType();\ninstance1.colors // ['red', 'green', 'yellow']\n```\n\n我们实际上是在（未来将要）新创建的SubType实例的环境下调用了SuperType构造函数。这样一来，就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType的每个实例就都会具有自己的colors属性的副本了。\n\n###### 3.2.1 好处（相对于原型支持传参）\n```js\nfunction SuperType(colors){\n   this.colors = colors;\n}\n\nfunction SubType(){\n   // SubType 继承 SuperType, 同时还传参\n   SuperType.call(this, ['red', 'green']);\n\n   // 实例属性\n   this.name = 'fc';\n}\n```\n\n###### 3.2.2 问题\n如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式\n\n##### 3.3 组合继承 (最常见)\n组合继承，有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，**既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。**\n\n```js\nfunction SuperType(name, colors){\n   this.name = name;\n   this.colors = colors;\n}\nSuperType.prototype.sayName = function (){\n   console.log(this.name);\n}\n\nfunction SubType(name, colors, age){\n   SuperType.call(this, name, colors);\n   this.age = age;\n}\nSubType.prototype = new SuperType();\nSubType.prototype.constructor = SubType;\nSubType.prototype.sayAge = function () {\n  console.log(this.age);\n}\n\nlet instance1 = new SubType('f1', ['red', 'yellow'], 12);\ninstance1.colors.push('black');\nconsole.log(instance1.colors); //  ['red', 'yellow', 'black']\ninstance1.sayName(); // f1\ninstance1.sayAge(); // 12\n\n\nlet instance2 = new SubType('f2', ['red', 'yellow'], 13);\nconsole.log(instance2.colors);   // ['red', 'yellow']\ninstance2.sayName(); // f2\ninstance2.sayAge(); // 13\n```\n\n组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript中最常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。\n\n##### 3.4 原型式继承（es6实现Object.create()）\n\n```js\nfunction myObject(o){\n   function F(){};\n   F.prototype = o;\n   return new F();\n}\n\nlet person = {\n   name: 'fc',\n   friends: ['A', 'B', 'C']\n}\n\n// myObject(person) 可以用Object.create(person)代替\nlet aPerson = myObject(person);\naPerson.name = 'fr';\naPerson.friends.push('D');\n\nlet bPerson = myObject(person);\nbPerson.name = 'fd';\nbPerson.friends.push('E');\n\nconsole.log(person.friends); // ['A', 'B', 'C', 'D', 'E']\n```\n\n在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。**不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。**\n\n##### 3.5 寄生式继承\n待补充...\n\n##### 3.6 寄生组合继承\n前面说过，组合继承是JavaScript最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。\n\n```js\nfunction SuperType(name){\n   this.name = name;\n   this.colors = ['red', 'green', 'yellow'];\n}\nSuperType.prototype.sayName = function (){\n   console.log(this.name);\n}\n\n\nfunction SubType(name, age){\n   SuperType.call(this, name); // 第一次调用构造函数\n   this.age = age;\n}\nSubType.prototype = new SuperType(); // 第二次调用构造函数\nSubType.prototype.constructor = SubType;\nSubType.prototype.sayAge = function (){\n   console.log(this.name);\n}\n```\n寄生组合继承:\n\n```js\nfunction inheritPrototype(subType, superType){\n   let prototype = Object.create(superType.prototype); // 创建对象\n   prototype.constructor = subType;  // 增强对象\n   subType.prototype = prototype;   // 制定对象\n}\n\nfunction SuperType(name){\n   this.name = name;\n   this.colors = ['red', 'green', 'yellow'];\n}\nSuperType.prototype.sayName = function (){\n   console.log(this.name);\n}\n\nfunction subType(name, age){\n   SuperType.call(this, name);\n   this.age = age; \n}\ninheritPrototype(subType, SuperType);\nSubType.prototype.sayAge = function (){\n   console.log(this.name);\n}\n```\n\n这个例子的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用instanceof和isPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。\n\n#### 4、总结\nECMAScript支持面向对象（OO）编程，但不使用类或者接口。对象可以在代码执行过程中创建和增强，因此具有动态性而非严格定义的实体。\n\n1. 工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。\n2. 构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用new操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。\n3. 原型模式，使用构造函数的prototype属性来指定那些应该共享的属性和方法。组合使用构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。\n\n**JavaScript主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。**\n\n原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。\n\n## 五、函数表达式\n### 1、函数创建\n定义函数的方式有两种：一种是函数声明，另一种就是函数表达式。\n\n**关于函数声明，它的一个重要特征就是函数声明提升（function declaration hoisting），意思是在执行代码之前会先读取函数声明。**这就意味着可以把函数声明放在调用它的语句后面。\n\n理解函数提升的关键，就是理解函数声明与函数表达式之间的区别。\n\n```js\n// 1、函数声明\nfunction functionName(arg0, arg1, arg2) {\n   //函数体\n}\n\n// 2、函数表达式\nlet functionName = function (){\n\n}\n```\n\n### 2、递归\n\narguments.callee是一个指向正在执行的函数的指针\n\n```js\nfunction factorial(num){\n   if(num <= 1){\n      return 1;\n   }else{\n      return num * arguments.callee(num-1);\n   }\n}\n```\n但在严格模式下，不能通过脚本访问arguments.callee，访问这个属性会导致错误。\n\n```js\nvar factorial=(function f(num){\n   if (num <=1){\n       return 1;\n   } else {\n       return num ＊ f(num-1);\n   }\n});\n```\n\n### 3、闭包\n**有不少开发人员总是搞不清匿名函数和闭包这两个概念，因此经常混用。闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。**\n\n当createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到匿名函数被销毁后，createComparisonFunction()的活动对象才会被销毁。 如下：\n\n```js\nfunction createComparisonFunction(propertyName) {\n   return function(object1, object2){\n       var value1=object1[propertyName];\n       var value2=object2[propertyName];\n       if (value1 < value2){\n           return -1;\n       } else if (value1 > value2){\n           return 1;\n       } else {\n           return 0;\n       }\n   };\n}\n\nvar compare = createComparisonFunction(\"name\");\nvar result = compare({ name: \"Nicholas\" }, { name: \"Greg\" });\n\ncompare = null; // 解除匿名函数引用，释放内存\n```\n\n由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多\n\n#### 3.1 闭包与变量\n作用域链的这种配置机制引出了一个值得注意的副作用，**即闭包只能取得包含函数中任何变量的最后一个值**\n\n```js\nfunction createFunctions(){\n   let result = [];\n   for (var i=0; i<10; i++){\n      result[i] = function(){\n         return i;\n      } \n   }\n   return result;\n}\n\ncreateFunctions()[0](); // 10\ncreateFunctions()[9](); // 10\n```\n上面函数实际上，每个函数都返回10。因为每个函数的作用域链中都保存着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()函数返回后，变量i的值是10，此时每个函数都引用着保存变量i的同一个变量对象，所以在每个函数内部i的值都是10\n\n```js\nfunction createFunctions(){\n   let result = [];\n   for (var i=0; i<10; i++){\n      result[i] = function(num){\n         return function(){\n             return num;\n         };\n      }(i) \n   }\n   return result;\n}\n```\n在这个版本中，我们没有直接把闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋给数组。这里的匿名函数有一个参数num，也就是最终的函数要返回的值。在调用每个匿名函数时，我们传入了变量i。**由于函数参数是按值传递的，所以就会将变量i的当前值复制给参数num。而在这个匿名函数内部，又创建并返回了一个访问num的闭包。这样一来，result数组中的每个函数都有自己num变量的一个副本，因此就可以返回各自不同的数值了**\n\n#### 3.2 this对象\n，this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。不过，匿名函数的执行环境具有全局性，因此其this对象通常指向window（但call/apply指向其他对象）。但有时候由于编写闭包的方式不同，这一点可能不会那么明显。\n\n```js\nlet name = 'this window';\nlet object = {\n   name: 'my object',\n   getNameFunc: function(){\n      // let that = this; 解决方法一：保存副本\n      return function() {\n         return this.name;\n      }\n   }\n}\nobject.getNameFunc()(); // this window  非严格模式下\n```\n\n#### 3.3 内存泄露\n如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素将无法被销毁。\n\n```js\nfunction assignHandler(){\n   var element=document.getElementById(\"someElement\");\n   element.onclick=function(){\n       alert(element.id);\n   };\n}\n```\n以上代码创建了一个作为element元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。由于匿名函数保存了一个对assignHandler()的活动对象的引用，因此就会导致无法减少element的引用数。只要匿名函数存在，element的引用数至少也是1，因此它所占用的内存就永远不会被回收\n\n```js\nfunction assignHandler(){\n   var element=document.getElementById(\"someElement\");\n   var id=element.id;\n   element.onclick=function(){\n       alert(id);\n   };\n   element=null;\n}\n```\n把element.id的一个副本保存在一个变量中，并且在闭包中引用该变量消除了循环引用。但仅仅做到这一步，还是不能解决内存泄漏的问题。**必须要记住：闭包会引用包含函数的整个活动对象，而其中包含着element。即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个引用。因此，有必要把element变量设置为null**\n\n### 4、模仿块级作用域\n匿名函数可以用来模仿块级作用域并避免这个问题。\n\n```js\n/**\n * 下面这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。\n   只要函数执行完毕，就可以立即销毁其作用域链了。 \n */\n\n(function(){\n   //这里是块级作用域\n})();\n```\n\n```js\nfunction(){\n   //这里是块级作用域\n}();     //出错！\n```\n这段代码会导致语法错误，是因为JavaScript将function关键字当作一个函数声明的开始，**而函数声明后面不能跟圆括号。然而，函数表达式的后面可以跟圆括号。**要将函数声明转换成函数表达式，只要像下面这样给它加上一对圆括号即可。\n\n\n### 5、私有变量\n严格来讲，JavaScript中没有私有成员的概念；所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。**私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。**\n\n我们把有权访问私有变量和私有函数的公有方法称为特权方法（privileged method）\n\n```js\nfunction MyObject(){\n    //私有变量和私有函数\n    var privateVariable=10;\n\n    function privateFunction(){\n        return false;\n    }\n\n\n    //特权方法\n    this.publicMethod=function (){\n        privateVariable++;\n        return privateFunction();\n    };\n}\n```\n\n#### 5.1 静态私有变量\n\n初始化未经声明的变量，总是会创建一个全局变量。因此，MyObject就成了一个全局变量，能够在私有作用域之外被访问到。但也要知道，在严格模式下给未经声明的变量赋值会导致错误。\n\n```js\n(function(){\n    //私有变量和私有函数\n    var privateVariable=10;\n\n    function privateFunction(){\n        return false;\n    }\n    //构造函数 \n    MyObject=function(){\n\n    };\n\n\n    //公有/特权方法\n    MyObject.prototype.publicMethod=function(){\n        privateVariable++;\n        return privateFunction();\n    };\n})();\n\nlet a = new MyObject();\na.publicMethod();\n```\n#### 5.2 模块模式\n前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式（module pattern）则是为单例创建私有变量和特权方法。所谓单例（singleton），指的就是只有一个实例的对象。\n\n由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的。\n\n```js\nvar singleton=function(){\n    //私有变量和私有函数\n    var privateVariable=10;\n    function privateFunction(){\n        return false;\n    }\n    \n    //特权/公有方法和属性\n      return {\n          publicProperty: true,\n          publicMethod : function(){\n              privateVariable++;\n              return privateFunction();\n          }\n      };\n  }(); // 函数表达式后面支持带（）。 如果函数声明function a(){}()就报错 ---> (function a(){})()\n\n\n// 使用\nlet applicaton = function(){\n    let components = new Array();\n    components.push(new BaseComponent());\n\n    return {\n      getComponents: function(){\n         return components;\n      },\n      registerComponents: function(components){\n          if(typeof components === 'object'){\n             components.push(new BaseComponent());\n          }\n      }\n    }\n}()  \n```\n\n#### 5.3 增强的模块模式\n\n有人进一步改进了模块模式，即在返回对象之前加入对其增强的代码。这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况。\n\n```js\nvar singleton=function(){\n\n    //私有变量和私有函数\n    var privateVariable=10;\n    function privateFunction(){\n        return false;\n    }\n\n    //创建对象\n    var object=new CustomType();\n\n    //添加特权/公有属性和方法\n    object.publicProperty=true;\n    object.publicMethod=function(){\n        privateVariable++;\n        return privateFunction();\n    };\n\n    //返回这个对象\n    return object;\n}();\n\n// 使用\nlet applicaton = function(){\n    let components = new Array();\n    components.push(new BaseComponent());\n    \n    // 创建applicaton副本\n    let app = new BaseComponent(); \n\n    app.getComponents=function(){\n       return components;\n    }\n    app.registerComponents=function(components){\n        if(typeof components === 'object'){\n           components.push(new BaseComponent());\n        }\n    }\n\n    return app;\n}() \n```\n\n### 6、总结\n**匿名函数，也称为拉姆达函数，是一种使用JavaScript函数的强大方式。** 以下总结了函数表达式的特点：\n1. 函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫做匿名函数。\n2. 递归函数应该始终使用arguments.callee来递归地调用自身，不要使用函数名——函数名可能会发生变化。\n\n**当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，**原理如下：\n1. 在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。\n2. 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。\n3. 但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。\n\n\n**使用闭包可以在JavaScript中模仿块级作用域**（JavaScript本身没有块级作用域的概念），要点如下:\n1. 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。\n2. 结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。\n\n**因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。**\n\n\n## 六、DOM\n### 1、DOM节点和操作\n#### 1.1 节点类型\n每个节点都有一个nodeType属性，用于表明节点的类型。\n\n```js\nif (someNode.nodeType==1){     //适用于所有浏览器\n   alert(\"Node is an element.\");\n}\n```\n\n#### 1.2 节点关系\n每个节点都有一个childNodes属性，其中保存着一个NodeList对象。NodeList是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。\n\n```js\nvar firstChild=someNode.childNodes[0];\nvar secondChild=someNode.childNodes.item(1);\nvar count=someNode.childNodes.length;\n```\n\n我们在本书前面介绍过，对arguments对象使用Array.prototype.slice()方法可以将其转换为数组。而采用同样的方法，也可以将NodeList对象转换为数组。\n\n```js\n//在IE8及之前版本中无效\nvar arrayOfNodes=Array.prototype.slice.call(someNode.childNodes,0);\n```\n\nDOM节点关系图：\n\n<img src=\"/img/dom_node.jpeg\" width=\"95%\" height=\"auto\">\n\n```js\nif(someNode.nextSibling === null){\n   console.log('我是最后一个节点');\n}else if(someNode.previousSibling === null){\n   console.log('我是第一个节点');\n}\n```\n\n#### 1.3 操作节点 \n\n如果传入到appendChild()中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置转移到新位置。\n\n```js\nvar returnedNode=someNode.appendChild(newNode);\nalert(returnedNode==newNode);           //true\nalert(someNode.lastChild==newNode);   //true\n```\n\n如果需要把节点放在childNodes列表中某个特定的位置上，而不是放在末尾，那么可以使用insertBefore()方法。这个方法接受两个参数：要插入的节点和作为参照的节点。\n\n```js\n//插入后成为最后一个子节点\nreturnedNode=someNode.insertBefore(newNode, null);\nalert(newNode==someNode.lastChild);   //true\n\n\n//插入后成为第一个子节点\nvar returnedNode=someNode.insertBefore(newNode, someNode.firstChild);\nalert(returnedNode==newNode);           //true\nalert(newNode==someNode.firstChild);  //true\n\n\n//插入到最后一个子节点前面\nreturnedNode=someNode.insertBefore(newNode, someNode.lastChild);\nalert(newNode==someNode.childNodes[someNode.childNodes.length-2]); //true\n```\n\nappendChild()和insertBefore()方法都只插入节点，不会移除节点。而下面要介绍的**replaceChild()方法接受的两个参数是：要插入的节点和要替换的节点。**要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。\n\n```js\n//替换第一个子节点\nvar returnedNode=someNode.replaceChild(newNode, someNode.firstChild);\n//替换最后一个子节点\nreturnedNode=someNode.replaceChild(newNode, someNode.lastChild);\n```\n\n**如果只想移除而非替换节点，可以使用removeChild()方法。这个方法接受一个参数，即要移除的节点。**\n\n```js\n//移除第一个子节点\nvar formerFirstChild=someNode.removeChild(someNode.firstChild);\n//移除最后一个子节点\nvar formerLastChild=someNode.removeChild(someNode.lastChild);\n```\n\n#### 1.4 其他方法\ncloneNode()方法接受一个布尔值参数，表示是否执行深复制。在参数为true的情况下，执行深复制，也就是复制节点及其整个子节点树；在参数为false的情况下，执行浅复制，即只复制节点本身。\n\ncloneNode()方法不会复制添加到DOM节点中的JavaScript属性，例如事件处理程序等。这个方法只复制特性、（在明确指定的情况下也复制）子节点，其他一切都不会复制。\n\n#### 1.5 Document类型\ndocument对象还有一个body属性，直接指向body。\n\n当页面中包含来自其他子域的框架或内嵌框架时，能够设置document.domain就非常方便了。由于跨域安全限制，来自不同子域的页面无法通过JavaScript通信。而通过将每个页面的document.domain设置为相同的值，这些页面就可以互相访问对方包含的JavaScript对象了。\n\n例如，假设有一个页面加载自www.wrox.com，其中包含一个内嵌框架，框架内的页面加载自p2p.wrox.com。由于document.domain字符串不一样，内外两个页面之间无法相互访问对方的JavaScript对象。但如果将这两个页面的document.domain值都设置为\"wrox.com\"，它们之间就可以通信了。\n\n```js\n//假设页面来自p2p.wrox.com域\n\ndocument.domain=\"wrox.com\";             // 成功\ndocument.domain=\"nczonline.net\";       // 出错！\n```\n\n#### 1.6 DOM操作技术\n\n```js\n// 动态加载js\nfunction loadScript(url){\n   let script = document.createElement(\"script\");\n   script.type = \"text/javascript\";\n   script.src = url || '';\n   document.body.appendChild(script);\n}\n\n// 动态加载css\nfunction loadStyle(url){\n  let head = document.getElementsByTagName(\"head\")[0];\n  let link = document.createElement('link');\n  link.rel = 'stylesheet';\n  link.type = 'text/css';\n  link.href = url;\n  head.appendChild(link);\n}\n```\n\n#### 1.7 总结\nDOM操作往往是JavaScript程序中开销最大的部分，而因访问NodeList导致的问题为最多。NodeList对象都是“动态的”，这就意味着每次访问NodeList对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少DOM操作。 \n\n### 2、DOM扩展\n#### 2.1 选择符\n众多JavaScript库中最常用的一项功能，就是根据CSS选择符选择与某个模式匹配的DOM元素。实际上，jQuery的核心就是通过CSS选择符查询DOM文档取得元素的引用，从而抛开了getElementById()和getElementsByTagName()。\n\n##### 2.1.1 querySelector()方法\nquerySelector()方法接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回null。\n\n```js\n// body元素\ndocument.querySelector('body');\n\n// id\ndocument.querySelector('#myDiv');\n\n// 取得class为selected第一个元素\ndocument.querySelector('.selected');\n\n// 取得class为button的第一个图像元素\ndocument.querySelector('img.button');\n```\n通过Document类型调用querySelector()方法时，会在文档元素的范围内查找匹配的元素。而通过Element类型调用querySelector()方法时，只会在该元素后代元素的范围内查找匹配的元素。如果传入了不被支持的选择符，querySelector()会抛出错误。\n##### 2.1.2 querySelectorAll()方法\nquerySelectorAll()方法接收的参数与querySelector()方法一样，都是一个CSS选择符，但返回的是所有匹配的元素而不仅仅是一个元素。这个方法返回的是一个NodeList的实例。\n\n具体来说，返回的值实际上是带有所有属性和方法的NodeList，而其底层实现则类似于一组元素的快照，而非不断对文档进行搜索的动态查询。这样实现可以避免使用NodeList对象通常会引起的大多数性能问题。\n\n```js\n// 取得p元素中所有strong元素\nlet strong = documet.querySelectorAll('p strong');\n```\n\n#### 2.2 遍历元素\n对于元素间的空格，IE9及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点。这样，就导致了在使用childNodes和firstChild等属性时的行为不一致。\n\n1. childElementCount：返回子元素（不包括文本节点和注释）的个数\n2. firstElementChild：指向第一个子元素；firstChild的元素版。\n3. lastElementChild：指向最后一个子元素；lastChild的元素版\n4. previousElementSibling：指向前一个同辈元素；previousSibling的元素版\n5. nextElementSibling：指向后一个同辈元素；nextSibling的元素版。\n\n利用这些元素不必担心空白文本节点，从而可以更方便地查找DOM元素。 \n\n```js\nvar i,\n   len,\n   child=element.firstChild;\nwhile(child !=element.lastChild){\n   if (child.nodeType==1){    //检查是不是元素\n       processChild(child);\n   }\n   child=child.nextSibling;\n}\n```\n\n使用元素版为：\n\n```js\nvar i,\n   len,\n   child=element.firstElementChild;\nwhile(child !=element.lastElementChild){\n   processChild(child);    //已知其是元素\n   child=child.nextElementSibling;\n}\n```\n#### 2.3 HTML5\n##### 2.3.1 getElementsByClassName()方法\n\n```js\n//取得所有类中包含\"username\"和\"current\"的元素，类名的先后顺序无所谓\nvar allCurrentUsernames=document.getElementsByClassName(\"username current\");\n```\n\n##### 2.3.2 classList属性\n在操作类名时，需要通过className属性添加、删除和替换类名。因为className中是一个字符串，所以即使只修改字符串一部分，也必须每次都设置整个字符串的值。\n\n```js\n// 删除 disable 类\ndiv.classList.remove('disable');\n\n// 添加 current 类\ndiv.classList.add('current');\n\n// 切换 user 类\ndiv.classList.toggle('user');\n\n// 确定是否有既定的类\nif(div.classList.contains('bd')){ \n\n}\n\n// 类的数量\nlet len = div.classList.length;\n```\n\n##### 2.3.3  焦点管理\nHTML5也添加了辅助管理DOM焦点的功能。首先就是document.activeElement属性，这个属性始终会引用DOM中当前获得了焦点的元素。\n\n另外就是新增了document.hasFocus()方法，这个方法用于确定文档是否获得了焦点。\n\n```js\nvar button=document.getElementById(\"myButton\");\nbutton.focus();\nalert(document.activeElement===button);    //true\n\nvar button=document.getElementById(\"myButton\");\nbutton.focus();\nalert(document.hasFocus());   //true\n```\n##### 2.3.4  HTMLDocument的变化\n**1、readyState属性**\n   IE4最早为document对象引入了readyState属性。然后，其他浏览器也都陆续添加这个属性，最终HTML5把这个属性纳入了标准当中。Document的readyState属性有两个可能的值：\n\n   ❏ loading，正在加载文档；\n\n   ❏ complete，已经加载完文档。\n\n**2、自定义数据属性**\nHTML5规定可以为元素添加非标准的属性，但要添加前缀data-，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以data-开头即可。然后通过dataset来获取： div.dataset.myname\n\n**3、scrollIntoView()方法**\nscrollIntoView()可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。\n\n```js\n//让元素可见\ndocument.forms[0].scrollIntoView();\n```\n\n当页面发生变化时，一般会用这个方法来吸引用户的注意力。实际上，为某个元素设置焦点也会导致浏览器滚动并显示出获得焦点的元素。\n\n##### 2.3.5 专有扩展\n**1、innerText属性**\n设置innerText永远只会生成当前节点的一个子文本节点，而为了确保只生成一个子文本节点，就必须要对文本进行HTML编码。利用这一点，可以通过innerText属性过滤掉HTML标签。方法是将innerText设置为等于innerText，这样就可以去掉所有HTML标签: div.innerText = div.innerText \n\n**2、滚动**\nscrollIntoView()和scrollIntoViewIfNeeded()的作用对象是元素的容器，而scrollByLines()和scrollByPages()影响的则是元素自身。\n\n```js\n//将页面主体滚动5行\ndocument.body.scrollByLines(5);\n//在当前元素不可见的时候，让它进入浏览器的视口\ndocument.images[0].scrollIntoViewIfNeeded();\n//将页面主体往回滚动1页\ndocument.body.scrollByPages(-1);\n```\n\n由于scrollIntoView()是唯一一个所有浏览器都支持的方法，因此还是这个方法最常用。\n\n\n### 3、DOM2和DOM3\n#### 3.1 DOM变化\nDOM2级核心”没有引入新类型，它只是在DOM1级的基础上通过增加新方法和新属性来增强了既有类型。 \n\n没啥特别要介绍的....\n\n#### 3.2 样式\n##### 3.2.1 计算的样式\n虽然style对象能够提供支持style特性的任何元素的样式信息，但它不包含那些从其他样式表层叠而来并影响到当前元素的样式信息。“DOM2级样式”增强了document.defaultView，提供了getComputedStyle()方法。这个方法接受两个参数：要取得计算样式的元素和一个伪元素字符串（例如\":after\"）。如果不需要伪元素信息，第二个参数可以是null。getComputedStyle()方法返回一个CSSStyleDeclaration对象（与style属性的类型相同）。\n\n```js\nlet elem1 = document.getElementById(\"elemId\");\nlet style = window.getComputedStyle(element, [pseudoElt]);\n\nlet h3 = document.querySelector('h3');\nlet result = window.getComputedStyle(h3, '::after').content;\n```\n\n##### 3.2.2 元素大小\n**1、偏移量**\n1. offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。\n2. offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度。\n3. offsetLeft：元素的左外边框至包含元素的左内边框之间的像素距离。\n4. offsetTop：元素的上外边框至包含元素的上内边框之间的像素距离。\n\n要想知道某个元素在页面上的偏移量，将这个元素的offsetLeft和offsetTop与其offsetParent的相同属性相加，如此循环直至根元素，就可以得到一个基本准确的值\n\n```js\n// 元素左边偏移量\nfunciton getElementLeft(el){\n   let actualLeft = el.offsetLeft;\n   let current = el.offsetParent;\n\n   while(current != null){\n      actualLeft += current.offsetLeft;\n      current = current.offsetParent;\n   }\n   return actualLeft;\n}\n\n// 元素距离顶部偏移量\nfunction getElementTop(el){\n   let actualTop = el.offsetTop;\n   let current = el.offsetParent;\n\n   while(current != null){\n     actualTop += el.offsetTop;\n     current = el.offsetParent;\n   }\n\n   return actualTop;\n}\n```\n**这些偏移量属性都是只读的，而且每次访问它们都需要重新计算。因此，应该尽量避免重复访问这些属性；如果需要重复使用其中某些属性的值，可以将它们保存在局部变量中，以提高性能。**\n\n\n**2、客户区大小**\n\n```js\nfunction getViewport(){\n   // 这个函数首先检查document.compatMode属性，以确定浏览器是否运行在混杂模式\n   if(document.compatMode == 'BackCompat'){\n      return {\n         width: document.body.clientWidth,\n         height: document.body.clientHeight\n      }\n   }else{\n      return {\n         width: document.documentElement.clientWidth,\n         height: document.documentElement.clientHeight\n      }\n   }\n}\n```\n\n**3、滚动大小**\n1. scrollHeight：在没有滚动条的情况下，元素内容的总高度。\n2. scrollWidth：在没有滚动条的情况下，元素内容的总宽度\n3. scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。  \n4. scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。\n\nscrollWidth和scrollHeight主要用于确定元素内容的实际大小。例如，通常认为\\<html\\>元素是在Web浏览器的视口中滚动的元素（IE6之前版本运行在混杂模式下时是\\<body\\>元素）。因此，带有垂直滚动条的页面总高度就是document.documentElement.scrollHeight。\n\n#### 3.3 遍历\n1. parentNode(): 遍历到当前节点的父节点；\n2. firstChild(): 遍历到当前节点的第一个子节点；\n3. lastChild()\n4. nextSibling()\n5. previousSibling()\n\n#### 3.4 范围\n“DOM2级遍历和范围”模块定义了“范围”（range）接口。通过范围可以选择文档中的一个区域，而不必考虑节点的界限（选择在后台完成，对用户是不可见的）。\n\nvar range=document.createRange();\n\n❏ startContainer：包含范围起点的节点（即选区中第一个节点的父节点)\n\n❏ startOffset：范围在startContainer中起点的偏移量。如果startContainer是文本节点、注释节点或CDATA节点,那么startOffset就是范围起点之前跳过的字符数量。否则，startOffset就是范围中第一个子节点的索引。\n\n❏ endContainer：包含范围终点的节点（即选区中最后一个节点的父节点）。\n\n❏ endOffset：范围在endContainer中终点的偏移量（与startOffset遵循相同的取值规则）。\n\n\n##### 3.4.1 用DOM范围实现简单选择\n要使用范围来选择文档中的一部分，最简的方式就是使用selectNode()或selectNodeContents()。这两个方法都接受一个参数，即一个DOM节点，然后使用该节点中的信息来填充范围。其中，selectNode()方法选择整个节点，包括其子节点；而selectNodeContents()方法则只选择节点的子节点。\n\n```js\n// html\n<! DOCTYPE html>\n<html>\n   <body>\n       <p id=\"p1\"><b>Hello</b> world! </p>\n   </body>\n</html>\n\n// js\nlet range1 = document.createRange();\nlet range2 = document.createRange();\nlet p1 = document.getElementById('p1');\n\nrange1.selectNode(p1); // 值为：<p id=\"p1\"><b>Hello</b> world! </p>\nrange2.selectNodeContents(p1); //值为： <b>Hello</b> world! \n```\n\n##### 3.4.2 用DOM范围实现复杂选择\n要创建复杂的范围就得使用setStart()和setEnd()方法。这两个方法都接受两个参数：一个参照节点和一个偏移量值。对setStart()来说，参照节点会变成startContainer，而偏移量值会变成startOffset。对于setEnd()来说，参照节点会变成endContainer，而偏移量值会变成endOffset。\n\n可以使用这两个方法来模仿selectNode()和selectNodeContents()。来看下面的例子：\n\n```js\nlet range1 = document.createRange();\nlet range2 = document.createRange();\nlet p1 = document.getElementById('p1');\nlet p1Index = -1;\nlet i, len;\n\nfor(i=0; len=p1.parentNode.childNodes.length; i<len; i++){\n    if(p1.parentNode.childNodes[i] == p1){\n        p1Index = i;\n        break;\n    }\n}\n\nrange1.setStart(p1.parentNode, p1Index);\nrange1.setEnd(p1.parentNode, p1Index+1);\nrange2.setStart(p1, 0);\nrange2.setEnd(p1, p1.childNodes.length);\n```\n\n##### 3.4.3 操作DOM范围中的内容\n在创建范围时，内部会为这个范围创建一个文档片段，范围所属的全部节点都被添加到了这个文档片段中。\n\n\n```js\n// html\n<p id=\"p1\"><b>He</b><b>llo</b> world! </p>\n\n// js\nlet p1 = document.getElementById('p1');\nhelloNode = p1.firstChild.firstChild;\nworldNode = p1.lastChild;\nrang = document.createRang();\n\nrang.setStart(helloNode, 2);\nrang.setEnd(worldNode, 3);\n\n// 1、deleteContents() -- 从文档中删除范围所包含的内容\nrang.deleteContents();  \n\n/** 结果为：\n * <p><b>He</b>rld! </p>\n **/\n\n// 2、extractContents() -- 返回范围的文档片段\nlet fragment = rang.extractContents();  \np1.parentNode.appendChild(fragment); \n\n/** 结果为：\n * <p><b>He</b>rld! </p>\n * <b>llo</b> wo\n **/\n\n// 3、cloneContents() -- 返回的文档片段包含的是范围中节点的副本，而不是实际的节点\nlet fragment = rang.cloneContents();  \np1.parentNode.appendChild(fragment); \n\n/** 结果为：\n   <p><b>Hello</b> world! </p>\n   <b>llo</b> wo\n **/\n```\n\n##### 3.4.4 插入DOM范围中的内容\n利用范围，可以删除或复制内容，还可以像前面介绍的那样操作范围中的内容。使用insertNode()方法可以向范围选区的开始处插入一个节点。\n\n```js\n// 假设我们想在前面例子中的HTML前面插入以下HTML代码：\n<span style=\"color: red\">Inserted text</span>\n\n\n// 代码\nlet p1 = document.getElementById('p1');\nlet helloNode = p1.firstChild.firstChild;\nlet worldNode = p1.lastChild;\nlet range = document.createRange();\n\nrange.setStart(helloNode, 2);\nrange.setEnd(worldNode, 3);\n\nlet span = documetn.createElement('span');\nspan.style.color = 'red';\nspan.appendChild(document.createTextNode('Inserted text'));\nrange.insertNode(span);\n\n/**\n * 结果\n * <p id=\"p1\"><b>He<span style=\"color: red\">Inserted text</span>llo</b> world</p>\n **/ \n```\n\n**除了向范围内部插入内容之外，还可以环绕范围插入内容，此时就要使用surroundContents()方法。这个方法接受一个参数，即环绕范围内容的节点。在环绕范围插入内容时，后台会执行下列步骤：**\n\n1. 提取出范围中的内容（类似执行extractContent()）\n2. 将给定节点插入到文档中原来范围所在的位置上\n3. 将文档片段的内容添加到给定节点中\n\n可以使用这种技术来突出显示网页中的某些词句，例如下列代码：\n\n```js\nlet p1 = document.getElementById('p1');\nlet helloNode = p1.firstChild.firstChild;\nlet worldNode = p1.lastChild;\nlet range = document.createRange();\n\nrange.selectNode(helloNode);\n\nlet span = docuemt.createElement('span');\nspan.style.backgroundColor = 'yellow';\nrange.surroundContents(span);\n\n/** 结果\n * <p><b><span style=\"background-color:yellow\">Hello</span></b> world! </p>\n **/ \n```\n\n\n##### 3.4.5 折叠DOM范围\n所谓折叠范围，就是指范围中未选择文档的任何部分。使用collapse()方法来折叠范围，这个方法接受一个参数，一个布尔值，表示要折叠到范围的哪一端。参数true表示折叠到范围的起点，参数false表示折叠到范围的终点。要确定范围已经折叠完毕，可以检查collapsed属性。\n\n<img src=\"/img/range2.jpeg\" width=\"95%\" height=\"auto\">\n\n```js\nrange.collapse(true);            //折叠到起点\nalert(range.collapsed);          //输出true\n```\n\n\n检测某个范围是否处于折叠状态，可以帮我们确定范围中的两个节点是否紧密相邻, 如下：\n\n```js\n// html\n<p id=\"p1\">Paragraph 1</p><p id=\"p2\">Paragraph 2</p>\n\n// js\nvar p1=document.getElementById(\"p1\"),\n   p2=document.getElementById(\"p2\"),\n   range=document.createRange();\nrange.setStartAfter(p1);\nrange.setEndBefore(p2);\nalert(range.collapsed);      //输出true\n```\n在这个例子中，新创建的范围是折叠的，因为p1的后面和p2的前面什么也没有。\n\n##### 3.4.6 比较DOM范围\n在有多个范围的情况下，可以使用compareBoundaryPoints()方法来确定这些范围是否有公共的边界（起点或终点）。\n\n❏ Range.START_TO_START(0)：比较第一个范围和第二个范围的起点；\n\n❏ Range.START_TO_END(1)：比较第一个范围的起点和第二个范围的终点；\n\n❏ Range.END_TO_END(2)：比较第一个范围和第二个范围的终点；\n\n❏ Range.END_TO_START(3)：比较第一个范围的终点和第一个范围的起点。\n\n**compareBoundaryPoints()方法可能的返回值如下：**\n\n* 如果第一个范围中的点位于第二个范围中的点之前，返回-1；\n* 如果两个点相等，返回0；\n* 如果第一个范围中的点位于第二个范围中的点之后，返回1。\n\n```js\n// html\n <p id=\"p1\"><b>Hello</b> world</p>\n\n// js\n let range1 = document.createRange();\n let range2 = document.createRange();\n let p1 = document.getElementById('p1');\n range1.selectNodeContents(p1);\n range2.selectNodeContents(p1);\n range2.setEndBefore(p1.lastChild);\n\n console.log(range1.compareBoundaryPoints(Range.START_TO_START, range2));  // 0\n console.log(range1.compareBoundaryPoints(Range.END_TO_END, range2)); // 1\n```\n\n在这个例子中，两个范围的起点实际上是相同的，因为它们的起点都是由selectNodeContents()方法设置的默认值来指定的。因此，第一次比较返回0。但是，range2的终点由于调用setEndBefore()已经改变了，结果是range1的终点位于range2的终点后面，因此第二次比较返回1。\n\n<img src=\"/img/range1.jpeg\" width=\"95%\" height=\"auto\">\n\n\n##### 3.4.7 复制DOM范围\nvar newRange=range.cloneRange();  方法会创建调用它的范围的一个副本。新创建的范围与原来的范围包含相同的属性，而修改它的端点不会影响原来的范围。\n##### 3.4.8 清理DOM范围\n\n```js\nrange.detach();         //从文档中分离\nrange=null;           //解除引用\n```\n\n## 七、事件\nJavaScript与HTML之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以使用侦听器（或处理程序）来预订事件，以便事件发生时执行相应的代码。这种在传统软件工程中被称为观察员模式的模型，支持页面的行为（JavaScript代码）与页面的外观（HTML和CSS代码）之间的松散耦合。\n\n### 1、事件流\n如果你单击了某个按钮，他们都认为单击事件不仅仅发生在按钮上。换句话说，在单击按钮的同时，你也单击了按钮的容器元素，甚至也单击了整个页面。\n\n**事件流描述的是从页面中接收事件的顺序。**但有意思的是，IE和Netscape开发团队居然提出了差不多是完全相反的事件流的概念。**IE的事件流是事件冒泡流，而Netscape Communicator的事件流是事件捕获流。**\n\n#### 1.1 事件冒泡\nIE的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）\n\n如果你单击了页面中的div元素，那么这个click事件会按照如下顺序传播：\n\n(1) <div\\>\n\n(2) <body\\>\n\n(3) <html\\>\n\n(4) document\n\n#### 1.2 事件捕获\n事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。\n\n点击div按一下顺序触发click:\n\n(1) document\n\n(2) <html\\>\n\n(3) <body\\>\n\n(4) <div\\>\n\n\n####  1.3 DOM事件流\n“DOM2级事件”规定的事件流包括三个阶段：**事件捕获阶段、处于目标阶段和事件冒泡阶段**。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应\n\n<img src=\"/img/dom.jpeg\" width=\"95%\" height=\"auto\">\n\n在DOM事件流中，实际的目标（div元素）在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从document到html再到body后就停止了。下一个阶段是“处于目标”阶段，于是事件在div上发生，并在事件处理（后面将会讨论这个概念）中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。\n\n### 2、事件处理程序\n事件就是用户或浏览器自身执行的某种动作。诸如click、load和mouseover，都是事件的名字。而响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以\"on\"开头，因此click事件的事件处理程序就是onclick, load事件的事件处理程序就是onload\n\n#### 2.1 html事件处理程序\n\n```js\n// 在这个函数内部，this值等于事件的目标元素，例如：\n<input type=\"button\" value=\"123\" onclick=\"alert(this.value);\" />\n```\n\n#### 2.2 DOM0级事件处理程序\n\n使用DOM0级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素的作用域中运行；换句话说，程序中的this引用当前元素。来看一个例子。\n\n```js\nvar btn=document.getElementById(\"myBtn\");\nbtn.onclick=function(){\n   alert(this.id);\n};\n\n// 也可以删除通过DOM0级方法指定的事件处理程序，\n// 只要像下面这样将事件处理程序属性的值设置为null即可：\nbtn.onclick=null;\n```\n\n#### 2.3 DOM2级事件处理程序\n“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和removeEventListener()。所有DOM节点中都包含这两个方法，并且它们都接受3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。\n\n通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿名函数将无法移除，如下面的例子所示：\n\n```js\nvar btn=document.getElementById(\"myBtn\");\nbtn.addEventListener(\"click\", function(){\n   alert(this.id);\n}, false);\n\n// 无法移除事件\nbtn.removeEventListener(\"click\", function(){\n  alert(this.id); \n}, false);\n\n// 下面可以移除事件\nbtn.addEventListener(\"click\", hander, false);\nbtn.removeEventListener(\"click\", hander, false);\nfunction hander(){\n   alert(this.id); // 没有用\n}\n```\n\n**大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。**最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，我们不建议在事件捕获阶段注册事件处理程序。\n\n\n### 3、事件对象\n在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息\n\n#### 3.1 DOM中的事件对象\n\n```js\nlet btn = document.getElementById('btn');\nbtn.addEventListener('click', function(event){\n   console.log(event.type); // 'click'\n}, false)\n```\n\n**event对象包含与创建它的特定事件有关的属性和方法**。触发的事件类型不一样，可用的属性和方法也不一样：\n\n<img src=\"/img/domEvent.jpeg\" width=\"95%\" height=\"auto\">\n\n下面例子检测了currentTarget和target与this的值。由于click事件的目标是按钮，因此这三个值是相等的\n\n```js\ndocument.body.onclick = function(event){\n   console.log(event.currentTarget === document.body); // true\n   console.log(this === document.body); //true\n   console.log(event.target === document.getElementById('myBody')); //true\n}\n```\n\n要阻止特定事件的默认行为，可以使用preventDefault()方法。例如，链接的默认行为就是在被单击时会导航到其href特性指定的URL。如果你想阻止链接导航这一默认行为，那么通过链接的onclick事件处理程序可以取消它。\n\n```js\nlet link = document.getElementById('myLink');\nlink.onclick = function(event) {\n  event.preventDefault(); \n}\n```\n\nstopPropagation()方法用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。例如，直接添加到一个按钮的事件处理程序可以调用stopPropagation()，从而避免触发注册在document.body上面的事件处理程序。\n\n```js\nlet btn = document.getElementById('myBtn');\nbtn.onclick = function() {\n   console.log('click');\n   event.stopPropagation();\n}\n\ndocument.body.onclick = function(){\n   console.log('body clicked'); // 由于btn阻止冒泡stopPropagation(), 所以body不会有事件注册\n}\n```\n\n事件对象的eventPhase属性，可以用来确定事件当前正位于事件流的哪个阶段。\n如果是在捕获阶段调用的事件处理程序，那么eventPhase等于1；\n如果事件处理程序处于目标对象上，则eventPhase等于2；\n如果是在冒泡阶段调用的事件处理程序，eventPhase等于3。\n这里要注意的是，尽管“处于目标”发生在冒泡阶段，但eventPhase仍然一直等于2。\n\n```js\nlet btn = document.getElementById('btn');\nbtn.onclick = function(event){\n   console.log(event.eventPhase); // 2, 如果事件处理程序处于目标对象上\n}\ndocument.body.addEventListener('click', function(event){\n   console.log(event.eventPhase); // 1, 如果是在捕获阶段调用的事件处理程序\n}, true)\ndocument.body.onclick = function(event){\n   consooe.log(event.eventPhase); // 3, 如果是在冒泡阶段调用的事件处理程序\n}\n```\n### 4、事件类型\n\n#### 4.1 UI事件\n1. load：当页面完全加载后在window上面触发，当所有框架都加载完毕时在框架集上面触发，当图像加载完毕时在img元素上面触发，或者当嵌入的内容加载完毕时在object元素上面触发。\n2. error：当发生JavaScript错误时在window上面触发，当无法加载图像时在img元素上面触发，当无法加载嵌入内容时在object元素上面触发，或者当有一或多个框架无法加载时在框架集上面触发。\n3. unload：与load事件对应的是unload事件，这个事件在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生unload事件。而利用这个事件最多的情况是清除引用，以避免内存泄漏。\n\n#### 4.2 焦点事件\n焦点事件会在页面元素获得或失去焦点时触发。利用这些事件并与document.hasFocus()方法及document.activeElement属性配合。\n\nfocus和blur，它们都是JavaScript早期就得到所有浏览器支持的事件。这些事件的最大问题是它们不冒泡。\n\n#### 4.3 鼠标事件\n页面上的所有元素都支持鼠标事件。除了mouseenter和mouseleave，所有鼠标事件都会冒泡，也可以被取消，而取消鼠标事件将会影响浏览器的默认行为。取消鼠标事件的默认行为还会影响其他事件，因为鼠标事件与其他事件是密不可分的关系。\n\n#### 4.4 滚轮事件\n#### 4.5 文本事件\n#### 4.6 键盘事件\n#### 4.7 合成事件\n#### 4.8 变动事件\n\n### 5、内存和性能\n可是在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。导致这一问题的原因是多方面的。首先，每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间。\n\n#### 5.1 事件委托\n**对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。**例如，click事件会一直冒泡到document层次。也就是说，我们可以为整个页面指定一个onclick事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。\n\n事件委派的优点：\n\n1. document对象很快就可以访问，而且可以在页面生命周期的任何时点上为它添加事件处理程序（无需等待DOMContentLoaded或load事件）。换句话说，只要可单击的元素呈现在页面上，就可以立即具备适当的功能。\n2. 整个页面占用的内存空间更少，能够提升整体性能\n3. 在页面中设置事件处理程序所需的时间更少。只添加一个事件处理程序所需的DOM引用更少，所花的时间也更少。\n\n\n最适合采用事件委托技术的事件包括click、mousedown、mouseup、keydown、keyup和keypress。虽然mouseover和mouseout事件也冒泡，但要适当处理它们并不容易，而且经常需要计算元素的位置。\n\n#### 5.2 移除事件处理程序\n\n```js\n<div id=\"myDiv\">\n  <input type=\"button\" value=\"Click Me\" id=\"myBtn\">\n</div>\n<script type=\"text/javascript\">\n  var btn=document.getElementById(\"myBtn\");\n  btn.onclick=function(){\n      //先执行某些操作\n\n      // 移除事件处理程序\n      // btn.onclick=null;\n\n      document.getElementById(\"myDiv\").innerHTML=\"Processing...\"; //麻烦了！\n  };\n</script>\n```\n\n采用事件委托也有助于解决这个问题。如果事先知道将来有可能使用innerHTML替换掉页面中的某一部分，那么就可以不直接把事件处理程序添加到该部分的元素中。而通过把事件处理程序指定给较高层次的元素，同样能够处理该区域中的事件。\n### 6、模拟事件\n#### 6.1 DOM中的事件模拟\n##### 6.1.1 模拟鼠标事件\n##### 6.1.2 模拟键盘事件\n##### 6.1.3 模拟其他事件\n```js\n// 模拟了DOMNodeInserted事件\nvar event=document.createEvent(\"MutationEvents\");\nevent.initMutationEvent(\"DOMNodeInserted\", true, false, someNode, \"\", \"\", \"\",0);\ntarget.dispatchEvent(event);\n\n// 模拟HTML事件\nvar event=document.createEvent(\"HTMLEvents\");\nevent.initEvent(\"focus\", true, false);\ntarget.dispatchEvent(event);\n```\n\n##### 6.1.4 自定义事件\nDOM3级还定义了“自定义事件”。自定义事件不是由DOM原生触发的，它的目的是让开发人员创建自己的事件。要创建新的自定义事件，可以调用createEvent(\"CustomEvent\")。\n#### 6.2 IE中的事件模拟\n待梳理，todo\n\n### 7、总结\n在使用事件时，需要考虑如下一些内存与性能方面的问题：\n1. 有必要限制一个页面中事件处理程序的数量，数量太多会导致占用大量内存，而且也会让用户感觉页面反应不够灵敏。\n2. 建立在事件冒泡机制之上的事件委托技术，可以有效地减少事件处理程序的数量。\n3. 建议在浏览器卸载页面之前移除页面中的所有事件处理程序。 ","tags":["读书笔记","javascript高级程序设计"]},{"title":"XMLHttpRequest和请求hook实现","url":"/2022/04/29/XMLHttpRequest和请求hook实现/","content":"\n## xhr\n### 构造方法\n该构造函数用于初始化一个 XMLHttpRequest 实例对象。在调用下列任何其他方法之前，必须先调用该构造函数，或通过其他方式，得到一个实例对象。\n```js\nconst request = new XMLHttpRequest();\n```\n\n### 标准属性\n1. XMLHttpRequest.onreadystatechange：当 readyState 属性发生变化时\n2. XMLHttpRequest.readyState\n\n| 值 | 状态 | 描述 |\n|---| --- | ---|\n| 0 | UNSENT| 代理被创建，但尚未调用 open() 方法|\n| 1 | OPENED | open() 方法已经被调用|\n| 2 | HEADERS_RECEIVED | send() 方法已经被调用，并且头部和状态已经可获得|\n| 3 | LOADING | 下载中； responseText 属性已经包含部分数据。|\n| 4 | DONE | 下载操作已完成 |\n\n3. XMLHttpRequest.response:返回一个 ArrayBuffer、Blob、Document，或 DOMString，具体是哪种类型取决于 XMLHttpRequest.responseType 的值。其中包含整个响应实体（response entity body）\n4. XMLHttpRequest.responseText:返回一个 DOMString，该 DOMString 包含对请求的响应，如果请求未成功或尚未发送，则返回 null\n5. XMLHttpRequest.responseType: 一个用于定义响应类型的枚举值(arraybuffer、blob、document、json、text)\n6. XMLHttpRequest.status: 返回一个无符号短整型数字，代表请求的响应状态(在请求完成前/如果 XMLHttpRequest出错，status的值都为0)\n7. XMLHttpRequest.timeout： 一个无符号长整型数字，表示该请求的最大请求时间（毫秒），若超出该时间，请求会自动终止。\n8. XMLHttpRequestEventTarget.ontimeout:当请求超时调用的\n9. XMLHttpRequest.withCredentials:一个布尔值，用来指定跨域 Access-Control 请求是否应当带有授权信息，如 cookie 或授权 header 头\n\n\n### 标准方法\n1. XMLHttpRequest.abort()：如果请求已被发出，则立刻中止请求。\n2. XMLHttpRequest.getAllResponseHeaders(): 以字符串的形式返回所有用 CRLF(回车符（CR）和换行符（LF）是文本文件用于标记换行的控制字符或字节码（bytecode）) 分隔的响应头，如果没有收到响应，则返回 null。\n3. XMLHttpRequest.getResponseHeader(): 返回包含指定响应头的字符串，如果响应尚未收到或响应中不存在该报头，则返回 null\n4. XMLHttpRequest.open(): 初始化一个请求。该方法只能在 JavaScript 代码中使用，若要在 native code 中初始化请求，请使用 openRequest()。\n5. XMLHttpRequest.overrideMimeType(): 覆写由服务器返回的 MIME 类型。\n6. XMLHttpRequest.send(): 发送请求。如果请求是异步的（默认），那么该方法将在请求发送后立即返回。\n7. XMLHttpRequest.setRequestHeader(): 设置 HTTP 请求头的值。必须在 open() 之后、send() 之前调用 setRequestHeader() 方法\n\n### 标准事件\n1. abort: 当 request 被停止时触发，例如当程序调用 XMLHttpRequest.abort() 时。也可以使用 onabort 属性。\n2. error: 当 request 遭遇错误时触发。 也可以使用 onerror 属性\n3. load: XMLHttpRequest请求成功完成时触发。 也可以使用 onload 属性\n4. loadend: 当请求结束时触发, 无论请求成功 ( load) 还是失败 (abort 或 error)。也可以使用 onloadend 属性。\n5. loadstart: 接收到响应数据时触发。也可以使用 onloadstart 属性。\n6. progress: 当请求接收到更多数据时，周期性地触发。也可以使用 onprogress 属性。\n7. timeout: 在预设时间内没有接收到响应时触发。 也可以使用 ontimeout 属性\n\n\n### 代码封装\n```js\nfunction (opts) { \nconst xhr = new XMLHttpRequest();\nxhr.open(opts.type || 'GET', opts.url, true);\nxhr.success = opts.success;\nxhr.fail = opts.fail;\nxhr.withCredentials = opts.withCredentials;\nxhr.onreadystatechange = function () {\n   if (xhr.readyState === 4) {\n       const status = xhr.status;\n       if (status >= 200) {\n           opts.success && opts.success(xhr.responseText);\n       } else {\n           opts.fail && opts.fail(`Request failed, status: ${status}, responseText: ${xhr.responseText}`);\n       }\n   }\n}\nif (opts.type === 'POST') {\n  if (opts.headers) {\n      for (const key in opts.headers) {\n          xhr.setRequestHeader(key, opts.headers[key]);\n      }\n  }\n  xhr.send(opts.data);\n} else {\n  xhr.send();\n}\nreturn xhr;\n}\n```\n\n## hook\n### 重写xhr.open原型方法, 替换url\n```js\nfunction fill(source: object, key: string, replacementFactory: Function) {\n  if (!(key in source)) {\n    return;\n  }\n\n  const original = source[key];\n  const wrapped = replacementFactory(original);\n\n  if (typeof wrapped === 'function') {\n    try {\n      wrapped.prototype = wrapped.prototype || {};\n    } catch (err) {\n      console.warn('This can throw if multiple fill happens on a global object like XMLHttpRequest', err);\n    }\n  }\n\n  source[key] = wrapped;\n}\n\nif (('XMLHttpRequest' in window)) {\n  fill(XMLHttpRequest.prototype, 'open', originalOpen => function replacementFactory(...args) {\n    const { url } = xhrHostReplace(args[1]);\n    args[1] = url;\n    return originalOpen.apply(this, args);\n  });\n}\n```\n\n### 生成xhr代理对象，覆盖全局xhr对象\nAjax-hook实现的整体思路是实现一个XMLHttpRequest的代理对象，然后覆盖全局的XMLHttpRequest，这样一但上层调用 new XMLHttpRequest这样的代码时，其实创建的是Ajax-hook的代理对象实例\n\n参考文档：https://www.jianshu.com/p/7337ac624b8e\n<br >\n[来源于](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)","tags":["xhr","请求hook"]},{"title":"Linux系统命令及Shell脚本实践指南","url":"/2022/04/25/Linux系统命令及Shell脚本实践指南/","content":"\n## linux简介\n### linux的特点\n1. **免费开源。**Linux是一款完全免费的操作系统，任何人都可以从网络上下载到它的源代码，并可以根据自己的需求进行定制化的开发，而且没有版权限制。\n2. **模块化程度高。**Linux的内核设计分成进程管理、内存管理、进程间通信、虚拟文件系统、网络5部分，其采用的模块机制使得用户可以根据实际需要，在内核中插入或移走模块，这使得内核可以被高度的剪裁定制，以方便在不同的场景下使用。\n3. **广泛的硬件支持。**得益于其免费开源的特点，有大批程序员不断地向Linux社区提供代码，使得Linux有着异常丰富的设备驱动资源，对主流硬件的支持极好，而且几乎能运行在所有流行的处理器上。\n4. **安全稳定。**Linux采取了很多安全技术措施，包括读写权限控制、带保护的子系统、审计跟踪、核心授权等，这为网络环境中的用户提供了安全保障。实际上有很多运行Linux的服务器可以持续运行长达数年而无须重启，依然可以性能良好地提供服务，其安全稳定性已经在各个领域得到了广泛的证实。\n5. **多用户，多任务。**多用户是指系统资源可以同时被不同的用户使用，每个用户对自己的资源有特定的权限，互不影响。多任务是现代化计算机的主要特点，指的是计算机能同时运行多个程序，且程序之间彼此独立，Linux内核负责调度每个进程，使之平等地访问处理器。由于CPU处理速度极快，从用户的角度来看所有的进程好像在并行运行。\n6. **良好的可移植性。**Linux中95%以上的代码都是用C语言编写的，由于C语言是一种机器无关的高级语言，是可移植的，因此Linux系统也是可移植的。\n\n\n### linux启动流程\n1. 首先，计算机会加载BIOS，这是计算机上最接近硬件的软件，各家主板制造商都会开发适合自己主板的BIOS，而BIOS中一项很重要的功能就是对自身的硬件做一次健康检查，只有硬件没有问题，才能运行软件，记住，操作系统也是一种软件\n2. 机器自检通过后，下面就要引导系统了。这个动作是BIOS设定的，BIOS默认会从硬盘上的第0柱面、第0磁道、第一个扇区中读取被称为MBR的东西，即主引导记录\n3. 第三步就是顺理成章地运行Grub了。Grub最重要的功能就是根据其配置文件加载kernel镜像，并运行内核加载后的第一个程序/sbin/init，这个程序会根据/etc/inittab来进行初始化的工作\n4. Linux将根据/etc/inittab中定义的系统初始化配置si::sysinit:/etc/rc.d/rc.sysinit执行/etc/rc.sysinit脚本，该脚本将会设置系统变量、网络配置，并启动swap、设定/proc、加载用户自定义模块、加载内核设置等。\n5. 根据第三步读到的runlevel值来启动对应的服务，如果值为3，就会运行/etc/rc3.d/下的所有脚本，如果值为5，就会运行/etc/rc5.d/下的所有脚本。\n6. 将运行/etc/rc.local\n7. 会生成终端或X Window来等待用户登录\n\n\n### linux帮助命令\n#### 使用man page\n```sh\nman ls\n```\n\n#### 使用info page\n可以在命令行中输入info ls来显示ls命令的说明文\n```sh\ninfo ls\n```\n\n## linux用户管理\n### linux用户和用户组\n#### uid和gid\nLinux系统中的用户分为3类，**即普通用户、根用户、系统用户。**\n1. 普通用户: 通常普通用户的UID大于500，因为在添加普通用户时，系统默认用户ID从500开始编号。\n2. 根用户: 根用户也就是root用户，它的ID是0，也被称为超级用户，root账户拥有对系统的完全控制权：可以修改、删除任何文件，运行任何命令。所以root用户也是系统里面最具危险性的用户，root用户甚至可以在系统正常运行时删除所有文件系统，造成无法挽回的灾难。\n3. 系统用户：系统用户是指系统运行时必须有的用户，但并不是指真实的使用者。系统用户的ID范围是1~499 \n\n```sh\n#要确认自己的UID，可以使用以下id命令来获得：\nid\n\n#要确认自己所属的用户组，可以使用以下groups命令来获得\ngroups\n\n#如果要查询当前在线用户，可在用户登录以后，使用命令who看到目前登录在系统中的所有用户\nwho\n```\n\n#### /etc/passwd 和 /etc/shadow\n在登录Linux时必须要输入用户名和密码。而系统用来记录用户名、密码最重要的两个文件就是/etc/passwd 和 /etc/shadow(而且默认只有root用户才有读的权限，其他人完全没有读取这个文件的可能)\n### linux账号管理\n#### 新增和删除用户\n1. 新增用户： useradd\n2. 修改密码： passwd\n3. 修改用户： usermod\n4. 删除用户： userdel\n\n#### 新增和删除用户组\n1. 新增用户组： groupadd\n2. 删除用户组： groupdel\n\n#### 检查用户信息\n1. 查看用户： users、who、w\n```sh\n#使用命令users可以查看当前系统有哪些用户。比如，在当前的系统中运行users命令，就会发现有两个root在当前机器上登录。\nusers\n\n#第一列是登录用户的用户名，第二列是用户登录的终端，第三列是用户登录的时间。\nwho\n\n#w命令的第一行会显示当前时间、系统运行时间、已登录的用户数量和系统负载。下面显示的信息分为8列\nw\n```\n\n2. 调查用户：finger\n```sh\n#如果在finger后跟上某个用户名，则显示该用户更详细的信息，\nfinger user1\n```\n\n### linux切换用户\n#### 切换其他用户\n假如说我以普通用户john登录到系统中，这时候想使用useradd添加一个用户，怎么办？普通用户是没有添加用户的权限的，只有root用户才能创建用户。当然我们可以使用exit命令退出当前用户，然后使用root用户登录，再使用useradd添加用户。但是也有一种更方便的方式，那就是使用su命令，su是切换用户的意思。在不加参数的情况下，su命令默认表示切换到root用户，之后只要输入root密码就可以切换身份为root了，完成操作后，使用exit命令可以退出root切换到原先的用户。如下所示：\n```sh\n#su命令默认表示切换到root用户，之后只要输入root密码就可以切换身份为root了，\n#完成操作后，使用exit命令可以退出root切换到原先的用户\nsu\n\n#加上-这个参数后，切换成root用户时，不但身份变成了root，而且还能应用root的用户环境\nsu -\n```\n**使用su命令切换用户之后，当前的用户环境并没有发生变化，而使用su-命令切换用户后，用户环境变成root的了**\n#### 用其他用户的身份执行命令：sudo\nsudo并不是真的切换了用户，而是使用其他用户的身份和权限执行了命令。\n\n\n\n### linux例行任务管理\n>在Linux中也有处理这两种任务的方法。如果任务是周期性执行的，其命令为cron；如果只是在某一个特定的时间执行一次，其命令为at。\n#### 单一时刻执行一次任务：at\n*默认情况下，所有用户都可以使用at命令来调度自己的任务，如果由于特殊的原因需要禁止某些用户使用这个功能，可以将该用户的用户名添加至/etc/at.deny*\n\n#### 周期性执行任务：cron\n*有一些任务是需要周期性执行的，比如说每天早晨的闹钟会在设定的时间准时响起*\n1. 启动crond进程\n```sh\nservice crond start\n\nservice crond status\n```\n2. 编辑任务crontab -e\n```sh\n* * * * * command\n\n#前面5个*可以用来定义时间，\n#第一个*表示分钟，可以使用的值是1~59，每分钟可以使用*和*/1表示；\n#第二个*表示小时，可以使用的值是0~23；\n#第三个*表示日期，可以使用的值是1~31；\n#第四个*表示月份，可以使用的值是1~12；\n#第五个*表示星期几，可以使用的值是0~6，0代表星期日；\n#最后是执行的命令\n```\n\n3. 示例\n```sh\n*  *  *  *  * service httpd restart\n*/1  *  *  *  * service httpd restart\n#这两种写法其实是一致的，都是每分钟重启httpd进程。请注意，这只是一个例子，除非你有确定的目的，否则不要在实际生产环境中这么设置\n\n*  */1  *  *  * service httpd restart\n#每小时重启httpd 进程\n\n\n*  23-3/1  *  *  * service httpd restart\n#从23点开始到3点，每小时重启httpd 进程\n\n\n30 23 *  *  * service httpd restart\n#每天晚上23点30分重启httpd进程\n\n\n30 23 1  *  * service httpd restart\n#每月的第一天晚上23点30分重启httpd进程\n\n\n30 23 1  1  * service httpd restart\n#每年1月1日的晚上23点30分重启httpd进程\n\n\n30 23 *  *  0 service httpd restart\n#每周日晚上23点30分重启httpd进程\n```\n\n4. 查看定时任务 crontab -l\n   \n*如果由于特殊的原因需要禁止某些用户使用这个功能，可以将该用户的用户名添加至/etc/cron.deny中*\n\n#### /etc/crontab管理\n我们知道用户可以通过crontab-e命令来编辑定义自己的任务，事实上，系统也有自己的例行任务，而其配置文件是/etc/crontab。\n```sh\n[root@localhost ~]# cat /etc/crontab\nSHELL=/bin/bash\nPATH=/sbin:/bin:/usr/sbin:/usr/bin\nMAILTO=root\nHOME=/\n\n# run-parts\n01 * * * * root run-parts /etc/cron.hourly\n02 4 * * * root run-parts /etc/cron.daily\n22 4 * * 0 root run-parts /etc/cron.weekly\n42 4 1 * * root run-parts /etc/cron.monthly\n```\n\n## linux文件管理\n### 文件和目录管理\n#### 文件的相关操作\nLinux遵循一切皆文件的规则，对Linux进行配置时，在很大程度上就是处理文件的过程，所以掌握文件的相关操作是非常有必要的\n1. 创建文件：touch\n2. 删除文件：rm\n3. 移动或重命名文件： mv，后面需要跟两个参数，**第一个参数是要被移动的文件，第二个参数是移动到的目录**\n```sh\n# 把test.log文件移动到/mnt中\nmv test.log /mnt/ \n# 把test.log重命名为test1.log\nmv test.log test1.log\n# 移动文件的同时重命名文件\nmv test.log /mnt/test2.log\n```\n4. 查看文件：cat\n5. 查看文件头： head\n```sh\n# 默认情况下，head将显示该文件前10行的内容;也可以使用-n参数指定显示的行数\nhead -n 20 /text.log\n```\n6. 查看文件尾: tail\n```sh\n# 要动态地查看文件，使用-f参数就可以做到\ntail -f /text.log\n```\n7. 文件格式转换：dos2unix, 当把Windows下的文本文件移动到Linux下时，会由于系统之间文本文件的换行符不同而造成文件在Linux下的读写操作有问题\n\n#### 目录的相关操作\n1. 创建目录：mkdir\n```sh\n# 可以使用-p参数一次性创建所有目录，这样就不用费力地一个个创建了，命令如下所示\nmkdir -p dir2/dir3\n```\n2. 删除目录：rmdir和rm\n```sh\n# rmdir 用来删除目录。但是需要注意的是，它只能删除空目录，如果目录不为空（存在文件或者子目录），那么该命令将拒绝删除指定的目录\nrmdir dir1 #提示dir1为非空目录\n\n# rm\nrm -rf dir1\n```\n3. 文件和目录复制：cp\n```sh\n# 复制文件且重命名\ncp a.txt /tmp/b.txt\n\n# 复制文件不重命名\ncp a.txt /tmp/\n\n# 复制目录所有文件\ncp -rf /dir1/* /dir2/ \n```\n\n#### 文件时间戳\n通过touch可以创建新文件。如果文件已经存在，那么touch命令仅仅会更新文件的创建时间而不会修改文件内容。请记住，在Linux下目录也是一种文件，所以如果touch一个目录，这个目录的创建时间也会被更新\n\n### 文件和目录权限\n#### 查看文件或者目录权限: ls -al\n```sh\n# -l参数表示要求ls命令列出每个文件的详细信息，\n# -a参数则要求ls命令还要同时列出隐藏文件\nls -al \n[root@localhost ~]# ls -al\ntotal 112\ndrwxr-x---  3 root root  4096 Oct  1 10:43 .\ndrwxr-xr-x 24 root root  4096 Oct  1 07:42 ..\n-rw-------  1 root root  5659 Sep 24 02:07 .bash_history\n-rw-r--r--  1 root root    24 Jan  6  2007 .bash_logout\n-rw-------  1 root root    72 Oct  1 08:45 .lesshst\ndrwx------  2 root root  4096 Oct  1 08:48 .ssh\n\n#第一列：是文件类别和权限，这列由10个字符组成，第一个字符表明该文件的类型\n#第二列：代表“连接数”，除了目录文件之外，其他所有文件的连接数都是1，目录文件的连接数是该目录中包含其他目录的总个数+2，也就是说，如果目录A中包含目录B和C，则目录A的连接数为4\n#第三列：代表该文件的所有人\n#第四列：代表该文件的所有组\n#第五列：是该文件的大小\n#第六列：是该文件的创建时间或最近的修改时间\n#第七列：是文件名\n```\n\n第一列含义：\n<img src=\"/img/linux1.jpeg\" style=\"max-width:95%\" />\n\n#### 改变文件权限：chmod\nLinux下的每个文件都定义了文件拥有者（user）、拥有组（group）、其他人（others）的权限，我们使用字母u、g、o来分别代表拥有者、拥有组、其他人，而对应的具体权限则使用rwx的组合来定义，增加权限使用+号，删除权限使用-号，详细权限使用=号。图中用一些例子说明了如何使用chmod来改变文件的权限。\n<img src=\"/img/linux2.jpeg\" style=\"max-width:95%\" />\n如果要给用户组或其他人添加或删除相关权限，只需要将上面的u相应地更换成g或o即可。但是正如大家看到的，这种方式同一时刻只能给文件拥有者、文件拥有组或是其他所有人设置权限，如果要想同时设置所有人的权限就需要使用数字表示法了，我们定义r=4，w=2，x=1，如果权限是rwx，则数字表示为7，如果权限是r-x，则数字表示为5。假设想设置一个文件的权限是：拥有者的权限是读、写、执行（rwx），拥有组的权限是读、执行（r-x），其他人的权限是只读（r--），那么可以使用命令chmod 754 somefile来设置\n\n```sh\n# 修改某个目录权限\nchmod -R 754 somedir\n```\n#### 改变文件的拥有者：chown\n```sh\n# 修改文件拥有者\nchown chao a.txt\n\n# 修改文件拥有组\nchown :chao a.txt\n\n# 同时修改文件拥有者和拥有组\nchown chao:chao a.txt\n\n# 同时修改目录拥有者和拥有组\nchown -R chao:chao somedir\n```\n#### 改变文件的拥有者：chown\n```sh\nchgrp -R chao somedir\n```\n\n#### 查看文件类型：file\n使用ls-l令可以通过查看第一个字符判断文件类型。字母d代表目录、字母l代表连接文件，字母b代表块文件，字母c代表字符文件，字母s代表socket文件，字符-代表普通文件，字母p代表管道文件\n\n### 查找文件\n#### 一般查找 find\n```sh\n# 从根目录开始寻找名为httpd.conf的文件\nfind / -name httpd.conf\n\n# 从etc目录开始寻找名为httpd.conf的文件\nfind /etc -name httpd.conf\n\n# 查找系统所有以conf结尾的文件\nfind / -name *.conf\n\n# 查找系统所有以http开头文件\nfind / -name httpd*\n```\n<img src=\"/img/linux3.jpeg\" style=\"max-width:95%\" />\n\n\n#### 数据库查找 locate\n与find不同，locate命令依赖于一个数据库文件，Linux系统默认每天会检索一下系统中的所有文件，然后将检索到的文件记录到数据库中，所以使用locate命令要比find命令反馈更为迅速。\n```sh\n# 更新数据库 --> 查找文件\nupdatedb\nfind /etc -name httpd.conf\n```\n\n#### 查找执行文件 which/whereis\nwhich用于从系统的PATH变量所定义的目录中查找可执行文件的绝对路径。比如说想查找node这个命令在系统中的绝对路径\n```sh\nwhich node\n\n# 使用whereis也能查到其路径，但是和which不同的是，\n# 它不但能找出其二进制文件，还能找出相关的man文件：\nwhereis node\n```\n\n### 文件压缩和打包\n#### gzip/gunzip\ngzip/gunzip是用来压缩和解压缩单个文件的工具\n```sh\n# 压缩install.log文件\ngzip install.log  # 最终压缩的文件名：install.log.gz\n\n# 解压 install.log.gz\ngunzip install.log.gz\n```\n#### tar\ntar不但可以打包文件，还可以将整个目录中的全部文件整合成一个包，整合包的同时还能使用gzip的功能进行压缩，比如说把整个/boot目录整合并压缩成一个文件\n```sh\n# 压缩命令: 压缩/boot目录成bott.tgz\n# -z的含义是使用gzip压缩\n# -c是创建压缩文件（create）\n# -v是显示当前被压缩的文件\n# -f是指使用文件名，也就是这里的boot.tgz文件\ntar -zcvf boot.tgz /boot\n\n# 压缩命令 讲zain目录 压缩为dist.tar.gz\ntar -czf dist.tar.gz zain/\n\n\n# 解压命令: 直接将boot.tgz在当前目录中解压成boot目录\ntar -zxvf boot.tgz\n\n# 解压命令：使用-c参数指定压缩后的目录存放位置。比如说将boot目录解压到/tmp目录中\ntar -zxvf boot.tgz -c /tmp\n```\n\n## linux文件系统\n### 文件系统\n大家已经知道Linux使用了树形文件存储结构，在磁盘上存储文件的时候，使用的则是目录加文件的形式。但实际上对于磁盘等各种存储设备来说，无论是什么数据，都只有0和1的概念。而对用户来说，0和1同样毫无意义，那怎么办呢？这就需要一种类似于“翻译”的机制存在于用户和磁盘之间了，在Linux中采用的是文件系统+虚拟文件系统（Virtual File System，VFS）的解决方案。\n\n### 磁盘分区、创建文件系统、挂载\n#### 创建文件系统：fdisk\n\n#### 磁盘挂载：mount\n创建了文件系统的分区后，在Linux系统下还需要经过挂载才能使用，挂载设备的命令是mount，\n\n#### 磁盘检查：fsck、badblocks\n当磁盘出现逻辑错误时，可以使用fsck来尝试修复。出现此类错误比较典型的情况是当机器突然掉电时可能引发。\n\n### 硬链接和软连接\n#### 硬链接\n硬链接（hard link）又称实际链接，是指通过索引节点来进行链接。在Linux文件系统中，所有的文件都会有一个编号，称为inode，多个文件名指向同一索引节点是被允许的，这种链接就是硬链接。硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接指向同一文件，删除一个链接并不会影响索引节点本身和其他的链接，只有当最后一个链接被删除时，文件的数据块及目录的链接才会被释放。也就是说，文件真正删除的前提条件是与之相关的所有硬链接均被删除。**硬链接有两个限制：**\n1. 不允许给目录创建硬链接；\n2. 只有在同一文件系统中的文件之间才能创建链接，即不同分区上的两个文件之间不能够建立硬链接。\n\n```sh\n# 创建目录\nmkdir -p hard\ncd hard\ntouch hard01\n\n# 查看inode\nls -li\n3834061-rw-r--r-- 1 root root 0 Jan 15 10:50 hard01\n\n# 创建hard01的硬链接hard01_hlink\n# 硬链接hard01_hlink指向的inode和hard01指向inode是一致的\nln hard01 hard01_hlink \n\n# ls -li 查看文件inode\n# 文件创建之初该值为1，该文件每增加一个硬链接该值将增1(变成2)，\n# 当此数为0的时候该文件才能真正被文件系统删除\nls -li\n3834061-rw-r--r-- 2 root root 0 Jan 15 10:50 hard01\n3834061-rw-r--r-- 2 root root 0 Jan 15 10:50 hard01_hlink\n```\n\n#### 软连接\n软链接（soft link）又称符号链接（symbolic link），是一个包含了另一个文件路径名的文件，可以指向任意文件或目录，也可以跨不同的文件系统。软链接和Windows下的“快捷方式”十分类似，删除软链接并不会删除其所指向的源文件，如果删除了源文件则软链接会出现“断链”。\n```sh\n# 创建目录\nmkdir -p soft\ncd soft\ntouch soft01\n\n# 创建软连接使用-s，\nln -s soft01 soft01_slink\n\nls -li\n3834063-rw-r--r-- 1 root root 0 Jan 15 10:50 soft01\n3834064-rw-r--r-- 1 root root 0 Jan 15 10:50 soft01_slink\n```\n另外还请注意，在创建软链接的前后分别使用ls -li命令，会发现软链接的inode和源文件的inode不一样，这说明软链接本身就是一个文件。\n读者可以尝试删除软链接的源文件，然后可以在终端中看到对应的软链接将会以闪烁的方式标记其已是一个断链。\n\n## 字符处理\n### 管道\n在Linux中也存在着管道，它是一个固定大小的缓冲区，该缓冲区的大小为1页，即4K字节。管道是一种使用非常频繁的通信机制，我们可以用管道符“|”来连接进程，由管道连接起来的进程可以自动运行，如同有一个数据流一样，所以管道表现为输入输出重定向的一种方法，它可以把一个命令的输出内容当作下一个命令的输入内容，两个命令之间只需要使用管道符连接即可。\n```sh\n# 如果想要看一下/etc/init.d目录下文件的详细信息，\n# 可以使用ls-l/etc/init.d命令，不过这可能会出现因输出内容过多而造成翻屏的情况，\n# 这样一来，先输出的内容在屏幕上就看不到了。\n# 其实这里就可以利用管道功能，将命令的输出使用more程序一页一页地显示出来\nls -l /etc/init.d | more\n```\n### 使用grep搜索文本\n```sh\ngrep [-ivnc] '需要匹配字符' 文件名\n# -i 不区分大小写\n# -c 统计包括匹配的行数\n# -n 输出行号\n# -v 反向匹配\n```\n\n案例：\n```sh\n# 查找含有name的行\ngrep 'name' txt1.txt\n\n# 查找含有name的行编号\ngrep -n 'name' txt1.txt\n\n# 查找含有name的行编号， 忽略大小写\ngrep -ni 'name' txt1.txt\n\n# 管道\ncat txt1.txt | grep -ni 'name'\n```\n\n### 使用sort排序\n```sh\nsort [-ntkr] 文件名\n# -n 采用数字排序\n# -t 指定分隔符\n# -k 指定第几行\n# -r 反向排序\n```\n\n案例：\n```sh\n# cat sort.txt\nb:3\nc:2\na:4\ne:5\nd:1\nf:11 \n\n# cat sort.txt | sort \na:4\nb:3\nc:2\nd:1\ne:5\nf:11\n#对输出内容直接排序时，默认按照每行的第一个字符进行排序\n\n# cat sort.txt | sort -t \":\" -k 2-n\nd:1\nc:2\nb:3\na:4\ne:5\nf:11\n```\n\n### 使用uniq删除重复内容\n如果文件（或标准输出）中有多行完全相同的内容，我们很自然希望能删除重复的行，同时还可以统计出完全相同的行出现的总次数，uniq命令就能帮助解决这个问题。\n```sh\nuniq [-ic]\n# -i 忽略大小写\n# -c 计算重复行数\n```\n\n案例：\n```sh\n# cat uniq.txt | uniq\nabc\n123\nabc\n123\n\n# cat uniq.txt | sort | uniq\n123\nabc\n\n#使用-c参数就会在每行前面打印出该行重复的次数\n# cat uniq.txt | sort | uniq -c\n2 123\n2 abc\n```\n\n\n### 使用cut截取文本\n顾名思义，cut就是截取的意思，它能处理的对象是“一行”文本，可从中选取出用户所需要的部分。在有特定的分隔符时，可以指定分隔符，然后打印出以分隔符隔开的具体某一列或某几列\n```sh\ncut -f指定行 -d'分隔符'\ncut -c指定列的字符\n```\n\n案例\n```sh\n# 比如说我们需要打印出系统中的所有用户\ncat /ect/passwd | cut -f1 -d':'\n\n# 同时打印出用户和这个用户的家目录\ncat /ect/passwd | cuf -f1,6 -d':'\n\n# 同时打印出每位用户的登录shell\ncat /ect/passwd | cuf -f1,6-7 -d':'\n\n# 假设想要打印出每行第1～5个字符，以及第7～10个字符的内容\ncat /ect/passwd | cuf -c1-5,7-10\n```\n\n### 使用tr做文本转换\ntr命令比较简单，其主要作用在于文本转换或删除。这里假设要把文件/etc/passwd中的小写字母转换为大写字母，然后再尝试删除文本中的冒号\n```sh\ncat /etc/passwd | tr '[a-z]' '[A-Z]'\n\ncat /etc/passwd | tr -d ':'\n```\n\n### 使用paste做文本合并\npaste的作用在于将文件按照行进行合并，中间使用tab隔开。假设有两个文件分别为a.txt、b.txt，下面使用paste命令来合并文件\n```sh\n# cat a.txt\n1\n2\n3\n\n# cat b.txt\na\nb\nc\n\n# past a.txt b.txt\n1 a\n2 b\n3 c\n\n# past -d: a.txt b.txt\n1:a\n2:b\n3:c\n```\n\n### 使用split分割大文件\n在Linux下使用split命令来实现文件的分割，支持按照行数分割和按照大小分割这两种模式。要说明的是，二进制文件因为没有“行”的概念，所以二进制文件无法使用行分割，而只能按照文件大小进行分割。\n```sh\n# -l参数：指定每500行为一个文件 \n# 分割完成后，当前目录下会产生很多小文件\nsplit -l 500 big_file.txt small_file_\n\n# 如果是二进制文件， 只能按照文件大小分割\n# 分割完成后，当前目录下会产生很多大小为6m的小文件\nsplit -b 64m big_bin small_bin_\n```\n\n## 网络管理\n### 网络接口\n#### ifconfig检查和配置网卡\n如果不使用任何参数，输入ifconfig命令时将会输出当前系统中所有处于活动状态的网络接口。\n<img src=\"/img/linux4.jpeg\" style=\"max-width:95%\" />\n图中的eth0表示的是以太网的第一块网卡。其中eth是Ethernet的前三个字母，代表以太网，0代表是第一块网卡，第二块以太网网卡则是eth1，以此类推。Linkencap是指封装方式为以太网；HWaddr是指网卡的硬件地址（MAC地址）；inetaddr是指该网卡当前的IP地址；Broadcast是广播地址（这部分是由系统根据IP和掩码算出来的，一般不需要手工设置）；Mask是指掩码；UP说明了该网卡目前处于活动状态；MTU代表最大存储单元，即此网卡一次所能传输的最大分包；RX和TX分别代表接收和发送的包；collision代表发生的冲突数，如果发现值不为0则很可能网络存在故障；txqueuelen代表传输缓冲区长度大小；第二个设备是lo，表示主机的环回地址，这个地址是用于本地通信的。\n\n**手动设置etho的ip地址**\n```sh\nifconfig etho 192.168.159.130 netmask 255.255.255.0\n\n# 有时候需要手工断开/启用网卡，以eth0为例，使用方法如下：\nifconfig eth0 down #断开\nifconfig etho up #启用\n```\n\n#### 将ip配置信息写入配置文件\n上一小节讲到的ifconfig命令可以直接配置网卡IP，但是这属于一种动态的配置，所配置的信息只是保存在当前运行的内核中。一旦系统重启，这些信息将丢失。为了能在重启后依然生效，可以在相关的配置文件中保存这些信息，这样，系统重启后将从这些配置文件中读取出来。RedHat和CentOS系统的网络配置文件所处的目录为/etc/sysconfig/network-scripts/，eth0的配置文件为ifcfg-eth0，如果有第二块物理网卡，则配置文件为ifcfg-eth1，以此类推\n```sh\ncat ifcfg-eth0\n\n# Advanced Micro Devices [AMD] 79c970 [PCnet32 LANCE]\nDEVICE=eth0 # DEVICE变量定义了设备的名称\nBOOTPROTO=static # 系统在启用这块网卡时，IP将会通过dhcp的方式获得；还有个可选的值是static，表示静态设置的IP\nONBOOT=yes # ONBOOT变量定义了启动时是否激活使用该设备，yes表示激活，no表示不激活\nIPADDR=192.168.159.129\nNETMASK=255.255.255.0\n\n# 生效操作\nifconfig eth0 down\nifconfig eth0 up\n# 或者\nservice network restart\n```\n\n### 路由和网关\nLinux主机之间是使用IP进行通信的，假设A主机和B主机同在一个网段内且网卡都处于激活状态，则A具备和B直接通信的能力（通过交换机或简易HUB）。但是如果A主机和B主机处于两个不同的网段，则A必须通过路由器才能和B通信。一般来说，路由器属于IT设备的基础设施，每一个网段都应该有至少一个网关。在Linux中可使用route命令添加默认网关。假设添加的网关是192.168.159.2，添加方式如下\n```sh\n# 添加\nroute add default gw 192.168.159.2\n\n# 删除\nroute del default gw 192.168.159.2\n```\n\n如果只使用route命令添加网关，一旦系统重启，配置信息就不存在了，必须将这种配置信息写到相关的配置文件中才能永久保存。可以在网卡配置文件中使用GATEWAY变量来定义网关，只需要添加如下部分到ifcfg-eth0中即可，当然别忘了重启网络服务使配置生效\n```sh\nGATEWAY=192.168.159.2\n```\n另外，在配置文件/etc/sysconfig/network中添加这段配置也能达到同样的效果。\n\n### DNS客户端配置\n#### /etc/hosts\n们使用hosts文件来记录主机名和IP的对应关系，这样访问对方的主机时，就不需要使用IP了，只需要使用主机名。这个文件在Linux下就是/etc/hosts，这种方式确实“可以工作”，但是当主机数量增长到一定数量级的时候仍然无法适用。为了彻底解决这个问题，人们发明了DNS系统。经过几十年的发展，虽然系统、网络技术都发生了翻天覆地的变化，但是这个文件还是被当作传统保留了下来。hosts文件的作用主要如下：\n* 加快域名解析。当访问网站时，系统会首先查看hosts文件中是否有记录，如果记录存在则直接解析出对应的IP，这时则不需要请求DNS服务器\n* 方便小型局域网用户使用的内部设备。很多单位的局域网中都存在着不少内部应用系统（比如办公自动化OA、公司论坛等），平时在工作中也都需要访问，但是由于这些局域网太小而不必为此专门设置DNS服务器，那么此时使用hosts文件则能简单地解决这个问题。\n\n#### /etc/resolv.conf\n从技术上来说，DNS就是全互联网上主机名及其IP地址对应关系的数据库。设置主机为DNS客户端的配置文件就是/etc/resolv.conf，其中包含nameserver、search、domain这3个关键字\n```sh\n# search关键字后紧跟的是一个域名。\n# 每个主机严格来说都应该有一个FQDN（全限定域名），所以往往域名就很长，\n# 如果这里写成search google.com，那么www就代表www.google. com了，\n# 这个关键字后可以跟多个域名。\nsearch bigo.local \nnameserver 172.24.8.15 # 172.24.8.15为DNS主机的IP地址\nnameserver 172.24.8.16\n```\n\n### 网络测试工具\n#### ping\nping程序的目的在于测试另一台主机是否可达，一般来说，如果ping不到某台主机，就说明对方主机已经出现了问题，但是不排除由于链路中防火墙的因素、ping包被丢弃等原因而造成ping不通的情况\n```sh\nping 10.0.1.1.145\n```\n#### host\nhost命令是用来查询DNS记录的，如果使用域名作为host的参数，命令返回该域名的IP\n```sh\n# host baidu.com\nbaidu.com has address 220.181.38.148\nbaidu.com has address 220.181.38.251\nbaidu.com mail is handled by 10 mx.maillb.baidu.com.\nbaidu.com mail is handled by 20 mx1.baidu.com.\nbaidu.com mail is handled by 20 jpmx.baidu.com.\nbaidu.com mail is handled by 20 mx50.baidu.com.\nbaidu.com mail is handled by 20 usmx01.baidu.com.\nbaidu.com mail is handled by 15 mx.n.shifen.com.\n```\n\n#### 网络故障排查\n1. 硬件故障又主要分为网卡物理损坏、链路故障等原因。\n2. 软件主要表现为网卡驱动故障，也就是操作系统对网卡驱动的不兼容，这个问题往往需要通过安装对应的网卡设备驱动来解决\n```sh\n# 第一步:确认网卡本身是否能正常工作? \nping 127.0.0.1\n\n# 第二步确认网卡是否出现了物理或驱动故障，使用ping本机IP地址的方式，如果能ping通则说明本地设备和驱动都正常\n\n# 第三步要确认是否能ping通同网段的其他主机\n\n# 第四步要确认是否能ping通网关IP\n\n# 第五步确认是否能ping通公网上的IP\n\n# 第六步确认是否能ping通公网上的某个域名，如果能ping通则说明DNS部分设置正确\n```\n## 进程管理\n### 什么是进程\n进程表示程序的一次执行过程，它是应用程序的运行实例，是一个动态的过程。或者可以更简单地描述为：进程是操作系统当前运行的程序。当一个进程开始运行时，就是启动了这个过程。\n\n所有的进程都可能存在3种状态：运行态、就绪态、阻塞态。运行态表示程序当前实际占用着CPU等资源；就绪态是指程序除CPU之外的一切运行资源都已经就绪，等待操作系统分配CPU资源，只要分配了CPU资源，即可立即运行；而阻塞态是指程序在运行的过程中由于需要请求外部资源（例如I/O资源、打印机等低速的或同一时刻只能独享的资源）而当前无法继续执行，从而主动放弃当前CPU资源转而等待所请求资源。\n\n而进程同步指的是进程间通过某种通信机制实现信息交互。现代计算机使用信号量机制来实现进程间的互斥和同步，它的基本原理是：两个或者多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一位置停止，直到它接收到一个特定的信号。\n### 进程、线程、程序区别\n#### 进程 VS 程序\n进程是动态的，而程序是静态的，进程是程序以及数据在计算机上的一次执行，没有静态的程序也就没有动态的执行。程序是可以以某种形式保存在存储介质上的，而进程只能在运行时存在于计算机的内存中。\n*如果说做一件事情需要经过若干既定的步骤，这些步骤可以被写成清单静态地列在纸上，那么它们就是广义上的“程序”，而只有真正开始将计划的步骤付诸实施的过程才是“进程”*\n\n\n#### 进程 VS 线程\n进程是资源分配的最小单位，线程是CPU调度的最小单位。做个简单的比喻：进程=火车，线程=车厢。\n1. 线程在进程下行进（单纯的车厢无法运行）\n2. 一个进程可以包含多个线程（一辆火车可以有多个车厢）\n3. 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）\n4. 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）\n\n### 进程观察： ps、top\n1. 命令ps输出的只是当前查询状态下进程瞬间的状态信息，如果要想及时动态地查看进程就需要使用top命令了。\n2. top命令提供了实时的系统状态监控，可以按照CPU使用、内存使用、执行时间等指标对进程进行排序\n\n```sh\nps [-Aawu]\n# -A 列出所有进程\n# -a 显示和本终端不相关的所有进程\n# -w 显示加宽可以显示更多信息\n# -u 显示有效使用者相关进程\n\ntop \n```\n\n### 进程的终止： kill、killall\nkill这些命令的原理都是向内核发送一个系统操作信号以及某个进程的标识号，使得内核对指定标识号的进程进行相应的操作。 典型用法是使用ps查出进程的PID，然后使用kill将其终止\n```sh\n# 第一步\nps -ef | grep dhcp # 2899\n# 或者\npidof dhcp  # 2899\n\n# 第二步\nkill 2899\n```\n\n命令kill后可以跟的信号代码一共有64种，使用kill-l就可以看到具体有哪些，如图所示。但是常用的一般只有3个，即HUP（1）、KILL（9）、TERM（15），分别代表重启、强行杀掉、正常结束。\n<img src=\"/img/linux5.jpeg\" style=\"max-width:95%\" />\n\n使用kill-1重启进程的时候实际上是不会改变主进程的PID的，也就是说只是发生了原地重启，或者说“软重启”\n```sh\n# 软重启\nkill -1 2899\n\n# 如果要停止系统中所有的httpd进程，\n# 那么只要按照以下方法操作\nkillall httpd\n```\n\n### 查询进程打开文件：lsof\nLinux中一切皆文件，所以在系统中，被打开的文件可以是普通文件、目录、网络文件系统中的文件、字符设备、管道、socket等。那么如何知晓现在系统打开的是哪些文件呢，这时lsof命令就有用武之地了。\n#### 查看进程\n使用lsof还可以查找使用了某个端口的进程，比如说如果系统中运行了sshd进程（基本上都是默认运行的），则该进程默认会绑定22端口，让我们来确认一下\n```sh\nlsof -i:22\n```\n\n#### 查看什么进程使用该文件\n```sh\nlsof /var/log/messages\n```\n\n#### 恢复被删除的文件， 此文件必须正在被某个进程使用\n*此文件必须正在被某个进程使用，也就是依然拥有打开文件的句柄能力。*\n\n现假设文件/var/log/messages不小心被删除了，首先来确认一下当前是否有进程正在使用这个文件，如果有则可以继续，如果没有就无法使用该方法继续了。本例中看到有个PID为2449的进程正在使用该文件，那么接下来只要找到对应/proc目录下的文件就可以了\n```sh\n# lsof | grep message \nsyslogd   2449      root    1w      REG      253,0   149423    4161767 /var/log/messages\n# cat /proc/2449/fd/2 > /var/log/messages\n# Service syslogd restart\n```\n\n### 进程优先级调整：nice、renice\n\n## vi和vim编辑器\nvim编辑器是vi的加强版，在简单的文本操作上与vi几乎完全一致，所以习惯使用vi的人可以完全无缝地切换使用vim编辑器。同时vim还增加了很多新功能，包括代码补全、错误跳转等，可方便编程\n\n### vim编辑器使用\n1. 搜索关键词\n```sh\n/keyword # 搜索keyword关键词\n```\n2. 替换关键词\n```sh\n:s/keyword/kw/g #将本行的keyword替换成kw\n\n:1,$s/keyword/kw/g #将1行到最后一行所有的keyword替换成kw\n```\n\n## 正则表达式\n### 正则基础\n1. “ .”（一个点）符号\n点符号用于匹配除换行符之外的任意一个字符。例如：r.t可以匹配rot、rut\n```sh\ngrep 'r..t' /etc/passwd\n```\n2. “ \\*”符号\n\"*\"符号用于匹配前一个字符 0次 或 任意多次，比如ab*，可以匹配a、ab、abb等。“*”号经常和“.”符号加在一起使用\n```sh\n# 查找包含字母r，后面紧跟任意长度的字符，再跟一个字母t的行\ngrep 'r.*t' /etc/passwd\n```\n\n3. “ \\\\{n,m\\\\}”符号\n```sh\n# \\{n\\} 匹配前面的字符n次\ngrep 'ro\\{2\\}t' /etc/passwd\n\n# \\{n,\\} 匹配前面的字符至少n次以上（含n次)\ngrep 'ro\\{2,\\}t' /etc/passwd\n\n# \\{n,m\\} 匹配前面的字符n到m次\ngrep 'ro\\{2,3\\}t' /etc/passwd\n```\n4. “ ^”符号\n```sh\n# 这个符号用于匹配开头的字符。比如说“^root”匹配的是以字母root开始的行\ngrep '^root' /etc/passwd\n```\n5. “ $”符号\n```sh\n# “$”用于匹配尾部，比如说“abc$”代表的是以abc结尾的行。\n# 如果是“^$”则代表该行为空，因为^和$间什么都没有\ngrep 'r.*t$' /etc/passwd\n```\n6. “ []”符号\n这是一对方括号，用于匹配方括号内出现的任一字符\n```sh\n# 匹配abc任意字符\n[abc]\n\n# 比如说要匹配任意一个大写字母，就需要使用“-”号做范围限定，写成[A-Z]，\n# 要匹配所有字母则写成[A-Za-z]。\n# 一定要注意，这里“-”的作用不是充当一个字符。\n[a-zA-Z]\n\n# “^”符号出现在[]中，则代表取反\n[^a-z] \n\n# 手机号码 （3移动8联调）\n^1[38][0-9]\\{9\\} \n```\n\n7. “ \\”转义符号\n```sh\n\"\\\\\"  # 对\\符号进行转义\n\"\\.*\" # 匹配任意长度的点号\n```\n\n8. “\\<”符号和“\\>”符号\n界定单词的左边界和右边界\n```sh\necho \"hello\" | grep '\\<hello\\>'  #匹配成功\necho \"hellod\" | grep '\\<hello\\>' # 没有输出， 匹配失败\n```\n\n9. “ \\d”符号\n```sh\necho 123 | grep [0-9] # 123\n\necho 123 | grep '\\d' # 匹配不成功\n\n# '\\d'是一种perf兼容模式表达式， 要想使用这种模式得加上-P参数\necho 123 | grep -P '\\d'\n```\n\n10. “ \\b”符号\n匹配单词的边界，比如“\\bhello\\b”可精确匹配“hello”单词\n```sh\necho 'hello world' | grep '\\bhello\\b' # hello world\necho 'helloworld' | grep '\\bhello\\b' # 无匹配\n```\n\n11. “ \\B”符号\n匹配非单词的边界，比如hello\\B可以匹配“helloworld”中的“hello”。\n\n12. “ \\w”符号\n匹配字母、数字和下划线，等价于[A-Za-z0-9]。\n\n13. “ \\W”符号\n匹配非字母、非数字、非下划线，等价于[^A-Za-z0-9]。\n\n14. “ \\s”符号\n匹配任何空白字符\n\n15. “ \\S”符号\n匹配任何非空白字符\n\n16. “ \\n”符号\n匹配一个换行符（就是另起一新行，光标在新行的开头）。\n*我们平时编写文件的回车符(即：回车键 )应该确切来说叫做回车式的换行符。*\n\n17. “ \\r”符号\n匹配一个回车符（就是光标回到一旧行的开头，即光标目前所在的行为旧行）。\n\n18. “ \\t”符号\n匹配一个制表符。\n\n19. 扩展正则表达式（需要使用egrep命令）\n```sh\n# “?”符号用于匹配前一个字符0次或1次，所以“ro?t”仅能匹配rot或rt。\n# “+”符号用于匹配前一个字符1次以上，所以“ro+t”就可以匹配rot、root等。\n# “|”符号是“或”的意思，即多种可能的罗列，彼此间是一种分支关系\n# “()”符号通常需要和“|”符号联合使用，用于枚举一系列可替换的字符\n```\n20. 通配符\n```sh\n# * 符号: 这里的“*”就是提到的第一个通配符，代表0个或多个字符。那么之前的*.doc就是指所有以.doc结尾的文件\nls -l *.doc \nls -l A*.doc # 找doc文档是以字母A开头\n\n# ？符号： 如果要列出以字母A开头、但是只有两个字母的文件名、以.doc结尾的文件，就需要使用“?”了\nls -l A?.doc\n\n# {} 符号: “{}”可拥有匹配所有括号内包含的以逗号隔开的字符\nls -l {A, B, C}.doc  # 相等于 ls -l [A-C].doc\n\n\n# ^和！符号： 这两个符号往往和“[]”一起使用，当出现在“[]”中的时候，代表取反。所以[^A]（或[!A]）代表不是A。\n\n```\n\n### 正则表达式示例\n#### grep\ngrep的英文是Global search Regular Expression and print out the line，即全面搜索正则表达式并打印出匹配行\n```sh\n# 使用“^”匹配行首\ngrep '^good' regexp.txt # good morning teacher\n\n# 使用“^$”组合，匹配空行\ngrep -c '^$' regexp.txt # 2\n\n# 使用“.”号匹配任意字符\ngrep 'g..d' regexp.txt # good gold golden\ngrep '[Gg]..d' regexp.txt # good Good g12d\n\n# 使用精确匹配\ngrep 'gold' regexp.txt # gold golden\ngrep '\\<gold\\>' regexp.txt # gold\ngrep '\\bgold\\b' regexp.txt # gold\n\n# 使用“-”号\ngrep 'g[1-9]d' regexp.txt # g1d g2d\n\n# 使用“*”号\ngrep 'go*d' regexp.txt # gd god good goood\n\n# 使用“.*”号\ngrep 'g.*d' regexp.txt # gd gad good goood\n\n# 使用“\\”做字符转义, 下面.符号解析成正则任意字符\ngrep 'www.helloworld.com' regexp.txt \ngrep 'www\\.helloworld\\.com' regexp.txt \n```\n\n### 文本处理工具sed\n#### sed介绍\nsed（stream editor）是一种非交互式的流编辑器，通过多种转换修改流经它的文本。但是请注意，默认情况下，sed并不会改变原文件本身，而只是对流经sed命令的文本进行修改，并将修改后的结果打印到标准输出中（也就是屏幕）。所以本节讲的所有的sed操作都只是对“流”的操作，并不会改变原文件。sed处理文本时是以行为单位的，每处理完一行就立即打印出来，然后再处理下一行，直至全文处理结束。sed可做的编辑动作包括删除、查找替换、添加、插入、从其他文件中读入数据等。\n**使用场景：常规编辑器编辑困难的文本；sed默认不更改源文件，如果想直接修改源文件本身则需要使用“-i”参数**\n#### 删除\n```sh\n# 删除第一行然后输出到屏幕\nsed '1d' sed.txt\n\n# 删除第一行, 保存修改后的文件\nsed '1d' sed.txt > save_file\n\n# 删除第一行. 直接修改文件使用i参数；这里不会有任何输出， 而是直接修改了源文件\nsed -i '1d' sed.txt\n\n# 删除指定范围的行\nsed '1, 3d' sed.txt\nsed '1, $d' sed.txt # 删除1到最后一行\n\n# 删除空行\nsed '/^$/d' sed.txt\n\n# 删除包含empty的行\nsed '/empty/d' sed.txt\n```\n\n#### 查找替换\n使用s命令可将查找到的匹配文本内容替换为新的文本\n```sh\n# 默认情况下每行只替换第一个line\nsed 's/line/LINE/' sed.txt # this is LINE 1, this is First line, line\n\n# 想要每行替换2个line\nsed 's/line/LINE/2' sed.txt # this is LINE 1, this is First LINE, line\n\n# 利用g选项， 完成所欲匹配值的替换\nsed 's/line/LINE/g' sed.txt # this is LINE 1, this is First LINE, LINE\n\n# 只替换开头的this为that\nsed 's/^this/that/' sed.txt # that is line 1, this is First line, line\n```\n\n#### 字符转换\n使用y命令可进行字符转换，其作用为将一系列字符逐个地变换为另外一系列字符\n```sh\n# 将file文件的O替换N, L替换E, D替换成W\nsed 'y/OLD/NEW' file \n\nsed 'y/12345/ABCD' sed.txt\n# this is line A, this is First line\n# this is line N, this is Second line\n# this is line C, this is Third line\n```\n#### 插入文本\n使用i或a命令插入文本，其中i代表在匹配行之前插入，而a代表在匹配行之后插入\n```sh\n# 使用i在第二行前插入文本\nsed '2 i Insert' sed.txt\n# this is line 1, this is First line\n# Insert\n# this is line 2, this is Second line\n\n# 使用a在第二行后插入文本\nsed '2 a Insert' sed.txt\n# this is line 1, this is First line\n# this is line 2, this is Second line\n# Insert\n\n\n# 在匹配行的上一行插入文本\nsed '/Second/i\\Insert' sed.txt\n# this is line 1, this is First line\n# Insert\n# this is line 2, this is Second line\n```\n\n#### 读入文本\n使用r命令可从其他文件中读取文本，并插入匹配行之后\n```sh\n# 将/etc/passwd中的内容读出来放到sed.txt空行之后\nsed '/^$/r /etc/passwd' sed.txt\n```\n\n#### 打印\n使用p命令可进行打印，这里使用sed命令时一定要加-n参数，表示不打印没关系的行\n```sh\n# 使用p命令， 则只打印实际处理过的行，简化了输出（-n）\nsed -n 's/the/THE/p' sed.txt\n```\n#### sed脚本\n工作往往有一定“标准化”的操作，比如说先去除文件中所有的空行，然后再全部替换某些字符等，这种过程类似于生产线上程式化的流水作业；可以把这些动作静态化地写到某个文件中，然后调用sed命令并使用-f参数指定该文件，这样就可以将这一系列动作“装载”并应用于指定文件中，这无疑加快了工作效率，这种文件就是sed脚本。\n```sh\n# this替换THAT, 然后删除空行\n# cat sed.rules\ns/this/THAT/g\n/^$/d\n\n# 使用-f参数指定该脚本并应用到sed.txt\nsed -f sed.rules sed.txt\n```\n\n### 文本处理工具awk\n#### 介绍\nsed其实是以行为单位的文本处理工具，而awk则是基于列的文本处理工具，它的工作方式是按行读取文本并视为一条记录，每条记录以字段分割成若干字段，然后输出各字段的值。\n\n#### 打印指定域\nawk使用$1、$2代表不同的域，则可以打印指定域\n```sh\n# 只打印部分\nawk '{print $1, $4}' awk.txt\n# zhao 021-1111111\n# liu  021-2222222\n\n# 打印全部\nawk '{print $0}' awk.txt\n# zhao male   30 021-1111111\n# liu  female 31 021-2222222\n# hu   female 31 021-3333333 shanghai\n```\n\n#### 指定打印分隔符\n默认情况下awk是使用空白字符作为分隔符的，但是也可以通过-F参数指定分隔符，来区分不同的域（有点像之前学过的cut命令）\n```sh\n# 用.作为分隔符，这样每一行$1就是.之前的字符， $2就是.之后的字符\nawk -F. '{print $1, $2}' awk.txt\n```\n#### 截取字符串\n可以使用substr()函数对指定域截取字符串。substr(指定域,第一个开始字符的位置,第二个结束的位置)\n#其中第二个结束的位置可以为空，这样默认输出到该域的最后一个字符。\n```sh\ncat awk.txt | awk '{print substr($1, 6)}'\n```\n\n#### 确定字符串的长度\n```sh\ncat awk.txt | awk '{print length}'\n```\n## shell编程概述和编程基础\n### shell介绍\n> shell是指一种命令行解释器，是为用户和操作系统之间通信提供的一种接口\n> 脚本语言又被称作解释型语言，这种语言经过编写后不需要做任何编译就可以运行。 \n> 计算机不能理解高级语言，只能理解机器语言，所以必须把高级语言翻译为机器码。而这种翻译的方式有两类，一类是编译，一类是解释，不同之处在于翻译的时间不同。编译型语言是运行前翻译，一般是使用编译工具将程序源码处理成机器认识的可执行文件（比如说Windows下的exe文件，Linux下的二进制可执行性文件），这种文件一旦产生，以后运行时将不需要再次翻译，所以一般来说，编译型语言的效率较高；而解释型语言是运行时翻译，执行一条语句就立即翻译一条，而且每次执行程序都需要进行解释，相对来说效率较低。但是也不能简单地认为编译型语言就一定比解释型效率高，随着解释器的发展，部分解释器能在运行程序时动态优化代码，因此这种效率差距也在一定程度上不断减小。\n\n\n### shell脚本\n#### 编写第一个shell脚本\n一个Shell脚本永远是以“#!”开头的，这是一个脚本开始的标记，它是在告诉系统执行这个文件需要使用某个解释器，后面的/bin/bash就是指明了解释器的具体位置\n```sh\n#! /bin/bash\necho 'hello world'\n```\n#### 运行脚本\n1. 第一种就是在该脚本所在的目录中直接bash这个脚本。实际上，如果使用这种方式来运行脚本，该脚本中的第一行“#!/bin/bash”就可以不需要了，因为直接bash一个文件就是指定了使用BashShell来解释脚本内容。\n```sh\nbash test.sh\n```\n2. 第二种方式是给该脚本加上可执行权限，然后使用“./”来运行，它代表运行的是当前目录下的HelloWorld.sh脚本，如果采用这种方式而脚本没有可执行权限则会报错。\n```sh\nchmod +x test.sh\n./test.sh\n```\n3. 如果希望该脚本能成为默认的系统命令，简单地将该脚本复制到任一系统$PATH变量所包含的目录中，同时赋予可执行权限，下次运行的时候只需要直接输入该命令即可\n```sh\nchmod +x text.sh\nmv test.sh /bin/\ntest.sh\n```\n\n#### shell脚本排错\n为了更清晰地看到脚本运行的过程，还可以借助-x参数来观察脚本的运行情况。\n```sh\nbash -x test.sh\n```\n### shell内置命令\n> 所谓Shell内建命令，就是由Bash自身提供的命令，而不是文件系统中的某个可执行文件。\n通常来说，内建命令会比外部命令执行得更快，执行外部命令时不但会触发磁盘I/O，还需要fork出一个单独的进程来执行，执行完成后再退出。而执行内建命令相当于调用当前Shell进程的一个函数。\n\n#### 如何确定内建命令：type\n```sh\ntype cd \n# cd is shell builtin\n\ntype ifconfig\n# ifconfig is /sbin/ifconfig\n```\n\n#### 执行程序：“.”（点号）\n点号用于执行某个脚本，甚至脚本没有可执行权限也可以运行\n```sh\n./test.sh\n# 提示无权限\n\n. ./test.sh\n# 执行成功\n\nsource test.sh\n# 执行成功， 同时返回脚本中最后一个命令的返回状态；\n# 如果没有返回值则返回0，代表执行成功； \n# 如果未找到指定的脚本则返回false\n```\n#### 别名：alias\nalias可用于创建命令的别名，若直接输入该命令且不带任何参数，则列出当前用户使用了别名的命令。现在你应该能理解类似ll这样的命令为什么与ls-l的效果是一样的吧\n```sh\n# 这样定义alias只能在当前Shell环境中有效，\n# 换句话说，重新登录后这个别名就消失了。\n# 为了确保永远生效，可以将该条目写到用户家目录中的.bashrc文件中\nalias myShutdown='shutdown -h now'\n```\n#### 任务前后台切换：bg、fg、jobs\n该命令用于将任务放置后台运行，一般会与Ctrl+z、fg、&符号联合使用。典型的使用场景是运行比较耗时的任务。比如打包某个占用较大空间的目录，若在前台执行，在任务完成前将会一直占用当前的终端，而导致无法执行其他任务，此时就应该将这类任务放置后台\n```sh\ntar -zcf user.tgz /user\n# 发现压缩很耗时， ctrl+z组合键暂停任务， jobs命令查看暂停任务为编号1\nbg 1 # 把tar任务放置后台\nfg 1 # 把后台tar任务调至前台\n\n# 如果已知某个任务非常耗时，可以在一开始就在命令行后面加上 &\ntar -zcf user.tgz /user &\n```\n\n#### 声明变量：declare、typeset\n```sh\n# i_num的值为1\ni_num=1\n# str的值为helloworld\nstr=\"helloworld\"\n\n# 使用declare声明只读变量\ndeclare -r readonly=10\n\n# 使用declare声明整型i_num1\ndeclare -i i_num1=1\n```\n#### 打印字符：echo\necho用于打印字符，典型用法是使用echo命令并跟上使用双引号括起的内容\n```sh\necho \"hello world\"\n\necho -n \"hello world\" # 不换行\n```\n#### 跳出循环：break\n从一个循环（for、while、until或者select）中退出。break后可以跟一个数字n，代表跳出n层循环，n必须大于1，如果n比当前循环层数还要大，则跳出所有循环。\n\n#### 循环控制：continue\n停止当前循环，并执行外层循环（for、while、until或者select）的下一次循环。continue后可以跟上一个数字n，代表跳至外部第n层循环。n必须大于1，如果n比当前循环层数还要大，将跳至最外层的循环\n\n#### 退出Shell：exit\n在Shell脚本中使用exit代表退出当前脚本。该命令可以接受的参数是一个状态值n，代表退出的状态，下面的脚本什么都不会做，一旦运行就以状态值为5退出。如果不指定，默认状态值是0。\n\n#### 发送信号给指定PID或进程：kill\n> Linux操作系统包括3种不同类型的进程，第一种是交互进程，这是由一个Shell启动的进程，既可以在前台运行，也可以在后台运行；第二种是批处理进程，与终端没有联系，是一个进程序列；第三种是监控进程，也称系统守护进程，它们往往在系统启动时启动，并保持在后台运行\n\nkill命令用来终止进程，其工作的原理是向系统的内核发送一个系统操作信号和某个程序的进程标识号，然后系统内核就可以对进程标识号指定的进程进行操作。\n\n#### 声明局部变量：local\n该命令用于在脚本中声明局部变量，典型的用法是用于函数体内，其作用域也在声明该变量的函数体中\n\n#### 从标准输入读取一行到变量：read\n有时候我们开发的脚本必须具有交互性，也就是在运行过程中依赖人工输入才能继续\n```sh\n#根据输入的箱数计算一共有多少瓶啤酒\n[root@localhost ~]# cat read.sh\n#!/bin/bash\ndeclare N\n\necho \"12 bottles of beer in a box\"\necho -n \"How many box do you want:\"\nread N\n\necho \"$((N*12)) bottle in total\"\n\n#运行效果\n[root@localhost ~]# bash read.sh\n12 bottles of beer in a box\nHow many box do you want:10  #这里输入数字\n120 bottle in total\n```\n如果不指定变量，read命令会将读取到的值放入环境变量REPLY中。另外要记住，read是按行读取的，用回车符区分一行，你可以输入任意文字，它们都会保存在变量REPLY中。\n```sh\nread \n# 输入read命令 helloworld \necho $REPLY\n# 输出 helloworld\n```\n#### 定义函数返回值：return\n```sh\n# cat return.sh\n\n#!/bin/bash\n#定义了一个函数fun_01，该函数简单地返回1\nfunction fun_01 {\n        return 1\n}\n#调用该函数\nfun_01\n#查看之前函数的返回值\necho $?\n```\n### 变量\n#### 局部变量\n所谓局部变量就是指在某个Shell中生效的变量，对其他Shell来说无效，而且会随着当前Shell的消失而消失，局部变量的作用域被限定在声明它们的Shell中，可以使用local内建命令来“显式”的声明局部变量，但仅限于函数内使用。换言之，每个Shell都有自己的变量空间，彼此互不影响。而环境变量不仅仅是对于该Shell生效，对其子Shell也同样生效。\n\n#### 环境变量\n环境变量通常又称“全局变量”，以区别于局部变量。在Shell脚本中，变量默认就是全局的，无论在脚本的任何位置声明，但是为了让子Shell继承当前Shell的变量，则可以使用export内建命令将其导出为环境变量。\n```sh\n# VAR是变量的名字，value为值，使用等号相连，注意等号两端没有空格\nexport VAR=value\n```\n\n**bash中默认包含有几十个预设的环境变量，这里挑选常见的一些予以介绍**\n```sh\n# 1. bash shell的全路径\necho $bash\n\n# 2. 记录当前用户的UID。\n# 当前的用户是root，所以该值应该为0。\necho $EUID\n\n# 3. 变量：FUNCNAME\ncat funcname.sh\n#!/bin/bash\nfuncname() {\n  echo $FUNCNAME # 打印内容：funcname\n}\nfuncname\n\nbash funcname\n\n# 4. 变量：HOSTNAME 展示主机名\necho $HOSTNAME\n\n# 5. 变量：LANG\n# 设置当前系统的语言环境，其实就是language的意思\necho $LANG\n\n# 6. 变量：PWD\n# 记录当前目录\necho $PWD\n\n# 7. 变量：OLDPWD\n# 记录之前目录，这个值是什么由之前所在的那个目录决定\necho $OLDPWD\n\n# 8. 变量：PATH\n# PATH 代表命令的搜索路径，非常重要\necho $PATH # 查看当前PATH的值\n```\n#### 变量命名\nShell中的变量必须以字母或者下划线开头，后面可以跟数字、字母和下划线，变量长度没有限制\n\n#### 变量赋值和取值\n**赋值**\n```sh\n#定义变量：变量名=变量值\n#注意点：变量名和变量值没有空格，之间没任何空格\nname=cc \nname=\"c c\" #其中引号可以爽双引号也可以是单引号\n```\n**取值**\n```sh\necho $name\necho ${name}\n\n#使用${}获取变量值是一种相对比较保守的方式\nname=\"sue \"\necho $nameHello # 报错\necho ${name}Hello # sue Hello\n\n#如果变量值引用的是其他变量，则必须使用双引号。\n#单引号会阻止shell解释特殊字符$\nname=john\nname1=\"$name\"\necho $name1 # john\nname1='$name' # 单引号会阻止shell解释特殊字符$\necho name1\n$name\n```\n\n#### 取消变量\n```sh\nname=john\necho $name\nunset name\necho $name #变量中已经没有内容了\n```\n\n#### 特殊变量\n**1. 位置参数**\nShell中还有一些预先定义的特殊只读变量，它们的值只有在脚本运行时才能确定。首先是“位置参数”，位置参数的命名简单直接， 比如：脚本本身为$0，第一个参数为$1，第二个参数为$2，第三个为$3，以此类推。当位置参数的个数大于9时，需要用${}括起来标识，比如说第10个位置参数应该记为${10}。另外，$#表示脚本参数的个数总和，$@或$*表示脚本的所有参数\n\n**2. 脚本或命令返回值：$?**\nLinux中规定正常退出的命令和脚本应该以0作为其返回值，任何非0的返回值都表示命令未正确退出或未正常执行。\n在自动化脚本中，也可以通过$?变量的值判断之前命令的执行状态，从而采取不同的动作。\n```sh\n# 尝试ping主机ping不通时的返回值\nping 192.234.41.100 -c 1\n# 返回非0， 代表命令执行不成功\n```\n\n#### 数组\nShell中的数组对元素个数没有限制，但只支持一维数组，这一点和很多语言不同。\n\n**1. 数组定义**\n```sh\n#方法一\ndeclare -a Array\nArray[0]=0\nArray[1]=1\nArray[2]=\"Helloworld\"\n\n#方法二\ndeclare -a Name=('john' 'sue')\nName[2]='wang' #增加元素\n\n#方法三: 不使用declare的关键字\nName=('john' 'sue')\n\n#方法四: 调号赋值\nScore=([3]=3 [5]=5 [7]=7)\n```\n**2. 数组操作**\n```sh\n# 1.取某个值\necho ${Array[0]}\n\n# 2.取出所有的值\necho ${Array[@]}\n0 1 Helloworld\necho ${Array[*]}\n0 1 Helloworld\n\n# 3.数组长度\necho ${#Array[@]}\n3\necho ${#Arraty[*]}\n3\necho ${#Array[2]} # 查找某个元素的长度\n10\n\n# 4.数组截取\necho ${Array[@]:1:2} # 取出数组的第一、第二元素\n1 Helloworld\necho ${Array[2]:0:5} # 取出第二个元素从弟0个字符开始联系5个字符\n\n# 5.连接数组\nConn=(${Array[@]} ${Name[@]})\necho ${Conn[@]}\n\n# 6.替换元素\nArr=(${Array[@]/Helloworld/HelloJohn})\necho ${Array[@]}\n0 1 HelloJohn\n```\n#### 变量的作用域\n变量的作用域又叫“命名空间”，表示变量（identifier，标识符）的上下文。相同的变量可以在多个命名空间中定义，并且彼此之间互不干涉，所以在一个新的命名空间中可以自定义任何变量，因为所定义的变量都只在各自的命名空间中。\n```sh\n# 在函数体内使用local关键字声明了和全局变量同名的局部变量后，\n# 对该变量的操作只会影响局部变量，而不会影响与之同名的全局变量。\n\n[root@localhost ~]# cat Namespace03.sh\n#!/bin/bash\nVAR_02=100\n\nfunction ch_var() {\n        local VAR_02=200 #此处使用local声明变量\n}\n\necho \"Before function VAR_02:$VAR_02\"\nch_var\necho \"After function VAR_02:$VAR_02\"\n\n\n#修改后的Namespace03.sh执行结果\n[root@localhost ~]# bash Namespace03.sh\nBefore function VAR_02:100\nAfter function VAR_02:100\n```\n\n### 转义和引用\nShell中有两类字符，一类是普通字符，在Shell中除了本身的字面意思外没有其他特殊意义，即普通纯文本（literal）；另一类即元字符（meta），是Shell的保留字符，在Shell中有着特殊意义。这在很多时候会造成麻烦：比如说想要在程序中用美元符打印商品的价格，但是这个符号一般被解析成提取变量的值。为了消除这些特殊字符的功能，就必须对其进行转义和引用。\n\n#### 转义\n要使用“\\”来转义“$”字符，让“$”失去其特殊含义，而只作为一个符号出现。\n```sh\n# echo $Dollar 报错\n# echo \\$Dollar \n$Dollar\n```\n<img src=\"/img/linux7.jpeg\" style=\"max-width:95%\" />\n\n#### 引用\n引用是指将字符串用某种符号括起来，以防止特殊字符被解析为其他意思。比如说上一小节中的转义符就是一种引用。Shell中一共有4种引用符，分别是双引号、单引号、反引号和转义符。其中双引号又叫“部分引用”或“弱引用”，可以引用除$符、反引号、转义符之外的所有字符；单引号又叫“全引用”或“强引用”，可以引用所有字符；反引号则会将反引号括起的内容解释为系统命令。\n##### 部分引用\n部分引用是指用双引号括起来的引用。在这种引用方式中，$符、反引号（`）、转义符（\\）这3种特殊字符依然会被解析为特殊意义\n```sh\nVAR03=100\necho \"$VAR03\" # 100\necho $VAR03 # 100\n\nVAR04=\"A  B  C\"\necho $VAR04 # A B C  (每个字母间隔只保留一个空格)\necho \"$VAR04\" # A  B  C\n```\n\n##### 全引用\n全引用是指用单引号括起来的引用。单引号中的任何字符都只当作是普通字符（除了单引号本身，也就是说单引号中间无法再包含单引号，即便用转义符转义单引号也不行）。所有在单引号中的字符都只能代表其作为字符的字面意义。\n```sh\necho '$VAR03'\n# $VAR03\necho '$VAR04'\n# $VAR04\n```\n**单引号和双引号在很多时候是一样的，只是要记住，在双引号中的$符、反引号、转义符还是会被解析成其特殊含义，而在单引号中所有的字符都只是字面意思**\n\n#### 命令替换\n命令替换是指将命令的标准输出作为值赋给某个变量。比如，在某个目录中输入ls命令可查看当前目录中所有的文件，但如何将输出存入某个变量中呢？这就需要使用命令替换了，这也是Shell编程中使用非常频繁的功能。\n```sh\n`命令`  # DATE_01=`data`\n$(命令) # DATE_02=$(data)\n\n# 但是有些情景是必须使用$()的：$()支持嵌套，而反引号不行\n# $()仅在Bash Shell中有效，而反引号可在多种UNIX Shell中使用\nFir_File_Lines=$(wc -l $(ls -l | sed -n 'lp'))\necho $Fir_File_Lines\n36 anaconda-ks.cfg\n```\n\n### 运算符\n#### 算术运算符\nShell只支持整数计算，也就是所有可能产生小数的运算都会舍去小数部分\n\n#### 自增自减\n前置自增或前置自减操作会首先修改变量的值，然后再将变量的值传递出去；后置自增或后置自减则会首先将变量的值传递出去，然后再修改变量的值\n\n### 其他运算符\n#### 使用$[]做运算\n```sh\n# $[]和$(())类似，可用于简单的算术运算\necho $[1+2]\necho $[5/2] # 2 舍去小数\n```\n#### 内建运算命令declare\n```sh\ni=1+1\necho $i #1+1\n\ndeclare -i j\nj=1+1\necho $j # 2\n```\n#### 算术扩展\n$((算术表达式))\n```sh\ni=2\necho $((2*i+1)) #5 这里i前面没有$\n\n#变量赋值\nvar=$((算术表达式))\nvar=$((2*i+1))\necho var # 5\n```\n\n### 特殊字符\n#### 通配符\n通配符用于模式匹配，常见的通配符有*、?和用[]括起来的字符序列。其中*代表任意长度的字符串。例如：a*可以匹配以a开头的任意长度的字符串，但是不包括点号和斜线号。也就是说a*不能匹配abc.txt。问号（?）可用于匹配任一单个字符。方括号[]代表匹配其中的任意一个字符，比如[abc]代表匹配a或者b或者c，[]中可以用-表明起止，比如[a-c]等同于[abc]，但是要注意-字符在[]外只是一个普通字符，没有任何特殊作用；*和?在[]中则变成了普通字符，没有通配的功效\n\n#### 引号\n引号包括单引号和双引号，单引号又叫称“全引用”或“强引用”；双引号又称“部分引用”或“弱引用”，所有用双引号括起来的字符除了美元符（$）、反斜线（\\）、反引号（`）依然保留其特殊用途外，其余字符都作为普通字符处理；而所有用单引号括起的部分都作为普通字符处理，但是要注意单引号中间不能再出现单引号，否则会Shell无法判断到底哪里是单引号的起止位置。\n\n#### 注释符\n如果出现#后连着!，也就是“#!”不会被理解成注释，因此，其后跟着的部分必须是某个解释器的路径，而且“#!”必须出现在整个脚本的第一行\n\n#### 大括号\n大括号{}在Shell中的用法很多，最常见的用法就是引用变量原型，又叫变量扩展。例如变量VAR，可以使用${VAR}引用，这是推荐的引用变量的方法。\n\n#### 杂项\n##### 反引号\n反引号用于命令替换，和$()的作用相同，表示返回当前命令的执行结果并赋值给变量。\n##### 位置参数\n```sh\n$0：脚本名本身。\n$1、$2……${10}：脚本的第一个参数、第二个参数……第十个参数。\n$#：变量总数。\n$*、$@：显示所有参数。\n$?：前一个命令的退出的返回值。\n$!：最后一个后台进程的ID号。\n```\n## 测试和判断\n### 测试\n```sh\n# ls一个存在的文件\nls /var/log/messages\necho $? # 0\n\n\n# ls一个不存在的文件\nls /var/log/messages11\necho $? # 2 非0代表文件不存在\n```\n**判断为真则返回0，为假则返回非0值。这种判断行为被称作“测试”**\n\n#### 测试结构\n测试方式是使用“[”启动一个测试，再写expression，再以“]”结束测试。需要注意的是，左边的括号“[”后有个空格，右括号“]”前面也有个空格，如果任意一边少了空格都会造成Shell报错\n```sh\n[ expression ]\n```\n\n#### 文件测试\n其中file_operator是文件测试符（具体参考下表），FILE是文件、目录（可以是文件或目录的全路径）\n```sh\n# 文件测试写法一\ntest file_operator FILE\n\ntest -e /var/log/messages\necho $?  # 1\n\n# 文件测试写法二\n[ file_operator FILE ]\n\n[-e /var/log/messages ]\necho $? # 1\n```\n<img src=\"/img/linux8.jpeg\" style=\"max-width:95%\" />\n\n```sh\n#!/bin/bash\nread -p \"What file do you want to test?\" filename\nif [ !-e \"$filename\" ]; then\n   echo \"The file does not exist.\"\n   exit 1\nfi\n\n\nif [ -r \"$filename\" ]; then\n  echo \"$filename is readable.\"\nfi\nif [ -w \"$filename\" ]; then\n  echo \"$filename is writeable\"\nfi\nif [ -x \"$filename\" ]; then\n  echo \"$filename is executable\"\nfi\n```\n\n#### 字符串测试\nShell中的字符串比较主要有等于、不等于、大于、小于、是否为空等测试\n<img src=\"/img/linux9.jpeg\" style=\"max-width:95%\" />\n\n```sh\n#定义空字符串str1\n[root@localhost ~]# str1=\"\"\n#测试str1是否为空，为空则返回0\n[root@localhost ~]# test-z \"$str1\"\n[root@localhost ~]# echo $?\n0\n#测试str1是否非空，非空则返回0，为空返回非0，此处返回1\n[root@localhost ~]# test-n \"$str1\"\n[root@localhost ~]# echo $?\n1\n\n\n#定义非空字符串str2，值为hello\n[root@localhost ~]# str2=\"hello\"\n#测试str2是否为空，为空返回0，不为空返回非0，此处返回1\n[root@localhost ~]# [ -z \"$str2\" ]\n[root@localhost ~]# echo $?\n1\n#测试str2是否非空，非空返回0\n[root@localhost ~]# [ -n \"$str2\" ]\n[root@localhost ~]# echo $?\n0\n\n\n#比较str1和str2是否相同，相同则返回0，否则返回非0，此处返回1\n[root@localhost ~]# [ \"$str1\" = \"$str2\" ]\n[root@localhost ~]# echo $?\n1\n#比较str1和str2是否不同，不同则返回0\n[root@localhost ~]# [ \"$str1\" != \"$str2\" ]\n[root@localhost ~]# echo $?\n0\n\n\n#比较str1和str1的大小，需要注意的是，>和<都需要进行转义\n[root@localhost ~]# [ \"$str1\" \\> \"$str2\" ]\n[root@localhost ~]# echo $?\n1\n[root@localhost ~]# [ \"$str1\" \\< \"$str2\" ]\n[root@localhost ~]# echo $?\n0\n\n\n#如果不想用转义符，则可以用[[]]括起表达式\n[root@localhost ~]# [[ \"$str1\" > \"$str2\" ]]\n[root@localhost ~]# echo $?\n1\n[root@localhost ~]# [[ \"$str1\" < \"$str2\" ]]\n[root@localhost ~]# echo $?\n0\n```\n\n#### 整数比较\n整数测试是一种简单的算术运算，作用在于比较两个整数的大小关系，测试成立则返回0，否则返回非0值\n```sh\n[root@localhost ~]# num1=10\n[root@localhost ~]# num2=10\n[root@localhost ~]# num3=9\n[root@localhost ~]# num4=11\n[root@localhost ~]# [ \"$num1\" -eq \"$num2\" ]\n[root@localhost ~]# echo $?\n0\n[root@localhost ~]# [ \"$num1\" -gt \"$num3\" ]\n[root@localhost ~]# echo $?\n0\n[root@localhost ~]# [ \"$num1\" -lt \"$num4\" ]\n[root@localhost ~]# echo $?\n0\n[root@localhost ~]# [ \"$num1\" -ge \"$num2\" ]\n[root@localhost ~]# echo $?\n0\n[root@localhost ~]# [ \"$num1\" -le \"$num2\" ]\n[root@localhost ~]# echo $?\n0\n[root@localhost ~]# [ \"$num1\" -ne \"$num3\" ]\n[root@localhost ~]# echo $?\n0\n```\n\n#### 逻辑测试符和逻辑运算符\n逻辑测试用于连接多个测试条件，并返回整个表达式的值。逻辑测试主要有逻辑非、逻辑与、逻辑或3种\n<img src=\"/img/linux10.jpeg\" style=\"max-width:95%\" />\n\n```sh\n#例一：逻辑非的使用\n#测试值为真的表达式在使用逻辑非后，表达式变为假，反之亦然\n[root@localhost ~]# [ !-e /var/log/messages ]\n[root@localhost ~]# echo $?\n1\n\n\n#例二：逻辑与的使用\n#表达式都为真，整个表达式才返回真，否则返回假\n[root@localhost ~]# [ -e /var/log/messages -a -e /var/log/messages01 ]\n[root@localhost ~]# echo $?\n1\n\n\n#例三：逻辑或的使用\n#测试表达式中只要有真，则整个表达式返回真\n[root@localhost ~]# [ -e /var/log/messages -o -e /var/log/messages01 ]\n[root@localhost ~]# echo $?\n0\n```\n\n**如果读者曾经学过其他的编程语言，一定知道“逻辑运算符”也有逻辑非、逻辑与、逻辑或3种判断符号(! && || )**\n```sh\n[root@localhost ~]# ! [ -e /var/log/messages ]\n[root@localhost ~]# echo $?\n1\n[root@localhost ~]# [ -e /var/log/messages ] && [ -e /var/log/messages01 ]\n[root@localhost ~]# echo $?\n1\n[root@localhost ~]# [ -e /var/log/messages ] || [ -e /var/log/messages01 ]\n[root@localhost ~]# echo $?\n0\n```\n\n### 判断\n在Shell中，流程控制分为两大类，一类是“循环”，一类是“判断选择”。属于“循环”的有for、while、until，这将会在下一章中介绍，本节介绍“判断选择”，关键字是if、case。\n#### if判断结构\n```sh\n#如果expression测试返回真，则执行command\nif expression; then\n    command\nfi    \n```\n例子：\n```sh\n#!/bin/bash\necho -n \"Please input a score:\"\nread SCORE\nif [ \"$SCORE\" -lt 60 ]; then\n        echo \"C\"\nfi\nif [ \"$SCORE\" -lt 80 -a \"$SCORE\" -ge 60 ]; then\n        echo \"B\"\nfi\nif [ \"$SCORE\" -ge 80 ]; then\n        echo \"A\"\nfi\n#脚本运行结果，依次输入95、75、45时，脚本分别打印了正确的成绩等级\n[root@localhost ~]# bash score01.sh\nPlease input a score:95\nA\n[root@localhost ~]# bash score01.sh\nPlease input a score:75\nB\n[root@localhost ~]# bash score01.sh\nPlease input a score:45\nC\n```\n\n#### if/else判断结构\n```sh\nif expression; then\n   command\nelif\n   command\nfi      \n```\n\n#### if/elif/else判断结构\n```sh\nif expression; then\n   command\nelif\n   if expression2; then\n      command2\n   else\n      command3\n   fi      \nfi      \n```\n\n#### case判断结构\n```sh\n# case判断结构中的var1、var2、var3等这些值只能是常量或正则表达式\ncase VAR in\nvar1) command1 ;;\nvar2) command2 ;;\nvar3) command3 ;;\n...\n*) command ;;\nesac\n```\n\n例子：\n```sh\n#!/bin/bash\nOS='uname-s'\ncase “$OS” in\nFreeBSD) echo \"This is FreeBSD\" ;;\nCYGWIN_NT-5.1) echo \"This is Cygwin\" ;;\nSunOS) echo \"This is Solaris\" ;;\nDarwin) echo \"This is Mac OSX\" ;;\nAIX) echo \"This is AIX\" ;;\nMinix) echo \"This is Minix\" ;;\nLinux) echo \"This is Linux\" ;;\n*) echo \"Failed to identify this OS\" ;;\nesac\n```\n## 循环\n### for循环\n#### 带列表的for循环\n```sh\nfruits=\"apple orange banana pear\"\nfor FRUITS in ${fruits}\ndo\n   echo \"#{FRUITS} is franky's favorite\"\ndone\n\n# Shell提供了用于计数的方式，比如说上例中1到5可以用{1..5}表示\nfor VAR in {1..5}\ndo\n   echo \"Loop $VAR times\"\ndone\n\n# 下面是利用seq命令的“步长”计算1到100内的奇数和\nsum=0\nfor VAR in $(seq 1 2 100)\ndo\n   let \"sum+VAR\"\ndone\necho \"Total: $sum\" # 2500\n\n# 列表for循环中in后面的内容可以是任意命令的标准输出\nfor VAR in $(ls)\ndo\n  ls -l $VAR\ndone  \n```\n#### 不带列表的for循环\n```sh\nfor VARIBLE in $@\ndo\n  echo -n $VARIBLE\ndone\n\nbash test.sh 1 2 3 4 # 1 2 3 4\n```\n#### 类C的for循环\n```sh\n# 类C的for循环语法结果\nfor ((expression1; expression2; expression3))\ndo\n       command\ndone\n```\n\n例子\n```sh\nfor((i=0; i<=10; i++))\ndo\n  echo -n \"$i \"\ndone\n\n# 在该示例中同时计算了1到100的和以及1到100的奇数和\nsum01=0\nsum02=0\nfor ((i=1,j=1; i<=100; i++,j+=2))\ndo\n let \"sum01+=i\"\n if [ $j -lt 100 ]; then\n    let \"sum02+=j\"\n fi   \ndone\necho \"sum01=$sum01\"\necho \"sum02=$sum02\"\n```\n#### for的无限循环\n```sh\nfor((;1;))\ndo\n echo \"infinite loop\"\ndone\n```\n### while循环\n#### while循环的语法\n```sh\nCONTER=5\nwhile [[ $CONTER -gt 0 ]]\ndo\n echi -n \"$CONTER\"\n let \"CONTER-=1\"\ndone\n\n# 是利用while做猜数字游戏，\n# 只有当输入的数字和预设的数字一致时，才会停止循环\nPRE_SET_NUM=8\necho \"Input a number between 1 and 10\"\nwhile read GUESS\ndo\n  if [[ $GUESS -eg $PRE_SET_NUM ]]; then\n     echo \"You get the right number\"\n     exit\n  else \n     echo \"Wrong, Try again\"\n  fi\ndone\n```\n\n#### 使用while按行读取文件\n```sh\n# cat while04.sh\n#!/bin/bash\nwhile read LINE\ndo\n        NAME=`echo $LINE | awk '{print $1}'`\n        AGE=`echo $LINE | awk '{print $2}'`\n        Sex=`echo $LINE | awk '{print $3}'`\n        echo \"My name is $NAME,I'm $AGE years old,I'm a $Sex\"\ndone < student_info.txt\n#运行结果\n[root@localhost ~]# bash while04.sh\nMy name is John,I'm 30 years old,I'm a Boy\nMy name is Sue,I'm 28 years old,I'm a Girl\nMy name is Wang,I'm 25 years old,I'm a Boy\nMy name is Xu,I'm 23 years old,I'm a Girl\n\n\n#while使用管道的按行读取\n#cat while04.sh\n#!/bin/bash\ncat student_info.txt | while read LINE\ndo\n       NAME=`echo $LINE | awk '{print $1}'`\n       AGE=`echo $LINE | awk '{print $2}'`\n       Sex=`echo $LINE | awk '{print $3}'`\n       echo \"My name is $NAME,I'm $AGE years old,I'm a $Sex\"\ndone\n```\n#### while的无限循环\n```sh\n# 我们可以利用while的无限循环实时的监测系统进程，\n# 以保证系统中的关键应用一直处于运行状态。\n#!/bin/bash\nwhile true\ndo\n    HTTPD_STATUS=`service httpd status | grep running`\n    if [-z \"$HTTPD_STATUS\" ]; then\n           echo \"HTTPD is stopped,try to restart\"\n           service httpd restart\n    else\n           echo \"HTTPD is running,wait 5 sec until next check\"\n    fi\n    sleep 5\ndone\n```\n### until循环\n待续...\n### select循环\nselect是一种菜单扩展循环方式，其语法和带列表的for循环非常类似，基本结构如下\n```sh\nselect MENU in (list)\ndo\n   command\ndone\n```\n例子：\n```sh\n# cat select01.sh\n#!/bin/bash\necho \"Which car do you prefer?\"\nselect CAR in Benz Audi VolksWagen\ndo\n        break #这里用到了没有讲过的break语句\ndone\necho \"You chose $CAR\"\n\n#运行结果\n# bash select01.sh\nWhich car do you prefer?\n1) Benz\n2) Audi\n3) VolksWagen\n#?  #此处尝试直接回车，结果select再次生成了列表等待输入\n1) Benz\n2) Audi\n3) VolksWagen\n#? 2#此处选择2，程序会退出select并继续执行后面的语句\nYou chose Audi\n```\n\n### 嵌套循环\n```sh\n# for循环嵌套\nfor ((i=1; i<9; i++))\ndo\n  for ((j=1; j<=9; j++))\n  do\n    let \"multi=$i*$j\"\n    echo -n \"$i*$j=$multi \"\n  done\ndone\n\n# while循环嵌套\ni=1\nwhile [[ \"$i\" -le \"9\" ]]\ndo\n j=1\n while [[ \"$j\" -le \"9\" ]]\n do\n    let \"multi=$i*$j\"\n    echo -n \"$i*$j=$multi \"\n    let \"j+=1\"   \n done\n echo \n let \"i+=1\"\ndone\n```\n### 循环控制\n#### break语句\nbreak用于终止当前整个循环体。一般情况下，break都是和if判断语句一起使用的，当if条件满足时使用break终止循环。\n#### continue语句\ncontinue并不会终止当前的整个循环体，它只是提前结束本次循环，而循环体还将继续执行；而break则会结束整个循环体。\n\n## 函数\n### 函数基本使用\n```sh\n# cat checkFileExist.sh\n#!/bin/bash\nFILE=/etc/notExistFile  #定义一个不存在的文件\n\nfunction checkFileExist(){              #定义checkFileExist函数\n    if [ -f $FILE ]; then\n           return 0\n    else\n           return 1\n    fi\n}\n\necho \"Call function checkFileExist\"     #提示函数调用\ncheckFileExist                          #调用函数\nif [ $? -eq 0 ]; then\n       echo \"$FILE exist\"\nelse\n       echo \"$FILE not exist\"\nfi\n\n#执行结果\n# bash checkFileExist.sh\nCall function checkFileExist\n/etc/notExistFile not exist             #这里是调用函数的输出内容\n```\n### 带参数的函数($1, $2, $N...)\n```sh\n# cat power.sh\n#!/bin/bash\nfunction power(){\n    RESULT=1\n    LOOP=0\n    while [[ \"$LOOP\" -lt $2 ]]\n    do\n           let \"RESULT=RESULT*$1\"\n           let \"LOOP=LOOP+1\"\n    done\n    echo $RESULT\n}\n\necho \"Call function power with parameters\"\npower $1 $2\n\n#计算2的2次方\n# bash power.sh 2 2\nCall function power with parameters\n4\n\n#计算3的3次方\n# bash power.sh 3 3\nCall function power with parameters\n27\n```\n\n### 函数库\n#### 自定义函数库\n```sh\n# cat lib01.sh\ncheckFileExists(){\n   if [ -f $1 ]; then\n          echo \"File:$1 exists\"\n   else\n          echo \"File:$1 not exist\"\n   fi\n}\n\n# cat callLib01.sh （函数库）\n#!/bin/bash\nsource ./lib01.sh    #引用当前目录下的lib01.sh函数库\n_checkFileExists /etc/notExistFile #调用函数库中的函数\n_checkFileExists /etc/passwd\n\n\n#执行结果\n# bash callLib01.sh\nFile:/etc/notExistFile not exist\nFile:/etc/passwd exists\n```\n\n#### 函数库/etc/init.d/functions\n很多Linux发行版中都有/etc/init.d目录，这是系统中放置所有开机启动脚本的目录，这些开机脚本在脚本开始运行时都会加载/etc/init.d/functions或/etc/rc.d/init.d/functions函数库（实际上这两个函数库的内容是完全一样的）\n```sh\n# cat callFunctions01.sh\n#!/bin/bash\nsource /etc/init.d/functions\nconfirm ITEM\nif [[ $? -eq 0 ]]; then\n       echo \"ITEM confirmed\"\nelse\n       echo \"ITEM not confirmed\"\nfi\n\n\n#运行结果\n# bash callFunctions01.sh\nStart service ITEM (Y)es/(N)o/(C)ontinue? [Y] Y\nITEM confirmed\n\n# bash callFunctions01.sh\nStart service ITEM (Y)es/(N)o/(C)ontinue? [Y] N\nITEM not confirmed\n```\n## 重定向\nI/O重定向是重定向中的一个重要部分，在Shell编程中会有很多机会用到这个功能。简单来说，I/O重定向可以将任何文件、命令、脚本、程序或脚本的输出重定向到另外一个文件、命令、程序或脚本。\n\n### io重定向符号和用法 \n<img src=\"/img/linux6.jpeg\" style=\"max-width:95%\" />\n\n#### 1.标准输出覆盖重定向：>\n使用标准输出覆盖重定向符号可以将原本输出到显示器上的内容重定向到一个文件中\n```sh\n# 比如使用ls-l可以列出指定目录中文件的详细信息，\n# 但是如果想把结果保存到文件中以便日后查看，\n# 则可以使用标准输出覆盖重定向符\nls -l /usr/> ls_usr.txt\n```\n*如果指定的重定向文件不存在，则命令会先创建这个文件，如果文件存在且内容不为空，则原文件内容将被全部清空。所以有时候需要先判断该文件是否存在，以避免不小心破坏了原有文件内容*\n\n```sh\n# 如果某命令的输出既有标准输出，又有标准错误输出，\n# 则可以分别指定不同标识符的内容输出到不同的文件中\nCOMMAND 1>stdout.txt 2>stderr.txt\n```\n\n#### 2.标准输出追加重定向：>>\n该符号用法和>完全一致，不同的只是如果指定的重定向文件存在且内容不为空，重定向并不会清空原文件内容，而是将命令的输出新增到原文件的尾部\n```sh\nls -l /usr/>>append.txt\nls -l /tmp/>>append.txt\n```\n\n#### 3.标识输出重定向：>&\n标识输出重定向的作用是将一个标识的输出重定向到另一个标识的输入。比如想要将标准输出和标准错误同时定向到同一个文件中。\n```sh\n# 执行COMMAND命令，将标准输出的内容重定向到stdout_stderr.txt中，\n# 如果有标准错误输出也同时重定向到该文件中\nCOMMAND > stdout_stderr.txt 2>&1\n```\n\n很多时候大家并不会在意错误输出，特别是一些系统后台任务可能在每天凌晨运行，这时出现的错误输出可能并不是系统管理员所关心的，所以也没有必要将错误输出保存到任何文件中。这时可以利用系统中的一个特殊设备/dev/null，将所有错误输出重定向到该设备中—系统会将任何输入到该设备的内容全部删除（就像一个宇宙黑洞）\n```sh\nCOMMAND > stdout.txt 2> /dev/null\n```\n\n#### 4.标准输入重定向：<\n标准输入重定向可以将原本应由从标准输入设备中读取的内容转由文件内容输入，也就是将文件内容写入标准输入中\n```sh\n#例二：给sort的标准输入重定向\n[root@localhost ~]# cat fruit01.txt\nbanana\napple\ncarrot\n[root@localhost ~]# sort < fruit01.txt\napple\nbanana\ncarrot\n```\n\n#### 5.管道：|\n简单地说管道就是将一个命令的输出作为另一个命令的输入，借此方式可通过多个简单命令的共同协作来完成较为复杂的工作\n\n### 使用exec\nexec是Shell的内建命令，执行这个命令时系统不会启动新的Shell，而是用要被执行的命令替换当前的Shell进程。因此假设在一个Shell中执行exec ls，则在列出当前目录后该Shell进程将会主动退出。如果使用ssh进行远程连接，则当前连接也会在执行完这个命令后断开\n\n###  Here Document\nHere Document又称此处文档，用于在命令或脚本中按行输入文本。HereDocument的格式为<<delimiter，其中delimiter是一个用于标注的“分隔符”，该分隔符后所有的输入都被当作是输入的文本，直到出现下一个分隔符为止\n```sh\nsort << END\n> banner\n> apple\n> carrot\n> END\napple\nbanner\ncarrot\n\n# 再以cat命令为例，要将输入的内容保存到HelloWorld02.txt中\ncat >> HelloWorld02.txt << END\n> Hello\n> World\n> END\ncat HelloWorld02.txt\nHello\nWorld\n```\n\n## shell脚本范例","tags":["读书笔记","linux系统","shell脚本"]},{"title":"EventEmitter和事件循环","url":"/2022/04/19/EventEmitter和事件循环/","content":"\n## Node事件循环\n>Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。\nNode.js 几乎每一个 API 都是支持回调函数的。\nNode.js 基本上所有的事件机制都是用设计模式中观察者模式实现。\nNode.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.\n\n### 事件驱动程序\nNode.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。\n当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。\n这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）\n在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。\n<img src=\"/img/event_loop.jpeg\" style=\"max-width:95%\" />\n\n### 实例\n```js\n// 引入 events 模块\nvar events = require('events');\n// 创建 eventEmitter 对象\nvar eventEmitter = new events.EventEmitter();\n \n// 创建事件处理程序\nvar connectHandler = function connected() {\n   console.log('连接成功。');\n  \n   // 触发 data_received 事件 \n   eventEmitter.emit('data_received');\n}\n \n// 绑定 connection 事件处理程序\neventEmitter.on('connection', connectHandler);\n \n// 使用匿名函数绑定 data_received 事件\neventEmitter.on('data_received', function(){\n   console.log('数据接收成功。');\n});\n \n// 触发 connection 事件 \neventEmitter.emit('connection');\n \nconsole.log(\"程序执行完毕。\");\n\n/**\n * node main.js\n   连接成功。\n   数据接收成功。\n   程序执行完毕。\n * /\n```\n\n\n\n## Node.js EventEmitter\n> EventEmitter是Node.js的内置模块events提供的一个类，它是Node事件流的核心；Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。\nNode.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。\n\n### EventEmitter类\nevents 模块只提供了一个对象： events.EventEmitter。**EventEmitter 的核心就是事件触发与事件监听器功能的封装。**\n```js\n//event.js 文件\nvar EventEmitter = require('events').EventEmitter; \nvar event = new EventEmitter(); \nevent.on('some_event', function() { \n    console.log('some_event 事件触发'); \n}); \nsetTimeout(function() { \n    event.emit('some_event'); \n}, 1000);\n\n//node event.js \n// some_event 事件触发\n```\n\n### 方法和事件\n#### 方法\n1. addListener(event, listener)：为指定事件添加一个监听器到监听器数组的尾部(on的同名函数)。\n2. on(event, listener)：为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数\n3. once(event, listener)：为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器\n4. removeListener(event, listener)：移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。\n5. emit(event, [arg1], [arg2], [...])：按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。\n\n#### 事件\n1. newListener\n2. removeListener\n\n#### 实例\n```js\nvar events = require('events');\nvar eventEmitter = new events.EventEmitter();\n\n// 监听器 #1\nvar listener1 = function listener1() {\n   console.log('监听器 listener1 执行。');\n}\n\n// 监听器 #2\nvar listener2 = function listener2() {\n  console.log('监听器 listener2 执行。');\n}\n\n// 绑定 connection 事件，处理函数为 listener1 \neventEmitter.addListener('connection', listener1);\n\n// 绑定 connection 事件，处理函数为 listener2\neventEmitter.on('connection', listener2);\n\nvar eventListeners = eventEmitter.listenerCount('connection');\nconsole.log(eventListeners + \" 个监听器监听连接事件。\");\n\n// 处理 connection 事件 \neventEmitter.emit('connection');\n\n// 移除监绑定的 listener1 函数\neventEmitter.removeListener('connection', listener1);\nconsole.log(\"listener1 不再受监听。\");\n\n// 触发连接事件\neventEmitter.emit('connection');\n\neventListeners = eventEmitter.listenerCount('connection');\nconsole.log(eventListeners + \" 个监听器监听连接事件。\");\n\nconsole.log(\"程序执行完毕。\");\n/**\n * node main.js\n   2 个监听器监听连接事件。\n   监听器 listener1 执行。\n   监听器 listener2 执行。\n   listener1 不再受监听。\n   监听器 listener2 执行。\n   1 个监听器监听连接事件。\n   程序执行完毕。\n * /\n```\n\n#### error 事件\nEventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。\n当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。\n我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。\n\n### node模块继承EventEmitter\n大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。\n\n为什么要这样做呢？原因有两点：\n1. 具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。\n2. JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。","tags":["node事件循环","EventEmitter"]},{"title":"node中Buffer和Stream以及fs","url":"/2022/04/18/node中Buffer和Stream以及fs/","content":"\n## Buffer和Stream的区别\nBuffer是数据以二进制形式临时存放在内存中的物理映射，stream为搬运数据的传送带和加工器，有方向、状态、缓冲大小\n<img src=\"/img/bufstream.awebp\" style=\"max-width:95%\" />\n\n\n## Buffer\n### 介绍\n**就像摆渡车一样，坐满了20位才发车(程序可以决定何时发生数据)，乘客有早到有晚到（程序无法控制数据流到达的时间），必须有一个地方等候，这就是车站（程序中缓冲区[buffer]）**\n<img src=\"/img/buffer.awebp\" style=\"max-width:95%\" />\n\n\n\n### Buffer和Cache\n1. 缓冲（Buffer）是用于处理二进制流数据，将数据缓冲起来，它是临时性的，对于流式数据，会采用缓冲区将数据临时存储起来，等缓冲到一定的大小之后在存入硬盘中。视频播放器就是一个经典的例子\n2. 缓存（Cache）我们可以看作是一个中间层，它可以是永久性的将热点数据进行缓存，使得访问速度更快，例如我们通过 Memory、Redis 等将数据从硬盘或其它第三方接口中请求过来进行缓存，目的就是将数据存于内存的缓存区中，这样对同一个资源进行访问，速度会更快，也是性能优化一个重要的点\n\n### Buffer和String\n#### 1、性能对比\n```js\nconst http = require('http');\nlet s = '';\nfor (let i =0; i<1024*10; i++){\n    s += 'a';\n}\nconst str = a;\nconst buffer = Buffer.from(s);\nconst server = http.createServer((req, res)=>{\n    if(req.url === '/buffer'){\n         res.end(buffer);\n    }else if(req.url === '/string'){\n        res.end(str);\n    }\n});\nserver.listen(3000);\n/**\n * ab -c 200 -t 60 http://localhost:3000/buffer\n * ab-c 200 -t 60 http://localhost:3000/string\n * \n * 相同的测试参数，Buffer完成请求13998次，string完成请求9237次，相差4761次，\n *  Buffer比字符串的的传输更快\n * /\n```\n#### 2、相互转换\n```js\n// string --> buffer\nconst buf = Buffer.from('nodejs');\n\n// buffer --> string\nconst str = buf.toString();\n```\n>1. Buffer => utf8：如遇到非UTF-8数据会转换为 �。\n2. Buffer => utf16le：每个字符会使用2或4个字节进行编码。\n3. Buffer => latin1：指定了Unicode编码范围，超出会截断并映射为范围内的字符串。\nbuffer不支持的编码类型，gbk、gb2312等可以借助js工具包iconv-lite实现\n\n\n### 使用场景\n1. I/O 操作：关于 I/O 可以是文件或网络 I/O\n2. 文件压缩：zlib.js 为 Node.js 的核心库之一，其利用了缓冲区（Buffer）的功能来操作二进制数据流，提供了压缩或解压功能\n\n### 内存分配机制\n>由于 Buffer 需要处理的是大量的二进制数据，假如用一点就向系统去申请，则会造成频繁的向系统申请内存调用，所以 Buffer 所占用的内存不再由 V8 分配，**而是在 Node.js 的 C++ 层面完成申请，在 JavaScript 中进行内存分配。因此，这部分内存我们称之为堆外内存。**   \n\n1. 在初次加载时就会初始化 1 个 8KB 的内存空间\n2. 根据申请的内存大小分为 小 Buffer 对象 和 大 Buffer 对象（通过8KB来区分）\n3. 小 Buffer 情况，会继续判断这个 slab 空间是否足够\n   1. 如果空间足够就去使用剩余空间同时更新 slab 分配状态，偏移量会增加\n   2. 如果空间不足，slab 空间不足，就会去创建一个新的 slab 空间用来分配\n4. 大Buffer 情况，则会直接走 createUnsafeBuffer(size) 函数\n5. 不论是小 Buffer 对象还是大 Buffer 对象，内存申请是在 C++ 层面完成，内存管理在 JavaScript 层面，最终还是可以被 V8 的垃圾回收标记所回收\n\n\n## Stream\n### 介绍\n流（stream）是 Node.js 中处理流式数据的抽象接口。 stream 模块用于构建实现了流接口的对象。\nNode.js 提供了多种流对象。 例如，HTTP 服务器的请求和 process.stdout 都是流的实例。\n流可以是可读的（Readable）、可写的（Writable）、可读可写（Duplex）或者操作被写入数据，然后读出结果（Transform）\n\n我们现在有一大罐水需要浇一片菜地，如果我们将水罐的水一下全部倒入菜地，首先得需要有多么大的力气（这里的力气好比计算机中的硬件性能）才可搬得动。如果，我们拿来了水管将水一点一点流入我们的菜地，这个时候不要这么大力气就可完成\n\n### 使用\n#### 常用事件\n1. data - 当有数据可读时触发。\n2. end - 没有更多的数据可读时触发。\n3. error - 在接收和写入过程中发生错误时触发。\n4. finish - 所有数据已被写入到底层系统时触发 \n*所有的 Stream 对象都是 EventEmitter 的实例*\n\n\n## fs\n### readFile和writeFile\n1. readFile方法是将要读取的文件内容完整读入缓存区，再从该缓存区中读取文件内容\n```js\nconst readFile = (file) => new Promise((resolve, reject) => {\n  fs.readFile(file, 'utf8', (err, data) => (err ? reject(err) : resolve(data)));\n});\n```\n2. writeFile方法是将要写入的文件内容完整的读入缓存区，然后一次性的将缓存区中的内容写入都文件中\n```js\nconst writeFile = (file, contents) => new Promise((resolve, reject) => {\n  fs.writeFile(file, contents, 'utf8', err => (err ? reject(err) : resolve()));\n});\n```\n**以上的读写操作，Node.js将文件内容视为一个整体，为其分配缓存区并且一次性将文件内容读取到缓存区中，在这个期间，Node.js将不能执行任何其他处理。所以当读写大文件的时候，有可能造成缓存区“爆仓”**\n\n### read和write\n1. read方法读取文件内容是不断地将文件中的一小块内容读入缓存区，最后从该缓存区中读取文件内容\n```js\nconst read = (file) => new Promise((resolve, reject) => {   \n  fs.open(file,'r',function(err,fd){\n    const buf = new Buffer(225);\n    //读取fd文件内容到buf缓存区\n    fs.read(fd,buf,0,9,3,function(err,bytesRead,buffer){\n      const str = buf.slice(0,bytesRead).toString();\n      resolve(str)\n      console.log(str);\n    }); \n  });\n}) \n```\n2. write方法执行过程：1将需要写入的数据写入到一个内存缓存区；2待缓存区写满后再将缓存区中的内容写入到文件中；3重复执行步骤1和步骤2，直到数据全部写入文件为止\n```js\nvar fs = require('fs');\nvar buf = new Buffer('test');\nfs.open('./mess.txt','w',function(err,fd){\n  fs.write(fd,buf,3,9,0,function(err,written,buffer){\n    fs.write(fd,buf,12,3,null,function(err,written,buffer){\n      if(err) console.log('写文件操作失败');\n      console.log('写文件操作成功');\n    });\n  });\n  //同步写入\n  fs.writeSync(fd,buf,3,9,0);\n});\n```\n**以上读写操作，node.js会将文件分成一块一块逐步操作，在读写文件过程中允许执行其他操作**\n\n### createReadStream和createWriteStream\n1. createReadStream方法创建一个将文件内容读取为流数据的ReadStream对象\n```js\n// 创建一个可以读的流，读取文件 file 内容\n const readFileStream = (file) => new Promise((resolve, reject) => {\n   let chunks = [];\n   let size = 0;\n   const readerStream = fs.createReadStream(file, { highWaterMark: 1024 });\n\n   readerStream.on('data', function (data) {\n     chunks.push(data);\n     size += data.length;\n   });\n\n   readerStream.on('end', function () {\n     const buf = Buffer.concat(chunks, size);\n     const str = iconv.decode(buf, 'utf8');\n     resolve(str);\n   });\n\n   readerStream.on('error', function (err) {\n     reject(err);\n   });\n });\n```\n2. createWriteStream方法创建一个将流数据写入文件中的WriteStream对象\n```js\n// 创建一个可以写入的流，写入到文件 file 中\nconst writeFileStream = (file, contents) => new Promise((resolve, reject)=>{\n  const writerStream = fs.createWriteStream(file);\n  writerStream.write(contents,'utf8');\n  writerStream.end();\n  writerStream.on('finish', function() {\n    resolve();\n  });\n  writerStream.on('error', function(err){\n    reject(err);\n });\n});\n```\n3. pipe\n```js\nvar fs = require(\"fs\");\n// 创建一个可读流\nvar readerStream = fs.createReadStream('input.txt');\n// 创建一个可写流\nvar writerStream = fs.createWriteStream('output.txt');\n// 管道读写操作\n// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中\nreaderStream.pipe(writerStream);\n```\n<img src=\"/img/pipe.webp\" style=\"max-width:95%\" />\n\n**如上面的图片所示，我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程**\n\n<br>\n[文章来源于1](https://juejin.cn/post/6955331683499376676#heading-1)\n[文章来源于2](https://mp.weixin.qq.com/s/UU-Gug_Dx-OmXVL-99rWRg)\n[文章来源于3](https://mp.weixin.qq.com/s/huPERCsDnDpk6jRnbD6n-Q)\n","tags":["Buffer","Stream","fs"]},{"title":"网络库中断发出去的请求","url":"/2022/03/13/网络库中断发出去的请求/","content":"\n## axios\n### 1、使用 CancelToken.souce 工厂方法创建一个 cancel token\n```js\nconst CancelToken = axios.CancelToken;\nconst source = CancelToken.source();\n\naxios.get('https://mdn.github.io/dom-examples/abort-api/sintel.mp4', {\n  cancelToken: source.token\n}).catch(function (thrown) {\n  // 判断请求是否已中止\n  if (axios.isCancel(thrown)) {\n    // 参数 thrown 是自定义的信息\n    console.log('Request canceled', thrown.message);\n  } else {\n    // 处理错误\n  }\n});\n\n// 取消请求（message 参数是可选的）\nsource.cancel('Operation canceled by the user');\n```\n\n### 2、通过传递一个 executor 函数到 CancelToken 的构造函数来创建一个 cancel token\n```js\nconst CancelToken = axios.CancelToken;\nlet cancel;\n\naxios.get('https://mdn.github.io/dom-examples/abort-api/sintel.mp4', {\n  cancelToken: new CancelToken(function executor(c) {\n    // executor 函数接收一个 cancel 函数作为参数\n    cancel = c;\n  })\n});\n\n// 取消请求\ncancel('Operation canceled by the user.');\n```\n\n## fetch\n###  使用Web提供的AbortController接口\n```js\n// 使用 AbortController() 构造函数创建一个控制器，然后使用 AbortController.signal 属性获取其关联 AbortSignal 对象的引用\nconst controller = new AbortController();\nlet signal = controller.signal;\nconsole.log('signal 的初始状态: ', signal);\n\nconst downloadBtn = document.querySelector('.download');\nconst abortBtn = document.querySelector('.abort');\n\ndownloadBtn.addEventListener('click', function(){\n  fetch(url, {signal}).then(function(response) {\n    //...\n  }).catch(function(e) {\n    console.log('Download error: ' + e.message);\n  })\n});\n\nabortBtn.addEventListener('click', function() {\n  controller.abort();\n  console.log('signal 的中止状态: ', signal);\n});\n```\n\n\n<br/>\n[文章来源于](https://mp.weixin.qq.com/s/OvipsKTx1786wqrc7bEObg)\n","tags":["axios","fetch"]},{"title":"图解http读书笔记","url":"/2022/03/13/图解http读书笔记/","content":"\n## web及网络基础\n### 1、IP、TCP和DNS\n1. 负责传输的IP协议\nIP（Internet Protocol）网际协议位于网络。 IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。\n\n2. 确保可靠性的TCP协议\nTCP位于传输层，提供可靠的字节流服务。TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方。\n\n<img src=\"/img/http1.jpeg\" style=\"max-width:95%\" />\n1. 发送端首先发送一个带SYN标志的数据包给对方。\n2. 接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。\n3. 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。\n\n3. 负责域名解析的DNS服务\nDNS（Domain Name System）服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务\n\n### 2、 URI和URL区别\n1. 与URI（统一资源标识符）相比，我们更熟悉URL（UniformResource Locator，统一资源定位符）。URL正是使用Web浏览器等访问Web页面时需要输入的网页地址\n2. URI就是由某个协议方案表示的资源的定位标识符，采用HTTP协议时，协议方案就是http。除此之外，还有ftp、mailto、telnet、file等\n3. URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置）。可见URL是URI的子集\n\n\n## HTTP报文\n### 报文结构\n<img src=\"/img/http2.jpeg\" alt=\"请求报文（上）和响应报文（下）的结构\" style=\"max-width:95%\" />\n上图：请求报文（上）和响应报文（下）的结构\n<img src=\"/img/http3.jpeg\" alt=\"请求报文（上）和响应报文（下）的实例\" style=\"max-width:95%\" />\n上图：请求报文（上）和响应报文（下）的实例\n\n### 编码提示传输速率\n#### 介绍\n1. 报文（message）: 是HTTP通信中的基本单位，由8位组字节流（octet sequence，其中octet为8个比特）组成，通过HTTP通信传输。\n2. 实体（entity）: 作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成\n\n*通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异*\n\n#### 压缩传输的内容编码（Content-Encoding）\n内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。常用的内容编码有：gzip、deflate\n<img src=\"/img/http4.jpeg\" alt=\"\" style=\"max-width:95%\" />\n\n#### 分割发送的分块传输编码（Transfer-Encoding）\n在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）\n<img src=\"/img/http5.jpeg\" alt=\"\" style=\"max-width:95%\" />\n\n**优点:**\n1. 分块编码有利于一边进行压缩一边发送数据，而不是先完成压缩过程以得知压缩后数据的大小\n2. 分块传输编码允许服务器在最后发送消息头字段，利于WEB性能优化的TTFB指标；(不依赖头部的长度content-length信息，也能知道实体的边界)\n3. HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久链接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。\n\n#### Content-Encoding 和 Transfer-Encoding: chunked\n在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，报文中的实体需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的 CRLF（\\r\\n），也不包括分块数据结尾的 CRLF。最后一个分块长度值必须为 0，对应的分块数据没有内容，表示实体结束。\nContent-Encoding 和 Transfer-Encoding 二者经常会结合来用，其实就是针对进行了内容编码（压缩）的内容再进行传输编码（分块）\n```js\ntelnet 106.187.88.156 80\n\nGET /test.php HTTP/1.1\nHost: qgy18.com\nAccept-Encoding: gzip\n\nHTTP/1.1 200 OK\nServer: nginx\nDate: Sun, 03 May 2015 17:25:23 GMT\nContent-Type: text/html\nTransfer-Encoding: chunked\nConnection: keep-alive\nContent-Encoding: gzip\n\n1f\n�H���W(�/�I�J\n\n0\n```\n\n####  发送多种数据的多部分对象集合\nHTTP协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。\n1. multipart/form-data: 在Web表单文件上传时使用。\n2. multipart/byteranges: 状态码206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。\n## 状态码\n\n<img src=\"/img/http6.jpeg\" alt=\"\" style=\"max-width:95%\" />\n\n### 204（No Content）\n该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分\n### 206（Partial Content）\n该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容\n\n### 301\n永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。\n\n也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。\n### 302\n临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。\n\n和301 Moved Permanently状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。\n\n### 304\n服务器端资源未改变，可直接使用客户端未过期的缓存。304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系\n\n### 400（Bad Request）\n该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。\n\n### 401（Unauthorized）\n该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。\n\n### 403（\tForbidden）\n未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源IP地址试图访问）等列举的情况都可能是发生403的原因\n\n### 500（Internal Server Error）\n该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障\n\n### 502（Bad Gateway）\n服务挂了（作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应）\n\n### 503（Service Unavailable）\n该状态码表明服务器暂时处于超负载或正在进行停机维护（请求人数太多，服务器为了自保，拒绝用户访问），现在无法处理请求\n\n### 504（Gateway Time-out）\n是指服务器作为网关或代理，但是没有及时从上游服务器收到请求 （可能是nginx或者后端配置参数错误或者不合理）\n\n\n## web安全\n### web攻击技术\n#### 主动攻击\n主动攻击模式里具有代表性的攻击是SQL注入攻击和OS命令注入攻击\n\n#### 被动攻击\n被动攻击模式中具有代表性的攻击是跨站脚本攻击（xss）和跨站点请求伪造(csrf)\n\n\n### 其他安全漏洞\n#### 密码破解\n#### 点击劫持\n点击劫持（Clickjacking）是指利用透明的按钮或链接做成陷阱，覆盖在Web页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段\n#### Dos攻击\n**DoS攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。**\n\n1. 集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈停止状态\n2. 通过攻击安全漏洞使服务停止","tags":["图解http","读书笔记"]},{"title":"高效能人士的7个习惯读书笔记","url":"/2022/03/13/高效能人士的7个习惯读书笔记/","content":"## 概览\n<img src=\"/img/eff1.jpeg\" style=\"max-width:95%\" />\n\n<img src=\"/img/eff2.jpeg\" style=\"max-width:95%\" />\n\n## 1、积极主动——个人愿景原则\n积极主动不仅指行事的态度，还意味着人一定要对自己的人生负责。个人行为取决于自身的抉择，而不是外在的环境，人类应该有营造有利的外在环境的积极性和责任感。\n\n### 采取主动\n研究自己心仪行业的状况，甚至思考自己的求职单位正面临何种难题，然后以有效的表达方式，向对方证明自己能够协助他们解决问题。这就是“解决方案式的推销（自己）” 是事业成功的重要诀窍之一\n\n### 变被动为主动\n积极主动与消极被动有天壤之别，尤其再加上聪明才智，差别就更大了。积极主动与消极被动之间的差别可不仅仅是提高20%~50%的效率，如果积极主动的人在智力、意识和敏感度方面技高一筹，那么差别就更大。\n\n### 关注圈与影响圈\n看一个人的时间和精力集中于哪些事物，也能大致判断他是否积极主动。\n\n积极主动的人专注于“影响圈”，他们专心做自己力所能及的事，他们的能量是积极的，能够使影响圈不断扩大。反之，消极被动的人则全神贯注于“关注圈”，紧盯他人弱点、环境问题以及超出个人能力范围的事不放，结果越来越怨天尤人，一味把自己当作受害者，并不断为自己的消极行为寻找借口。\n<img src=\"/img/eff6.jpeg\" style=\"max-width:95%\" />\n\n只有当我们在影响圈上下功夫、关注自己的思维方式时，我们才能获得改变自己的正能量，并最终也影响儿子。努力改变自己，而不是一味地担忧，我们就能改变现状。\n\n### 直接控制、间接控制和无法控制\n* 可直接控制的问题：可以通过培养正确习惯来解决，这显然在影响圈范围内，本书第二部分“个人领域的成功”中讨论到的习惯一、二、三即属于这一类。\n* 可间接控制的问题：可以通过改进施加影响的方法来解决，例如采取移情方式而不是针锋相对，以身作则而不是口头游说。这在第三部分“公众领域的成功”的习惯四、五、六中有所论述。\n* 无法控制的问题：我们要做的就是改变面部曲线，以微笑、真诚与平和来接受现实。纵使有再多不满，也要学着泰然处之，这样才不至于被问题左右。\n### 扩大影响圈\n令人鼓舞的是，在面对环境选择回应方式的同时，我们对环境的影响力也得到增强。这就像一个化学方程式，改变其中的某一部分，其结果就会跟着改变。\n\n## 2、以始为终——自我领导原则\n\n### 定义\n应该从现在开始，以你的人生目标作为衡量一切的标准，你的一言一行，一举一动，无论发生在何时，都必须遵循这一原则，即由个人最重视的期许或价值观来决定一切。牢记自己的目标或者使命，就能确信日常的所作所为并非与之南辕北辙，并且每天都向着这个目标努力，不敢懈怠。\n\n### 任何事物都需要两次创造\n“以终为始”的一个原则基础是“任何事都是两次创造而成”。我们做任何事都是先在头脑中构思，即智力上的或第一次的创造，然后付诸实践，即体力上的或第二次的创造。\n\n### 领导与管理：两次创造\n领导与管理就好比思想与行为。管理关注基层，思考的是“怎样才能有效地把事情做好”；领导关注高层，思考的是“我想成就的是什么事业”。“管理是正确地做事，领导则是做正确的事。”管理是有效地顺着成功的梯子往上爬，领导则判断这个梯子是否搭在了正确的墙上。\n\n\n\n## 3、要事第一——自我管理原则\n1. 习惯一告诉你：“你是创造者，你掌控自己的人生。”这个习惯的基础是人类特有的四大天赋，即想象力、良知、独立意志以及最为重要的自我意识。\n2. 习惯二是关于第一次的创造或者智力上的创造的习惯，其原则基础是想象力和良知这两大天赋。\n3. 习惯三是关于第二次的创造或者体力上的创造的习惯，是对前面两个习惯的实现、执行和自然流露。它要求我们运用独立意志努力实现一个目标，即以原则为基础安排人生。\n<img src=\"/img/eff3.jpeg\" style=\"max-width:95%\" />\n\n### 时间管理理论的演进\n1. 第一代理论着重利用便条与备忘录，在忙碌中调配时间与精力\n2. 第二代理论强调行事历与日程表，反映出时间管理已注意到规划未来的重要\n3. 第三代是目前正流行、讲求优先顺序的观念。也就是依据轻重缓急设定短、中、长期目标，再逐日订立实现目标的计划，将有限的时间、精力加以分配，争取最高的效率；但也有人发现，过分强调效率，把时间崩得死死的，反而会产生反效果\n4. 第四代理论出现。与以往截然不同之处在于，它根本否定“时间管理”这个名词，主张关键不在于时间管理，而在于个人管理。与其着重于时间与事务的安排，不如把重心放在维持产出与产能的平衡上。\n\n### 授权——高效能的秘诀\n授权是提高效率或效能的秘诀之一，可惜一般人多吝于授权，总觉得不如靠自己更省时省事。其实把责任分配给其他成熟老练的员工，才有余力从事更高层次的活动。因此，授权代表成长，不但是个人，也是团体的成长。\n\n## 4、双赢思维——人际领导原则\n### 六个交往模式\n#### 利人利己（双赢）\n#### 两败俱伤（输/输）\n为了报复，不惜牺牲自身的利益，却不问是否值得；只有不够成熟、掌握不了人生方向的人，才会这样。极具依赖性的人也会倾向于两败俱伤模式，他们的人生没有方向，生活痛苦，于是认为所有人都该如此—— “大家都不赢的话，做个失败者也没什么。”\n#### 损人利己（赢/输）\n学校是赢/输模式的另一个温床，“正态分布曲线”主要说明的是：你之所以得A，是因为有人得了C；一个人的价值是通过与他人比较才得以实现的，内在价值毫无意义，外在表现才最重要。\n在竞争激烈和信任薄弱的环境里，我们需要赢/输模式。但是竞争在生活中只居少数，我们不需要每天都和配偶、孩子、同事、邻居、朋友竞争。“你和爱人谁说了算（谁是赢家）？”这是一个很荒唐的问题，如果没有人赢，那就是两个都输。\n\n#### 独善其身（赢）\n#### 舍己为人（输/赢）\n“我是个和事佬，只要能息事宁人，我做什么都行。”这种人没有标准，没有要求，没有期望，也没有将来。他们通常喜欢取悦他人，喜欢满足他人的希望。别人的认同和接受能够给他们力量，他们没有勇气表达自己的感受和信念，总是服从于别人的意志。\n\n许多主管、经理和家长都在这两种模式间左右摇摆，当他们无法忍受混乱无序、缺乏目标、纪律松散的状态的时候，就会倾向于赢/输模式，之后随着内疚感日增，又会回到输/赢模式，而新一轮的愤怒与挫败感再次将他们推向赢/输模式。\n#### 好聚好散（无交易）\n如果实在无法达成共识，实现双赢，就不如好聚好散（放弃交易）。好聚好散的意思是，如果不能利益共享，那就商定放弃交易。道不同，不相为谋，所以我们之间没有期望，没有订立合约，没有雇佣和合作关系，这比明确期望后再让对方希望破灭要好得多。心中留有退路，顿觉轻松无比，更不必耍手段、施压力，迫使对方就范。坦诚相见，更有助于发掘及解决问题。即使买卖不成，仁义尚在，或许日后还有合作的机会。\n\n### 哪个模式最好\n**如果赢要以过多的时间和精力为代价，以至于得不偿失，那么还是“退一步海阔天空”的好。**\n**有些情况并非如此。比如说，当你的孩子面临生命危险的时候，对你来说，拯救孩子高于一切，自然无暇顾及他人。**\n**因此，最好的选择必须依情况而定，关键是认清形势，不要教条地把某一种模式应用于每一种情况**\n**但从长远来看，只有双赢才是在相互依赖的环境中唯一可行的交往模式**\n\n## 5、知己知彼——移情沟通原则\n知彼解己——首先去寻求了解对方，然后再争取让对方了解自己。这一原则是进行有效人际沟通的关键\n### 你真的听懂了吗\n如果你要和我交往，想对我有影响力，你首先要了解我，而做到这一点不能只靠技巧。如果我觉察到你在使用某种技巧，就会有受骗和被操纵的感觉。我不知道你为什么这样做，有什么动机。你让我没有安全感，自然也不会对你敞开心扉\n\n### 移情聆听\n一是充耳不闻，压根就不听别人说话；二是装模作样，“是的！嗯！没错！”；三是选择性接收，只听一部分，通常学龄前儿童的喋喋不休会让我们采取这种方式；四是聚精会神，努力听到每一个字。但是，很少有人会达到第五个层次，即最高层次——移情聆听。\n移情聆听是指以理解为目的的聆听，要求听者站在说话者的角度理解他们的思维方式和感受。\n移情聆听还是感情投资的关键，因为只有对方认同，你的投资才有意义，否则就算你费尽心机，对方也只会把它看作是一种控制、自利、胁迫和屈就，结果是情感账户被支取。\n移情聆听是有风险的。只有当你做好了被对方影响的准备，才能深入到移情聆听的阶段，而这是需要足够的安全感的，因为这时候的你会变得很脆弱。从某种意义上说，这很矛盾，因为在影响对方之前，你必须先被影响，即真正理解对方。\n所以说习惯一、二和三是基础，帮你保持核心不变，即以原则为中心，从而平和而有力地应对坚实内心之外的脆弱。\n\n### 先诊断，后开方\n销售方面也是这样。平庸的业务员推销产品，杰出的业务员销售解决问题、满足需求之道。万一产品不符合客户需要，也要勇于承认。\n\n### 四种自传式回应\n1. 价值判断——对旁人的意见只有接受或不接受。\n1. 追根究底——依自己的价值观探查别人的隐私。\n1. 好为人师——以自己的经验提供忠告。\n1. 自以为是——根据自己的行为与动机衡量别人的行为与动机。\n### 有效的沟通\n\n## 6、统合综效——创造合作原则\n统合综效的基本心态是：如果一位具有相当聪明才智的人跟我意见不同，那么对方的主张必定有我尚未体会的奥妙，值得加以了解。与人合作最重要的是，重视不同个体的不同心理、情绪与智能，以及个人眼中所见到的不同世界。与所见略同的人沟通，益处不大，要有分歧才有收获。\n\n### 核心\n统合综效的精髓就是判断和尊重差异，取长补短\n\n### 敞开胸怀，博采众议\n所谓统合综效的沟通，是指敞开胸怀，接纳一切奇怪的想法，同时也贡献自己的见地。乍看之下，这似乎把习惯二“以终为始”弃之不顾，其实正好相反。在沟通之初，谁也没有把握事情会如何变化，最后结果又如何。但安全感与信心使你相信，一切会变得更好，这正是你心中的目标。\n因为凡是创新就得有担当，不怕失败，不断尝试，即便最后证明是错误的。不愿冒风险的人，经不起此种煎熬。\n### 沟通三层次\n<img src=\"/img/eff4.jpeg\" style=\"max-width:95%\" />\n\n1. 低层次的沟通源自低信任度，其特点是人与人之间互相提防，步步为营，经常借助法律说话，为情况恶化作打算，其结果只能是赢/输或者输/赢，而且毫无效率可言，即产出/产能不平衡\n2. 中间一层是彼此尊重的交流方式，唯有相当成熟的人才办得到。但是为了避免冲突，双方都保持礼貌，但却不一定为对方设想。即使掌握了对方的意向，也不能了解背后的真正原因，也不可能完全开诚布公，探讨其余的选择路径。\n3. 统合综效意味着1+1等于8或16，甚至1600。源自高信任度的统合综效能带来比原来更好的解决方案，每一个参与者都能认识到这一点，并全心享受这种创造性的事业。\n### 尊重差异\n自以为是的人总以为自己最客观，别人都有所偏颇，其实这才是画地为牢。反之，虚怀若谷的人承认自己有不足之处，而乐于在与人交往中汲取丰富的知识见解，重视不同的意见，因而增广见闻。此所谓“三人行，必有我师焉”。\n与所见略同的人沟通，益处不大，要有分歧才有收获\n\n\n## 7、不断更新——自我提升和完善原则\n拥有财富，并不代表经济独立，拥有创造财富的能力才真正可靠\n\n### 自我提升和完善的四个层面\n习惯七就是个人产能。它保护并优化你所拥有的最重要的资产——你自己。它从四个层面更新你的天性，那就是：身体、精神、智力、社会/情感\n\n#### 身体层面\n在你执行慢跑计划期间，即使清晨有雨，也不能放弃。而是要想太好了！下雨了！我可以在锻炼身体的同时磨炼意志！\n锻炼的所有好处几乎都产生于最后阶段。我想增强力量，就必须等到肌肉纤维断裂，神经纤维感到疼痛才行，因为这时候自然机制才会予以过度补偿，纤维在48小时后会变得更加坚韧。\n\n#### 精神层面\n有些人是通过欣赏优秀的文学或音乐作品来实现精神层面的更新，还有些人是通过与自然交流来达到同样目的。我的做法是每天认真阅读和思考《圣经》，因为它体现了我的价值体系，每及此时，我都会感觉脱胎换骨，精神抖擞，信心百倍，并重获为他人服务的决心\n\n#### 智力层面\n智力层面的更新主要靠教育，借此不断学习知识，磨砺心智，开阔视野。有时需要借助课堂教学或系统的学习计划。\n养成定期阅读优秀文学作品的习惯是拓展思维的最佳方式，这是第二象限事务，人们可以借此接触到当前或历史上最伟大的思想。\n磨砺心智的另一种有效方式是写作。通过不断记录自己的想法、经历、深刻见解和学习心得，我们的思路就会更加明晰、准确和连贯\n\n#### 社会/情感层面\n我开始实践习惯五——先理解别人，我要做到移情聆听，目的不是做出回答，而是深入、全面地了解你的想法。当我能够像你一样解释你的观点之后，就集中精力阐明我自己的观点，让你也能够理解我的观点\n\n### 更新中的统合综效\n真正的经济独立指的不是家财万贯，而是拥有创造财富的能力，这是内在的。\n“每天的个人领域的成功”（每天至少用一个小时实现身体、精神和智力层面的更新）是培养七个习惯的关键，完全在个人的影响圈范围内。第二象限事务会集中必要精力将所有习惯整合到生活中，让你以原则作为生活的中心。\n\n### 螺旋式上升\n<img src=\"/img/eff5.jpeg\" style=\"max-width:95%\" />\n\n","tags":["读书笔记","个人成长","高效能人士7个习惯"]},{"title":"nodejs文件下载","url":"/2022/02/27/nodejs文件下载/","content":"\n### 简单文件下载\n\n**服务器上文件系统已经存在了某个文件，客户端请求下载直接把文件读了吐回去。设置 Content-Disposition 头部为 attachment 是关键，告诉浏览器应该下载这个文件**\n\n>Content-Type: application/octet-stream告诉浏览器这是一个二进制文件。 Content-Disposition告诉浏览器这是一个需要下载的附件并告诉浏览器默认的文件名。\n如果不添加Content-Disposition响应头，浏览器可能会下载或显示文件内容，不同浏览器的处理有所不同。\n\n```js\nimport Koa from 'koa';\nimport Router from 'koa-router';\nimport * as fs from 'fs/promises'; // node版本必须在12\n\nconst app = new Koa();\nconst router = new Router();\n\nrouter.get('/download/simple', async (ctx) => {\n  const file = await fs.readFile(`${__dirname}/1.txt`, 'utf-8');\n  ctx.set({\n    'Content-Disposition': `attachment; filename=1.txt`,\n  });\n  ctx.body = file;\n});\n\napp.use(router.routes());\napp.listen(80);\n```\n\n\n### 流式下载（大文件）\n\n**Node无法将大文件一次性读取到进程内存里，这时候用流来解决。 此例子不设置 Content-Disposition 头部也是会下载的，因为 Content-Type 被设置为了 application/octet-stream，浏览器认为其是一个二进制流文件所以默认下载处理了**\n\n```js\nrouter.get('/download/stream', async (ctx) => {\n  const file = fs.createReadStream(`${__dirname}/1.txt`);\n  ctx.set({\n    'Content-Disposition': `attachment; filename=1.txt`,\n  });\n  ctx.body = file;\n});\n```\n\n### 下载进度条提示\n\n**大文件下载进度显示，浏览器通过Content-Length来识别**\n\n```js\nconst { PassThrough } = require('stream');\nrouter.get('/download/progress', async (ctx) => {\n  const { enable } = ctx.query;\n  const buffer = await fsp.readFile(`${__dirname}/1.txt`);\n  const stream = new PassThrough();\n  const l = buffer.length;\n  const count = 4;\n  const size = Math.floor(l / count);\n  const writeQuarter = (i = 0) => {\n    const start = i * size;\n    const end = i === count - 1 ? l : (i + 1) * size;\n    stream.write(buffer.slice(start, end));\n\n    if (end === l) {\n      stream.end();\n    } else {\n      // Koa 不再知道文件大小和类型，并将文件分为 4 份，每份间隔 3 秒发送来模拟大文件下载。\n      setTimeout(() => writeQuarter(i + 1), 3000);\n    }\n  };\n  \n  // 通过参数是否显示进度条，给出剩余下载时间\n  if (!!enable) {\n    ctx.set({\n      'Content-Length': `${l}`,\n    });\n  }\n\n  ctx.set({\n    'Content-Type': 'plain/txt',\n    'Content-Disposition': `attachment; filename=1.txt`,\n    Connection: 'keep-alive',\n  });\n  ctx.body = stream;\n  writeQuarter();\n});\n```\n\n\n### 断点续传\n\n**下载文件特别大时，常常也会因为网络不稳定导致下载中途断开而失败，**\n\n```js\nfunction getStartPos(range = '') {\n  var startPos = 0;\n  if (typeof range === 'string') {\n    var matches = /^bytes=([0-9]+)-$/.exec(range);\n    if (matches) {\n      startPos = Number(matches[1]);\n    }\n  }\n  return startPos;\n}\n\nrouter.get('/download/partial', async (ctx) => {\n  const range = ctx.get('range');\n  const start = getStartPos(range);\n  const stat = await fsp.stat(`${__dirname}/1.txt`);\n  const stream = fs.createReadStream(`${__dirname}/1.txt`, {\n    start,\n    highWaterMark: Math.ceil((stat.size - start) / 4),\n  });\n\n  stream.on('data', (chunk) => {\n    console.log(`Readed ${chunk.length} bytes of data.`);\n    stream.pause();\n    setTimeout(() => {\n      stream.resume();\n    }, 3000);\n  });\n\n  console.log(`Start Pos: ${start}.`);\n  if (start === 0) {\n    ctx.status = 200;\n    ctx.set({\n      'Accept-Ranges': 'bytes',\n      'Content-Length': `${stat.size}`,\n    });\n  } else {\n    ctx.status = 206;\n    ctx.set({\n      'Content-Range': `bytes ${start}-${stat.size - 1}/${stat.size}`,\n    });\n  }\n\n  ctx.set({\n    'Content-Type': 'application/octet-stream',\n    'Content-Disposition': `attachment; filename=1.txt`,\n    Connection: 'keep-alive',\n  });\n  ctx.body = stream;\n});\n\n```\n\n### 动态表格下载\n\n**实际业务问题：根据请求参数条件读取数据库的某张表的全部记录并导出为表格**\n\n```js\n// Controller.js\nconst sequelize = new Sequelize(name, user, password, {\n  dialect: 'mysql',\n  host,\n  port,\n});\nconst model = sequelize.import('/path/to/model');\nconst { rows } = await model.findAndCountAll({\n  where: conditions,\n  attributes: ['f_user_id'],\n  group: 'f_user_id',\n});\n\nconst list = awaitPromise.all(\n  rows.map((item) => {\n    const { f_user_id } = item;\n    const userRows = await model.findAll({\n      where: { ...conditions, f_user_id },\n      // ordering, eager loading, ...\n    });\n\n    // formating userRows -> userData\n\n    return userData;\n  })\n);\n\nconst headers = ['ID', /*...*/];\nconst sheetData = [headers, ...list];\n\nctx.attachment(`${sheetName}.xlsx`);\nctx.body = await exportXlsx(sheetName, sheetData);\n```\n\n```js\n// xlsx.js\nconst ExcelJS = require('exceljs');\nconst fs = require('fs');\n\nmodule.exports = {\n  exportXlsx: async (name = 'sheet', data) => {\n    const tempFilePath = `./xlsx/${Date.now()}.xlsx`;\n    const workbook = new ExcelJS.stream.xlsx.WorkbookWriter({ \n      filename: tempFilePath \n    }); // 创建一个流式写入器\n    const sheet = workbook.addWorksheet('My Sheet'); // 添加工作表\n    const { length } = data;\n    for (let i = 0; i < length; i++) {\n      sheet.addRow(data[i]);\n    }\n    sheet.commit(); // 提交工作表\n    await workbook.commit(); // 交工作簿，即写入文件\n    return fs.createReadStream(tempFilePath);\n  },\n};\n```\n**待优化：**\n1. 没考虑数据量的问题，当时数据超过几万条时候，nodejs的内存就会爆掉，进而退出进程\n2. 数据查询逻辑不考虑性能，没考虑sql查询并发数问题\n3. 没有考虑内存限制, exceljs提供了流api\n\n**优化措施：**\n1. **分段处理:** 最简单的策略就是将几 w 条数据库数据按每组 1w 条分组，分批次处理。 利用流程控制库async\n```js\nlet total = await model.count(/* ... */)\nlet page = 0;\nconst tasks = [];\nconst size = 10000;\nwhile (total > 0) {\n  tasks.push(() => queryModel({\n    limit: size,\n    offset: size * page\n  }))\n  page++;\n  total -= size;\n}\nawait async.series(tasks);\n```\n2. **减少sql查询数:** 源码中出现先 group by 查询出去重的 f_user_id 后，再来并发查询某一用户的所有记录。这里应该用 SQL 中的 IN 先查完再匹配处理: \n```js\nmodel.findAll({\n  where: {\n    ...conditions,\n    f_user_id: rows.map(x =>`${x.f_user_id}`)\n  }\n})\n```\n3. **流处理:** 在上面的xlsx.js文件中，是先输出一个文件再使用fs.createReadStream流输出\n```js\nconst workbook = new Excel.stream.xlsx.WorkbookWriter(options);\nconst sheet = workbook.addWorksheet('My Sheet');\n// ...\nctx.body = workbook.stream;\n```   \n\n<br >\n[文章来源](https://mp.weixin.qq.com/s/Jz_Xu6Np38TpdwFVUGNGdA)","tags":["文件下载","流式下载","断点续传"]},{"title":"前端使用http提交数据方式","url":"/2022/02/24/前端使用http提交数据方式/","content":"\n## 支持方式\n### url param\nurl param是一种resful风格（https://www.ruanyifeng.com/blog/2014/05/restful_api.html），把参数写在url中\n```js\n// 这里的 chao 就是路径中的参数（url param）, 获取chao相关信息\nhttp://abc.com/person/chao\n```\n\n### query\n通过 url 中 ？后面的用 & 分隔的字符串传递数据。 需要对数据做 url encode\n\n```js\n// 这里的 chao 就是路径中的参数（url param）, 获取chao相关信息\n// 其中非英文的字符和一些特殊字符要经过编码，可以使用 encodeURLComponent 的 api，\n// 或者使用封装了一层的 qeury-string 库来处理\n\nhttp://abc.com/person?name=chao&age=12\n\n```\n\n### form-urlencoded\n**用 form 表单提交数据就是这种，它和 query 字符串的方式的区别只是放在了 body 里，然后指定下 header头 content-type 是 application/x-www-form-urlencoded。 需要对数据做 url encode**\n\n<img src=\"/img/form-urlencoded.png\" />\n\n通过 & 分隔的 form-urlencoded 的方式需要对内容做 url encode，如果传递大量的数据，比如上传文件的时候就不是很合适了，因为文件 encode 一遍的话太慢了，这时候就可以用 form-data\n\n### form-data\nform data 不再是通过 & 分隔数据，**而是用 --------- + 一串数字做为分隔符**。因为不是 url 的方式了，自然也不用再做 url encode。\n\n**form-data 需要指定 content type 为 multipart/form-data，然后指定 boundary 也就是分割线。很明显，这种方式适合传输文件，而且可以传输多个文件**\n\n<img src=\"/img/form-data.png\" />\n\n### application/json\n**form-urlencoded 需要对内容做 url encode，而 form data 则需要加很长的 boundary，两种方式都有一些缺点。如果只是传输 json 数据的话，content-type 为 application/json**\n\n<img src=\"/img/json.png\" />\n\n<br />\n[文章来源于](https://mp.weixin.qq.com/s/Df3Q3IRBZlHq9RkSsHGT8g)\n","tags":["resful","query","form-urlencoded","form-data","application/json"]},{"title":"深入浅出nodejs读书笔记","url":"/2022/02/09/深入浅出nodejs读书笔记/","content":"\n## nodejs模块机制\n### commonjs介绍\ncommonjs对模块的定义十分简单，主要分为**模块引用、模块定义、模块标识3个部分。**\n* 模块引用 \n```js\nvar math = require('math');\n```\n* 模块定义\n```js\n// 在模块中，上下文提供require()方法来引入外部模块。\n// 对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。\n// 在模块中，还存在一个module对象，它代表模块自身，而exports是module的属性.\nexports.add = function () {\n  var sum = 0,\n    i = 0,\n    args = arguments,\n    l = args.length;\n  while (i < l) {\n    sum += args[i++];\n  }\n  return sum;\n};\n```\n* 模块标识\n模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以．、.．开头的相对路径，或者绝对路径\n\n### commonjs模块实现\n\nnode模块分为2类：**node提供的核心模块 和 用户编写的文件模块；**核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件，node启动时候已经加载到内存，文件定位和编译执行这两个步骤可以省略掉所以速度最快。\n\n加载模块过程：**路径分析 --> 文件定位 --> 编译执行**\n\nNode对引入过的模块都会进行缓存，第二次优先从缓存加载；浏览器仅仅缓存文件，而Node缓存的是编译和执行之后的对象；核心模块的缓存检查先于文件模块。\n#### 1. 路径分析\n模块路径是Node在定位文件模块的具体文件时制定的查找策略，**具体表现为一个路径组成的数组**\n```js\n// 1. 创建module_path.js文件，其内容为console.log(module.paths);\n// 2. 将其放到任意一个目录中然后执行node module_path.js。\n\n[ '/home/zc/research/node_modules',\n'/home/zc/node_modules',\n'/home/node_modules',\n'/node_modules' ]\n```\n根据上面的例子可以的模块路径生成规则：\n❑ 当前文件目录下的node_modules目录。\n❑ 父目录下的node_modules目录。\n❑ 父目录的父目录下的node_modules目录。\n❑ 沿路径向上逐级递归，直到根目录下的node_modules目录。\n\n**总结：生成方式与JavaScript的原型链或作用域链的查找方式十分类似。在加载的过程中，Node会逐个尝试模块路径中的路径，直到找到目标文件为止。**\n  \n\n#### 2. 文件定位\n* 文件扩展名分析\nNode会按．js、.json、.node的次序补足扩展名，依次尝试； 在尝试过程中，调用fs模块同步阻塞式地判断文件是否存在。\n\n* 目录分析和包\nrequire()通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，此时Node会将目录当做一个包来处理；优先找到目录下package.json文件下main属性当入口； 如果压根没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.json、index.node\n\n#### 3. 编译执行\n编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，**Node会新建一个模块对象，然后根据路径载入并编译。**\n```js\n//模块对象\nfunction Module(id, parent) {\n  this.id = id;\n  this.exports = {};\n  this.parent = parent;\n  if (parent && parent.children) {\n    parent.children.push(this);\n  }\n\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\n```\n\n**每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能**  \n\n* 读取文件方式\n  * .js文件， 通过fs模块同步读取\n  * .node文件， 这是c/c++编写的扩展文件，通过dlopen()加载编译成文件\n  * .json文件，通过fs模块同步读取， **然后json.parse()解析（反序列化：字节序列转化成对象的过程）**\n\n* 模块编译过程\ncommonjs规范规定每个模块文件中存在着require、exports、module这3个变量，但是它们在模块文件中并没有定义，那么从何而来呢？甚至在Node的API文档中，我们知道每个模块中还有\\__filename、\\__dirname这两个变量的存在，它们又是从何而来的呢。\n\n事实上，在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了(function (exports, require, module, \\__filename, \\__dirname) {\\n，在尾部添加了\\n});。一个正常的JavaScript文件会被包装成如下的样子：\n```js\n(function (exports, require, module, __filename, __dirname) {\n  var math = require('math');\n  exports.area = function (radius) {\n    return Math.PI * radius * radius;\n  };\n});\n```\n这样每个模块文件之间都进行了作用域隔离。包装之后的代码会通过vm原生模块的runInThisContext()方法执行（类似eval，只是具有明确上下文，不污染全局），返回一个具体的function对象；最后，将当前模块对象的exports属性、require()方法、module（模块对象自身），以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。\n\n上面是这些变量并没有定义在每个模块文件中却存在的原因。在执行之后，模块的exports属性被返回给了调用方。exports属性上的任何方法和属性都可以被外部调用到，但是模块中的其余变量或属性则不可直接被调用。\n\n### 模拟require模块加载机制\n```js\nconst path = require('path'); // 路径操作\nconst fs = require('fs'); // 文件读取\nconst vm = require('vm'); // 文件执行\n\n// 定义导入类，参数为模块路径\nfunction Require(modulePath) {\n    // 获取当前要加载的绝对路径\n    let absPathname = path.resolve(__dirname, modulePath);\n    // 获取所有后缀名\n    const extNames = Object.keys(Module._extensions);\n    let index = 0;\n    // 存储原始文件路径\n    const oldPath = absPathname;\n    function findExt(absPathname) {\n        if (index === extNames.length) {\n           return throw new Error('文件不存在');\n        }\n        try {\n            fs.accessSync(absPathname);\n            return absPathname;\n        } catch(e) {\n            const ext = extNames[index++];\n            findExt(oldPath + ext);\n        }\n    }\n    // 递归追加后缀名，判断文件是否存在\n    absPathname = findExt(absPathname);\n    // 从缓存中读取，如果存在，直接返回结果\n    if (Module._cache[absPathname]) {\n        return Module._cache[absPathname].exports;\n    }\n    // 尝试加载当前模块\n    tryModuleLoad(module);\n    // 创建模块，新建Module实例\n    const module = new Module(absPathname);\n    // 添加缓存\n    Module._cache[absPathname] = module;\n    // 加载当前模块\n    tryModuleLoad(module);\n    // 返回exports对象\n    return module.exports;\n}\n\n// 定义模块, 添加文件id标识和exports属性\nfunction Module(id) {\n    this.id = id;\n    // 读取到的文件内容会放在exports中\n    this.exports = {};\n}\nModule.wrapper = [\n    \"(function(exports, module, Require, __dirname, __filename) {\",\n    \"})\"\n]\nModule._extensions = {\n    '.js'(module) {\n        const content = fs.readFileSync(module.id, 'utf8');\n        const fnStr = Module.wrapper[0] + content + Module.wrapper[1];\n        const fn = vm.runInThisContext(fnStr);\n        fn.call(module.exports, module.exports, module, Require,_filename,_dirname);\n    },\n    '.json'(module) {\n        const json = fs.readFileSync(module.id, 'utf8');\n        module.exports = JSON.parse(json); // 把文件的结果放在exports属性上\n    }\n}\n\n// 定义模块加载方法\nfunction tryModuleLoad(module) {\n    // 获取扩展名\n    const extension = path.extname(module.id);\n    // 通过后缀加载当前模块\n    Module._extensions[extension](module);\n}\n```\n\n\n\n## 异步io\n### 为什么要异步io\n* 用户体验： 同步io会影响接口响应时间（M+N+..），异步io会快速响应接口(max(M,N,..))\n* 资源分配，目前主流的方式：单线程串行执行 和 多线程并行执行\n  * 多线程， 缺点：多线程编程经常面临锁、状态同步等问题； 优点：在多核cpu上能够有效提升cpu利用率\n  * 单线程， 缺点：阻塞io导致硬件资源得不到充分利用；**在计算机资源中，通常I/O与CPU计算之间是可以并行进行的。但是同步的编程模型导致的问题是，I/O的进行会让后续任务等待，这造成资源不能被更好地利用。** 优点：同步利于程序员编码\n  * **node单线程异步io方案：利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O，让单线程远离阻塞，以更好地使用CPU；为了弥补单线程无法利用多核CPU的缺点，Node提供了类似前端浏览器中WebWorkers的子线程，该子进程可以通过工作进程高效地利用CPU和I/O。**\n\n### 异步io现状\n* 异步io和非阻塞io\n  >异步与非阻塞听起来似乎是同一回事。从实际效果而言，异步和非阻塞都达到了我们并行I/O的目的。 但是从计算机内核I/O而言，异步/同步和阻塞/非阻塞实际上是两回事。操作系统内核对于I/O只有两种方式：阻塞与非阻塞。\n  任意技术都并非完美的。阻塞I/O造成CPU等待浪费，非阻塞带来的麻烦却是需要轮询去确认是否完全完成数据获取，它会让CPU处理状态判断，是对CPU资源的浪费。这里我们且看轮询技术是如何演进的，以减小I/O状态判断的CPU损耗。\n\n* 现存轮询技术\n  * read: 它是最原始、性能最低的一种，通过重复调用来检查I/O的状态来完成完整数据的读取。在得到最终数据前，CPU一直耗用在等待上。\n  <img src=\"/img/node5.jpeg\" style=\"max-width:95%\" />\n  * select: 它是在read的基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断。\n  * poll: 该方案较select有所改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查。但是当文件描述符较多的时候，它的性能还是十分低下的。\n  * epoll: 该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。\n  <img src=\"/img/node4.jpeg\" style=\"max-width:95%\" />\n\n### node如何实现异步io\n* 事件循环\n  在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。\n  <img src=\"/img/node1.jpeg\" style=\"max-width:95%\" />\n\n* 观察者\n  在每个Tick的过程中，如何判断是否有事件需要处理呢？**这里必须要引入的概念是观察者。每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。**\n  > 浏览器采用了类似的机制。事件可能来自用户的点击或者加载某些文件时产生，而这些产生的事件都有对应的观察者。在Node中，事件主要来源于网络请求、文件I/O等，这些事件对应的观察者有文件I/O观察者、网络I/O观察者等。观察者将事件进行了分类。\n  > 事件循环是一个典型的生产者/消费者模型。异步I/O、网络请求等则是事件的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理\n\n* 请求对象\n  从JavaScript代码到系统内核之间都发生了什么？\n  ```js\n    fs.open = function(path, flags, mode, callback) {\n    // ...\n    binding.open(pathModule._makeLong(path),\n                  stringToFlags(flags),\n                  mode,\n                  callback);\n  };\n  ```\n  <img src=\"/img/node2.jpeg\" style=\"max-width:95%\" />\n  JavaScript线程可以继续执行当前任务的后续操作。当前的I/O操作在线程池中等待执行，不管它是否阻塞I/O，都不会影响到JavaScript线程的后续执行，如此就达到了异步的目的。\n\n* 执行回调\n  **事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素**\n  <img src=\"/img/node3.jpeg\" style=\"max-width:95%\" />\n\n* 总结\n  我们可以提取出异步I/O的几个关键词：单线程、事件循环、观察者和I/O线程池。这里单线程与I/O线程池之间看起来有些悖论的样子。由于我们知道JavaScript是单线程的，所以按常识很容易理解为它不能充分利用多核CPU。事实上，在Node中，除了JavaScript是单线程外，Node自身其实是多线程的，只是I/O线程使用的CPU较少。另一个需要重视的观点则是，除了用户代码无法并行执行外，所有的I/O（磁盘I/O和网络I/O等）则是可以并行起来的。\n\n### node中非io的异步api\n* 定时器（setTimout/setInterval）\n  调用setTimeout()或者setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将立即执行。\n\n\n* process.nextTick()\n  每次调用process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick时取出执行。定时器中采用红黑树的操作时间复杂度为O(lg(n)), nextTick()的时间复杂度为O(1)。相较之下，process.nextTick()更高效。\n\n* setImmediate()\n  和process.nextTick功能一样\n\n* 优先级对比\n  process.nextTick > setImmediate； 这里的原因在于事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者，setImmediate()属于check观察者。在每一个轮循环检查中，**idle观察者先于I/O观察者，I/O观察者先于check观察者**\n\n### 事件驱动和高性能服务器\n* 经典服务器模型\n  * 同步式：一次只能处理一个请求，并且其余请求都处于等待状态。\n  * 每进程/每请求：为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多。\n  * 每线程/每请求：为每个请求启动一个线程来处理。尽管线程比进程要轻量，但是由于每个线程都占用一定内存，当大并发请求到来时，内存将会很快用光，导致服务器缓慢。(Apache服务)\n  * **事件驱动：Node通过事件驱动的方式处理请求，无须为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价很低。（node、nginx）**\n\n## 异步编程\n### 函数数编程\n\n**高阶函数则是可以把函数作为参数，或是将函数作为返回值的函数。**高阶函数在JavaScript中比比皆是，其中ECMAScript5中提供的一些数组方法（forEach()、map()、reduce()、reduceRight()、filter()、every()、some()）十分典型。\n\n**偏函数用法是指创建一个调用另外一个部分——参数或变量已经预置的函数——的函数的用法。**\n```js\n// 这种通过指定部分参数来产生一个新的定制函数的形式就是偏函数\nlet isType = function (type) {\n  return function (obj) {\n    return toString.call(obj) == '[object ' + type + ']';\n  };\n};\n\nlet isString = isType('String');\nlet isFunction = isType('Function');\n```\n\n### 异步编程优势和难点\n#### A、优势\n**Node带来的最大特性莫过于基于事件驱动的非阻塞I/O模型，这是它的灵魂所在。非阻塞I/O可以使CPU与I/O并不相互依赖等待，让资源得到更好的利用**\n\n<img src=\"/img/node6.jpeg\" style=\"max-width:95%\" />\n\n利用事件循环的方式，**JavaScript线程像一个分配任务和处理结果的大管家，I/O线程池里的各个I/O线程都是小二，负责兢兢业业地完成分配来的任务，小二与管家之间互不依赖，所以可以保持整体的高效率。**这个利用事件循环的经典调度方式在很多地方都存在应用，最典型的是UI编程，如iOS应用开发等。\n\nNode是为了解决编程模型中阻塞I/O的性能问题的，采用了单线程模型，**这导致Node更像一个处理I/O密集问题的能手，而CPU密集型则取决于管家的能耐如何**\n\n由于事件循环模型需要应对海量请求，海量请求同时作用在单线程上，就需要防止任何一个计算耗费过多的CPU时间片。**至于是计算密集型，还是I/O密集型，只要计算不影响异步I/O的调度，那就不构成问题。**\n\n#### B、缺点\n1. 异常处理（最大缺点）\n   > 异步I/O的实现主要包含两个阶段：**提交请求和处理结果。这两个阶段中间有事件循环的调度，两者彼此不关联。异步方法则通常在第一个阶段提交请求后立即返回，因为异常并不一定发生在这个阶段，try/catch的功效在此处不会发挥任何作用**\n   \n   ```js\n     // callback被存放起来，直到下一个事件循环（Tick）才会取出来执行\n     var async = function (callback) {\n       process.nextTick(callback);\n     };\n\n     try {\n       async(callback);\n     } catch (e) {\n       // TODO\n     }     \n   ```\n\n2. 函数嵌套过深, 目前node较高版本已支持async/await模式解决了函数嵌套问题\n3. 多线程编程\n   > 浏览器提出了Web Workers，它通过将JavaScript执行与UI渲染分离，可以很好地利用多核CPU为大量计算服务。同时前端Web Workers也是一个利用消息机制合理使用多核CPU的理想模型\n   <img src=\"/img/node7.jpeg\" style=\"max-width:95%\" />\n\n   Node借鉴了浏览器web workers这个模式，**child_process是其基础API, cluster模块是更深层次的应用。**借助Web Workers的模式，开发人员要更多地去面临跨线程的编程，这对于以往的JavaScript编程经验是较少考虑的。\n\n\n4. 异步转同步， 目前node较高版本已支持async/await模式\n\n### 异步编程解决方案\n#### 1. 事件发布/订阅模式\n> 事件侦听器模式也是一种钩子（hook）机制，利用钩子导出内部数据或状态给外部的调用者。 Node自身提供的events模块是发布/订阅模式的一个简单实现，Node中部分模块都继承自它。\n\nEventProxy的原理\n```js\n// 核心代码\n\n```\n\n#### 2. Promise/Deferred模式\n\n#### 3. async/await模式\n\n#### 4. 流程控制库\n1. 尾触发和next(Connect中间件)\n   > 除了事件和Promise外，还有一类方法是需要手工调用才能持续执行后续调用的，我们将此类方法叫做尾触发，常见的关键词是next\n\n   ```js\n     var app = connect();\n     // Middleware\n     app.use(connect.staticCache());\n     app.use(connect.static(__dirname + '/public'));\n     app.use(connect.cookieParser());\n     app.use(connect.session());\n     app.use(connect.query());\n     app.use(connect.bodyParser());\n     app.use(connect.csrf());\n     app.listen(3001);\n   ```\n\n   **connect核心代码**\n```js\nfunction app(req, res){ app.handle(req, res); }\n\n// use方法\napp.use = function(route, fn){\n // some code\n this.stack.push({ route: route, handle: fn });\n return this;\n};\n\nfunction createServer() {\n function app(req, res){ app.handle(req, res); }\n utils.merge(app, proto);\n utils.merge(app, EventEmitter.prototype);\n app.route = '/';\n app.stack = [];\n for (var i = 0; i < arguments.length; ++i) {\n   app.use(arguments[i]);\n }\n return app;\n};\n\napp.listen = function(){\n var server = http.createServer(this);\n return server.listen.apply(server, arguments);\n};\n\napp.handle = function(req, res, out) {\n // some code\n next();\n};\n\n// 原始的next()方法较为复杂，下面是简化后的内容，\n// 其原理十分简单，取出队列中的中间件并执行，同时传入当前方法以实现递归调用，达到持续触发的目的\nfunction next(err){\n  // some code\n  // next callback\n  layer = stack[index++];\n  layer.hander(req, res, next);\n}\n\n```\n\n\n1. async流程库： 异步的串行执行\n   ```js\n     async.series([\n       function (callback) {\n         fs.readFile('file1.txt', 'utf-8', callback);\n       },\n       function (callback) {\n         fs.readFile('file2.txt', 'utf-8', callback);\n       }\n     ], function (err, results) {\n       // results => [file1.txt, file2.txt]\n     });\n   ```\n\n### 异步并发控制\n> 目前社区中有bigpipe、async异步流程库解决方案    \n\nbigpipe核心实现\n\n  ```js\n        /**\n         * 推入方法，参数。最后一个参数为回调函数\n         * @param {Function} method异步方法\n         * @param {Mix} args参数列表，最后一个参数为回调函数\n         */\n        Bagpipe.prototype.push = function (method) {\n          var args = [].slice.call(arguments, 1);\n          var callback = args[args.length -1];\n          if (typeof callback ! == 'function') {\n            args.push(function () {});\n          }\n          if (this.options.disabled || this.limit < 1) {\n            method.apply(null, args);\n            return this;\n          }\n\n          // 队列长度也超过限制值时\n          if (this.queue.length < this.queueLength || ! this.options.refuse) {\n            this.queue.push({\n              method: method,\n              args: args\n            });\n          } else {\n            var err = new Error('Too much async call in queue');\n            err.name = 'TooMuchAsyncCallError';\n            callback(err);\n          }\n\n          if (this.queue.length > 1) {\n            this.emit('full', this.queue.length);\n          }\n          this.next();\n          return this;\n        };\n\n        /*\n         * 继续执行队列中的后续动作\n         */\n        Bagpipe.prototype.next = function () {\n          var that = this;\n          if (that.active < that.limit && that.queue.length) {\n            var req = that.queue.shift();\n            that.run(req.method, req.args);\n          }\n        };  \n        \n        /*\n         * 执行队列中的方法\n         */\n        Bagpipe.prototype.run = function (method, args) {\n          var that = this;\n          that.active++;\n          var callback = args[args.length -1];\n          var timer = null;\n          var called = false;\n\n          // inject logic\n          args[args.length -1] = function (err) {\n            // anyway, clear the timer\n            if (timer) {\n              clearTimeout(timer);\n              timer = null;\n            }\n            // if timeout, don't execute\n            if (! called) {\n              that._next();\n              callback.apply(null, arguments);\n            } else {\n              // pass the outdated error\n              if (err) {\n              that.emit('outdated', err);\n              }\n            }\n          };\n\n          var timeout = that.options.timeout;\n          if (timeout) {\n            timer = setTimeout(function () {\n              // set called as true\n              called = true;\n              that._next();\n              // pass the exception\n              var err = new Error(timeout + 'ms timeout');\n              err.name = 'BagpipeTimeoutError';\n              err.data = {\n                name: method.name,\n                method: method.toString(),\n                args: args.slice(0, -1)\n              };\n              callback(err);\n            }, timeout);\n          }\n          method.apply(null, args);\n        };\n  ```\n\n## 内存控制\n### V8的垃圾回收机制和内存限制\n#### 1. V8的内存限制\n> 至于V8为何要限制堆的大小，表层原因为V8最初为浏览器而设计，不太可能遇到用大量内存的场景。对于网页来说，V8的限制值已经绰绰有余。深层原因是V8的垃圾回收机制的限制。按官方的说法，以1.5 GB的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至要1秒以上。这是垃圾回收中引起JavaScript线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力都会直线下降\n\n\n* 关于V8，作为虚拟机，V8的性能表现优异。\n* Node中通过JavaScript使用内存时就会发现只能使用部分内存（64位系统下约为1.4 GB,32位系统下约为0.7 GB）。\n\n**手动打开node内存限制**  \n```js\n// 设置老生代内存空间的最大值\nnode --max-old-space-size=1700 test.js // 单位为MB\n// 或者 设置新生代内存空间的大小\nnode --max-new-space-size=1024 test.js // 单位为KB\n```\n\n\n#### 2. V8的对象分配\n在V8中，所有的JavaScript对象都是通过**堆来进行分配的**。\n```js\n// heapTotal和heapUsed是V8的堆内存使用情况，\n// heapTotal: 前者是已申请到的堆内存，\n// heapUsed: 后者是当前使用的量。\n// 至于rss为常驻内存\n$ node\n> process.memoryUsage();\n{ rss: 14958592,\n  heapTotal: 7195904,\n  heapUsed: 2821496 \n}\n```\n\n#### 3. V8的垃圾回收机制\n> V8的垃圾回收策略主要基于分代式垃圾回收机制。在自动垃圾回收的演变过程中，人们发现没有一种垃圾回收算法能够胜任所有的场景。因为在实际的应用中，对象的生存周期长短不一，不同的算法只能针对特定情况具有最好的效果\n\n1. a、v8的内存分代\n在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象\n<img src=\"/img/node8.jpeg\" style=\"max-width:95%\" />\n\n2. b、Scavenge算法\n在Scavenge的具体实现中，主要采用了Cheney算法； Cheney算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。\n\n<img src=\"/img/node9.jpeg\" style=\"max-width:95%\" />\n\n当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。对象从新生代中移动到老生代中的过程称为晋升。\n**对象晋升的条件主要有两个：1、一个是对象是否经历过Scavenge回收，2、一个是To空间的内存（to空间超过25%）占用比超过限制。**\n\n\n\n3. c、Mark-Sweep & Mark-Compact (标记清除 & 标记整理)\n> 对于老生代中的对象，由于存活对象占较大比重，再采用Scavenge的方式会有两个问题：一个是存活对象较多，复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题。这两个问题导致应对生命周期较长的对象时Scavenge会显得捉襟见肘。为此，V8在老生代中主要采用了Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收\n\n  1. **Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。**Mark-Sweep只清理死亡对象。活对象在新生代中只占较小部分，死对象在老生代中只占较小部分，这是两种回收方式能高效处理的原因\n  <img src=\"/img/node11.jpeg\" style=\"max-width:95%\" />\n\n  2. **Mark-Compact是标记整理的意思，是在Mark-Sweep的基础上演变而来的。**它们的差别在于对象在标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存\n  <img src=\"/img/node12.jpeg\" style=\"max-width:95%\" />\n\n\n4. d、3种垃圾回收算法的简单对比\n<img src=\"/img/node10.jpeg\" style=\"max-width:95%\" />\n\n5. e、增量标记\n为了避免出现JavaScript应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”（stop-the-world）\n<img src=\"/img/node13.jpeg\" style=\"max-width:95%\" />\n\n6. f、查看垃圾回收日志\n   1. 查看垃圾回收日志的方式主要是在启动时添加--trace_gc参数\n   2. 通过在Node启动时使用--prof参数，可以得到V8执行时的性能分析数据，其中包含了垃圾回收执行时占用的时间 \n\n### 查看内存指标\n>应用中存在一些全局性的对象是正常的，而且在正常的使用中，变量都会自动释放回收。但是也会存在一些我们认为会回收但是却没有被回收的对象，这会导致内存占用无限增长。一旦增长达到V8的内存限制，将会得到内存溢出错误，进而导致进程退出\n\n#### 查看内存使用情况\n1. a、查看进程内存占用：**process.memoryUsage()可以看到Node进程的内存占用情况**\n  ```js\n    var showMem = function () {\n    var mem = process.memoryUsage();\n    var format = function (bytes) {\n      return (bytes / 1024 / 1024).toFixed(2) + ' MB';\n    };\n    // heapTotal：堆中总申请的内存量；heapUsed：堆中使用中内存量\n    console.log('Process: heapTotal ' + format(mem.heapTotal) +\n      ' heapUsed ' + format(mem.heapUsed) + ' rss ' + format(mem.rss));\n  };\n  ```\n\n2. b、查看系统的内存占用\n os模块中的totalmem()和freemem()这两个方法用于查看操作系统的内存使用情况\n\n#### 堆外内存\n>通过process.memoryUsage()的结果可以看到，堆中的内存用量总是小于进程的常驻内存用量，这意味着Node中的内存使用并非都是通过V8进行分配的。我们将那些不是通过V8分配的内存称为堆外内存\n\n```js\nvar useMem = function () {\n var size = 200 * 1024 * 1024;\n var buffer = new Buffer(size);\n for (var i = 0; i < size; i++) {\n   buffer[i] = 0;\n }\n return buffer;\n};\n```\nheapTotal与heapUsed的变化极小，唯一变化的是rss的值，并且该值已经远远超过V8的限制值。**这其中的原因是Buffer对象不同于其他对象，它不经过V8的内存分配机制，所以也不会有堆内存的大小限制。**\n\n>为何Buffer对象并非通过V8分配？这在于Node并不同于浏览器的应用场景。在浏览器中，JavaScript直接处理字符串即可满足绝大多数的业务需求，而Node则需要处理网络流和文件I/O流，操作字符串远远不能满足传输的性能需求。\n\n#### 总结\n**node的内存构成主要由通过V8进行分配的部分和node自行分配部分，受V8的垃圾回收机制限制主要是V8的堆内存**\n\n### 内存泄漏\n>造成内存泄漏的原因有如下几个: **1、缓存 2、队列消费不及时 3、作用域未释放**\n\n#### 1. 慎将内存当缓存使用\n>一旦一个对象被当做缓存来使用，那就意味着它将会常驻在老生代中。缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在进行扫描和整理时，对这些对象做无用功。**所以在Node中，任何试图拿内存当缓存的行为都应当被限制。当然，这种限制并不是不允许使用的意思，而是要小心为之**\n\n1. a、缓存限制策略\n   需要加入一种策略来限制缓存无限制增长，**例如LRU算法的缓存算法**\n   ```js\n        var LimitableMap = function (limit) {\n          this.limit = limit || 10;\n          this.map = {};\n          this.keys = [];\n        };\n\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n        LimitableMap.prototype.set = function (key, value) {\n          var map = this.map;\n          var keys = this.keys;\n          if (! hasOwnProperty.call(map, key)) {\n            if (keys.length === this.limit) {\n              var firstKey = keys.shift();\n              delete map[firstKey];\n            }\n            keys.push(key);\n          }\n          map[key] = value;\n        };\n\n        LimitableMap.prototype.get = function (key) {\n          return this.map[key];\n        };\n\n        module.exports = LimitableMap;\n   ```\n\n2. b、缓存的解决方案\n   1. 将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效\n   2. 进程之间可以共享缓存： 例如redis\n\n\n#### 2. 关注队列状态\n在大多数应用场景下，消费的速度远远大于生产的速度，内存泄漏不易产生。但是一旦消费速度低于生产速度，将会形成堆积。\n\n**例子：**有的应用会收集日志。如果欠缺考虑，也许会采用数据库来记录日志。日志通常会是海量的，数据库构建在文件系统之上，写入效率远远低于文件直接写入，于是会形成数据库写入操作的堆积，而JavaScript中相关的作用域也不会得到释放，内存占用不会回落，从而出现内存泄漏\n\n**解决方案：**\n 1. 通过监控系统产生报警并通知相关人员\n 2. 任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传达超时异常，启动拒绝模式\n\n\n### 内存排查\n1. 常见的内存排查工具\n   1. v8-profiler：它可以用于对V8堆内存抓取快照和对CPU进行分析\n   2. node-heapdump：它允许对V8堆内存抓取快照，用于事后分析。\n   3. node-memwatch：\n\n2. 总结\n   **排查内存泄漏的原因主要通过对堆内存进行分析而找到**\n\n### 大内存应用 \n>在Node中，不可避免地还是会存在操作大文件的场景。由于Node的内存限制，操作大文件也需要小心，好在Node提供了stream模块用于处理大文件；Node中的大多数模块都有stream的应用，比如fs的createReadStream()和createWriteStream()方法可以分别用于创建文件的可读流和可写流，process模块中的stdin和stdout则分别是可读流和可写流的示例。\n\n1. fs.createReadStream 和 fs.createWriteStream 使用\n\n```js\nvar reader = fs.createReadStream('in.txt');\nvar writer = fs.createWriteStream('out.txt');\nreader.on('data', function (chunk) {\n writer.write(chunk);\n});\nreader.on('end', function () {\n writer.end();\n});\n\n// 另外一种写法\nvar reader = fs.createReadStream('in.txt');\nvar writer = fs.createWriteStream('out.txt');\nreader.pipe(writer);\n```\n可读流提供了管道方法pipe()，封装了data事件和写入操作。通过流的方式，上述代码不会受到V8内存限制的影响，有效地提高了程序的健壮性。\n\n## 理解buffer\n>由于应用场景不同，在Node中，应用需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，还要处理大量二进制数据，JavaScript自有的字符串远远不能满足这些需求，于是Buffer对象应运而生\n\n### Buffer的结构\n1. a、介绍\n 1. 1、由于Buffer太过常见，Node在进程启动时就已经加载了它，并将其放在全局对象（global）上。所以在使用Buffer时，无须通过require()即可直接使用；\n 2. 2、Buffer是一个典型的JavaScript与C++结合的模块，它将性能相关部分用C++实现，将非性能相关的部分用JavaScript实现。\n 3. 3、Buffer所占用的内存不是通过V8分配的，属于堆外内存。\n\n2. b、buffer对象\nBuffer对象类似于数组，它的元素为16进制的两位数，即0到255的数值。\n```js\nvar str = \"深入浅出node.js\";\nvar buf = new Buffer(str, 'utf-8');\nconsole.log(buf); // <Buffer e6 b7 b1 e5 85 a5 e6 b5 85 e5 87 ba 6e 6f 64 65 2e 6a 73>\n\n// \nvar buf = new Buffer(100);\nconsole.log(buf.length); //  100\nbuf[10] = 123;\nconsole.log(buf[10]); //  123\n```\n\n3. c、buffer的内存分配\n  * Buffer对象的内存分配不是在V8的堆内存中，而是在Node的C++层面实现内存的申请的。因为处理大量的字节数据不能采用需要一点内存就向操作系统申请一点内存的方式，这可能造成大量的内存申请的系统调用，对操作系统有一定压力。为此Node在内存的使用上应用的是在C++层面申请内存、在JavaScript中分配内存的策略\n  * slab机制介绍：xxxxx\n\n\n4. d、总结\n真正的内存是在Node的C++层面提供的，JavaScript层面只是使用它。当进行小而频繁的Buffer操作时，采用slab的机制进行**预先申请和事后分配，**使得JavaScript到操作系统之间不必有过多的内存申请方面的系统调用。对于大块的Buffer而言，则直接使用C++层面提供的内存，而无需细腻的分配操作。\n\n### Buffer的转换\n1. a、字符串转buffer\n```js\n//默认按UTF-8编码进行转码和存储\nnew Buffer(str, [encoding]);\n\nbuf.write(string, [offset], [length], [encoding]);\n```\n\n2. b、buffer转字符串\n```js\nbuf.toString([encoding], [start], [end]);\n```\n\n### Buffer的拼接\n1. buffer拼接\n```js\nvar fs = require('fs');\nvar rs = fs.createReadStream('test.md');\nvar data = '';\nrs.on(\"data\", function (chunk){\n data += chunk; // data = data.toString() + chunk.toString();\n});\nrs.on(\"end\", function () {\n console.log(data);\n});\n```\n2. 中文乱码原因\n   1. 模拟出现乱码：\n   ```js\n   // 将文件可读流的每次读取的Buffer长度限制为11\n   var rs = fs.createReadStream('test.md', {highWaterMark: 11});\n   ```\n   <img src=\"/img/node14.jpeg\" style=\"max-width:95%\" />\n   1. 上面的诗歌中，“月”、“是”、“望”、“低”4个字没有被正常输出，取而代之的是3个?。产生这个输出结果的原因在于文件可读流在读取时会逐个读取Buffer；\n   2. 由于我们限定了Buffer对象的长度为11，因此只读流需要读取7次才能完成完整的读取；\n   3. 上文提到的buf.toString()方法默认以UTF-8为编码，中文字在UTF-8下占3个字节。所以第一个Buffer对象在输出时，只能显示3个字符，Buffer中剩下的2个字节（e6 9c）将会以乱码的形式显示。第二个Buffer对象的第一个字节也不能形成文字，只能显示乱码。于是形成一些文字无法正常显示的问题；\n\n\n   2. 临时解决方案\n   ```js\n    var rs = fs.createReadStream('test.md', { highWaterMark: 11});\n    //该方法的作用是让data事件中传递的不再是一个Buffer对象，而是编码后的字符串\n    fs.setEncoding('utf8');\n   ```\n   虽然string_decoder模块很奇妙，但是它也并非万能药，它目前只能处理UTF-8、Base64和UCS-2/UTF-16LE这3种编码。所以，通过setEncoding()的方式不可否认能解决大部分的乱码问题，但并不能从根本上解决该问题\n   \n3. 正确拼接buffer\n   1. 通过iconv模块来转码\n   2. 修改+=改成Buffer.concat()生成一个合并的Buffer对象\n```js\nvar chunks = [];\nvar size = 0;\nres.on('data', function (chunk) {\n chunks.push(chunk);\n size += chunk.length;\n});\nres.on('end', function () {\n var buf = Buffer.concat(chunks, size);\n var str = iconv.decode(buf, 'utf8');\n console.log(str);\n});\n```\n### Buffer的性能\n#### 1. 介绍\nBuffer在文件I/O和网络I/O中运用广泛，尤其在网络传输中，它的性能举足轻重。在应用中，我们通常会操作字符串，但一旦在网络中传输，都需要转换为Buffer，以进行二进制数据传输。\n```js\nvar http = require('http');\nvar helloworld = \"\";\nfor (var i = 0; i < 1024 * 10; i++) {\n helloworld += \"a\";\n}\n\n// 使向客户端输出的是一个Buffer对象，无须在每次响应时进行转换\n// helloworld = new Buffer(helloworld);\n\nhttp.createServer(function (req, res) {\n res.writeHead(200);\n res.end(helloworld);\n}).listen(8001);\n```\n#### 2. 读取文件(fs.createReadStream)\nfs.createReadStream()的工作方式是在内存中准备一段Buffer，然后在fs.read()读取时逐步从磁盘中将字节复制到Buffer中。完成一次读取时，则从这个Buffer中通过slice()方法取出部分数据作为一个小Buffer对象，再通过data事件传递给调用方。如果Buffer用完，则重新分配一个；如果还有剩余，则继续使用。\n\n**读取一个相同的大文件时，highWaterMark值的大小与读取速度的关系：该值越大，读取速度越快**\n\n## 网络编程\n>在Web领域，大多数的编程语言需要专门的Web服务器作为容器，如ASP、ASP.NET需要IIS作为服务器，PHP需要搭载Apache或Nginx环境等，JSP需要Tomcat服务器等。\n**Node提供了net、dgram、http、https这4个模块，分别用于处理TCP、UDP、HTTP、HTTPS。**\n### 构建TCP服务\n#### 1. tcp介绍\n1. TCP属于传输层协议， http属于应用层\n2. TCP是面向连接的协议，最显著的特征是传输之前要3次握手\n   \n\n#### 2. 创建tcp\n```js\n/*\nserver.js\n*/\nvar net = require('net');\nvar server = net.createServer(function (socket) {\n // 新的连接\n socket.on('data', function (data) {\n   socket.write(\"你好\");\n });\n socket.on('end', function () {\n   console.log(\"连接断开\");\n });\n socket.write(\"欢迎光临《深入浅出Node.js》示例：\\n\");\n});\n\nserver.listen(8124, function () {\n console.log('server bound');\n});\n```\n\n```js\n/*\n client.js\n*/\nvar net = require('net');\n//'connect' listener\nvar client = net.connect({port: 8124}, function () { \n console.log('client connected');\n client.write('world! \\r\\n');\n});\n\nclient.on('data', function (data) {\n console.log(data.toString());\n client.end();\n});\n\nclient.on('end', function () {\n console.log('client disconnected');\n});\n```\n#### 3. tcp事件\n1. 服务器事件，对于通过net.createServer()创建的服务器而言，它是一个EventEmitter实例。\n   1. listening：在调用server.listen()绑定端口或者Domain Socket后触发，简洁写法为server.listen(port, listeningListener)，\n   2. connection：每个客户端套接字连接到服务器端时触发\n   3. close：当服务器关闭时触发，在调用server.close()后，服务器将停止接受新的套接字连接，但保持当前存在的连接，等待所有连接都断开后，会触发该事件。\n   \n2. 连接事件，服务器可以同时与多个客户端保持连接，对于每个连接而言是典型的可写可读Stream对象。\n   1. data：当一端调用write()发送数据时，另一端会触发data事件，事件传递的数据即是write()发送的数据\n\n#### 4. 可读可写的stream流使用pipe()管道操作\n由于TCP套接字是可写可读的Stream对象，可以利用pipe()方法巧妙地实现管道操作\n```js\nvar net = require('net');\n\nvar server = net.createServer(function (socket) {\n socket.write('Echo server\\r\\n');\n socket.pipe(socket);\n});\n\nserver.listen(1337, '127.0.0.1');\n```\n\n### 构建UDP服务\n#### 1. UDP和TCP区别\nUDP和TCP都是处在传输层；UDP与TCP最大的不同是UDP不是面向连接的，由于UDP无须连接，资源消耗低，处理快速且灵活，所以常常应用在那种偶尔丢一两个数据包也不会产生重大影响的场景，比如音频、视频等。UDP目前应用很广泛，DNS服务即是基于它实现的。 \n\n\n#### 2. 创建UDP套接字\nUDP套接字一旦创建，既可以作为客户端发送数据，也可以作为服务器端接收数据\n```js\nvar dgram = require('dgram');\nvar socket = dgram.createSocket(\"udp4\");\n```\n\n#### 3. 创建UDP服务端\n若想让UDP套接字接收网络消息，只要调用dgram.bind(port,[address])方法对网卡和端口进行绑定即可\n```js\nvar dgram = require(\"dgram\");\nvar server = dgram.createSocket(\"udp4\");\n\nserver.on(\"message\", function (msg, rinfo) {\n console.log(\"server got: \" + msg + \" from \" +\n   rinfo.address + \":\" + rinfo.port);\n});\n\nserver.on(\"listening\", function () {\n var address = server.address();\n console.log(\"server listening \" +\n     address.address + \":\" + address.port);\n});\n\nserver.bind(41234);\n```\n\n#### 4. 创建UDP客户端\n```js\n// client.js\nvar dgram = require('dgram');\n\nvar message = new Buffer(\"深入浅出Node.js\");\nvar client = dgram.createSocket(\"udp4\");\nclient.send(message, 0, message.length, 41234, \"localhost\", function(err, bytes) {\n client.close();\n});\n```\n\n\n### 构建HTTP服务\n#### 1. 构建http服务\nTCP与UDP都属于网络传输层协议，如果要构造高效的网络应用，就应该从传输层进行着手。但是对于经典的应用场景，则无须从传输层协议入手构造自己的应用，比如HTTP或SMTP等，这些经典的应用层协议对于普通应用而言绰绰有余。\n```js\nvar http = require('http');\nhttp.createServer(function (req, res) {\n res.writeHead(200, {'Content-Type': 'text/plain'});\n res.end('Hello World\\n');\n}).listen(1337, '127.0.0.1');\nconsole.log('Server running at http://127.0.0.1:1337/');\n```\n\n#### 2. http报文\n1. curl -v  127.0.0.1:5001看http原理\n   1. 第一部分内容为经典的TCP的3次握手过程\n   ```js\n    * Trying 127.0.0.1:5001...\n    * Connected to 127.0.0.1 (127.0.0.1) port 5001 (#0)\n   ```\n   2. 第二部分是在完成握手之后，客户端向服务器端发送请求报文\n   ```js\n    > GET / HTTP/1.1\n    > Host: 127.0.0.1:5001\n    > User-Agent: curl/7.77.0\n    > Accept: */*\n    >\n   ```\n   3. 第三部分是服务器端完成处理后，向客户端发送响应内容，包括响应头和响应体\n   ```js\n   < HTTP/1.1 200 OK\n   < X-Powered-By: Hexo\n   < Content-Type: text/html\n   < Date: Sat, 26 Mar 2022 08:48:21 GMT\n   < Connection: keep-alive\n   < Transfer-Encoding: chunked\n   <\n   <!DOCTYPE html>\n   <html lang=\"en\">\n   <head><meta name=\"generator\" content=\"Hexo 3.9.0\">\n   ...\n   ...\n   ...\n   ```\n   4. 结束回话\n   ```js\n   * Connection #0 to host 127.0.0.1 left intact\n   ```\n\n2. 从协议的角度来说，现在的应用，如浏览器，其实是一个HTTP的代理，用户的行为将会通过它转化为HTTP请求报文发送给服务器端，服务器端在处理请求后，发送响应报文给代理，代理在解析报文后，将用户需要的内容呈现在界面上。\n3. 以浏览器打开一张图片地址为例：首先，浏览器构造HTTP报文发向图片服务器端；然后，服务器端判断报文中的要请求的地址，将磁盘中的图片文件以报文的形式发送给浏览器；浏览器接收完图片后，调用渲染引擎将其显示给用户。\n   \n   \n#### 3. http模块\n> 在Node中，HTTP服务继承自TCP服务器（net模块），它能够与多个客户端保持连接，由于其采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用，所以能实现高并发。HTTP服务与TCP服务模型有区别的地方在于，在开启keepalive后，一个TCP会话可以用于多次请求和响应。TCP服务以connection为单位进行服务，HTTP服务以request为单位进行服务。http模块即是将connection到request的过程进行了封装\n\n1. **http请求**\n   对于TCP连接的读操作，http模块将其封装为ServerRequest对象。让我们再次查看前面的请求报文，报文头部将会通过http_parser进行解析\n   ```js\n    headers:\n    { 'user-agent': 'curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5',\n      host: '127.0.0.1:1337',\n      accept: '*/*' },\n   ```\n   \n2. **http响应**\n   1. 我们可以调用setHeader进行多次设置，但只有调用writeHead后，报头才会写入到连接中\n   2. 报文体部分则是调用res.write()和res.end()方法实现，后者与前者的差别在于res.end()会先调用write()发送数据，然后发送信号告知服务器这次响应结束\n   3. 报头是在报文体发送前发送的，一旦开始了数据的发送，writeHead()和setHeader()将不再生效。这由协议的特性决定。\n   \n3. **http事件：**如同TCP服务一样，HTTP服务器也抽象了一些事件，以供应用层使用，同样典型的是，服务器也是一个EventEmitter实例\n   1. connection事件：在开始HTTP请求和响应前，客户端与服务器端需要建立底层的TCP连接，这个连接可能因为开启了keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发一次connection事件\n   2. request事件：建立TCP连接后，http模块底层将在数据流中抽象出HTTP请求和HTTP响应，当请求数据发送到服务器端，在解析出HTTP请求头后，将会触发该事件；在res.end()后，TCP连接可能将用于下一次请求响应\n   3. checkContinue事件：某些客户端在发送较大的数据时，并不会将数据直接发送，而是先发送一个头部带Expect: 100-continue的请求到服务器，服务器将会触发checkContinue事件\n   4. upgrade事件：当客户端要求升级连接的协议时，需要和服务器端协商，客户端会在请求头中带上Upgrade字段，服务器端会在接收到这样的请求时触发该事件。这在后文的WebSocket部分有详细流程的介绍。如果不监听该事件，发起该请求的连接将会关闭。\n\n### 构建websocket服务\n#### 1. node与websocket\nWebSocket实现了客户端与服务器端之间的长连接，而Node事件驱动的方式十分擅长与大量的客户端保持高并发连接\n\n#### 2. websocket与http\n1. 客户端与服务器端只建立一个TCP连接，可以使用更少的连接。\n2. WebSocket服务器端可以推送数据到客户端，这远比HTTP请求响应模式更灵活、更高效。\n3. 有更轻量级的协议头，减少数据传送量 \n4. 相比HTTP, WebSocket更接近于传输层协议，它并没有在HTTP的基础上模拟服务器端的推送，而是在TCP上定义独立的协议。让人迷惑的部分在于WebSocket的握手部分是由HTTP完成的，使人觉得它可能是基于HTTP实现的。\n  \n#### 3. websocket握手阶段\n1. 和普通的http请求报文多这2个协议头， 表示升级到websocket协议\n```js\n...\n...\nUpgrade: websocket\nConnection: Upgrade\n```\n2. 服务端实现websocket\n```js\nvar server = http.createServer(function (req, res) {\nres.writeHead(200, {'Content-Type': 'text/plain'});\nres.end('Hello World\\n');\n});\nserver.listen(12010);\n\n// 在收到upgrade请求后，告之客户端允许切换协议\nserver.on('upgrade', function (req, socket, upgradeHead) {\nvar head = new Buffer(upgradeHead.length);\nupgradeHead.copy(head);\nvar key = req.headers['sec-websocket-key'];\nvar shasum = crypto.createHash('sha1');\nkey = shasum.update(key + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\").digest('base64');\nvar headers = [\n  'HTTP/1.1101 Switching Protocols',\n  'Upgrade: websocket',\n  'Connection: Upgrade',\n  'Sec-WebSocket-Accept: ' + key,\n  'Sec-WebSocket-Protocol: ' + protocol\n];\n// 让数据立即发送\nsocket.setNoDelay(true);\nsocket.write(headers.concat('', '').join('\\r\\n'));\n// 建立服务器端WebSocket连接\nvar websocket = new WebSocket();\nwebsocket.setSocket(socket);\n});\n```\n3. 客户端代码\n```js\nvar WebSocket = function (url) {\n // 伪代码，解析ws://127.0.0.1:12010/updates，用于请求\n this.options = parseUrl(url);\n this.connect();\n};\nWebSocket.prototype.onopen = function () {\n // TODO\n};\n\nWebSocket.prototype.setSocket = function (socket) {\n this.socket = socket;\n};\n\nWebSocket.prototype.connect = function () {\n var that = this;\n var key = new Buffer(this.options.protocolVersion + '-' + Date.now()).toString('base64');\n var shasum = crypto.createHash('sha1');\nvar expected = shasum.update(key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11').digest('base64');\n\nvar options = {\nport: this.options.port, //12010\nhost: this.options.hostname, // 127.0.0.1\nheaders: {\n 'Connection': 'Upgrade',\n 'Upgrade': 'websocket',\n 'Sec-WebSocket-Version': this.options.protocolVersion,\n 'Sec-WebSocket-Key': key\n}\n};\nvar req = http.request(options);\nreq.end();\n\nreq.on('upgrade', function(res, socket, upgradeHead) {\n// 连接成功\nthat.setSocket(socket);\n// 触发open事件\nthat.onopen();\n});\n};\n```\n\n#### 4. websocket传输数据阶段\nwebsocket协议升级的过程\n<img src=\"/img/node15.jpeg\" style=\"max-width:95%\" />\n\n#### 5. 总结\n>尽管Node没有内置WebSocket的库，但是社区的ws模块封装了WebSocket的底层实现。socket.io即是在它的基础上构建实现\n\n1. Node基于事件驱动的方式使得它应对WebSocket这类长连接的应用场景可以轻松地处理大量并发请求\n2. 基于JavaScript，以封装良好的WebSocket实现，API与客户端可以高度相似。\n\n## 进程\n### 1. 服务模型变迁\n1. 石器时代：**同步**\n   它的服务模式是一次只为一个请求服务，所有请求都得按次序等待服务。\n2. 青铜时代：**复制进程**\n   为了解决同步架构的并发问题，一个简单的改进是通过进程的复制同时服务更多的请求和用户。这样每个连接都需要一个进程来服务，即100个连接需要启动100个进程来进行服务，这是非常昂贵的代价。\n3. 白银时代：**多线程**\n   为了解决进程复制中的浪费问题，多线程被引入服务模型，让一个线程服务一个请求。线程相对进程的开销要小许多，并且线程之间可以共享数据，内存浪费的问题可以得到解决，并且利用线程池可以减少创建和销毁线程的开销。\n4. 黄金时代：**事件驱动**\n   **node多进程目的：CPU的利用率和进程的健壮性**\n   所有处理都在单线程上进行，影响事件驱动服务模型性能的点在于CPU的计算能力，它的上限决定这类服务模型的性能上限，但它不受多进程或多线程模式中资源上限的影响，可伸缩性远比前两者高。如果解决掉多核CPU的利用问题，带来的性能上提升是可观的\n\n\n### 2. 多进程架构\n1. 介绍\n面对单进程单线程对多核使用不足的问题，前人的经验是启动多进程即可。理想状态下每个进程各自利用一个CPU，以此实现多核CPU的利用。所幸，Node提供了child_process模块，并且也提供了child_process.fork()函数供我们实现进程的复制。\n```js\n// worker.js\nvar http = require('http');\nhttp.createServer(function (req, res) {\n res.writeHead(200, {'Content-Type': 'text/plain'});\n res.end('Hello World\\n');\n}).listen(Math.round((1 + Math.random()) * 1000), '127.0.0.1');\n\n//master.js\nvar fork = require('child_process').fork;\nvar cpus = require('os').cpus();\nfor (var i = 0; i < cpus.length; i++) {\n fork('./worker.js');\n}\n```\n\n2. 主从模式（master-worker）\n主进程和工作进程。这是典型的分布式架构中用于并行处理业务的模式，具备较好的可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它是趋向于稳定的。工作进程负责具体的业务处理.\n<img src=\"/img/node16.jpeg\" style=\"max-width:95%\" />\n\n3. 创建子进程\n> 1. spawn()：启动一个子进程来执行命令。\n> 2. exec()：启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况。\n> 3. execFile()：启动一个子进程来执行可执行文件。\n> 4. fork()：与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的JavaScript文件模块即可。\n\n<img src=\"/img/node17.jpeg\" style=\"max-width:95%\" />\n```js\nvar cp = require('child_process');\ncp.spawn('node', ['worker.js']);\n\ncp.exec('node worker.js', function (err, stdout, stderr) {\n // some code\n});\n\n// 如果是JavaScript文件通过execFile()运行，\n// 它的首行内容必须添加如下代码: #! /usr/bin/env node\ncp.execFile('worker.js', function (err, stdout, stderr) {\n // some code\n});\n\ncp.fork('./worker.js');\n```\n4. 进程之间通信\n通过fork()或者其他API，创建子进程之后，为了实现父子进程之间的通信，父进程与子进程之间将会创建IPC通道。通过IPC通道，父子进程之间才能通过message和send()传递消息。\n```js\n// parent.js\nvar cp = require('child_process');\nvar n = cp.fork(__dirname + '/sub.js');\nn.on('message', function (m) {\n console.log('PARENT got message:', m);\n});\nn.send({hello: 'world'});\n\n// sub.js\nprocess.on('message', function (m) {\n console.log('CHILD got message:', m);\n});\nprocess.send({foo: 'bar'});\n```\n\n5. 进程间通信原理\nIPC的全称是Inter-Process Communication，即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。实现进程间通信的技术有很多，如命名管道、匿名管道、socket、信号量、共享内存、消息队列、DomainSocket等。Node中实现IPC通道的是管道（pipe）技术。\n表现在应用层上的进程间通信只有简单的message事件和send()方法，接口十分简洁和消息化。图为IPC创建和实现的示意图。\n<img src=\"/img/node18.jpeg\" style=\"max-width:95%\" />\n\n\n父进程在实际创建子进程之前，会创建IPC通道并监听它，然后才真正创建出子进程，并通过环境变量（NODE_CHANNEL_FD）告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接。\n<img src=\"/img/node19.jpeg\" style=\"max-width:95%\" />\n\n> 只有启动的子进程是Node进程时，子进程才会根据环境变量去连接IPC通道，对于其他类型的子进程则无法实现进程间通信，除非其他进程也按约定去连接这个已经创建好的IPC通道\n\n\n6. 句柄传递\n  1. 端口被占用早期解决方案\n    在监听的过程中都抛出了EADDRINUSE异常，这是端口被占用的情况，新的进程不能继续监听该端口了。这个问题破坏了我们将多个进程监听同一个端口的想法。要解决这个问题，通常的做法是让每个进程监听不同的端口，其中主进程监听主端口（如80），主进程对外接收所有的网络请求，再将这些请求分别代理到不同的端口的进程上。\n    <img src=\"/img/node20.jpeg\" style=\"max-width:95%\" />\n\n  2. 只用一个端口的解决方案(多个子进程可以同时监听相同端口)\n    **句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。**比如句柄可以用来标识一个服务器端socket对象、一个客户端socket对象、一个UDP套接字、一个管道等。发送句柄意味着什么？在前一个问题中，我们可以去掉代理这种方案，使主进程接收到socket请求后，将这个socket直接发送给工作进程，而不是重新与工作进程之间建立新的socket连接来转发数据。\n    ```js\n        // parent.js\n        var cp = require('child_process');\n        var child1 = cp.fork('child.js');\n        var child2 = cp.fork('child.js');\n\n        // Open up the server object and send the handle\n        var server = require('net').createServer();\n       \n       // server.on('connection', function (socket) {\n       //   socket.end('handled by parent\\n');\n       // });        \n        \n        server.listen(1337, function () {\n          child1.send('server', server);\n          child2.send('server', server);\n          // 对于主进程而言，我们甚至想要它更轻量一点，\n          // 那么是否将服务器句柄发送给子进程之后，就可以关掉服务器的监听，让子进程来处理请求呢\n          server.close();\n        });\n        \n        // child.js\n        var http = require('http');\n        var server = http.createServer(function (req, res) {\n          res.writeHead(200, {'Content-Type': 'text/plain'});\n          res.end('handled by child, pid is ' + process.pid + '\\n');\n        });\n\n        process.on('message', function (m, tcp) {\n          if (m === 'server') {\n            tcp.on('connection', function (socket) {\n              server.emit('connection', socket);\n            });\n          }\n        });        \n    ```\n    <img src=\"/img/node21.jpeg\" style=\"max-width:95%\" />\n    <img src=\"/img/node22.jpeg\" style=\"max-width:95%\" />\n  \n  3. 句柄传送和还原\n     发送到IPC管道中的实际上是我们要发送的句柄文件描述符，文件描述符实际上是一个整数值。这个message对象在写入到IPC管道时也会通过JSON.stringify()进行序列化。所以最终发送到IPC通道中的信息都是字符串，send()方法能发送消息和句柄并不意味着它能发送任意对象。\n     连接了IPC通道的子进程可以读取到父进程发来的消息，将字符串通过JSON.parse()解析还原为对象后，才触发message事件将消息体传递给应用层使用。\n   <img src=\"/img/node23.jpeg\" style=\"max-width:95%\" />\n\n  4. 端口共同监听\n     多个进程可以监听到相同的端口而不引起EADDRINUSE异常。其答案也很简单，我们独立启动的进程中，TCP服务器端socket套接字的文件描述符并不相同，导致监听到相同的端口时会抛出异常。\n     Node底层对每个端口监听都设置了SO_REUSEADDR选项，这个选项的涵义是不同进程可以就相同的网卡和端口进行监听，这个服务器端套接字可以被不同的进程复用。\n     ```js\n     setsockopt(tcp->io_watcher.fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on))\n     ```\n     由于独立启动的进程互相之间并不知道文件描述符，所以监听相同端口时就会失败。但对于send()发送的句柄还原出来的服务而言，它们的文件描述符是相同的，所以监听相同端口不会引起异常。\n\n### 3. 集群稳定\n>搭建好了集群，充分利用了多核CPU资源，似乎就可以迎接客户端大量的请求了。 但是会出现以后几个需要主要的：**多个工作进程的存活状态管理、工作进程的平滑重启、配置或者静态数据的动态重新载入**\n\n#### a、进程事件\n1. error：当子进程无法被复制创建、无法被杀死、无法发送消息时会触发该事件\n2. exit：子进程退出时触发该事件，子进程如果是正常退出，这个事件的第一个参数为退出码，否则为null。如果进程是通过kill()方法被杀死的，会得到第二个参数，它表示杀死进程时的信号。\n3. close：在子进程的标准输入输出流中止时触发该事件，参数与exit相同\n4. disconnect：在父进程或子进程中调用disconnect()方法时触发该事件，在调用该方法时将关闭监听IPC通道。\n```js\n/*\n 如SIGTERM是软件终止信号，进程收到该信号时应当退出\n*/\nprocess.on('SIGTERM', function() {\n console.log('Got a SIGTERM, exiting...');\n process.exit(1);\n});\n\nconsole.log('server running with PID:', process.pid);\nprocess.kill(process.pid, 'SIGTERM');\n```\n\n#### b、自动重启\n1. 主进程加入子进程管理机制\n>我们能够通过监听子进程的exit事件来获知其退出的信息，接着前文的多进程架构，我们在主进程上要加入一些子进程管理的机制，比如重新启动一个工作进程来继续服务。\n\n<img src=\"/img/node24.jpeg\" alt=\"主进程加入子进程管理机制\" style=\"max-width:95%\" />\n\n```js\n// master.js\nvar fork = require('child_process').fork;\nvar cpus = require('os').cpus();\n\nvar server = require('net').createServer();\nserver.listen(1337);\n\nvar workers = {};\nvar createWorker = function () {\n var worker = fork(__dirname + '/worker.js');\n // 退出时重新启动新的进程\n worker.on('exit', function () {\n   console.log('Worker ' + worker.pid + ' exited.');\n   delete workers[worker.pid];\n   createWorker();\n });\n // 句柄转发\n worker.send('server', server);\n workers[worker.pid] = worker;\n console.log('Create worker. pid: ' + worker.pid);\n};\n\nfor (var i = 0; i < cpus.length; i++) {\n createWorker();\n}\n\n// 进程自己退出时，让所有工作进程退出\nprocess.on('exit', function () {\n for (var pid in workers) {\n   workers[pid].kill();\n }\n});\n\n// worker.js\nvar http = require('http');\nvar server = http.createServer(function (req, res) {\n res.writeHead(200, {'Content-Type': 'text/plain'});\n res.end('handled by child, pid is ' + process.pid + '\\n');\n});\n\nvar worker;\nprocess.on('message', function (m, tcp) {\n if (m === 'server') {\n   worker = tcp;\n   worker.on('connection', function (socket) {\n       server.emit('connection', socket);\n     });\n   }\n });\n\n process.on('uncaughtException', function () {\n   // 停止接收新的连接\n   worker.close(function () {\n     // 所有已有连接断开后，退出进程\n     process.exit(1);\n   });\n });\n```\n\n1. 自杀信号(平滑重启)\n>在极端的情况下，所有工作进程都停止接收新的连接，全处在等待退出的状态。但在等到进程完全退出才重启的过程中，所有新来的请求可能存在没有工作进程为新用户服务的情景，这会丢掉大部分请求。\n为此需要改进这个过程，不能等到工作进程退出后才重启新的工作进程。当然也不能暴力退出进程，因为这样会导致已连接的用户直接断开。于是我们在退出的流程中增加一个自杀（suicide）信号。工作进程在得知要退出时，向主进程发送一个自杀信号，然后才停止接收新的连接，当所有连接断开后才退出。主进程在接收到自杀信号后，立即创建新的工作进程服务。\n\n<img src=\"/img/node25.jpeg\" alt=\"进程的自杀和重启\" style=\"max-width:95%\" />\n\n```js\n// master.js\n var createWorker = function () {\n   var worker = fork(__dirname + '/worker.js');\n   // 启动新的进程\n   worker.on('message', function (message) {\n     if (message.act === 'suicide') {\n       createWorker();\n     }\n   });\n   worker.on('exit', function () {\n     console.log('Worker ' + worker.pid + ' exited.');\n   delete workers[worker.pid];\n });\n worker.send('server', server);\n workers[worker.pid] = worker;\n console.log('Create worker. pid: ' + worker.pid);\n};\n\n\n// worker.js\nvar server = http.createServer(function (req, res) {\n res.writeHead(200, {'Content-Type': 'text/plain'});\n res.end('handled by child, pid is ' + process.pid + '\\n');\n // 为了模拟未捕获的异常，我们将工作进程的处理代码改为抛出异常\n throw new Error('throw exception');\n});\n\nprocess.on('uncaughtException', function (err) {\n process.send({act: 'suicide'});\n // 停止接收新的连接\n worker.close(function () {\n   // 所有已有连接断开后，退出进程\n   process.exit(1);\n });\n});\n```\n**优点：与前一种方案相比，创建新工作进程在前，退出异常进程在后。至此我们完成了进程的平滑重启，一旦有异常出现，主进程会创建新的工作进程来为用户服务，旧的进程一旦处理完已有连接就自动断开。整个过程使得我们的应用的稳定性和健壮性大大提高。**\n\n1. 限量重启\n>通过自杀信号告知主进程可以使得新连接总是有进程服务，但是依然还是有极端的情况。工作进程不能无限制地被重启，如果启动的过程中就发生了错误，或者启动后接到连接就收到错误，会导致工作进程被频繁重启。\n\n\n#### c、负载均衡\n1. 在多进程之间监听相同的端口，使得用户请求能够分散到多个进程上进行处理，这带来的好处是可以将CPU资源都调用起来；\n2. Node默认提供的机制是采用操作系统的抢占式策略。所谓的抢占式就是在一堆工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务；\n3. 这种抢占式策略对大家是公平的，各个进程可以根据自己的繁忙度来进行抢占。但是对于Node而言，需要分清的是它的繁忙是由CPU、I/O两个部分构成的，影响抢占的是CPU的繁忙度。对不同的业务，可能存在I/O繁忙，而CPU较为空闲的情况，这可能造成某个进程能够抢到较多请求，形成负载不均衡的情况；\n4. 为此Node在v0.11中提供了一种新的策略使得负载均衡更合理，**这种新的策略叫Round-Robin，又叫轮叫调度。**轮叫调度的工作方式是由主进程接受连接，将其依次分发给工作进程。分发的策略是在N个工作进程中，每次选择第i = (i + 1) mod n个进程来发送连接。\n\n#### d、状态共享\n我们知道在Node进程中不宜存放太多数据，因为它会加重垃圾回收的负担，进而影响性能。同时，Node也不允许在多个进程之间共享数据。但在实际的业务中，往往需要共享一些数据，譬如配置数据，这在多个进程中应当是一致的。为此，在不允许共享数据的情况下，我们需要一种方案和机制来实现数据在多个进程之间的共享。\n\n1. 第三方存储数据\n>解决数据共享最直接、简单的方式就是通过第三方来进行数据存储，比如将数据存放到数据库、磁盘文件、缓存服务（如Redis）中，所有工作进程启动时将其读取进内存中。但这种方式存在的问题是如果数据发生改变，还需要一种机制通知到各个子进程，使得它们的内部状态也得到更新。\n\n2. 主动通知\n>一种改进的方式是当数据发生更新时，主动通知子进程。当然，即使是主动通知，也需要一种机制来及时获取数据的改变。这个过程仍然不能脱离轮询，但我们可以减少轮询的进程数量，我们将这种用来发送通知和查询状态是否更改的进程叫做通知进程。为了不混合业务逻辑，可以将这个进程设计为只进行轮询和通知，不处理任何业务逻辑。\n这种推送机制如果按进程间信号传递，在跨多台服务器时会无效，是故可以考虑采用TCP或UDP的方案。进程在启动时从通知服务处除了读取第一次数据外，还将进程信息注册到通知服务处。一旦通过轮询发现有数据更新后，根据注册信息，将更新后的数据发送给工作进程\n\n<img src=\"/img/node26.jpeg\" alt=\"主动通知进程\" style=\"max-width:95%\" />\n\n\n### 4. cluster模块\n#### a. 使用方式\n```js\n// 官方推荐\nvar cluster = require('cluster');\nvar http = require('http');\nvar numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n // Fork workers\n for (var i = 0; i < numCPUs; i++) {\n   cluster.fork();\n }\n\n cluster.on('exit', function(worker, code, signal) {\n   console.log('worker ' + worker.process.pid + ' died');\n });\n} else {\n // Workers can share any TCP connection\n // In this case its a HTTP server\n http.createServer(function(req, res) {\n   res.writeHead(200);\n   res.end(\"hello world\\n\");\n }).listen(8000);\n}\n\n/*\n 自己优化的 cluster.js\n*/\nvar cluster = require('cluster');\n\n// 通过cluster.setupMaster()创建子进程而不是使用cluster.fork()，程序结构不再凌乱，逻辑分明，代码的可读性和可维护性较好。\ncluster.setupMaster({\n exec: \"worker.js\"\n});\n\nvar cpus = require('os').cpus();\nfor (var i = 0; i < cpus.length; i++) {\n cluster.fork();\n}\n```\n\n在进程中判断是主进程还是工作进程，主要取决于环境变量中是否有NODE_UNIQUE_ID\n```js\ncluster.isWorker = ('NODE_UNIQUE_ID' in process.env);\ncluster.isMaster = (cluster.isWorker === false);\n```\n\n#### b. cluster工作原理\ncluster模块就是child_process和net模块的组合应用。cluster启动时，它会在内部启动TCP服务器，在cluster.fork()子进程时，将这个TCP服务器端socket的文件描述符发送给工作进程。如果进程是通过cluster.fork()复制出来的，那么它的环境变量里就存在NODE_UNIQUE_ID，如果工作进程中存在listen()侦听网络端口的调用，它将拿到该文件描述符，通过SO_REUSEADDR端口重用，从而实现多个子进程共享端口。对于普通方式启动的进程，则不存在文件描述符传递共享等事情。\n\n#### c. cluster事件\n1. fork：复制一个工作进程后触发该事件\n2. online：复制好一个工作进程后，工作进程主动发送一条online消息给主进程，主进程收到消息后，触发该事件。\n3. listening：工作进程中调用listen()（共享了服务器端Socket）后，发送一条listening消息给主进程，主进程收到消息后，触发该事件\n4. disconnect：主进程和工作进程之间IPC通道断开后会触发该事件。\n5. exit：有工作进程退出时触发该事件。\n6. setup:cluster.setupMaster()执行后触发该事件\n\n\n\n## 构建web应用\n### 1、基础功能\n1. 请求方法\n```js\nfunction (req, res) {\n switch (req.method) {\n    case 'POST':\n      update(req, res);\n      break;\n    case 'DELETE':\n      remove(req, res);\n      break;\n    case 'PUT':\n      create(req, res);\n      break;\n    case 'GET':\n    default:\n      get(req, res);\n }\n}\n```\n2. 路径解析\n```js\nfunction (req, res) {\n var pathname = url.parse(req.url).pathname;\n var paths = pathname.split('/');\n var controller = paths[1] || 'index';\n var action = paths[2] || 'index';\n var args = paths.slice(3);\n if (handles[controller] && handles[controller][action]) {\n   handles[controller][action].apply(null, [req, res].concat(args));\n } else {\n   res.writeHead(500);\n   res.end('找不到响应控制器');\n }\n}\n\nhandles.index = {};\nhandles.index.index = function (req, res, foo, bar) {\n res.writeHead(200);\n res.end(foo);\n};\n```\n   **http://user:pass@host.com:8080/p/a/t/h?query=string#hash    hash部分会被丢弃，不会存在于报文的任何地方**\n  \n3. 查询字符串\n```js\nfunction (req, res) {\n req.query = url.parse(req.url, true).query;\n hande(req, res);\n}\n// 如果查询字符串中的键出现多次，那么它的值会是一个数组\n// 业务的判断一定要检查值是数组还是字符串，否则可能出现TypeError异常的情况\n// foo=bar&foo=baz\n// var query = url.parse(req.url, true).query;\n// {\n//   foo: ['bar', 'baz']\n// }\n```\n4. cookie\n```js\nvar parseCookie = function (cookie) {\n var cookies = {};\n if (! cookie) {\n   return cookies;\n }\n var list = cookie.split('; ');\n for (var i = 0; i < list.length; i++) {\n   var pair = list[i].split('=');\n   cookies[pair[0].trim()] = pair[1];\n }\n return cookies;\n};\n\nvar serialize = function (name, val, opt) {\n var pairs = [name + '=' + encode(val)];\n opt = opt || {};\n\n if (opt.maxAge) pairs.push('Max-Age=' + opt.maxAge);\n if (opt.domain) pairs.push('Domain=' + opt.domain);\n if (opt.path) pairs.push('Path=' + opt.path);\n if (opt.expires) pairs.push('Expires=' + opt.expires.toUTCString());\n if (opt.httpOnly) pairs.push('HttpOnly');\n if (opt.secure) pairs.push('Secure');\n\n return pairs.join('; ');\n};\n\nvar handle = function (req, res) {\n res.writeHead(200);\n if (! req.cookies.isVisit) {\n   res.setHeader('Set-Cookie', serialize('isVisit', '1'));\n   res.end('欢迎第一次来到动物园');\n } else {\n   // TODO\n }\n};\n\nfunction (req, res) {\n req.cookies = parseCookie(req.headers.cookie);\n hande(req, res);\n};\n```\n5. session\n6. 缓存\n```js\n// 文件的时间戳改动但内容并不一定改动。\n// 时间戳只能精确到秒级别，更新频繁的内容将无法生效\nvar getHash = function (str) {\n var shasum = crypto.createHash('sha1');\n return shasum.update(str).digest('base64');\n};\n\nvar handle = function (req, res) {\n fs.readFile(filename, function(err, file) {\n   var hash = getHash(file);\n   var noneMatch = req.headers['if-none-match'];\n   if (hash === noneMatch) {\n     res.writeHead(304, \"Not Modified\");\n     res.end();\n   } else {\n     res.setHeader(\"ETag\", hash);\n     res.writeHead(200, \"Ok\");\n     res.end(file);\n   }\n });\n};\n```\n尽管条件请求可以在文件内容没有修改的情况下节省带宽，但是它依然会发起一个HTTP请求，使得客户端依然会花一定时间来等待响应。可见最好的方案就是连条件请求都不用发起\n```js\nvar handle = function (req, res) {\n fs.readFile(filename, function(err, file) {\n   var expires = new Date();\n   expires.setTime(expires.getTime() + 10 * 365 * 24 * 60 * 60 * 1000);\n   res.setHeader(\"Expires\", expires.toUTCString());\n   res.writeHead(200, \"Ok\");\n   res.end(file);\n });\n};\n\n//但是Expires的缺陷在于浏览器与服务器之间的时间可能不一致，\n// 这可能会带来一些问题，比如文件提前过期，或者到期后并没有被删除\nvar handle = function (req, res) {\n fs.readFile(filename, function(err, file) {\n   res.setHeader(\"Cache-Control\", \"max-age=\" + 10 * 365 * 24 * 60 * 60 * 1000);\n   res.writeHead(200, \"Ok\");\n   res.end(file);\n });\n};\n```\n\n### 2、数据上传\n通过报头的Transfer-Encoding或Content-Length即可判断请求中是否带有内容。\n```js\nvar hasBody = function(req) {\n return ('transfer-encoding' in req.headers) || ('content-length' in req.headers);\n};\n\nfunction (req, res) {\n if (hasBody(req)) {\n   var buffers = [];\n   req.on('data', function (chunk) {\n     buffers.push(chunk);\n   });\n   req.on('end', function () {\n     req.rawBody = Buffer.concat(buffers).toString();\n     handle(req, res);\n   });\n } else {\n   handle(req, res);\n }\n}\n```\n\n#### 表单提交\n```js\n// 表单格式\nvar handle = function (req, res) {\n if (req.headers['content-type'] === 'application/x-www-form-urlencoded') {\n   req.body = querystring.parse(req.rawBody);\n }\n todo(req, res);\n};\n\n// json格式\nvar handle = function (req, res) {\n if (mime(req) === 'application/json') {\n   try {\n     req.body = JSON.parse(req.rawBody);\n   } catch (e) {\n     // 异常内容，响应Bad request\n     res.writeHead(400);\n     res.end('Invalid JSON');\n     return;\n   }\n }\n todo(req, res);\n};\n```\n#### 文件提交\n值得注意的一点是，由于是文件上传，那么像普通表单、JSON或XML那样先接收内容再解析的方式将变得不可接受。接收大小未知的数据量时，我们需要十分谨慎。\n```js\n/**\n   文件提交的报文头\n   Content-Type: multipart/form-data; boundary=AaB03x\n   Content-Length: 18231\n*/\n// 处理文件格式\nvar formidable = require('formidable');\nfunction (req, res) {\n if (hasBody(req)) {\n   if (mime(req) === 'multipart/form-data') {\n     var form = new formidable.IncomingForm();\n     form.parse(req, function(err, fields, files) {\n        req.body = fields;\n        req.files = files;\n        handle(req, res);\n     });\n   }\n } else {\n   handle(req, res);\n }\n}\n\n// 处理各种格式\nfunction (req, res) {\n if (hasBody(req)) {\n   var done = function () {\n     handle(req, res);\n   };\n   if (mime(req) === 'application/json') {\n     parseJSON(req, done);\n   } else if (mime(req) === 'application/xml') {\n     parseXML(req, done);\n   } else if (mime(req) === 'multipart/form-data') {\n     parseMultipart(req, done);\n   }\n } else {\n   handle(req, res);\n }\n}\n```\n#### 数据上传的安全\n1. 内存限制\n❑ 限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码。\n❑ 通过流式解析，将数据流导向到磁盘中，Node只保留文件路径等小数据。\n```js\nvar bytes = 1024;\nfunction (req, res) {\n var received = 0,\n var len = req.headers['content-length'] ? parseInt(req.headers['content-length'], 10) : null;\n\n // 如果内容超过长度限制，返回请求实体过长的状态码\n if (len && len > bytes) {\n   res.writeHead(413);\n   res.end();\n   return;\n }\n // limit\n req.on('data', function (chunk) {\n   received += chunk.length;\n   if (received > bytes) {\n     // 停止接收数据，触发end()\n     req.destroy();\n   }\n });\n\n handle(req, res);\n};\n```\n\n2. CSRF（跨站请求伪造）\n解决CSRF攻击的方案有添加随机值的方式。 为每个请求的用户，在Session中赋予一个随机值；在做页面渲染的过程中，将这个_csrf值告之前端；所以我们只需要在接收端做一次校验就能轻易地识别出该请求是否为伪造的\n\n### 3、路由解析\n\n### 4、中间件\n>对于Web应用而言，我们希望不用接触到这么多细节性的处理，为此我们引入中间件（middleware）来简化和隔离这些基础设施与业务逻辑之间的细节，让开发者能够关注在业务的开发上，以达到提升开发效率的目的。\n\n#### 实现中间件\n中间件的上下文也就是请求对象和响应对象：req和res。有一点区别的是，由于Node异步的原因，我们需要提供一种机制，在当前中间件处理完成后，通知下一个中间件执行。\n```js\nvar match = function (pathname, routes) {\n var stacks = [];\n for (var i = 0; i < routes.length; i++) {\n   var route = routes[i];\n   // 正则匹配\n   var reg = route.path.regexp;\n   var matched = reg.exec(pathname);\n   if (matched) {\n     // 抽取具体值\n     // 代码省略\n     // 将中间件都保存起来\n     stacks = stacks.concat(route.stack);\n   }\n }\n return stacks;\n};\n\nvar handle = function (req, res, stack) {\n var next = function () {\n   // 从stack数组中取出中间件并执行\n   var middleware = stack.shift();\n   if (middleware) {\n     // 传入next()函数自身，使中间件能够执行结束后递归\n     middleware(req, res, next);\n   }\n };\n // 启动执行\n next();\n};\n\napp.use = function (path) {\n var handle;\n if (typeof path === 'string') {\n   handle = {\n     // 第一个参数作为路径\n     path: pathRegexp(path),\n     // 其他的都是处理单元\n     stack: Array.prototype.slice.call(arguments, 1)\n   };\n } else {\n   handle = {\n     // 第一个参数作为路径\n     path: pathRegexp('/'),\n     // 其他的都是处理单元\n     stack: Array.prototype.slice.call(arguments, 0)\n   };\n }\n routes.all.push(handle);\n };\n\nfunction (req, res) {\n var pathname = url.parse(req.url).pathname;\n // 将请求方法变为小写\n var method = req.method.toLowerCase();\n // 获取all()方法里的中间件\n var stacks = match(pathname, routes.all);\n if (routes.hasOwnPerperty(method)) {\n   // 根据请求方法分发，获取相关的中间件\n   stacks.concat(match(pathname, routes[method]));\n }\n\n if (stacks.length) {\n   handle(req, res, stacks);\n } else {\n   // 处理404请求\n   handle404(req, res);\n }\n}\n\n\n// querystring解析中间件\nvar querystring = function (req, res, next) {\n req.query = url.parse(req.url, true).query;\n next();\n};\n// cookie解析中间件\nvar cookie = function (req, res, next) {\n var cookie = req.headers.cookie;\n var cookies = {};\n if (cookie) {\n   var list = cookie.split('; ');\n   for (var i = 0; i < list.length; i++) {\n     var pair = list[i].split('=');\n     cookies[pair[0].trim()] = pair[1];\n   }\n }\n\n req.cookies = cookies;\n next();\n};\n\n// 使用中间件\napp.use(querystring);\napp.use(cookie);\napp.use(session);\napp.get('/user/:username', getUser);\napp.put('/user/:username', authorize, updateUser);\n```\n\n#### 异常处理\n如果某个中间件出现错误该怎么办？我们需要为自己构建的Web应用的稳定性和健壮性负责。于是我们为next()方法添加err参数，并捕获中间件直接抛出的同步异常\n```js\nvar handle500 = function (err, req, res, stack) {\n // 选取异常处理中间件\n stack = stack.filter(function (middleware) {\n   return middleware.length === 4;\n });\n\n var next = function () {\n   // 从stack数组中取出中间件并执行\n   var middleware = stack.shift();\n   if (middleware) {\n     // 传递异常对象\n     middleware(err, req, res, next);\n   }\n };\n // 启动执行\n next();\n};\n\nvar handle = function (req, res, stack) {\n var next = function (err) {\n   if (err) {\n     return handle500(err, req, res, stack);\n   }\n   // 从stack数组中取出中间件并执行\n   var middleware = stack.shift();\n   if (middleware) {\n     // 传入next()函数自身，使中间件能够执行结束后递归\n     try {\n     middleware(req, res, next);\n     } catch (ex) {\n     next(err);\n     }\n   }\n };\n // 启动执行\n next();\n};\n\nvar session = function (req, res, next) {\n var id = req.cookies.sessionid;\n store.get(id, function (err, session) {\n   if (err) {\n     // 将异常通过next()传递\n     return next(err);\n   }\n   req.session = session;\n   next();\n });\n};\n```\n\n\n\n#### 中间件与性能\n1. 编写高效的中间件: 缓存需要重复计算的结果、避免不必要的计算。比如HTTP报文体的解析，对于GET方法完全不需要。\n2. 合理利用路由，避免不必要的中间件执行: 例如静态文件中间件 app.use('/public',staticFile);\n\n\n### 5、页面渲染\n#### 内容响应\n客户端在接收到这个报文后，正确的处理过程是通过gzip来解码报文体中的内容，用长度校验报文体内容是否正确，然后再以字符集UTF-8将解码后的脚本插入到文档节点中\n```js\nContent-Encoding: gzip\nContent-Length: 21170\nContent-Type: text/javascript; charset=utf-8\n```\n1. mime\n浏览器正是通过不同的Content-Type的值来决定采用不同的渲染方式，这个值我们简称为MIME值。\n2. 附件下载\nContent-Disposition字段影响的行为是客户端会根据它的值判断是应该将报文数据当做即时浏览的内容，还是可下载的附件。当内容只需即时查看时，它的值为inline，当数据可以存为附件时，它的值为attachment。另外，Content-Disposition字段还能通过参数指定保存时应该使用的文件名。示例如下\n```js\nContent-Disposition: attachment; filename=\"filename.ext\"\n```\n附件下载示例：\n```js\nres.sendfile = function (filepath) {\n fs.stat(filepath, function(err, stat) {\n   var stream = fs.createReadStream(filepath);\n   // 设置内容\n   res.setHeader('Content-Type', mime.lookup(filepath));\n   // 设置长度\n   res.setHeader('Content-Length', stat.size);\n   // 设置为附件\n   res.setHeader('Content-Disposition' 'attachment; filename=\"' + path.basename(filepath) + '\"');\n   res.writeHead(200);\n   stream.pipe(res);\n });\n};\n```\n3. 响应json\n```js\nres.json = function (json) {\n res.setHeader('Content-Type', 'application/json');\n res.writeHead(200);\n res.end(JSON.stringify(json));\n};\n```\n4. 重定向\n```js\nres.redirect = function (url) {\n res.setHeader('Location', url);\n res.writeHead(302);\n res.end('Redirect to ' + url);\n};\n```\n#### 视图渲染\n```js\nres.render = function (view, data) {\n res.setHeader('Content-Type', 'text/html');\n res.writeHead(200);\n // 实际渲染\n var html = render(view, data);\n res.end(html);\n};\n```\n\n#### 模板\n这个模板引擎会将Hello <%= username%>转换为\"Hello \" + obj.username。该过程进行以下几个步骤。\n❑ 语法分解。提取出普通字符串和表达式，这个过程通常用正则表达式匹配出来，<% =%>的正则表达式为/<%=([\\s\\S]+?)%>/g。\n❑ 处理表达式。将标签表达式转换成普通的语言表达式。\n❑ 生成待执行的语句。\n❑ 与数据一起执行，生成最终字符串。\n```js\nvar render = function (str, data) {\n // 模板技术呢，就是替换特殊标签的技术\n var tpl = str.replace(/<%=([\\s\\S]+? )%>/g, function(match, code) {\n   return \"' + obj.\" + code + \"+ '\";\n });\n\n tpl = \"var tpl = '\" + tpl + \"'\\nreturn tpl; \";\n var complied = new Function('obj', tpl);\n return complied(data);\n};\n```\n**模板编译**\n为了能够最终与数据一起执行生成字符串，我们需要将原始的模板字符串转换成一个函数对象。比如Hello<%=username%>这句模板字符串，最终会生成如下的代码：\n```js\nfunction (obj) {\n var tpl = 'Hello ' + obj.username + '.';\n return tpl;\n}\n```\n这个过程称为模板编译，生成的中间函数只与模板字符串相关，与具体的数据无关。如果每次都生成这个中间函数，就会浪费CPU。为了提升模板渲染的性能速度，我们通常会采用模板预编译的方式。\n```js\nvar complie = function (str) {\n var tpl = str.replace(/<%=([\\s\\S]+? )%>/g, function(match, code) {\n   return \"' + obj.\" + code + \"+ '\";\n });\n\n tpl = \"var tpl = '\" + tpl + \"'\\nreturn tpl; \";\n return new Function('obj, escape', tpl);\n};\nvar render = function (complied, data) {\n return complied(data);\n};\n```\n通过预编译缓存模板编译后的结果，实际应用中就可以实现一次编译，多次执行，而原始的方式每次执行过程中都要进行一次编译和执行。\n\n**模板性能**\n ❑ 缓存模板文件。\n ❑ 缓存模板文件编译后的函数。\n```js\nres.render = function (viewname, data) {\n var layout = data.layout;\n if (layout) {\n   if (! cache[layout]) {\n     try {\n     cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), 'utf8');\n     } catch (e) {\n     res.writeHead(500, {'Content-Type': 'text/html'});\n     res.end(’布局文件错误’);\n     return;\n     }\n   }\n }\n var layoutContent = cache[layout] || '<%-body%>';\n\n var replaced;\n try {\n   replaced = renderLayout(layoutContent, viewname);\n } catch (e) {\n   res.writeHead(500, {'Content-Type': 'text/html'});\n   res.end(’模板文件错误’);\n   return;\n }\n // 将模板和布局文件名做key缓存\n var key = viewname + ':' + (layout || '');\n if (! cache[key]) {\n   // 编译模板\n   cache[key] = compile(replaced);\n }\n res.writeHead(200, {'Content-Type': 'text/html'});\n var html = cache[key](data);\n res.end(html);\n};\n```\n\n\n\n## node产品化\n### 项目工程化\n1. 目录结构\n2. 构建工具: shell\n3. 编码规范：lint和typescript\n4. 代码审查\n\n### 部署流程\n#### a、部署环境\n预发布环境与普通的测试环境的差别在于它的数据较为接近线上真实的数据， 也就是所谓的灰度环境。\n\n#### b、部署操作\n1. 以 nohup 和 & 后台方式启动服务 \n```sh\nnohup node app.js &\n```\n\n```bash\n#! /bin/bash\nDIR=`pwd`\nNODE=`which node`\n# get action\nACTION=$1\n\n# help\nusage() {\n echo \"Usage: ./appctl.sh {start|stop|restart}\"\n exit 1;\n}\n\nget_pid() {\n if [ -f ./run/app.pid ]; then\n   echo `cat ./run/app.pid`\n fi\n}\n\n# start app\nstart() {\n pid=`get_pid`\n\n if [ ! -z $pid ]; then\n   echo 'server is already running'\n else\n   $NODE $DIR/app.js 2>&1 &\n   echo 'server is running'\n fi\n}\n\n# stop app\nstop() {\n pid=`get_pid`\n if [ -z $pid ]; then\n   echo 'server not running'\n else\n   echo \"server is stopping ...\"\n   kill -15 $pid\n   echo \"server stopped ! \"\n fi\n}\nrestart() {\n stop\n sleep 0.5\n echo =====\n start\n}\n\ncase \"$ACTION\" in\n start)\n   start\n ;;\n stop)\n   stop\n ;;\n restart)\n   restart\n ;;\n *)\n   usage\n ;;\nesac\n```\n\n部署的过程只要执行下面bash脚本：\n./appctl.sh start\n./appctl.sh stop\n./appctl.sh restart\n\n\n2. pm2方式操作进程\n\n### 性能\n#### a、动静分离\nNode尽管也能通过中间件实现静态文件服务，但是Node处理静态文件的能力并不算突出。将图片、脚本、样式表和多媒体等静态文件都引导到专业的静态文件服务器上，让Node只处理动态请求即可。这个过程可以用Nginx或者专业的CDN来处理。静态文件请求分离后，对静态请求使用不同的域名或多个域名还能消除掉不必要的Cookie传输和浏览器对下载线程数的限制\n<img src=\"/img/node27.jpeg\" alt=\"动静分离\" style=\"max-width:95%\" />\n\n#### b、启用缓存\n提升性能其实差不多只有两个途经，一是提升服务的速度，二是避免不必要的计算。前者提升的性能在海量流量面前终有瓶颈，但后者却能够在访问量越大时收益越多。避免不必要的计算，应用场景最多的就是缓存\n\n\n#### c、多进程架构\n通过多进程架构，不仅可以充分利用多核CPU，更是可以建立机制让Node进程更加健壮，以保障Web应用持续服务。由于Node是通过自有模块构建HTTP服务器的，不像大多数服务器端技术那样有专有的Web容器，所以需要开发者自己处理多进程的管理。不过好在官方已经有cluster模块，在社区也有pm、forever、pm2这样的模块用于进程管理\n\n#### d、读写分离\n就任意数据库而言，读取的速度远远高于写入的速度。而某些数据库在写入时为了保证数据一致性，会进行锁表操作，这同时会影响到读取的速度。某些系统为了提升性能，通常会进行数据库的读写分离，将数据库进行主从设计，这样读数据操作不再受到写入的影响，降低了性能的影响\n\n#### e、分布式部署\n通过多机器集群化分布式部署，可以加强应用的健壮性\n\n### 日志\n#### a、访问日志\n中间件框架Connect在其众多中间件中提供了一个日志中间件，通过它可以将关键数据按一定格式输出到日志文件中\n\n#### b、异常日志\n\n❑ console.log：普通日志\n\n❑ console.info：普通信息\n\n❑ console.warn：警告信息\n\n❑ console.error：错误信息\n\n```js\n/**\n * console模块在具体实现时，log与info方法都将信息输出给标准输出process.stdout, warn与error方法则* 将信息输出到标准错误process.stderr，而info和error分别是log和warn的别名。\n */\n\nConsole.prototype.log = function() {\n this._stdout.write(util.format.apply(this, arguments) + '\\n');\n};\n\nConsole.prototype.info = Console.prototype.log;\n\nConsole.prototype.warn = function() {\n this._stderr.write(util.format.apply(this, arguments) + '\\n');\n};\n\nConsole.prototype.error = Console.prototype.warn;\n\n\n// 格式化方法\nvar format = function (msg) {\n var ret = '';\n if (! msg) {\n   return ret;\n }\n\n var date = moment();\n var time = date.format('YYYY-MM-DD HH:mm:ss.SSS');\n if (msg instanceof Error) {\n   var err = {\n     name: msg.name,\n     data: msg.data\n   };\n\n   err.stack = msg.stack;\n   ret = util.format('%s %s: %s\\nHost: %s\\nData: %j\\n%s\\n\\n',\n     time,\n     err.name,\n     err.stack,\n     os.hostname(),\n     err.data,\n     time\n   );\n   console.log(ret);\n } else {\n   ret = time + ' ' + util.format.apply(util, arguments) + '\\n';\n }\n return ret;\n};\n```\n\n#### c、日志和数据库\n有的开发者对日志可能不太了解，会选择将一些日志写入到数据库中。数据库比日志文件好的地方在于它是结构化数据，可以直接编写SQL语句进行分析，日志文件则需要再加工之后才能分析。\n\n但是日志文件与数据库写入在性能上处于两个级别，数据库在写入过程中要经历一系列处理，比如锁表、日志等操作。写日志文件则是直接将数据写到磁盘上。为此，如果有大量的访问，可能会存在写入操作大量排队的状况，数据库的消费速度严重低于生产速度，进而导致内存泄漏等。\n\n相比之下，写日志是轻量的方法，将日志分析和日志记录这两个步骤分离开来是较好的选择。日志记录可以在线写，日志分析则可以借助一些工具同步到数据库中，通过离线分析的方式反馈出来\n#### d、分隔日志\n线上业务可能访问量巨大，产生的日志也可能是大量的，上述示例只是简单地将普通日志和异常日志分开放在两个文件中，日志过多时也不便直接查看。为此，将产生的日志按日期分割是一个不错的主意。\n\n\n### 监控告警\n\n**服务监控的手段， 按层次可以划分为：**\n\n1. 系统层（CPU、网络状态、IO、机器负载等）\n2. 应用层（进程状态、错误日志、吞吐量等）\n3. 业务层（服务/接口的错误码、响应时间）\n4. 用户层（用户行为、舆情监控、前端埋点）\n\n\n> 应用的监控主要有两类，一种是业务逻辑型的监控，一种是硬件型的监控。监控主要通过定时采样来进行记录。除此之外，还要对监控的信息设置上限，一旦出现大的波动，就需要发出警报提醒开发者。\n#### a、监控\n1. **日志监控：**从访问日志中也能实现PV和UV的监控。同QPS值一样，通过对PV/UV的监控，可以很好地知道应用的使用者们的习惯、预知访问高峰\n2. **响应时间：**响应时间可以在Nginx一类的反向代理上监控，也可以通过应用自行产生的访问日志来监控\n3. **进程监控：**监控进程一般是检查操作系统中运行的应用进程数，比如对于采用多进程架构的Web应用，就需要检查工作进程的数量，如果低于预估值，就应当发出报警声\n4. **磁盘监控：**\n5. **内存监控：**如果内存只升不降，那么铁定存在内存泄漏问题。健康的内存使用应当是有升有降，在访问量大的时候上升，在访问量回落的时候，占用量也随之回落\n6. **cpu监控：**CPU的使用分为用户态、内核态、IOWait等。如果用户态CPU使用率较高，说明服务器上的应用需要大量的CPU开销；如果内核态CPU使用率较高，说明服务器花费大量时间进行进程调度或者系统调用；IOWait使用率则反应的是CPU等待磁盘I/O操作\n7. **cpu负载：**CPU load过高说明进程数量过多，这在Node中可能体现在用子进程模块反复启动新的进程\n8. **I/O负载：**I/O负载指的主要是磁盘I/O。反应的是磁盘上的读写情况，对于Node编写的应用，主要是面向网络服务，是故不太可能出现I/O负载过高的情况，大多数的I/O压力来自于数据库\n9. **网络监控：**流入流量和流出流量\n\n#### b、告警\n1. 邮件或企业微信告警\n2. 电话告警\n\n\n### 稳定性\n#### a、多机器\n但是一旦出现分布式，就需要考虑负载均衡、状态共享和数据一致性等问题。\n#### b、多机房\n#### c、容灾备份\n\n## 测试\n### 1、单元测试\n>单元测试主要用于检测代码的行为是否符合预期\n\n### 2、性能测试\n>在完成代码的行为检测后，还需要对已有代码的性能作出评估，检测已有功能是否能满足生产环境的性能要求，能否承担实际业务带来的压力。换句话说，性能也是功能\n\n1. **基准测试**\n基准测试要统计的就是在多少时间内执行了多少次某个方法。为了增强可比性，一般会以次数作为参照物，然后比较时间，以此来判别性能的差距\n```js\n// Array.prototype.map\nvar nativeMap = function (arr, callback) {\n return arr.map(callback);\n};\n// 自定义循环提值\nvar customMap = function (arr, callback) {\n var ret = [];\n for (var i = 0; i < arr.length; i++) {\n   ret.push(callback(arr[i], i, arr));\n }\n return ret;\n};\n\n// 性能对比方法\nvar run = function (name, times, fn, arr, callback) {\n var start = (new Date()).getTime();\n for (var i = 0; i < times; i++) {\n   fn(arr, callback);\n }\n var end = (new Date()).getTime();\n console.log('Running %s %d times cost %d ms', name, times, end - start);\n};\n\n// 调用示例\nvar callback = function (item) {\n return item;\n};\n\nrun('nativeMap', 1000000, nativeMap, [0, 1, 2, 3, 5, 6], callback);\nrun('customMap', 1000000, customMap, [0, 1, 2, 3, 5, 6], callback);\n```\n*为了得到更规范和更好的输出结果，这里介绍benchmark这个模块是如何组织基准测试的。*\n\n\n2. **压力测试**\n对网络接口做压力测试需要考查的几个指标有**吞吐率、响应时间和并发数，**这些指标反映了服务器的并发处理能力。最常用的工具是ab、siege、http_load等\n\n\n\n<br >\n[同步与异步、阻塞与非阻塞傻傻分不清楚？你得从linux中的5种IO模型看起](https://juejin.cn/post/7119034398078402568)","tags":["读书笔记","深入浅出nodejs"]},{"title":"npm|yarn|pnpm区别","url":"/2022/02/07/npm-yarn-pnpm区别/","content":"\n## npm\n### 1. 原理\n<img src=\"/img/npm4.png\" />\n1. 检查.npmrc文件, 优先级为：项目级的.npmrc 文件 > 用户级的.npmrc 文件> 全局级的.npmrc文件 > npm内置的.npmrc 文件\n2. 检查有无lock文件\n3. 无lock文件\n   1. 从npm远程获取包信息\n   2. 根据package.json构建依赖树\n   3. 在缓存中依此查找依赖树中每个包\n      1. 不存在缓存：\n         1. 从npm包远程仓库下载包\n         2. 检查包的完整性\n         3. 检查不通过就重新下载\n         4. 检查通过\n            1. 将下载的包复制到npm缓存目录\n            2. 将下载的包依照依赖树结构解压到node_modules\n      2. 存在缓存：将缓存按照依赖结构解压到 node_modules\n   4. 将包解压到 node_modules\n   5. 生成lock文件\n4. 有lock文件\n   1. 检查package.json中依赖版本和是否和package-lock.json中的依赖有冲突\n   2. 如果没有冲突，直接跳过获取包的、构建依赖树、查找缓存后续过程相同\n\n**1. 项目代码中引用了一个模块，模块查找流程如下**\n1. 在当前模块路径下搜索\n2. 在当前模块 node_modules 路径下搜素\n3. 在上级模块的 node_modules 路径下搜索\n4. 直到搜索到全局路径中的 node_modules\n\n**2. npm 3.x 新增扁平结构**\n1. **安装模块时，不管其是直接依赖还是子依赖的依赖，优先将其安装在node_modules根目录；当安装到相同模块时，判断已安装的模块版本是否符合新模块的版本范围，如果符合则跳过，如果不符合则在当前模块的node_modules下安装该模块。** \n2. **解决了**\n  1. 不同层级的依赖中， 可能引用同一个模块， 导致大量冗余\n  2. 在windows系统中，文件路径最大长度为260个字符，嵌套过深可能导致不可预祝的问题   \n   \n\n### 2. 缺点\n1. **没有彻底解决扁平结构**\n   1. 如果依赖的不同版本的包依然会存在嵌套问题\n   <img width=\"80%\" src=\"/img/npm5.jpeg\" />\n\n\n## yarn\n### 1. 原理\n<img src=\"/img/yarn.webp\" />\n1. **A、检查（checking）:**主要是检查项目中是否存在一些 npm 相关的配置文件，如 package-lock.json 等。如果存在，可能会警告提示，因为它们可能会存在冲突。在这一阶段，也会检查系统 OS、CPU 等信息。\n2. **B、解析包（resolving packages）:** 在经过复杂的解析算法后，我们就确定了所有依赖的具体版本信息以及下载地址\n    1. 首先获取项目 package.json 中声明的首层依赖，包括 dependencies, devDependencies, optionalDependencies 声明的依赖\n    2. 接着采用遍历首层依赖的方式获取依赖包的版本信息，以及递归查找每个依赖下嵌套依赖的版本信息，并将解析过和正在解析的包用一个 Set 数据结构来存储，这样就能保证同一个版本范围内的包不会被重复解析\n3. **C、获取包（fetching packages）:** 这一步主要是利用系统缓存，到缓存中找到具体的包资源(查看缓存：yarn cache dir)\n     1. 首先会尝试在缓存中查找依赖包，如果没有命中缓存，则将依赖包下载到缓存中。（判断系统中存在符合 \"cachefolder+slug+node_modules+pkg.name\" 规则的路径）\n     2. 对于没有命中缓存的包，Yarn 会维护一个 fetch 队列，按照规则进行网络请求。这里也是 yarn 诞生之初解决 npm v3 安装缓慢问题的优化点，**支持并行下载**\n4. **D、链接包（linking dependencies:** 这一步主要是将缓存中的依赖，复制到项目目录下，同时遵循扁平化原则  \n5. **F、构建包（building fresh packages）:** 如果依赖包中存在二进制包需要进行编译，会在这一步进行。 \n\n### 2. yarn和npm区别\n1. lockfile。package-lock.json 自带版本锁定+依赖结构，你想改动一些依赖，可能影响的范围要比表面看起来的复杂的多；而 yarn.lock 自带版本锁定，并没有确定的依赖结构，使用 yarn 管理项目依赖，需要 package.json + yarn.lock 共同确定依赖的结构\n2. 依赖管理策略\n3. 性能， yarn性能在有缓存、重新install的情况下会比npm好不少\n\n\n## pnpm\n### 1. 特点\n1. 包安装速度极快\n2. 磁盘空间利用非常高效\n3. 支持 monorepo\n   之前对于多个项目的管理，我们一般都是使用多个 git 仓库，但 monorepo 的宗旨就是用一个 git 仓库来管理多个子项目，所有的子项目都存放在根目录的packages目录下，那么一个子项目就代表一个package\n4. 安全性更高\n   \n### 2. 原理\n#### 1. 速度快\n**在绝多大数场景下，pnpm包安装的速度都是明显优于npm/yarn，速度会比 npm/yarn快2-3倍**\n1. yarn PnP：直接去掉 node_modules，将依赖包内容写在磁盘，节省了 node 文件 I/O 的开销，这样也能提升安装速度。（具体原理见这篇文章https://loveky.github.io/2019/02/11/yarn-pnp/)\n\n#### 2. 存储管理\n**a. 基于内容寻址的文件系统来存储磁盘上所有的文件** \n1. 不会重复安装同一个包: 如果 100 个项目都依赖 lodash，那么 lodash 很可能就被安装了 100 次，磁盘中就有 100 个地方写入了这部分代码， 使用 pnpm 只会安装一次，磁盘中只有一个地方写入\n2. 即使一个包的不同版本，pnpm 也会极大程度地复用之前版本的代码：比如 lodash 有 100 个文件，更新版本之后多了一个文件，那么磁盘当中并不会重新写入 101 个文件，而是保留原来的 100 个文件的 hardlink，仅仅写入那一个新增的文件\n\n#### 3. 依赖管理\n#### 4. 安全管理\n### 3. 日常使用\n1. pnpm install\n2. pnpm update\n3. pnpm uninstall\n```js\n// 移除 axios \n// --filter 来指定 package。\npnpm uninstall axios --filter package-a\n```\n4. pnpm link\n```js\n// 将本地项目连接到另一个项目。注意，使用的是硬链接，而不是软链\npnpm link ../../axios\n```\n\n\n<br/>\n\n[文章来源](https://jishuin.proginn.com/p/763bfbd3bcff)\n\n[文章来源](https://cloud.tencent.com/developer/article/1555982)\n\n[文章来源](https://jishuin.proginn.com/p/763bfbd655cc)","tags":["npm、yarn和pnpm区别","yarn","pnpm"]},{"title":"前端服务灰度发布","url":"/2022/01/27/前端服务灰度发布/","content":"\n### 灰度发布优点\n1. 提前收集用户意见，完善产品功能\n2. 控制未知异常影响最小范围\n\n\n### 前端灰度发布的要素\n#### 1. 放量规则\n1. 按照用户某些特征进行放量： 年龄、国家、城市、注册id等等\n2. 常用的放量规则：用户注册有一个自增的序列号，当灰度放量的时候可以根据这个序列号座位灰度特征\n\n#### 2. 资源新旧版本\n1. 明确给用户展示不同版本的页面，可以是前端静态版本号形式\n\n\n### 灰度实现的原理\n1. 用户访问网站\n2. 判断是否为灰度用户（有一定规则）\n3. 命中用户就展示新版本， 未命中就展示老版本\n\n### 灰度发布的几种形式\n#### 前端灰度发布\n1. ssr服务端渲染\n   1. 用户访问网站\n   2. ssr服务获取用户特征\n   3. 灰度规则服务返回灰度名单\n   4. ssr服务返回前端展示\n2. 前后端半分离，入口页面托管在服务端（nodejs、php）\n3. 前后端分离\n   1. 前端代码写2套内容，在页面渲染之前发起异步获取灰度规则\n   2. 通过修改nginx配置来灰度\n     1. 2套代码，分别部署\n     2. 通过nginx加权轮询来控制百分比灰度\n   3. nginx+lua脚本+灰度规则\n\n#### 后端灰度发布\n1. 类似前端ssr服务端渲染\n\n\n\n<br />\n[文章来源于](https://mp.weixin.qq.com/s/-nZZX0I3PZvEUpUXwmb1MQ)","tags":["金丝雀发布","灰度发布"]},{"title":"框架分类和本质","url":"/2022/01/15/框架分类和本质/","content":"\n### 什么是架构\n选择合适且有不错扩展能力的技术方案，解决业务真实存在的问题。\n\n也可以粗暴的理解为架构就是骨架，人类的身体的支撑是主要由骨架来承担的，然后是其上的肌肉、皮肤。\n### 什么是框架和框架本质\n#### 1. 系统和子系统\n1. 系统：泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能独立完成的工作能力的群体\n2. 子系统：一群关联的个体组成的系统，多半是更大系统中的一部分\n\n#### 2. 模块和组件\n1. 区分逻辑：两者都是系统组成的部分，从不同的角度拆分\n2. 模块：根据逻辑单位划分； 将复杂的问题简单化，可以系统、子系统、服务、函数、功能模块\n3. 组件：根据物理文件单位划分；可以是数据库、nginx、ui组件等技术组件\n\n\n#### 3. 框架和架构\n1. **框架是规范**，如开源框架：Ruby on Rails、Spring、Laravel、Django等，这是可以拿来直接使用或者在此基础上二次开发\n2. **架构是结构，软件系统的顶层结构**。架构是指经过系统性思考，权衡利弊之后在现有的资源约束下的最合理决策，最终明确的系统骨架：包括子系统、模块、组件以及他们之间的关系， 约束规范，指定原则，并且由它来指导团队中的每个人思想层面一致\n  1. 系统性思考的合理决策：技术选型、解决方案\n  2. 明确系统骨架：明确系统有哪些组成部分\n  3. 系统协作关系：各组成部分如何协作来实现业务请求\n  4. 约束规范和指导原则：保证系统有序、高效、稳定运行\n\n\n3. **架构师具备的能力**\n架构师思考的问题：如何针对当前需求，选择合适的应用架构，如何面对未来，保证架构平滑过渡   \n   1. 理解业务\n   2. 全局把控\n   3. 选择合适技术\n   4. 解决关键问题\n   5. 指导研发落地实施   \n   \n#### 4. 架构分层和分类\n##### 1. 业务架构\n1. 介绍：业务架构包括业务规划、业务流程、对整个系统的业务进行拆分、对领域模型进行设计、把现实的业务转化成抽象对象\n2. 原则：没有最优的架构，只有最合适的架构，一切系统设计原则都是要以解决业务问题为最终目标，脱离实际业务的技术情怀架构往往会给系统带来大坑。合理的架构能够提前预见业务发展1-2年为宜。\n##### 2. 应用架构\n1. 介绍：应用作为独立可部署的单元，为系统划分了明确边界，深刻影响系统功能组织、代码开发、部署和运维等各方面\n2. 关键点：\n   1. 职责划分：明确应用（各个逻辑模块和子系统）的边界：逻辑分层、子系统和模块定义\n   2. 职责之间的协作：接口协议（应用对外输出的接口）、协议关系（应用之间的调用关系）\n##### 3. 数据架构\n1. 介绍：数据架构指导数据库和缓存设计\n##### 4. 代码/开发架构\n1. 代码单元：配置设计；框架、类库\n2. 代码单元组织：编码规范、编码惯例；项目模块划分；顶层文件结构设计；依赖关系\n##### 5. 技术架构\n\n##### 6. 部署架构\n介绍：拓扑架构，包括架构部署几个节点、节点之间的关系、服务的高可用、网络路口和协议，决定了应用如何运行，运行的性能、可维护、可扩展性， 这是所有架构的基础。\n\n### 设计模式\n#### 1. 什么是设计模式\n模式就是经验，设计模式就是设计经验，有了这些经验，我们就能在特定情况下使用特定的设计、组合设计，这样可以大大节省我们的设计时间，提高工作效率。\n\n#### 2. 架构方面设计模式分类\n1. 单库单应用模式：结构简单、开发速度快、为原型验证和用户少的应用设计\n2. 内容分发模式：目前用的比较多\n3. 查询分离模式：对于大并发的查询、业务\n4. 微服务模式：适用于复杂的业务模式的拆解\n5. 多级缓存模式：可以把缓存玩的很好\n6. 分库分表模式：解决单机数据库瓶颈\n7. 弹性伸缩模式：解决波峰波谷业务流量不均匀的方法之一\n8. 多机房模式：解决高可用、高性能的一种方法\n\n##### a. 单库单应用模式 \n1. 优点：结构简单、开发速度快、实现简单，可用于产品的第一版等有原型验证需求、用户少的设计。\n2. 缺点：性能差、基本没有高可用、扩展性差，不适用于大规模部署、应用等生产环境。\n<img src=\"/img/arc1.jpeg\" style=\"max-width:95%\" />\n\n##### b. 内容分发模式\n基本上所有的大型的网站都有或多或少的采用这一种设计模式，常见的应用场景是使用CDN技术把网页、图片、CSS、JS等这些静态资源分发到离用户最近的服务器。\n<img src=\"/img/arc2.jpeg\" style=\"max-width:95%\" />\n\n##### c. 查询分离模式 \n这种模式主要解决单机数据库压力过大，从而导致业务缓慢甚至超时，查询响应时间变长的问题，也包括需要大量数据库服务器计算资源的查询请求。这个可以说是单库单应用模式的升级版本，也是技术架构迭代演进过程中的必经之路\n<img src=\"/img/arc3.jpeg\" style=\"max-width:95%\" />\n\n使用场景：\n1. 场景一：全文关键词检索\n>我想这个需求，绝大多数应用都会有，如果使用传统的数据库技术，大部分可能都会使用like这种SQL语句，高级一点可能是先分词，然后通过分词index相关的记录。SQL语句的性能问题与全表扫描机制导致了非常严重的性能问题，现在基本上很少见到。这里的ES是ElasticSearch的缩写，是一种查询引擎。\na. 服务端把一条业务数据落库\nb. 服务端异步把该条数据发送到ES\nc. ES把该条记录按照规则、配置放入自己的索引库\nd. 客户端查询的时候，由服务端把这个请求发送到ES，得到数据后，根据需求拼装、组合数据，返回给客户端\n   \n2. 场景二：大量的普通查询\n>这个场景是指我们的业务中的大部分辅助性的查询，如：取钱的时候先查询一下余额，根据用户的ID查询用户的记录，取得该用户最新的一条取钱记录等。我们肯定是要天天要用的，而且用的还非常多。同时呢，我们的写入请求也是非常多的，导致大量的写入、查询操作压向同一数据库，然后，数据库挂了，系统挂了。所以要求我们必须分散数据库的压力，一个业界较成熟的方案就是数据库的读写分离，写的时候入主库，读的时候读从库。这样就把压力分散到不同的数据库了，如果一个读库性能不行，扛不住的话，可以一主多从，横向扩展。\na.服务端把一条业务数据落库\nb.数据库同步或异步或半同步把该条数据复制到从库\nc.服务端读数据的时候直接去从库读相应的数据\n\n##### d. 微服务模式 \n我把业务分块，做了垂直切分，切成一个个独立的系统，每个系统各自衍化，有自己的库、缓存、ES等辅助系统，系统之间的实时交互通过RPC，异步交互通过MQ，通过这种组合，共同完成整个系统功能。 那么，这么做是否真的解决上述问题了呢？不玩虚的，一个个来说。对于问题一，由于拆分成了多个子系统，系统的压力被分散了，而各个子系统都有自己的数据库实例，所以数据库的压力变小。\n\n<img src=\"/img/arc4.jpeg\" style=\"max-width:95%\" />\n\n> **优点如下：**\na.对于问题二，一个子系统A的数据库挂了，只是影响到系统A和使用系统A的那些功能，不会所有的功能不可用，从而解决一个数据库挂了，导致所有功能不可用的问题。\nb.问题三、四，也因为拆分得到了解决，各个子系统有自己独立的GIT代码库，不会相互影响。通用的模块可通过库、服务、平台的形式解决。\nc.问题五，子系统A发生改变，需要上线，那么我只需要编译A，然后上线就可以了，不需要其他系统做同样的事情。\nd.问题六，顺应了康威定律，我部门该干什么事、输出什么，也通过服务的形式暴露出来，我部只管把我部的职责、软件功能做好就可以。\ne.问题七，所有需要我部数据的需求，都通过接口的形式发布出去，客户通过接口获取数据，从而屏蔽了底层数据库结构，甚至数据来源，我部只需保证我部的接口契约没有发生变化即可，新的需求增加新的接口，不会影响老的接口。\nf.问题八，不同的子系统需要不同的权限，这个问题也优雅的解决了。\ng.问题九，暂时控制住了复杂性，我只需控制好大的方面，定义好系统边界、接口、大的流程，然后再分而治之、逐个击破、合纵连横。\n\n**另外，对于这个模式来说，最难把握的是度，切记不要切分过细，我见过一个功能一个子系统，上百个方法分成上百个子系统的，真的是太过度了。实践中，一个较为可行的方法是：能不分就不分，除非有非常必要的理由！。**\n\n##### e. 多级缓存模式 \n<img src=\"/img/arc5.jpeg\" style=\"max-width:95%\" />\n\n**客户端处缓存 --> API网关处缓存 --> 后端业务处**\n\n1. 优点：抗住大量读请求，减少后端压力。\n2. 缺点：数据一致性问题较突出，容易发生雪崩，即：如果客户端缓存失效、API网关缓存失效，那么所有的大量请求瞬间压向后端业务系统，后果可想而知。\n\n##### f. 分库分表模式 \n这种模式主要解决单表写入、读取、存储压力过大，从而导致业务缓慢甚至超时，交易失败，容量不够的问题。一般有水平切分和垂直切分两种，这里主要介绍水平切分\n\n<img src=\"/img/arc6.jpeg\" style=\"max-width:95%\" />\n\n如上图所示红色部分，把一张表分到了几个不同的库中，从而分担压力\n\n主机：硬件，指一台物理机，或者虚拟机，有自己的CPU，内存，硬盘等。\n\n实例：数据库实例，如一个MySQL服务进程。一个主机可以有多个实例，不同的实例有不同的进程，监听不同的端口。 \n\n库：指表的集合，如学校库，可能包含教师表、学生表、食堂表等等，这些表在一个库中。一个实例中可以有多个库。库与库之间用库名来区分。 \n\n表：库中的表，不必多说，不懂的就不用往下看了，不解释。\n\n\n**a. 优点：减少数据库单表的压力。**\n\n**b. 缺点：事务保证困难、业务逻辑需要做大量改造。**\n\n##### h. 弹性伸缩模式 \n这种模式主要解决突发流量的到来，导致无法横向扩展或者横向扩展太慢，进而影响业务，全站崩溃的问题。\n\n<img src=\"/img/arc7.jpeg\" style=\"max-width:95%\" />\n\n首先把所有的计算资源整合成资源池的概念，然后通过一些策略、监控、服务，动态的从资源池中获取资源，用完后在放回到池子中，供其他系统使用。具体实现上比较成熟的两种资源池方案是VM、docker，每个都有着自己强大的生态。监控的点有CPU、内存、硬盘、网络IO、服务质量等，根据这些，在配合一些预留、扩张、收缩策略，就可以简单的实现自动伸缩。\n\n优点：弹性、随需计算，充分优化企业计算资源。\n\n缺点：应用要从架构层做到可横向扩展化改造、依赖的底层配套比较多，对技术水平、实力、应用规模要求较高。\n##### i. 多机房模式 \n这种模式主要解决不同地区高性能、高可用的问题。\n\n<img src=\"/img/arc8.jpeg\" style=\"max-width:95%\" />\n\n优点：高可用、高性能、异地多活。\n\n缺点：数据同步、数据一致性、请求路由。\n\n\n<br/>\n[文章来源于](https://mp.weixin.qq.com/s/2koujY54dUsNvmZ9KdueOg)\n[文章来源于](https://mp.weixin.qq.com/s/7X_WdKXgI7Vglt3qstf-Ug)","tags":["框架分类","框架本质","设计模式"]},{"title":"技术管理学习感悟[转载]","url":"/2021/11/29/技术管理学习感悟/","content":"\n\n### 自我定位\n#### 技术人员发展\n##### 1. 技术类\n###### 架构师\n* 侧重于广； 关注技术的整体性、架构性、业务解决方案\n* 需要能力： **技术实操、架构能力、业务理解、培养梯队、沟通能力**\n\n###### 技术专家\n* 侧重于深； 关注某个专项技术的深度、专业度和精细度\n* 需要能力： **技术实操、专业研究、业务理解、培养梯队、沟通能力**\n\n##### 2. 管理类\n###### 技术管理\n* 就是工程师从团队一线管理人员、部门技术经理到技术总裁和cto\n* 需要能力： **业务理解、技术判断、目标规划、团建建设、任务执行、上下沟通**\n\n###### 职业经理\n* 不限于管理技术团队， 往往是负责一个完整的业务， 类似ceo和gm\n* 需要能力： **行业洞察、商业判断、资本运作、目标规划、内外沟通**\n\n##### 3. 创业类\n###### 技术创始人\n* 牵头创业，做行业的领头羊，最终成为企业家\n* 需要能力：**业务理解、技术判断、资本运作、公司经营、内外沟通**\n\n###### 技术合伙人\n* 全盘负责公司的技术， 以技术管理为公司保驾护航\n* 需要能力：**业务理解、技术判断、目标规划、团队建设、任务执行、内外沟通**\n\n##### 4. 顾问类\n\n#### 技术和管理平衡\n##### 顾虑\n1. **转管理之前没仔细了解过管理; 万一做不好怎么办？我的退路在哪里？**\n\n2. **刚刚开始做管理， 还无法靠管理”安身立命“**\n\n3. **根据自己的成功路径依赖，认为技术才是自己的”大本营“**\n\n##### 解决之道（患得患失）\n###### 1.患失（技术）\n* 技术管理，本质还是因为你技术好才当技术管理；放弃了技术根本做不好技术管理；技术管理只是在一定的程度上放弃了编码\n* 首先， 把技术提到更高视角来看待\n* 其次， 换一种学习方式来掌握技术：\n  * a. 建立自己的学习机制，\n  * b. 请教专家\n  * c. 共创： 不要自己埋头思考， 团队共创成果超乎你的想象\n\n###### 2. 患得（管理）\n* 患得，其实就是患不得， 转行做技术管理怕自己得不到管理\n* 首先， 一线技术管理， 即便做不好也并非没有回头路\n* 其次， 做管理所积累的能力， 完全可以迁移到技术带头人 或者 技术leader的角色\n* 最后， 你一定在技术管理中有所得， 会在管理过程中有丰富的收获\n\n#### 如何做到技术判断力\n##### 1. 技术评估维度\n###### 结果评估\n* 以终为始，事先就要就要明确如何验收，最终项目有没有到达目标，做到有的放矢\n\n###### 可行性评估\n* 能不能做\n* 值不值得做\n  * 资源投入成本：投入多少人、时间、物资\n  * 维护成本： 技术选项成本、技术升级成本、问题排查成本、代码维护成本\n  * 机会成本：选择了当前的技术就意味放弃另一件事， 没做另外一件事会为团队带来什么影响\n  * 协作成本\n\n###### 风险评估\n* 那些风险需要提前未雨绸缪，考虑技术方案带来最大损失最大值和边界\n\n##### 2. 提高技术视野和判断\n###### 建立技术学习机制\n* 让团队对各个方向的技术保持敏感度，要求小组定期交流和分享\n\n###### 专项技术调研项目化\n* 专门立项做技术调研， 并且要求相关项目负责人做调研汇报\n\n###### 和技术大牛交流\n* 针对某项技术找大牛取经\n\n###### 听取工作汇报\n* 读取员工的周报或者汇报时候，相互探讨， 也是一种切磋和学习\n\n#### 管理风格\n##### 指令式管理\n* 介绍：重事不重人，关注目标和结果，不亲力亲为去操作； 类似马车上车夫，不亲自拉车，下指令马的一举一动\n* 使用场景：当一项工作不容闪失，而你又是唯一熟悉、且最有掌控力的人；一个命令的你可能更降低风险、达到目标\n* 优缺点：团队执行力强，但是梯队很难培养\n\n##### 支持式管理\n* 介绍：重人不重事，凡事亲力亲为以身作则，在意团队成员且为他们分担工作；类似站在马匹中间，和大家一起风力拉车\n* 使用场景：当一个团队特别需要凝聚力和斗志，需要攻坚的时候；支持式管理特别能带动团队士气， 在带动大家热情和积极性很有优势\n* 优缺点：团队有归属感但是带不了大规模团队\n\n##### 教练式管理\n* 介绍：重人也重事，关注全局和方向，并在做事给予教练辅导和启发； 类似陪着马一起赶路， 同时会辅助马匹怎样能够把路走好、往那里去， 但是不会代替马匹亲自拉车\n* 使用场景：当有些核心人才需要重点培养，团队需要发展梯队时候；教练式管理不但把事情做好，个人能力还能成长\n* 优缺点：个人能力最显著成长，团队梯队也能快速完善起来；但是管理者精力消耗很大，很难覆盖全体成员，适合核心梯队的培养\n\n##### 授权式管理\n* 介绍：不重人也不重事，关注目标和结果，不关心过程和人员发展； 类似给个目标，马匹会自动到达目的地\n* 使用场景：适合于成熟的团队，成员有很好的发挥空间和舞台\n* 优缺点： 团队不成熟的时候， 成员就会野蛮生成， 事情发展态势也能把握， 风险很大\n\n#### 如何做到让团队信任我\n##### 1. 管理经验不足和能力欠缺\n* 做到能力迁移， 快速提升能力和经验\n* 能力三核心： 知识、技能、才干\n* 知识： 大部分能力用于特定的工作场景，较难直接迁移；  技能：快速学习能力、进度控制能力； 才干：长期工作和生活沉淀和锤炼出来的模式、特质和品格， 特别适合迁移， 自信的人就去鼓励组员、有前瞻性的人就去做好的规划\n\n##### 2. 和团队成员对立比较\n* 团队存在资历和能力强的组员：我们作为技术管理人员做的不是管束和控住大家， 而是引导和支持大家\n\n##### 3. 背负沉重历史包袱\n* 背负上级太高的期待，而担心自己做不好： 和上级建立起沟通渠道， 定期汇报自己和团队工作， 并就已完成的工作征求上级的看法和评价\n\n\n### 管理本质\n#### 角色认知\n#### 管理规划(看方向)\n#### 团队建设（带人）\n#### 任务执行（做事）\n\n#### 管理沟通\n\n\n### 角色认知\n#### 管理到底是做什么事情（后面章节会展开）\n* 管理规划(看方向)\n* 团队建设（带人）\n* 任务执行（做事）\n\n#### 工程师到管理角色到底发生那些改变\n* 第一从工作职责来看， 职责从头马变成车夫， 核心职责是拉好车\n* 第二负责对象来看，之前负责对象自己， 是管好自己和对自己的工作负责； 变成对团队和上级和公司给你的资源负责\n* 第三关注焦点来看， 工程师关注是过程导向，眼睛盯着脚下的路就可以； 变成要盯着远方目标， 你要决定带着团队去哪里\n* 第四工作内容和能力要求来看， 工程师靠个人专业能力来产生业绩； 变成看方向、带人、做事\n* 第五从任务来源来看，之前是等上级安排、听上级指挥； 变成虽然有上级安排，更多是自己筹划和上级沟通，从等活儿变成主动规划\n* 第六从实施手段来看，工程师要亲力亲为， 变成依靠团队完成\n* 第七从合作维度来看，工程师主要是和同级伙伴共同完成， 变成和上级协调资源、下级推进度\n* 第八从合作关系来看\n* 第九从思维方式来看\n* 第十从技术视角来看\n\n#### 新的管理者采坑\n##### 1. 误区一：过程导向、被动执行\n* 不主动找活，等待上级派活、等待上级做决定、选方案\n* 管理沟通中， 充当传话筒， 没反思沟通要到达的目的和效果\n* 过于关注苦劳和付出， 经常说没有功劳也有苦劳\n\n##### 2. 误区二：大包大揽、唯我最强\n* 梯队问题， 团队梯段建设需要授权\n* 激励问题， 管理者冲的太靠前， 团队成员积极性受挫\n* 个人发展问题， 自己忙于具体工作， 做不了更大的业务\n\n##### 3. 误区三：带头大哥、当家保姆\n* 绝对不会让我的兄弟们吃亏\n* 团队有技术能力比我强的高工，索性给他当了保姆， 忘记了自己是车夫和舵手\n\n##### 4. 误区四：单一视角、固化思维\n* 待描述\n\n##### 5. 误区五：自扫门前雪、固收边界\n* 这是测试问题、产品问题、其他部门问题\n* 不是我们团队的问题\n\n##### 6. 误区六：患得患失\n* 不写代码， 心里发虚\n* 管理太琐碎， 离技术越来越远， 担心个人发展\n* 管理是个矛盾的事情： 自己的技术专业越来越差，却要带领整个团队\n\n\n### 管理规划（看方向）\n#### 1. 刚开始做管理规划，从哪里着手\n* 职能：非常清楚简练的说出团队职责和使命\n* 目标：看得清团队的方向，知道这辆车拉倒那里去\n* 团队：盘点团队成员，了解他们具体情况\n* 路径：为了实现目标，我们选择走那一条路？ 需要投入那些资源？\n\n#### 2. 如何界定团队干什么（职能）\n##### a. 如果判断团队真正职能\n* 公司为什么要给这些资源？ 希望产出什么？\n* 团队存在的独特价值\n* 用什么维度来评判团队价值高低\n\n##### b. 设定团队职能（职责+使命）步骤\n* 收集信息：向上沟通、向下沟通、左看右顾（兄弟团队边界界定）、你的理解\n* 提炼和升华：职责提炼（基于上级的期待和要求和你对业务核心价值的理解）、使命升华（基于公司和行业，设定期待）、确定衡量维度\n* 确认和宣导：上级确认、团队宣导\n\n#### 3. 如何为团队设定合理目标（目标）\n* KPI: 到某个时间节点，什么指标到达什么数字\n* OKR: 到某个时间节点，完成什么工作，该工作实现那些功能和到达什么效果\n* 避免采坑：\n    * 目标基于现有资源、而不是基于远期目标往前推：完成几项重要的结果，然后再看看调配和补充资源\n    * 目标不明确：目标不能太笼统，目标不要强调“我做了什么”，而强调完成工作之后“取得了什么效果”\n    * 目标设定之后没及时跟下面传达：及时传达让团队明确方向\n    * 目标总是变来变去： 目标设置为 业务目标（紧急）  和 专业目标（重要）\n\n#### 4. 如何规划团队的组织结构（团队）\n##### a. 从团队目标角度看\n* 团队规模：团队多少人是现有的， 多少人是接来下新增的\n* 团队分工：团队负责哪些业务，每个业务配置多少人力，这些人力怎么分工\n* 团队梯队：一个团队梯队的情况代表团队的成熟度和复原力\n\n##### b. 从资源角度看\n* 从资源来看待团队，是成熟管理者标志之一；站在公司角度看， 每个团队都是一批人力资源\n* 如何合理推算成本：\n   * 取决你的业务的理解， 以及希望到达的目标\n   * 可以参照行业资源配比\n\n##### c. 从人才培养角度看\n* 人才培养概念：到了下个时间节点，你需要重点培养出哪些人，给他们什么样的平台和空间，以及你有能力提供给他们什么指导和支持， 期待什么能够胜任什么职位和角色\n* 体现目前团队状态三要素\n   * 规模：包括当前人数、预算人数和总人数\n   * 分工：体现团队人力都分布在那些业务上，以及各个业务有谁负责\n   * 梯队：团队的级别和梯队分布\n<img src=\"/img/person.webp\" width=\"700\" height = \"auto\" align=center />\n\n#### 5. 如何申请资源（路径）\n* 招聘作为缓冲的解决问题手段，更多的要看长线是否需要\n\n### 团队建设（带人）\n#### 1. 刚开始做团队建设，从哪里入手\n* 团队建设就是可以用 **马车模型** 诠释\n  * 马匹个体（马跑的快）：力气、意愿\n  * 马匹之间（车跑的快）：马队阵型、节奏和默契\n  * 马车整体（马车一直跑）：马队构成和团队构成、马队的精神面貌和团队文化\n* 团队建设的维度：组员个体、组员个体间、团队整体\n  * 个体（动力）：能力和激励\n  * 个体间（凝聚力）：分工和协作\n  * 团队（耐力）：梯队和文化\n<img src=\"/img/tuandui.webp\" width=\"700\" height = \"auto\" align=center />\n\n#### 2. 如何提升员工个人能力\n##### a. 提升员工个人能力途径\n1. 帮助员工自学： 组员员工参加培训、为员工购买书籍\n2. 相互交流讨论： 组织分享会、代码评审会、工作复盘、\n3. 工作实践：\n    * 授权和辅导，给员工独立负责重要工作机会，给予辅助和反馈\n    * 调研工作项目化，把调研学习的工作进行项目化\n    * 总结和内化，员工在这个总结和反思的过程中，甚至比总结的结果更重要\n\n\n##### b. 激发员工学习动力和意愿\n1. 推：\n   * 提出明确工作要求，一周内熟悉某个业务并可以开发\n   * 设置学习机制，强制要求遵守学习规则，完成学习任务\n   * 同行压力，团队学习和分享氛围，给不学习员工压力\n\n2. 拉：\n   * 树立榜样\n   * 配备导师\n   * 给技术学习地图\n\n3. 放：\n   * 给员工勇挑重任机会\n   * 给员工自主空间、耐心、信心\n\n\n#### 3. 如何提高员工的意愿和积极性\n##### 1. 激励认知不系统\n* 清楚激励都有哪些手段，以及如何使用，各种零散的说法让人无所适从。\n\n##### 2. 激励可用资源匮乏\n* 实实在在的物质激励不受自己掌控，画大饼的精神激励，员工又不买账。\n\n##### 3. 激励达不到效果\n* 虽然激励的动作都做到位了，但是并没有收到激发员工动力的效果，或者效果不够令人满意\n\n\n#### 4. 如何提高团队凝聚力\n##### 1. 提升归属\n* 个人职责清晰合理\n* 相互紧密协助\n* 团队文化价值认同\n\n##### 2. 共同愿景\n* 明确共同目标\n\n##### 3. 加强了解\n* 认同和容忍都是基于彼此深入了解\n* 默契来自各自工作方式的了解\n\n##### 4. 面对挑战\n* 共同面对挑战， 并且取得胜利\n\n#### 5. 如何物色和培养核心人才\n##### 1. 物色\n* a. 保持人才选拔和团队建设一致\n * 能力：对于功能交付的团队，其功能开发质量和效率是否突出\n * 协作：团队的核心骨干都要有比较好的协作意识，才可以干更大的事情，才可以发挥一个骨干需要发挥的作用\n * 文化：你团队如果倡导“积极主动”或“自驱”的团队文化，那么一个专业能力很强但是被动的人是否值得你培养\n\n\n* b. 和你相似的是人才，和你互补的才是更宝贵的人才， 突出思维方式多样性\n  * 管理者作为成长发展方面的“成功人士”，多少都会有些“成功路径依赖”，也就是认为“类似自己这样的人才是好的”，所以很多管理者自然而然地会喜欢用和自己风格相近的人\n\n\n##### 2. 培养\n* 对齐期待，达成共识，指定个人发展计划\n  * 个人聚焦成长有哪些，并且通过把那几件事情做到什么标准来提现\n  * 不承诺原则：**1. 靠自己的影响力来获取 2. 为培养失败留下退路，即使没有培养成你期待的骨干，也可以通过其他激励手段留下来**\n* 提供机会和发挥空间，最好授权\n  * 事前：指定初衷、明确期待、听其思路、重要约定\n  * 事中：了解进展、给予支持\n  * 事后：评估结果、洞察优势、积极反馈、改进建议\n* 建立反馈机制\n  * 建立周期性沟通机制\n  * 复盘个人成长计划\n  * 安排第二导师\n\n#### 6. 如何建设团队文化，营造团队气氛\n##### 1. 团队文化能带来什么\n* 效率，一个强调“安全”的数据团队，每个人都会考虑在工作推进过程中的安全措施。统一的行为准则和协作上的默契，带来了工作效率的大幅度提升。\n* 空间，在“员工激励”一文中我们提到，自主性能够提升员工的投入度，激发员工的自驱力\n* 归属，价值认同是一种高层次认同，一旦认同，便具有很好的稳定性和黏性，这种认同为大家带来了深深的团队归属感，共事的员工也更有凝聚力。\n* 耐力，一个企业或一个团队的文化，对于其稳定性、健壮性及耐力的重要作用。用通俗的话说就是，一个拥有鲜明而稳定的价值观的团队，更扛得住“折腾”\n\n##### 2. 如何打造团队文化\n* 命名它：总结提炼\n* 助长它：组内宣传\n* 追求它：绩效、个人发展计划、团队活动设计\n\n\n#### 7. 如何和低绩效员工谈绩效\n##### 1. 正常的绩效沟通到达的目标\n* 对齐：你们可以互相同步自己的信息，听取对方对于这些事实的看法和判断，了解对方在乎的焦点在哪里，交换双方对于同一个结果的评价标准\n* 辅导：绩效沟通的过程，不仅仅是告知员工绩效结果，更重要的是通过对过去工作的回顾，让员工有更多的思考和觉察，充当教练员角色\n* 激励：通过沟通令他重燃斗志，对未来充满希望，从而达到激励的效果\n\n##### 2. 绩效沟通的具体步骤\n* a. 绩效沟通核心不在于谈，而在于绩效管理全过程的完整性\n  * 绩效评估方案的制定，即未来给员工打绩效的依据\n  * 和员工确认绩效计划\n  * 归档并维护\n  * 绩效评估，需要对员工本次绩效周期内工作表现进行评估和打分\n  * 绩效沟通，和员工对齐共识、辅导和激励的效果\n* b. 绩效沟通之前， 先摆正自己的角色和姿态\n  * 审视一下自己的角色：你是这个团队的管理者，是这个团队的负责人，你是有责任来评价团队每个员工的工作表现和业绩的\n  * 你有管理者的职业素养，有管理者的工作视角，也有令人信服的评价依据，你做出来的就是最公平和最恰当的决策，你不欠他的，你也不是针对他\n  * 你需要考虑的事情是，如何和他达成共识，期待并支持他也可以像其他同事一样，变得更加出色\n* c. 把沟通当做承上启下的新起点，而不是末日审判\n  * 避免抓住过去的问题不放,如果把焦点放在对失败的探讨上，会让他感受到末日审判般的沮丧\n  * 用教练式的引导方式，一起做一场着眼未来的、面向长期发展的绩效沟通，就能收获到辅导和激励的效果\n\n\n\n\n### 任务执行（做事）\n#### 1. 多任务并行如何应对\n##### a. 任务过程细分\n* 事前（轻重缓急）：我们需要回答的问题是：要做哪些事？先做哪件，后做哪件？也就是分清楚轻重缓急，也叫优先级梳理\n* 事中（有效执行）：我们要确保事情的进展按照计划推进，尽在掌握之中，也就是有效地推进执行。\n* 事后（流程机制）：我们要复盘做事的整个过程，并从过去的经验之中抽取一些流程机制，以便以后在类似的场景下也可以做得更好、更顺畅\n\n##### b. 如何分类任务的重要性和紧急性\n* 如果做，收益是否很大？收益越大，这个事情就越重要。\n* 如果不做，损失是否很大？损失越大，这个事情就越紧急。\n\n##### c. 日常工作分类\n* 计划内工作：看收益是否足够大。收益越大就越重要，也就越需要给予相匹配的优先级、资源和关注度；收益相对不大，就放入“To do list”，作为待办任务处理\n* 计划外工作：看损失是否足够大。损失够大，就按照紧急任务安排，以止损为核心目的；如果损失可控，就放入“计划内工作”列表\n<img src=\"/img/things.webp\" width=\"700\" height = \"auto\" align=center />\n\n#### 2. 如何确保项目的有效执行\n##### a. 任务执行不到位的分类\n* 标不清晰，执行上的偏离预期\n   * 目标不够明确具体，至少没有具体到执行人员可以执行的程度\n   * 上、下级对目标的理解看似一致，实则有偏差，尤其是对进度、质量和效果的拿捏上\n   * 目标发生变化了，没有及时同步给相关的人员\n* 不明确项目责任人\n* 依赖人的主动性\n* 沟通不到位\n\n##### b. 有效执行四要素\n* 目标清晰： 目标清晰到可以执行的程度\n* 责任明确： 有唯一的总负责人对整个项目负责\n* 机制健全： 靠机制去推进， 不能依赖人的主动性\n* 沟通到位： 共识的传递进展通报\n\n#### 3. 如何让流程机制得到有效执行\n##### a. 机制建立\n* 明确目标：即该机制要解决什么场景下的什么问题\n* 提炼应对该场景的关键点\n* 明确由谁来确保机制执行， 即谁在什么时候检查什么关键点\n* 确认操作成本\n* 沟通，并和其他执行人取得共识\n\n##### b. 建立可执行机制的原则\n* 可操作，即简单原则。\n  * 机制要以最小的学习成本和操作成本为原则，这是最首要的原则\n* 只打关节点，即关键原则。\n  * 你只要告诉大家，在哪几个最关键的节点，做什么样的动作即可，而且这样的关键点也不能太多，以不超过 5 个为宜。这样做可以大大降低执行成本，提升机制的可操作性\n* 明确到人，即问责原则。\n  * 在各个关键点由谁来跟进呢？这个问题要有明确的约定，不能完全靠人的自觉性\n* 从case中来，到case中去，即实用原则。\n  * 千万不要为了建机制而建机制，每一个机制都要有实用价值。由于机制都是有场景化特性的，当场景发生了变化，机制也要随着升级，而对于机制的重新审视和学习都意味着额外的开销，所以，每个机制的维护都是有成本的\n\n\n##### c. 建立机制、人的探讨\n* 机制不是越多越好，而是越少越好\n  * 机制的建立并不会解决问题，对机制的执行才能解决问题，而机制的建立、执行和后期维护都是需要成本的，所以，千万不要贪多，在风险可控的前提下，机制能不建就不建，能少则少\n* 关于到底是人靠谱还是机制靠谱\n  * 即便是最靠谱的员工，也会由于身体状态、精神状态、情绪状态以及外部干扰变得偶尔不靠谱，而机制的意义就在于，当人不靠谱时，事情也不至于变得很差。所以，机制是为了保证做事的“下限”的\n\n### 管理沟通\n#### 1. 沟通目的\n* **建立通道**：即建立沟通关系和沟通渠道，说白了就是你要和谁建立沟通关系，以什么方式和频度进行沟通\n* **同步信息**：也就是把相互不了解的信息同步给对方，让对方知悉了解此事。这个目的在日常沟通中非常常见，比如同步目标、汇报进度、通知通报等，即属于此类目的\n* **表达情感**：沟通只是为了表达某种情感，比如表达焦虑和压力、快乐和感谢\n* **输出影响**：比如提出建议希望对方采纳、管理上级的预期、和员工沟通绩效、向上级申请资源等等，都是希望别人能够采纳和满足自己的观点和诉求，从而达到输出自己影响的目的\n\n#### 2. 夯实不确定沟通事件中确定的部分\n* **管理逻辑**： 就是从管理角色认知和管理方法来看待该问题处理的逻辑。这是可以随着管理认知和管理经验的不断积累而不断提升的，你的管理逻辑和管理判断力会越来越可靠，应对管理沟通也就越来越有掌控感，所以这是相对稳定的一个因素\n* **沟通通道**：一个沟通通道的水平，主要体现在通道是否稳定和顺畅\n* **工具流程**：持续掌握适合自己的工具和流程，你可以使用的工具和流程，就变成了一个相对稳定因素\n* **影响力**：影响力不是一天两天的事情， 然后发挥的作用的时候也是相对稳定的，尤其是在说服影响的沟通中\n\n\n#### 3. 向上沟通\n##### a. 能不和上级聊就不聊\n1. 沟通意愿：如果作为一名管理者，你还不主动和上级沟通的话，那就相当于已经上大学了，还要家长和老师逼着做作业一样，还怎么带着团队前进\n2. 事务特点：根据事务的特点来确定沟通频率和方式， 例如：紧急、重要、敏感\n3. 沟通风格： 审视上级沟通对象来选择沟通方式和风格\n4. 信任关系：你需要花多大精力去准备沟通，很大程度上取决于你和上级的沟通通道的品质。信任决定着你们沟通关系的稳定性，默契代表着你们沟通关系的效率和性能。\n\n##### b. 拿捏不好和上级聊的分寸和尺度\n1. 这次沟通能给你带来什么价值\n2. 这次沟通能为上级带来什么价值\n\n##### c. 很难领会到上级意图\n1. 你想表达的、你实际表达的、对方听到的、对方对应听到内容的理解\n2. 多回放：你是不是这个意思、你看我的理解是否准确\n\n##### d. 如何影响上级的一些观点和决策\n1. 术：说服一个人时， 在于：沟通行为、内容、方式、风格\n2. 势：说服效果影响更大的因素：影响力、职权影响、非职权影响\n\n\n#### 4. 横向沟通和非职权沟通\n1. 积累信任：a. 信表现：你一向很靠谱 b. 信人品：做事公平公正\n2. 打磨专业：a. 信权威：你是这方面专业人士 b. 信逻辑：论据充分，逻辑清晰\n3. 着眼互惠：a. 信双赢：为你带来什么好处 b. 信平衡：我帮你搞定这个问题\n4. 运用情绪: 展示个人做事气魄\n\n\n#### 5. 向下沟通\n##### a. 如何批评员工\n1. 批评人原则\n   1. 对事不对人原则： 批评事，不要打击人， 更不能给别人贴标签\n   2. 具体事情原则：指出具体哪里不好， 让对方认同\n   3. 面向未来原则：提供改变的出口和方向\n1. 批评人步骤\n   1. 指出具体的言行上的问题， 而不是人的问题\n   2. 指出该问题带来的影响\n   3. 期待的结果；探讨取得期待结果的行动\n\n##### b. 如何解决和员工沟通不顺畅\n1. 对于内向沉默的员工：**工作话题不局限于工作，跟员工建立起沟通关系和沟通通道**\n   1. 找到关切点：我看到日常喜欢xx、我看到取得了xx成绩\n   2. 表达欣赏：很有挑战、很了不起\n   3. 表示好奇：我很想知道你是怎么做到的\n   4. 持续挖掘：还有呢？\n2. 对于聊不到一个频道的员工\n3. 对于捉摸不透的员工：减少沟通偏差，多用回放沟通方式， 例如你是不是这个意思？你看我理解对不对？\n\n##### c. 如何和牛人员工沟通\n1. 作为管理者，你如果还在和自己团队的架构师在技术上一较高下，甚至是“你死我活”地争执，那么这就不是一个沟通问题，而是一个典型的管理问题，确切地说，是**管理角色认知问题**\n2. 管理牛人的四个原则\n   1. 认清自己角色：作为团队的leader,带领而非控制，要站在更高的视角\n   2. 认同高工：认同高工价值及其专业性，给予发挥空间\n   3. 支持高工：a. 澄清目标 b. 协调资源  c. 拿到结果\n   4. 约束高工：a. 评价权限 b. 制约砝码\n\n##### d. 如何和刺头员工沟通\n1. 定义刺头员工：那些需要你付出非常多的时间和精力去管理的员工\n2. 评判刺头员工价值的原则：\n   1. 团队：从破坏性到建设性\n   2. 做事：从破坏性到建设性\n\n#### 6. 管理沟通常见的坑\n##### a. 视角问题：仅从自己出发，对管理者的角色和视角认知不够\n1. 表现为：评审产品设计时候，怎么会有这么二的设计，一点逻辑都没有\n2. 错误点：这不是我团队的事情， 问题都是别人团队的\n3. 解决方法：管理者是用团队业绩来评估价值的，即便不是管理者个人的原因，只要结果是团队不出业绩，那么管理者的价值就很难体现；管理者要做出好的业绩，就需要站高一层，站在自己上级的视角来和各个团队协同，以收获共同期待的成果\n\n##### b. 姿态问题：总是在防卫，随时准备战斗\n1. 表现为：\n2. 错误点：\n3. 解决方法：防卫姿态对于管理者做好工作不会有正向价值，长此以往，就等于关闭了别人提供帮助的大门，任其自生自灭，这显然是个双输的结果；工作中最好还是以做事为主，少考虑一些个人感受。如果就事论事地去沟通问题，反而会赢得更多合作者的尊重\n\n##### c. 方式问题：给人贴标签，对人不对事\n1. 表现为：\n   1. 你怎么这么不靠谱，这么简单的事儿你都搞不定！\n   2. 这是一种“对人不对事”的沟通，你已经给对方贴上了负面的“标签”，而一旦给人贴上了标签，对方也就放弃了改变自己的意愿，失去了改变自己的动力\n2. 错误点：管理者就是想发泄情绪、管理者借情绪表达自己对下属和合作方的期待\n3. 解决方法：学会管理自己的情绪，就事论事地来讨论事情\n\n##### d. 意识问题：沟通没形成闭环\n1. 表现为：你安排了一项任务石沉大海\n2. 错误点：认为消息和邮件发出去了，接收到的人就应该都及时看到；任务安排出去了，别人就得无失真地接收到\n3. 解决方法：对于你关心的问题，一定要去确认清楚，跟进到底，形成沟通闭环\n\n##### e. 初衷问题：只给抱怨不给建议\n1. 表现为：\n   1. “这个规定太不合理了，没法遵守！”——那么，怎么样就合理了？\n   2. “我们在指定日期肯定做不完，没戏！”——那么，什么条件满足之后，就能做完呢？或者，认为什么时候能做完？\n2. 错误点：就是发泄抱怨，并没有给出应对的建议和解决方案\n3. 解决方法：我们也许并不需要完美地解决这个问题，而只需要把一个 40 分的状态改善到 60 分就行了，或者即便没有改善到 60 分，我们也把事情往好的方向上推进了一点点，这也是我们的价值\n\n### 管理路径\n#### 1. 空降的方法论\n空降时你对“车”“马”“路”和“方向”都还不熟悉，当然是你运用自己管理方法论的重要时刻\n\n**空降成功的标准**\n1. 和新同事建立起了良好的信任和协作关系，尤其是和直接上级及重要下级\n2. 交付出明确的、符合公司和上级期待的成果和价值\n3. 只要你愿意，你可以在该公司的该职位上持续做下去，上级和公司是欢迎的\n\n**如何达成成功空降**\n1. 牢记初衷(角色认知)：你到底想要的是什么？你能为上级、下级和公司带来哪些价值呢？”通过问自己这个问题，我会秉持一种帮助公司、帮助上级和下属的初衷，把我们的利益全部统一起来， 谁也不会拒绝你给他带来支持和帮助的。\n2. 对齐期待(角色认知)：\n   1. 区分头衔和角色：CTO、技术VP、技术总监、技术经理等头衔，但是你得清楚，这只是你的头衔，并不是你的工作“角色”。即使是同一个头衔，在不同公司所需要承担的角色可能是千差万别的，所以，不要指望按照头衔去筹划自己的工作，就可以满足上级和公司的期待\n   2. 厘清自己的“角色”：都会问未来上级一个问题“长期我们很难约定，仅就我入职后的前三个月或前六个月，你觉得我做好哪三件事，你会对我的工作比较满意？”\n3. 兑现承诺： 承诺并兑现，是快速获取上级信任的有效途径\n   1. 和重要相关方建立合作关系，也就是把沟通通道先建起来 --- 管理沟通\n   2. 盘点团队当前工作的轻重缓急 --- 任务管理，即“做事”\n   3. 盘点团队人员情况 --- 团队建设，即“带人”\n   4. 管理规划  --- 管理规划，即“看方向”\n\n#### 2. 管理的框架和方法论（管理全景图）\n1. **角色认知：**关于角色认知和角色澄清的方法论\n2. **管理规划：**关于带着团队看方向的方法论\n   1. **职能，**关于如何澄清团队职能定位——回答团队核心价值的方法论\n   2. **目标，**关于目标设定和目标管理的方法论\n   3. **团队，**关于团队规划的方法论\n   4. **路径，**关于路径选择和成本预算的方法论\n3. **团建建设：**关于如何带人的方法论\n   1. **能力，**关于如何培养员工工作能力的方法论\n   2. **激励，**关于如何提升员工工作意愿和积极性的方法论\n   3. **分工，**关于如何做团队分工和组织架构设计的方法论\n   4. **协作，**关于如何提升团队凝聚力和默契的方法论\n   5. **梯队，**关于如何进行梯队建设的方法论\n   6. **文化，**关于如何打造团队文化价值观的方法论\n4. **任务管理：**关于如何做事的方法论\n   1. **轻重缓急，**关于如何排优先级的方法论\n   2. **有效执行，**关于如何做项目管理或项目执行的方法论\n   3. **流程机制，**关于如何通过流程机制来提升工作质量和效率的方法论\n5. **管理沟通：**关于如何有效沟通的方法论\n   1. **目的，**关于如何明确沟通初衷和目的的方法论\n   2. **内容，**关于如何确保信息有效传递的方法论\n   3. **通道，**关于如何建立和增进沟通关系的方法论\n   4. **职权影响，**关于不断理解职能影响力的方法论\n   5. **非职权影响，**关于提升和运用职权之外的影响力的方法论\n\n\n<br />\n文章来源： 技术管理和实践","tags":["个人成长","角色认知","团队建设","管理规划","任务执行","管理沟通"]},{"title":"serverless与前端研发模式 [转载]","url":"/2021/11/18/serverless与前端研发模式/","content":"\n### 名称解释\n> 1. IaaS:  IaaS：Infrastructure as a Service（基础设施即服务）;IaaS处于最底层，服务商提供底层/物理层基础设施资源（服务器，数据中心，环境控制，电源，服务器机房），客户自己部署和执行操作系统或应用程序等各种软件。 **例如：你提供他人厨房、煤气、炉子，他人使用基础设施， 来烤自己的披萨**\n> \n> 2. PaaS:  PaaS：Platform as a Service（平台即服务）; PaaS处于中间层，服务商提供基础设施底层服务，提供操作系统（Windows，Linux）、数据库服务器、Web服务器、域控制器和其他中间件，以及服务模型中的备份服务等中件层服务。例如IIS，.NET，Apache，MySQL …，客户自己控制上层的应用程序部署与应用托管的环境。**例如：你提供他人披萨皮，他人只要设计披萨口味， 来烤自己的披萨**\n> \n> 3. SaaS:  SaaS：Software as a Service（软件即服务）; SaaS处于最上层，服务商提供基于软件的解决方案，满足客户最终需求；如OA、CRM、MIS、ERP、HRM、CM、Office 365、iCloud、G Suite等应用，客户不需考虑任何形式的专业技术知识，获得完整的软件包，使他们的日常工作和生活变得更轻松。**例如：你提供完整的披萨，到手是一个成品；他人只要设计好自己logo， 来卖自己的披萨**\n> \n> 4. BaaS:  BaaS：Backend as a Service（后端即服务）;  服务商为客户(开发者)提供整合云后端的服务，如提供文件存储、数据存储、推送服务、身份验证服务等功能，以帮助开发者快速开发应用。\n> \n> 5. FaaS:  FaaS：Function as a service（函数即服务）; 服务商提供一个平台，允许客户开发、运行和管理应用程序功能，而无需构建和维护通常与开发和启动应用程序相关的基础架构的复杂性。 按照此模型构建应用程序是实现“无服务器”体系结构的一种方式，通常在构建微服务应用程序时使用。\n\n### 前端发展历程和挑战\n#### 1. 发展历程\n##### pc时代\n主要工作是切图、写样式、写交互、浏览器兼容； 还会做一些组件化、前后端分离的事情； ***总结就是专注于浏览器领域***\n\n##### 移动互联网时代\n跨端方向： h5、react native、 flutter；工程化方向： 基于nodejs前端工程 ***总结前端跨出了浏览器， 走向了android、ios和前端工程化*** \n\n##### serverless时代  \n前端的工作更加丰富化，从客户端走向服务端，从单端走向多端： ssr、 bff、csr、微前端 ***总结前端整体向”前端全栈化“的方向发展*** \n#### 2. 挑战\n##### 知识体系\n除了传统的js、css、node、前端框架、打包工具、前端工程化。 还会涉及到后端领域：egg、redis、网关、mysql、rpc服务等。 运维领域： 容器、监控和告警\n##### 工作内容\n除了偏前端的工作：写页面、组件、性能优化、跨端、前端工程化。 还会涉及到后端和运维的工作：bff、ssr、网关、监控告警和集群化部署\n\n### 前端面对日益复杂的业务场景\n#### 1. CSR\nCSR: 是一种目前流行的渲染方式，它依赖的是运行在客户端的JS，用户首次发送请求只能得到小部分的指引性HTML代码。第二次请求将会请求更多包含HTML字符串的JS文件。 ***使用场景：C端业务***\n#### 2. SSR\nSSR: 传统的渲染方式，由服务端把渲染的完整的页面吐给客户端。这样减少了一次客户端到服务端的一次http请求，加快相应速度，一般用于首屏的性能优化。 ***使用场景：对首屏要求高、有内容分享需求***\n\n#### 3. BFF\nBFF: Backend For Frontend (后端服务于前端) ，前后端胶水层。 ***使用场景：减少前后端沟通成本、多端应用适配、让后端更加专注于原子化服务***\n#### 4. 微前端\n微前端：微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。 ***使用场景：后端管理系统***\n\n### 传统的研发模式和挑战\n#### 1. 研发流程\n<img src=\"/img/csr.webp\" height = \"auto\" align=center />\n如图可得： \n1. cdn服务\n2. 静态server托管html。 含文件服务、登陆认证、AB 灰度等功能; 运维部署需要域名申请、lvs接入、机器资源\n3. BFF服务。 需要运维强介入，域名申请、lvs接入、机器资源。（ 如果接入网关基本无需运维介入 ）\n\n#### 2. 面临挑战\n1. 运维成本高、流程长； 需要换种qps、cpu和内存等指标\n2. 开发成本高； 不仅需要开发业务、更需要开发基础服务\n3. 机器资源利用率的浪费，无法精确预估流量 （使用k8s动态扩容可以无视）\n4. 对前端要求更高， 招聘成本更难\n   \n### 基于serverless的研发模式\n#### 1. 策略和架构\n##### 基础能力平台化\n<img src=\"/img/serverless_2.webp\" height = \"auto\" align=center />\n\n> 业务再也不需要关注前端基础服务的开发，平台提供，开箱即用，简单配置即可\n\n##### 友好的开发体验\n<img src=\"/img/serverless.webp\" height = \"auto\" align=center />\n\n> 用户在开发 SSR 和 BFF 的过程中无需感知到差异性，和开发 CSR 一样轻松\n   \n##### 整体架构\n<img src=\"/img/serverless_3.webp\" height = \"auto\" align=center />\n\n#### 2. cicd\n<img src=\"/img/ci.webp\" height = \"auto\" align=center />\n\n#### 3. 实践\n##### 目标\n1. 无感中ssr、bff开发带来的差异， 和csr开发一样轻松\n2. 支持csr到ssr到bff再到微前端**渐进式开发**\n   \n##### 1. CSR \n###### a. 开发流程\n<img src=\"/img/csr1.webp\" height = \"auto\" align=center />\n1. 前端前端开发、云编译、生成静态资源上次到cdn\n2. html入口会生成es5、es6两份，通过部署控制台配置上线， 整个过程用户只关注开发和配置\n\n###### b. 运行流程\n<img src=\"/img/csr2.webp\" height = \"auto\" align=center />\n1. 静态资源cdn\n2. html入口\n3. 浏览器Polyfill, 按需返回提高性能\n\n##### 2. SSR\n###### a. 开发流程\n<img src=\"/img/ssr1.webp\" height = \"auto\" align=center />\n1. 编译生成ssr runtime 和 启动文件\n2. 添加redis缓存组件\n3. 启动ssr server\n\n###### b. 运行流程\n<img src=\"/img/ssr2.webp\" height = \"auto\" align=center />\n1. 访问ssr入口， 到达网关， 然后到达渲染处理\n2. 查看是否有缓存，有就直接方式html; 没有就访问ssr server \n3. 超时或者异常，会兜底到web server获取csr页面 \n\n##### 3. 一体化BFF\n###### a. 开发流程\n<img src=\"/img/bff1.webp\" height = \"auto\" align=center />\n1. 项目中添加api目录， 和前端开发一样， 通过import方式引入\n2. 生成bff的runtime, 部署服务会多一个bff  server\n\n###### b. 运行流程\n<img src=\"/img/bff2.webp\" height = \"auto\" align=center />\n\n##### 4. 微前端\n###### a. 开发流程\n<img src=\"/img/micFed1.webp\" height = \"auto\" align=center />\n\n###### b. 运行流程\n<img src=\"/img/micFed2.webp\" height = \"auto\" align=center />\n\n### serverless监控和运维\n#### 1. 业务监控和指标大盘\n1. grafana报表\n   \n#### 2. 日志系统\n1. 用户行为打点日志\n#### 3. 运行时的监控和调试\n1. sentry错误监控\n2. apm前端资源和接口性能监控\n3. easy-monitor服务端性能\n\n\n<br/>\n[文章来源于](https://mp.weixin.qq.com/s/J2fHm_mR7UE65q1vSQ9xpA?st=4C7DB6F51F132A3368EFB533BCD7A842B49302A24C9477FEF33A439C6057A1F595541AEE2507F7D0CB08FD444CC58669B1141CEF1EFB448E84E1E825E66F504045EBF38276934F3E35D21BF73B76272A96E1B0AAFC936CBB482A7F390990EAE634528C4DFD88BD0F8B70FFCE7AC31F5AE9FDD6C618736BA66C81871C490D1388F6EF36CDB44ADD6259F52C61DD87E1B9BFAFBA47A642670BA4677C94EDD0D78F38F958F30B026FFF29B3CEA80EFD5E96C67F14EDB9F3EC31B62BB153DBEFC37B3A78E43240E76183903CD576EDF7A624A2FA101E6FC3CCE984436F5C7EA13572&vid=1688851884861646&cst=0B8E0646D00C493A9AF905E0F7F1AD4DB95E6574B50C74C6B2C1D12178C7839181D489E09EA6DDF4D3396322BD31131D&deviceid=fae71291-ae83-4e26-9054-666127dd2311&version=3.1.12.70057&platform=mac)","tags":["serverless","BaaS","FaaS","IaaS","PaaS","SaaS"]},{"title":"费曼学习法","url":"/2021/11/18/费曼学习法/","content":"\n### 费曼学习法\n\n#### 概念\n\n学习任何东西， **如果能用简单的话、用自己的话、不带行业内的专业术语讲给外行人听， 对方能听的懂**， 那就代表你真的掌握这个知识点了。\n\n\n\n#### 原理\n\n1. **学习知识**： 我决定要弄懂前端工程化；首先确定要学习的具体内容，然后网上找资料、github源码、自己实操等学习途径， 掌握到了前端工程化知识点\n2. **以教促学**： 把自己学习到的前端工程化知识分享给别人， 或者自己讲给自己听 ， 最次写技术博客分享\n3. **回顾过程**： 记录在分享的的过程中不好的地方、回答卡壳地方； 然后查资料、问同事填补知识漏洞\n4. **总结提炼**：  根据第三步，总结和提炼知识要点， 用自己的话、用类比等方式再深入浅出的讲一次\n\n\n<img src=\"/img/学习2.jpeg\" height = \"auto\" align=center />\n<img src=\"/img/学习1.jpeg\" height = \"auto\" align=center />\n\n#### 使用场景\n\n1. 检验**自己**是否真正的掌握了知识点\n\n2. 检验**别人**是否真正的掌握了知识点\n\n3. 通过**提问**学习新到知识点","tags":["个人成长","学习方法","费曼学习法"]},{"title":"js原型链和闭包","url":"/2021/11/04/js原型链和闭包/","content":"\n\n### 原型和原型链\n\n#### 原型概念\n每一个js对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型继承属性和方法\n#### 原型链概念\n每个实例对象（object）都有一个私有属性（称之为 \\__proto__ ）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象（\\__proto__），层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。\n\n#### 原理\n##### 1. prototype\n```js\nfunction Person() {\n\n}\n\nPerson.prototype.name = 'fanky';\nlet person1 = new Person();\nlet person2 = new Person();\nconsole.log(person1.name) // fanky\nconsole.log(person2.name) // fanky\n```\n> **函数的prototype属性指向一个对象， 这个对象正是调用该构造函数而创建的实例原型， 也就是person1 和 person2**\n\n##### 2. \\__proto__\n```js\nfunction Person() {\n\n}\nlet person = new Person();\nconsole.log(person.__proto__ === Person.prototype); // true\n```\n每一个js对象(除了 null )都具有的一个属性，叫\\__proto__，这个属性会指向该对象的原型。\n##### 3. constructor\n```js\nfunction Person() {\n\n}\nconsole.log(Person === Person.prototype.constructor); // true\n```\n\n> 每个原型都有一个 constructor 属性指向关联的构造函数\n\n##### 4. 实例和原型\n```js\n// 构造函数\nfunction Person() {\n\n}\n\n// 原型\nPerson.prototype.name = 'fanky';\n\n// 实例\nlet person = new Person();\nperson.name = 'Daisy';\nconsole.log(person.name) // Daisy\n\ndelete person.name;\nconsole.log(person.name) // fanky\n```\n> 但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.\\__proto__ ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 fanky\n\n但是万一还没有找到呢？原型的原型又是什么呢？\n\n##### 5. 原型的原型\n```js\nlet obj = new Object();\nobj.name = 'fanky'\nconsole.log(obj.name); // fanky\n```\n> 其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 \\__proto\\__ 指向构造函数的 prototype \n\n\n##### 6. 原型链\n那 Object.prototype 的原型呢: \n```js\nconsole.log(Object.prototype.__proto__ === null) // true\n```\n<img src=\"/img/prototype.png\"  alt=\"原型链\" height=\"auto\"/>\n***图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线***\n\n##### 7. hasOwnProperty\n在原型链上查询属性比较耗时，对性能有影响，试图访问不存在的属性时会遍历整个原型链。\n```js\nconst object1 = {};\nobject1.property1 = 42;\nconsole.log(object1.hasOwnProperty('property1'));\n// expected output: true\n\nconsole.log(object1.hasOwnProperty('toString'));\n// expected output: false\n```\n\n#### 作用\n##### 继承属性\n```js\nlet f = function () {\n   this.a = 1;\n   this.b = 2;\n}\nlet o = new f(); // {a: 1, b: 2}\nf.prototype.b = 3;\nf.prototype.c = 4;\nconsole.log(o.b); // 3\nconsole.log(o.c); // 4\n```\n##### 继承方法\n```js\nvar o = {\n  a: 2,\n  m: function(){\n    return this.a + 1;\n  }\n};\nconsole.log(o.m()); // 3\n\nvar p = Object.create(o); //p是一个继承自 o 的对象\np.a = 4;\nconsole.log(p.m()); // 5\n// 调用 p.m 时，'this' 指向了 p\n// 又因为 p 继承了 o 的 m 函数\n// 所以，此时的 'this.a' 即 p.a，就是 p 的自身属性 'a'\n```\n\n### 闭包\n#### 概念\n> 1. 闭包就可以在全局函数里面操作另一个作用域的局部变量\n> 2. 形成步骤： \n>     a. 外层函数嵌套内层函数 \n>     b.  内层函数使用外层函数的局部变量 \n>     c. 把内层函数作为外层函数的返回值\n#### 作用\n##### 1. 封装私有变量/模拟模块化\n```js\n   function create_counter(initial) {\n        var x = initial || 0;\n        return {\n            inc: function () {\n                x += 1;\n                return x;\n            }\n        }\n   }\n   var c1 = create_counter();\n   c1.inc(); // 1\n   c1.inc(); // 2\n   c1.inc(); // 3\n\n   var c2 = create_counter(10);\n   c2.inc(); // 11\n   c2.inc(); // 12\n   c2.inc(); // 13\n\n```\n##### 2. 做缓存\n数字累加\n##### 3. 实现代码块\n```js\nfor (var i = 0; i < 5; i++) {\n    (function(i) {\n        setTimeout(function() {\n            console.log(i)\n        }, 1000);\n    })(i);\n}\n```\n\n#### 性能考量\n##### 1. 常驻内存， 增加内存使用量\n##### 2. 使用不当的话，应用不销户，造成泄漏\n\n<br />\n[文章来源于1](https://github.com/mqyqingfeng/blog/issues/2)\n[文章来源于2](https://github.com/YvetteLau/Step-By-Step/issues/24)\n\n\n","tags":["原型链","原型","闭包"]},{"title":"浏览器数据库IndexedDB","url":"/2021/09/29/浏览器数据库indexDB/","content":"\n### IndexedDB介绍\n#### 概念\nIndexedDB是浏览器提供的本地数据库， 它可以被网页脚本创建和操作\n\n#### 特点\n1. 键值对存储。 所有的数据都可以存储， 每一个数据都有主键， 主键是唯一的、不会重复\n2. 异步。 IndexedDB操作不会锁死浏览器，用户依然可以进行其他操作； 和localstorage对比， 后者是同步的\n3. 支持事务。 意味一系列操作之中， 只要有一步失败， 整个事务就会取消， 数据库回滚到之前的状态， 不存在只改写一部分数据\n4. 同源策略。 受同源策略限制， 每一个数据库都有对应创建它的域名， 网页只能访问自身域名下数据库\n\n#### IndexedDB基本概念\n1. 数据库 -- IDBDatabase 对象。 每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库；同一个时刻，只能有一个版本的数据库存在。如果要修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成  \n2. 对象仓库 -- IDBObjectStore 对象。每个数据库包含若干个对象仓库（object store）。它类似于关系型数据库的表\n3. 索引 -- IDBIndex 对象\n4. 事务 -- IDBTransaction 对象\n5. 操作请求 -- IDBRequest 对象\n6. 指针 -- IDBCursor 对象\n7. 主键集合 -- IDBKeyRange 对象\n\n### 操作流程\n#### 1. 打开数据库\n```js\nvar request = window.indexedDB.open(databaseName, version);\n\nrequest.onerror = function (event) {\n  console.log('数据库打开报错');\n};\n\nrequest.onsuccess = function (event) {\n  db = request.result;\n  console.log('数据库打开成功');\n};\n\n// 如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件\nrequest.onupgradeneeded = function (event) {\n  db = event.target.result;\n};\n```\n\n#### 2. 新建数据库\n```js\nrequest.onupgradeneeded = function (event) {\n  db = event.target.result;\n  var objectStore;\n  if (!db.objectStoreNames.contains('person')) {\n    objectStore = db.createObjectStore('person', { keyPath: 'id' });\n  }\n}\n```\n\n#### 3. 新增数据\n新增数据指的是向对象仓库写入数据记录。这需要通过事务完成\n\n```js\nfunction add() {\n  var request = db.transaction(['person'], 'readwrite')\n    .objectStore('person')\n    .add({ id: 1, name: '张三', age: 24, email: 'zhangsan@example.com' });\n\n  request.onsuccess = function (event) {\n    console.log('数据写入成功');\n  };\n\n  request.onerror = function (event) {\n    console.log('数据写入失败');\n  }\n}\n\nadd()\n```\n\n\n#### 4. 读取数据\n读取数据也是通过事务完成。\n\n```js\n\nfunction read() {\n   var transaction = db.transaction(['person']);\n   var objectStore = transaction.objectStore('person');\n   var request = objectStore.get(1);\n\n   request.onerror = function(event) {\n     console.log('事务失败');\n   };\n\n   request.onsuccess = function( event) {\n      if (request.result) {\n        console.log('Name: ' + request.result.name);\n        console.log('Age: ' + request.result.age);\n        console.log('Email: ' + request.result.email);\n      } else {\n        console.log('未获得数据记录');\n      }\n   };\n}\n\nread();\n```\n\n#### 5. 遍历数据\n遍历数据表格的所有记录，要使用指针对象 IDBCursor。\n```js\nfunction readAll() {\n  var objectStore = db.transaction('person').objectStore('person');\n\n   objectStore.openCursor().onsuccess = function (event) {\n     var cursor = event.target.result;\n\n     if (cursor) {\n       console.log('Id: ' + cursor.key);\n       console.log('Name: ' + cursor.value.name);\n       console.log('Age: ' + cursor.value.age);\n       console.log('Email: ' + cursor.value.email);\n       cursor.continue();\n    } else {\n      console.log('没有更多数据了！');\n    }\n  };\n}\n\nreadAll()\n```\n\n\n#### 6. 更新数据\n更新数据要使用IDBObject.put()方法。\n```js\nfunction update() {\n  var request = db.transaction(['person'], 'readwrite')\n    .objectStore('person')\n    .put({ id: 1, name: '李四', age: 35, email: 'lisi@example.com' });\n\n  request.onsuccess = function (event) {\n    console.log('数据更新成功');\n  };\n\n  request.onerror = function (event) {\n    console.log('数据更新失败');\n  }\n}\n\nupdate();\n```\n\n\n#### 7. 删除数据\nIDBObjectStore.delete()方法用于删除记录。\n```js\nfunction remove() {\n  var request = db.transaction(['person'], 'readwrite')\n    .objectStore('person')\n    .delete(1);\n\n  request.onsuccess = function (event) {\n    console.log('数据删除成功');\n  };\n}\n\nremove();\n```\n\n<br>\n[文章来源](https://www.ruanyifeng.com/blog/2018/07/indexeddb.html)","tags":["IndexedDB"]},{"title":"负载均衡原理","url":"/2021/09/24/负载均衡原理/","content":"\n### 名称解释\n1. LVS: Linux Virtual Server，意即 Linux 虚拟服务器，是一个虚拟的服务器集群系统(是一个虚拟的**四层**路由交换器集群系统，根据目标地址和目标端口实现用户请求转发)\n2. SLB: 负载均衡集群，load balance，简称为LB，也可以写成service load balance，从而称之为SLB，\n3. RS: real server真正的业务服务器\n4. DS: Direstor Server调度服务器，\n5. VIP: Virtual IP，LVS 面向用户请求的 IP 地址\n6. DIP：Director Server IP，主要用于和内部主机通讯的IP地址\n7. RIP：Real Server IP\n\n### 负载均衡介绍\n#### 1. 分类\n1. 四层负载均衡：根据请求报文中的目标地址和端口进行调度; 代表软件有lvs属于tcp网络层\n2. 七层负载均衡：根据请求报文的内容进行调度，这种调度属于「代理」的方式； 代表软件有nginx、haproxy属于http应用层   \n\n#### 2. 原理\n<img src=\"/img/lvs-nat.png\" height = \"auto\" align=center />\n\n1. 当客户端请求的是集群服务时\n2. LVS 修改请求报文的目标地址为 RIP，转发至后端的 RealServer，请求到响应至业务真实机器\n3. RS返回数据报文给lvs, lvs以修改报文的地址和内容给用户\n\n\n#### 3.负载均衡历史演进\n\n##### 最终架构图\n<img src=\"/img/lvs.jpeg\" height = \"auto\" align=center />\n\n#####  疑问一： Nginx 是否多此一举，能否能直接从 LVS 打到站点层?\n1. LVS 是四层负载均衡器， lvs 只负责包的转发，只要拿出包头查看一下 ip 地址就可知道该转发哪里，很高效\n2. Nginx 是七层负载均衡器，nginx 可以根据 url 来转发流量\n\n<br >\n[文章来源1](https://liaoph.com/lvs/)\n[文章来源2](https://www.zhihu.com/question/61783920/answer/2023377962?utm_source=wechat_session&utm_medium=social&utm_oi=70356303872000&utm_content=group3_Answer&utm_campaign=shareopn)\n\n","tags":["负载均衡","lvs","slb/lb","rs"]},{"title":"从js代码转译看V8引擎","url":"/2021/09/18/从js代码转译看V8引擎/","content":"### 字节码和机器码\n1. 字节码\n   1. 是一种包含执行程序，由数值常量、引用、指令等构成的序列组成的二进制文件; **字节码是一种中间码，它比机器码更抽象，需要直译器转译后才能成为机器码的中间代码**。\n   2. 优点： 1. 不针对特定CPU架构 2. 比原始的高级语言转换成机器语言更快\n2. 机器码： 学名机器语言指令，有时也被称为原生码，**是电脑的CPU可直接解读的数据**。\n\n\n### AST（抽象语法树）\nAST： 它是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。  执行过程：源码 --> 词法分析 （Token） --> 语法分析 (AST)\n\n\n### js在v8引擎中执行\n\n#### 1. 初期V8引擎架构\n1. 第一步： 将js源码转化成AST（抽象语法树）\n2. 第二步： 通过引擎编译AST变成机器码二进制文件， 然后直接运行机器码二进制文件\n3. 第三步： 在执行第二步过程中，标记重复执行的函数，将标记的代码生成更加高效的二进制代码（缓存在内存和硬盘中）， 节省了重复编译的时间。 \n\n#### 2. 现在V8引擎架构\n1. 第一步： 将js源码转化为AST(抽象语法树)\n2. 第二步： 通过解释器将AST编译成字节码， 开始逐句对字节码解释成二进制机器码并执行\n3. 第三步： 在解释过程中，标记重复执行代码，将标记的代码通过引擎进行编译生成高效的二进制机器码， 再次运行到这个函数时只执行二进制机器码， 不用再解释字节码\n\n#### 3. 现在V8引擎引入字节码的好处\n1. 启动时间缩短。 启动时只需编码字节码， 编译字节码速度远快于二进制机器码\n2. 内存空间变小。 字节码空间小于二进制机器码\n3. 代码复杂度降低。 引入字节码大大降低V8适配不同的CPU所需要的代码复杂程度\n\n\n### js代码在现在V8引擎运行\njs源码  -->  AST  --> 字节码  --> 解释器执行  --> 机器码  --> 输出结果\n\n\n<br>\n[文章来源]（https://juejin.cn/post/6844904152745639949#heading-6）\n\n","tags":["V8引擎","AST（抽象语法树）"]},{"title":"redis日常命令","url":"/2021/09/06/redis日常命令/","content":"\n## redis是什么\nredis是key-value数据库， 支持数据持久化， 支持list、hash、set数据结构\n\n\n## 使用场景\n### a. 削峰\n常见的秒杀活动中并发请求量会非常大，为了防止我们DB宕机，需要通过中间件进行削峰限流。很简单一个应用方法，前端接受10000/s的并发请求，而后端接口只能处理100/s并发请求，那么将前端的并发请求扔到redis队列中缓存起来，最大不超过100个\n### b. 热数据\n一些系统频繁请求的数据存放到redis中减少DB压力。举个例子：每个系统中都会有字典数据，这些数据不会经常变但是访问特别频繁，将这些数据存放到redis中加快访问速度减少DB压力\n### c. 计数器\n利用redis提供的递增和递减命令实现计数器功能， 例如：计算用户请求某个接口次数\n### d. 分布式锁\n分布式服务中需要对某个资源进行保护，保证不会产生并发，通过redis的分布式锁实现\n\n## redis功能\n### a. 数据缓存\n### b. 数据持久化\n### c. 哨兵、复制\n高可用，主从同步，主库挂了哨兵自动切换备库\n### d. 集群\n\n## redis优劣势\n### a. 优势\n1. 因为redis为单线程，不存在多进程或者多线程导致的切换而消耗CPU\n2. 直接读取内存， 性能快\n\n### d. 劣势\n1. 无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善\n\n## redis 常用问题\n### 缓存穿透\n#### 介绍\n缓存穿透是指缓存服务器中没有缓存数据，数据库中也没有符合条件的数据，导致业务系统每次都绕过缓存服务器查询下游的数据库，缓存服务器完全失去了其应用的作用, 下游的数据库很容易宕机\n#### 解决方案\n1. 当查询数据库没有数据默认给缓存value设置 null 过期时间为5s或者2s具体看场景。\n2. 布隆过滤器(Bloom Filter)：可以将查询的数据条件都哈希到一个足够大的布隆过滤器中，用户发送的请求会先被布隆过滤器拦截，一定不存在的数据就直接拦截返回了，从而避免下一步对数据库的压力。\n### 缓存击穿\n#### 介绍\n缓存击穿是指当某一key的缓存过期时大并发量的请求同时访问此key，瞬间击穿缓存服务器直接访问数据库，让数据库处于负载的情况。\n#### 解决方案\n1. 异步定时更新：某一个热点数据的过期时间是1小时，那么每59分钟，通过定时任务去更新这个热点key，并重新设置其过期时间\n2. 互斥锁：在缓存处理上，通常使用一个互斥锁来解决缓存击穿的问题。简单来说就是当Redis中根据key获得的value值为空时，先锁上，然后从数据库加载，加载完毕，释放锁。若其他线程也在请求该key时，发现获取锁失败，则先阻塞。\n### 缓存雪崩\n#### 介绍\n缓存数据在相近时间大量过期或者缓存服务宕机，导致并发请求在某一时刻全部落到DB，导致DB宕机。\n#### 解决方案\n1. 过期时间随机生成\n2. 热点数据永不过期\n3. 缓存服务集群化部署，避免服务单机故障\n\n<br>\n<img src=\"/img/redis.jpg\" width=\"90%\" >\n<br>\n\n## 缓存更新策略\n1. 对一致性要求不高就设置缓存过期时间， 根据业务具体情况设置5分钟等\n2. 对一致性要求非常高：\n   1. 先删除缓存，再更新数据库。 解决方案延时双删，步骤：\n     1. **线程1删除缓存，然后去更新数据库**\n     2. **线程2来读缓存，发现缓存已经被删除，所以直接从数据库中读取，这时候由于线程1还没有更新完成，所以读到的是旧值，然后把旧值写入缓存**\n     3. **线程1，根据估算的时间，sleep，由于sleep的时间大于线程2读数据+写缓存的时间，所以缓存被再次删除**\n     4. **如果还有其他线程来读取缓存的话，就会再次从数据库中读取到最新值**\n\n   2. 先更新数据库，再删除缓存。\n     1. 解决方案引入消息队列（太复杂，不推荐）\n\n## redis常用命令\n\n1. 链接远程redis\n```js\n redis-cli -h 主机 -p 端口 -a 密码\n```\n\n2. 选择具体数据库， 一共有16个\n```js\n select 0\n```\n\n3. 获取key value\n```js\n get key ---> get NODE_BIGOLIVEE_BFF:abcdc\n```\n\n4. 获取hash value\n```js\n hmget key NODE_BIGOLIVEE_BFF:abcdc\n```\n\n5. 获取redis key 过期时间\n```js\n ttl NODE_BIGOLIVEE_BFF:abcdc\n```\n\n1. 设置redis key 过期时间\n```js\n expire NODE_BIGOLIVEE_BFF:abcdc 30  // 设置30秒后过期\n```\n\n<br />\n<br />\n1. [文章来源](https://redis.readthedocs.io/en/2.4/key.html)\n2. [文章来源](https://www.huaweicloud.com/articles/2a40a0aba67a3368598e77ebb6650aa7.html)","tags":["redis","codis集群","foss集群同步"]},{"title":"egg日志","url":"/2021/08/29/egg日志/","content":"\n\n## 使用场景\n 1. 问题排查\n 2. 应用运行状态监控\n\n## 日志特性\n1. 日志等级\n2. 统一错误日志\n3. 启动日志和运行日志分离\n4. 多进程日志\n5. 日志自动切割\n6. 日志高性能写入\n7. 日志扩展、自定义\n\n## 日志操作\n### 打印日志\n1. 应用日志： 和业务无关， 例如应用启动\n   app.logger.info()\n\n2. 请求日志： 记录请求相关日志， 日志会带上请求相关信息\n   ctx.logger.info('ctx.logger') \n   //2019-02-03 11:18:56,157 INFO 46536 [-/127.0.0.1/-/5ms GET /api/user] ctx.logger\n      \n3. this.logger: 在controller、 service等实例中获取， 会带上日志文件路径，便于快速定位问题\n   this.logger.info('this.logger');\n   //2019-02-03 11:18:56,158 INFO 46536 [-/127.0.0.1/-/5ms GET /api/user] [controller.user] this.logger\n\n ### 日志等级\n 1. NONE(默认不输出)、DEBUF --> logger.debug、INFO --> logger.info 、\bWARN ---> looger.warn、ERROR ---> looger.error  \n\n\n### 错误日志\nctx.logger.error(new Error('error')); --- > 存放路径common-error.log\n\n\n\n### 日志输出方式\n 1. 终端和日志同时会输出\n 2. local 和 unittest 环境下为 baseDir，即项目源码的根目录。\n 3. prod 和其他运行环境，都为 HOME，即用户目录，如 /home/admin。\n   \n### 框架内置日志标识\n1. ${appInfo.name}-web.log：应用输出的日志，通过上述的 ctx.logger 等打印。\n2. egg-web.log： 用于框架内核、插件日志，通过 app.coreLogger 打印。\n3. common-error.log：所有 Logger 的错误日志会统一汇集到该文件。   \n\n\n## 日志切割\n### 按天切割\n1. 这是框架的默认日志切割方式，在每日 00:01 按照 .log.YYYY-MM-DD 文件名进行切割。\n### 按文件大小切割\n```\n// config/config.default.js\nconst path = require('path');\n\nmodule.exports = appInfo => {\n  const config = {};\n\n  config.logrotator = {\n    filesRotateBySize: [\n      'egg-web.log',\n    ],\n    maxFileSize: 2 * 1024 * 1024 * 1024,\n  };\n\n  return config;\n};\n```\n         ","tags":["egg","egg-logger"]},{"title":"egg插件使用和开发","url":"/2021/08/29/egg插件开发/","content":"\n### 介绍\n#### 有了中间件为啥还要插件？\n1. 中间件是定位拦截用户请求， 并在它的前后做一件事情， 例如：鉴权、访问日志、安全检查\n2. 中间件加载是有先后顺序的， 但是中间件自身缺无法管理这种顺序， 只能交给使用者\n3. 一些非常复杂的初始化逻辑， 需要在应用启动的时候完成， 如果放在中间件就不合适\n\n#### 中间件、插件、应用的关系\n一个插件就是一个迷你版的应用， 包含：\n1. 包含了：Service、中间件、配置、扩展等\n2. 没有 Controller 和 Router\n3. 没有plugin.js, 只能声明跟其他插件的依赖， 不能决定插件是否开启\n4. 插件本身可以包含中间件\n\n\n### 使用\n#### 1. plugin.js参数的配置\n1. {Boolean} enable - 是否开启此插件，默认为 true\n2. {String} package - npm 模块名称，通过 npm 模块形式引入插件\n3. {String} path - 插件绝对路径，跟 上一个参数package 配置互斥\n4. {Array} env - 只有在指定运行环境才能开启，会覆盖插件自身 package.json 中的配置\n\n#### 2. egg内置插件\n关闭内置插件\n```js\n// config/plugin.js\nexports.cors = {\n  enable: false;\n};\n\n// 也可以简写为：\nexports.cors = false;\n```\n3. package 和 path\n* package 是 npm 方式引入，也是最常见的引入方式\n* path 是绝对路径引入，如应用内部抽了一个插件，但还没达到开源发布独立 npm 的阶段，或者是应用自己覆盖了框架的一些插件\n\n```js\n// config/plugin.js\nconst path = require('path');\nexports.mysql = {\n  enable: true,\n  path: path.join(__dirname, '../lib/plugin/bg-mysql'),\n};\n```\n\n#### 3. 内置插件列表\n1. 异常处理 onerror \n2. session实现 session\n3. 安全 security\n4. 日志分割 logrotator\n5. 定时任务 schedule\n6. 模板引擎 view\n7. 文件流式上传 multpart \n8. 等等...\n### 开发\n#### 1. 脚手架快速开发\n```js\nmkdir egg-test && cd egg-test\nnpm init egg --type=plugin\nnpm i\nnpm test\n```\n\n### 插件使用场景\n#### 1. 扩展内置对象接口\n1. app/extend/request.js - 扩展 Koa#Request 类\n2. app/extend/response.js - 扩展 Koa#Response 类\n3. app/extend/context.js - 扩展 Koa#Context 类\n4. app/extend/helper.js  - 扩展 Helper 类\n5. app/extend/application.js - 扩展 Application 类\n6. app/extend/agent.js - 扩展 Agent 类\n\n#### 2. 插入自定义中间件\n```js\n// 启动前想读取一些本地配置\n// ${plugin_root}/app.js\nconst fs = require('fs');\nconst path = require('path');\n\nmodule.exports = app => {\n  app.customData = fs.readFileSync(path.join(app.config.baseDir, 'data.bin'));\n\n  app.coreLogger.info('read data ok');\n};\n```\n#### 3. 设置定时任务\n```js\n// 1. package.json\n{\n  \"name\": \"your-plugin\",\n  \"eggPlugin\": {\n    \"name\": \"your-plugin\",\n    \"dependencies\": [ \"schedule\" ]\n  }\n}\n\n\n//2.  ${plugin_root}/app/schedule/\nexports.schedule = {\n  type: 'worker',\n  cron: '0 0 3 * * *',\n  // interval: '1h',\n  // immediate: true,\n};\n\nexports.task = async ctx => {\n  // your logic code\n};\n```\n\n### 插件开发实践\n#### 1. 之前插件存在问题\n1. 在一个应用中同时使用同一个服务的不同实例（连接到两个不同的 MySQL 数据库）。\n2. 从其他服务获取配置后动态初始化连接（从配置中心获取到 MySQL 服务地址后再建立连接）。\n   \n#### 2. 实现\n如果让插件各自实现，可能会出现各种奇怪的配置方式和初始化方式，所以框架提供了 app.addSingleton(name, creator) 方法来统一这一类服务的创建。需要注意的是在使用 app.addSingleton(name, creator) 方法时，配置文件中一定要有 client 或者 clients 为 key 的配置作为传入 creator 函数 的 config。\n\n```js\n// egg-mysql/app.js\nmodule.exports = app => {\n  // 第一个参数 mysql 指定了挂载到 app 上的字段，我们可以通过 `app.mysql` 访问到 MySQL singleton 实例\n  // 第二个参数 createMysql 接受两个参数(config, app)，并返回一个 MySQL 的实例\n  app.addSingleton('mysql', createMysql);\n}\n\n\nasync function createMysql(config, app) {\n  // 异步获取 mysql 配置\n  const mysqlConfig = await app.configManager.getMysqlConfig(config.mysql);\n  assert(mysqlConfig.host && mysqlConfig.port && mysqlConfig.user && mysqlConfig.database);\n  // 创建实例\n  const client = new Mysql(mysqlConfig);\n\n  // 做启动应用前的检查\n  const rows = await client.query('select now() as currentTime;');\n  app.coreLogger.info(`[egg-mysql] init instance success, rds currentTime: ${rows[0].currentTime}`);\n\n  return client;\n}\n```\n\n\n#### 3. 应用层面使用案例\n##### 单实例\n```js\n// config/config.default.js\nmodule.exports = {\n  mysql: {\n    client: {\n      host: 'mysql.com',\n      port: '3306',\n      user: 'test_user',\n      password: 'test_password',\n      database: 'test',\n    },\n  },\n};\n\n// app/controller/post.js\nclass PostController extends Controller {\n  async list() {\n    const posts = await this.app.mysql.query(sql, values);\n  },\n}\n```\n\n##### 多实例\n```js\n// config/config.default.js\nexports.mysql = {\n  clients: {\n    // clientId, access the client instance by app.mysql.get('clientId')\n    db1: {\n      user: 'user1',\n      password: 'upassword1',\n      database: 'db1',\n    },\n    db2: {\n      user: 'user2',\n      password: 'upassword2',\n      database: 'db2',\n    },\n  },\n  // default configuration for all databases\n  default: {\n    host: 'mysql.com',\n    port: '3306',\n  },\n}\n\n// app/controller/post.js\nclass PostController extends Controller {\n  async list() {\n    const posts = await this.app.mysql.get('db1').query(sql, values);\n  },\n}\n```\n\n##### 动态创建实例 \n```js\n// app.js\nmodule.exports = app => {\n  app.beforeStart(async () => {\n    // 从配置中心获取 MySQL 的配置 { host, post, password, ... }\n    const mysqlConfig = await app.configCenter.fetch('mysql');\n    // 动态创建 MySQL 实例\n    app.database = await app.mysql.createInstanceAsync(mysqlConfig);\n  });\n};\n\n\n// app/controller/post.js\nclass PostController extends Controller {\n  async list() {\n    const posts = await this.app.database.query(sql, values);\n  },\n}\n```\n\n### 插件寻址规则\n1. 优先级A: 如果配置了 path，直接按照 path 加载\n2. 优先级B: 没有 path 根据 package 名去查找，查找的顺序依次是：\n  * 应用根目录下的 node_modules\n  * 应用依赖框架路径下的 node_modules\n  * 当前路径下的 node_modules （主要是兼容单元测试场景）\n\n\n\n<br >\n[文章来源1](https://eggjs.org/zh-cn/basics/plugin.html)\n[文章来源2](https://eggjs.org/zh-cn/advanced/plugin.html)","tags":["egg","plugin","egg插件"]},{"title":"web页面性能关键指标","url":"/2021/08/23/web页面性能关键指标/","content":"### 前言\n对于前端页面性能的评估，一般是两种形式：\n1. 一种是使用性能分析工具，在线对网页各项指标进行打分评估, 例如：Lighthouse。\n2. 一种是使用性能监控，通过 performance api 或者自定义的埋点上报用户网络真实的访问情况，然后进行统计分析。\n\n### 核心指标\n#### 1.FP && FCP\n白屏时间：页面开始有内容的时间，在没有内容之前是白屏\n\n#### 2.FSP\n首屏时间： 可视区域内容已完全呈现的时间\n\n#### 3.FCI\n可交互时间：用户第一次可以与页面交互的时间\n#### 4.TTl\n可流畅交互时间：用户第一次可以持续与页面交互的时间\n\n### 页面呈现过程相关指标\n#### 1. 文档加载\n##### time to first byte (TTFB)\nTTFB: 浏览器从请求页面开始到接收第一字节的时间，这个时间段内包括 DNS 查找、TCP 连接和 SSL 连接。\n##### domContentLoaded (DCL)\nDCL: HTML 文档被完全加载和解析完成之后, 无需等待样式表、图像和子框架加载完成\n##### load (L)\nL:  页面所有资源都加载完毕后（比如图片，CSS）\n\n#### 2. 内容呈现\n##### first paint (FP)\nFP: 从开始加载到浏览器首次绘制像素到屏幕上的时间，也就是页面在屏幕上首次发生视觉变化的时间; **这是开发人员关心页面加载的第一个关键时刻 --- 当浏览器开始呈现页面时**\n##### first contentful paint (FCP)\nFCP：浏览器首次绘制来自 DOM 的内容的时间，内容必须是文本、图片（包含背景图）、非白色的 canvas 或 SVG。 这是用户第一次开始看到页面内容，但仅仅有内容，并不意味着它是有用的内容（例如 Header、导航栏等），也不意味着有用户要消费的内容\n\n##### largest meaningful paint (LMP)\n\n##### largest contentful paint (LCP)\nLCP: 可视区域中最大的内容元素呈现到屏幕上的时间，用以估算页面的主要内容对用户可见时间\n##### first screen paint (FSP)\nFSP: 页面从开始加载到首屏内容全部绘制完成的时间，用户可以看到首屏的全部内容\n#### 3. 交互响应\n##### first cpu idle (FCI)\nFCI: 用户第一次可以与页面交互的时间\n##### time to interactive (TTI)\nTTI: 用户第一次可以持续与页面交互的时间\n\n### 页面性能评分计算公式\nhttps://googlechrome.github.io/lighthouse/scorecalc/\n\n\n<br/>\n[文章参考1](https://zhuanlan.zhihu.com/p/98880815)\n[文章参考2](https://juejin.cn/post/6844904153869713416)\n[文章参考3](https://segmentfault.com/a/1190000038421305)","tags":["web性能指标","fp","fcp","fmp","tti"]},{"title":"前端鉴权方式","url":"/2021/08/22/前端鉴权方式/","content":"\n## 前端鉴权背景\n原因：**http请求无状态**\n\n<br>\n<img src=\"/img/oauth2.jpg\" width=\"90%\" >\n<br>\n\n## 鉴权方式\n\n### 1. 初窥：前端全局变量、sessionStorage、localStorage\n#### a. 利弊\n1. 全局变量不利于持久化， 一刷新页面就没有\n2. sessionStorage、localStorage虽可以持久化，但操作麻烦，要前端存、前端手动带上给服务端\n\n### 2. 基础：前端存储cookie\n#### a. 介绍\n相比sessionStorage、localStorage等本方式，借助 HTTP 头、浏览器能力，**cookie 可以做到前端无感知**\n\n#### b. 原理\n1. 在提供标记的接口，通过 HTTP 返回头的 Set-Cookie 字段，直接「种」到浏览器上\n2. 浏览器发起请求时，会自动把 cookie 通过 HTTP 请求头的 Cookie 字段，带给接口\n\n\n### 2. 方案一：服务端session\n#### a. 介绍\n<img src=\"/img/session.webp\" height = \"auto\" />\n\n1. 浏览器登录发送账号密码，服务端查用户库，校验用户\n2. 服务端把用户登录状态存为 Session，生成一个 sessionId\n3. 通过登录接口返回，把 sessionId set 到 cookie 上\n4. 此后浏览器再请求业务接口，sessionId 随 cookie 带上\n5. 服务端查 sessionId 校验 session\n6. 成功后正常做业务处理，返回结果\n\n#### b.服务端存储\n1. redis: 内存型数据库，性能好\n2. mysql: 性能不高\n3. 应用内存: 重启就没了\n\n#### c.问题\n1. 服务端存放session\n2. 分布式存储session\n\n### 3. 方案二：token\n#### a. 介绍\n<img src=\"/img/token.webp\" height = \"auto\" />\n\n1. 用户登录，服务端校验账号密码，获得用户信息\n2. 把用户信息、token 配置编码成 token，通过 cookie set 到浏览器\n3. 此后用户请求业务接口，通过 cookie 携带 token\n4. 接口校验 token 有效性，进行正常业务接口处理\n\n#### b. 步骤\n1. 存储方式： 前端cookie\n2. 存储内部： 被编码过的有效期、使用现在、用户信息\n\n#### c. 编码\n1. base64\n2. 签名防篡改\n\n#### d. 问题\n1. 新增cookie数量\n2. cookie格式没有规范\n### 4. 方案三：jwt\n#### a. 介绍和格式\n jwt(json web token)是一个开放标准，定义了一种传递 JSON 信息的方式。这些信息通过数字签名确保可信。\n<img src=\"/img/jwt.webp\" height = \"auto\" width=\"90%\" />\n\n#### b. 原理\n<img src=\"/img/jwt1.webp\" height = \"auto\" />\n1. access token：用来访问业务接口，由于有效期足够短，盗用风险小，也可以使请求方式更宽松灵活\n2. refresh token ：用来获取 access token，有效期可以长一些，通过独立服务和严格的请求方式增加安全性；由于不常验证，也可以如前面的 session 一样处理\n\n#### c. session和token的区别\n1. session：我们通常认为 session 是「种在 cookie 上、数据存在服务端」的认证方案\n2. token： token 是「客户端存哪都行、数据存在 token 里」的认证方案\n\n\n### 5. sso (单点登录)\n#### a. 介绍\n一次登录，全线通用」的能力，叫做「单点登录」\n\n#### b. “假的”单点登录\n如果业务系统都在同一主域名下，比如wenku.baidu.com、tieba.baidu.com，就好办了。可以直接把 cookie domain 设置为主域名 baidu.com，百度也就是这么干的\n\n#### c. \"真实\"单点登录\na.com、b.com、c.com一次登录， 全系统可用\n<img src=\"/img/sso.webp\" height = \"auto\" />\n\n1. 用户进入 A 系统，没有登录凭证（ticket），A 系统给他跳到 SSO\n2. SSO 没登录过，也就没有 sso 系统下没有凭证（注意这个和前面 A ticket 是两回事），输入账号密码登录\n3. SSO 账号密码验证成功，通过接口返回做两件事：一是种下 sso 系统下凭证（记录用户在 SSO 登录状态）；二是下发一个 ticket\n4. 客户端拿到 ticket，保存起来，带着请求系统 A 接口\n5. 系统 A 校验 ticket，成功后正常处理业务请求\n6. 此时用户第一次进入系统 B，没有登录凭证（ticket），B 系统给他跳到 SSO\n7. SSO 登录过，系统下有凭证，不用再次登录，只需要下发 ticket\n8. 客户端拿到 ticket，保存起来，带着请求系统 B 接口\n\n#### d. 完整版sso\n<img src=\"/img/sso1.webp\" height = \"auto\" />\n\n1. 在 SSO 域下，SSO 不是通过接口把 ticket 直接返回，而是通过一个带 code 的 URL 重定向到系统 A 的接口上，这个接口通常在 A 向 SSO 注册时约定\n2. 浏览器被重定向到 A 域下，带着 code 访问了 A 的 callback 接口，callback 接口通过 code 换取 ticket\n3. 这个 code 不同于 ticket，code 是一次性的，暴露在 URL 中，只为了传一下换 ticket，换完就失效\n4. callback 接口拿到 ticket 后，在自己的域下 set cookie 成功\n5. 在后续请求中，只需要把 cookie 中的 ticket 解析出来，去 SSO 验证就好\n6. 访问 B 系统也是一样\n\n## 鉴权总结\n##### 1. HTTP 是无状态的，为了维持前后请求，需要前端存储标记\n##### 2. cookie 是一种完善的标记方式，通过 HTTP 头或 js 操作，有对应的安全策略，是大多数状态管理方案的基石\n##### 3. session 是一种状态管理方案，前端通过 cookie 存储 id，后端存储数据，但后端要处理分布式问题\n##### 4. token 是另一种状态管理方案，相比于 session 不需要后端存储，数据全部存在前端，解放后端，释放灵活性\n##### 5. token 的编码技术，通常基于 base64，或增加加密算法防篡改，jwt 是一种成熟的编码方案\n##### 6. 在复杂系统中，token 可通过 service token、refresh token 的分权，同时满足安全性和用户体验\n##### 7. session 和 token 的对比就是「用不用cookie」和「后端存不存」的对\n##### 8. 单点登录要求不同域下的系统「一次登录，全线通用」，通常由独立的 SSO 系统记录登录状态、下发 ticket，各业务系统配合存储和认证 ticket\n\n\n\n[文章来源于](https://mp.weixin.qq.com/s/GlSpsx3KY6oPLzS3HzGXPw)\n\n\n\n\n","tags":["前端鉴权","token","cookie","session","jwt","单点登录"]},{"title":"node中使用redis做请求限流","url":"/2021/08/14/node中使用redis做请求限流/","content":"\n## 限流介绍\n请求限流用于控制网络请求和传输量的技术， 用于健全node服务应用， **通常会开启接口速率限制，来控制一定周期内最大的请求量，用于保护服务应用免遭恶意请求和流量攻击**\n\n## 限流常用算法 \n### 1. 固定窗口算法\n#### a. 介绍\n 固定窗口算法： 在固定的时间范围内，窗口大小指允许通过最大请数。 也就是一段时间内最大允许请求量; 也就是在一个周期开始的时候，计数器清零，每个请求都将被计数，若计数达到上限，则不会再响应多余的请求，直到进入下一个周期\n\n#### b. 代码实现\n```js\n// index.js\nimport { fixedWindow } from \"./middleware/fixedWindow.js\";\napp.use(fixedWindow);\n\n// middleware/ratelimit\nimport Redis from 'ioredis'\n\nconst FIX_WINDOW_SIZE = 60; // second\nconst FIX_WINDOW_MAX_REQUEST = 100;\n\nconst redisClient = new Redis(6379);\n\nexport const fixedWindow = async (ctx, next) => {\n  const redisKey = `${ctx.ip}:ratelimit`;\n  const curCount = await redisClient.get(redisKey);\n  if (!curCount) {\n    await redisClient.setex(redisKey, FIX_WINDOW_SIZE, 1);\n    next();\n    return;\n  }\n  if (Number(curCount) < FIX_WINDOW_MAX_REQUEST) {\n    await redisClient.incr(redisKey);\n    next();\n  } else {\n    ctx.status = 429;\n    ctx.body = \"you have too many requests\";\n  }\n};\n```\n#### c. 缺点\n<img src=\"/img/redis1.png\" height = \"auto\" align=center />\n**不平滑， 在2个窗口之间容易被攻击，图中9：03 - 9：04实际请求数已经超过了设置的最大上限**\n\n\n### 2. 滑动窗口算法\n#### a. 介绍\n<img src=\"/img/redis2.jpeg\" height = \"auto\" align=center />\n滑动窗口算法：这种算法是对固定窗口算法一种优化（这种算法一定范围内只有一个窗口）， 在一个周期范围内有多个窗口进行计数， 窗口越多， 算法就越平滑。\n\n#### b. 代码实现\n```js\n// 1. 在每次更新键值的时候，通过 EXPIRE 去更新 Redis Key 的过期时间\n// 2. 在每次更新键值的时候，通过 HDEL 删除在滑动窗口之前的 Hash Key\n// 3. 在每次更新键值的时候，我们需要通过 HGETALL 获取到所有 Key，然后进行进行判断：\n//      3.1 存在 Key 在最小拆分窗口的周期时间内，HINCRBY 在原有 Key 的基础上去增加 1\n//      3.2 不存在 Key 在最小拆分窗口的周期时间时，将当前时间的时间戳作为 HINCRBY 的 Key\n\n```\n\n\n### 3. 漏桶算法\n#### a. 介绍\n<img src=\"/img/redis4.png\" height = \"auto\" align=center />\n漏桶算法：api请求过程类比漏桶加水，漏桶流入速度不做限制， 而是限制漏桶流出速度； 当流入速度大于流出速度， 随着桶中水平面不断上涨， 漏桶水流就会溢出，\n\n\n#### b. 代码实现\n\n\n### 4. 令牌桶算法\n#### a. 介绍\n<img src=\"/img/redis3.png\" height = \"auto\" align=center />\n令牌桶算法：定义了一个集合（也就是桶）， 集合中容纳一定数量的令牌， api被请求一次消耗一个令牌； 如集合中没有令牌则不允许请求通过， 集合通过一定的速率去生成新的令牌， 以此达到限流的作用。\n\n\n#### b. 代码实现\n```js\n//1. 当请求进来时，初始化一个令牌桶与过期时间，其中每次进行更新操作，都需要设置令牌桶的过期时间为需要补充的令牌数\n// 2. 计算当前最新的令牌数为多少，判断是否请求能拿到令牌：\n//   2.1 若请求能拿到令牌，则更新最新的令牌数与更新时间\n//   2.2 若不能拿到令牌，将该请求抛弃\n\n\n```\n## redis-cell模块\n\n## nginx 限制IP的连接和并发达到限流 \n\n\n[参考文章1](https://vv13.cn/blog/post/Algorithm/20200902_%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%9C%A8Node.js%E4%B8%AD%E4%BD%BF%E7%94%A8Redis%E5%81%9A%E8%AF%B7%E6%B1%82%E9%99%90%E6%B5%81/)\n\n[参考文章2](http://www.html.cn/qa/node-js/10803.html)","tags":["node限流","redis"]},{"title":"网络7层模型和4层模型","url":"/2021/08/12/网络7层模型和4层模型/","content":"\n### 7层和4层模型介绍\nOSI 和TCP/IP 的对应关系和协议：\n<img src=\"/img/osi.jpeg\" height = \"auto\" align=center />\n\n\n### 7层模型作用\nOSI对应的作用：\n<img src=\"/img/osi1.jpeg\" height = \"auto\" align=center />\n\n\n### tcp和udp区别\n1. TCP是面向连接的，UDP是面向无连接的。TCP在通信之前必须通过三次握手机制与对方建立连接，而UDP通信不必与对方建立连接，不管对方的状态就直接把数据发送给对方 \n1. TCP连接过程耗时，UDP不耗时 \n1. TCP连接过程中出现的延时增加了被攻击的可能，安全性不高，而UDP不需要连接，安全性较高 \n1. TCP是可靠的，保证数据传输的正确性，不易丢包;UDP是不可靠的，易丢包 \n1. tcp传输速率较慢，实时性差，udp传输速率较快。tcp建立连接需要耗时，并且tcp首部信息太多，每次传输的有用信息较少，实时性差。 \n1. tcp是流模式，udp是数据包模式。tcp只要不超过缓冲区的大小就可以连续发送数据到缓冲区上，接收端只要缓冲区上有数据就可以读取，可以一次读取多个数据包，而udp一次只能读取一个数据包，数据包之间独立\n\n\n### 封装 和 解封\n#### 1. 封装过程\n<img src=\"/img/tcp1.webp\" height = \"auto\" align=center />\n\n#### 2. 解封过程\n<img src=\"/img/tcp2.webp\" height = \"auto\" align=center />\n\n\n\n<br />\n[文章来源于](https://mp.weixin.qq.com/s/2f7WoFIAFGVPeRUg4--xNw)","tags":["OSI模型","TCP/IP模型","网络模型"]},{"title":"egg加载器","url":"/2021/07/19/egg加载器/","content":"\n### 加载器\nEgg 在 Koa 的基础上进行增强最重要的就是基于一定的约定，根据功能差异将代码放到不同的目录下管理，对整体团队的开发成本提升有着明显的效果。Loader 实现了这套约定，并抽象了很多底层 API 可以进一步扩展\n\n\n### 框架、插件和应用的关系\n#### 1. 框架继承\n```js\n+-----------------------------------+--------+\n|      app1, app2, app3, app4       |        |\n+-----+--------------+--------------+        |\n|     |              |  framework3  |        |\n+     |  framework1  +--------------+ plugin |\n|     |              |  framework2  |        |\n+     +--------------+--------------+        |\n|                   Egg             |        |\n+-----------------------------------+--------|\n|                   Koa                      |\n+-----------------------------------+--------+\n```\n\n#### 2. 加载单元执行顺序\n***文件按表格内的顺序自上而下加载***\n<img src=\"/img/egg.png\" height = \"auto\" align=center />\n> - 按插件 => 框架 => 应用依次加载\n> - 插件之间的顺序由依赖关系决定，被依赖方先加载，无依赖按 object key 配置顺序加载，具体可以查看插件章节\n> - 框架按继承顺序加载，越底层越先加载。\n\n#### 3. 加载单元生命周期\n1. 配置文件即将加载，这是最后动态修改配置的时机（configWillLoad）\n2. 配置文件加载完成（configDidLoad）\n3. 文件加载完成（didLoad）\n4. 插件启动完毕（willReady）\n5. worker 准备就绪（didReady）\n6. 应用启动完成（serverDidReady）\n7. 应用即将关闭（beforeClose）\n\n### 加载器函数\n#### 1. loadFile\n```\n// 用于加载一个文件，比如加载 app/xx.js 就是使用这个方法\n// app/xx.js\nmodule.exports = app => {\n  console.log(app.config);\n};\n\n// app.js\n// 以 app/xx.js 为例，我们可以在 app.js 加载这个文件\nconst path = require('path');\nmodule.exports = app => {\n  app.loader.loadFile(path.join(app.config.baseDir, 'app/xx.js'));\n};\n```\n#### 2. loadToApp\n```\n// 用于加载一个目录下的文件到 app，比如 app/controller/home.js 会加载到 app.controller.home。\n// app.js\n// 以下只是示例，加载 controller 请用 loadController\nmodule.exports = app => {\n  const directory = path.join(app.config.baseDir, 'app/controller');\n  app.loader.loadToApp(directory, 'controller');\n};\n```\n\n#### 3. loadToContext\n```\n// 与 loadToApp 有一点差异，loadToContext 是加载到 ctx 上而非 app，而且是懒加载。加载时会将文件都放到一个临时对象上，在调用 ctx API 时才实例化对象。\n// 以下为示例，请使用 loadService\n// app/service/user.js\nconst Service = require('egg').Service;\nclass UserService extends Service {\n\n}\nmodule.exports = UserService;\n\n// app.js\n// 获取所有的 loadUnit\nconst servicePaths = app.loader.getLoadUnits().map(unit => path.join(unit.path, 'app/service'));\n\napp.loader.loadToContext(servicePaths, 'service', {\n  // service 需要继承 app.Service，所以要拿到 app 参数\n  // 设置 call 在加载时会调用函数返回 UserService\n  call: true,\n  // 将文件加载到 app.serviceClasses\n  fieldClass: 'serviceClasses',\n});\n```\n\n### CustomLoader\nloadToContext 和 loadToApp 可被 customLoader 配置替代。\n```\n// app.js\nmodule.exports = app => {\n  const directory = path.join(app.config.baseDir, 'app/adapter');\n  app.loader.loadToApp(directory, 'adapter');\n};;\n\n=====\n变成：\n=====\n\n// config/config.default.js\nmodule.exports = {\n  customLoader: {\n    // 定义在 app 上的属性名 app.adapter\n    adapter: {\n      // 相对于 app.config.baseDir\n      directory: 'app/adapter',\n      // 如果是 ctx 则使用 loadToContext\n      inject: 'app',\n      // 是否加载框架和插件的目录\n      loadunit: false,\n      // 还可以定义其他 LoaderOptions\n    }\n  },\n};\n```","tags":["egg加载器","egg loader"]},{"title":"linux常用的命令行","url":"/2021/07/09/linux常用的命令行/","content":"\n### 系统信息\n1. df -h  容易阅读的方式显示磁盘分区使用情况\n2. df /etc/dhcp  显示指定文件所在分区的磁盘使用情况\n\n### 文件和目录\n1. rm -rf dir 删除一个叫做 'dir' 的目录并同时删除其内容 \n2. mv dir new_dir 重命名/移动 一个目录 \n3. cp file1 file2 复制一个文件\n4. cp /dir/* . 复制一个**目录下的所有文件**到当前工作目录 \n5. cp /dir . 复制一个目录到当前目录\n6. tree 显示文件和目录由根目录开始的树形结构\n7. mkdir -p dir 创建目录\n8. ls -al 显示文件(隐藏文件)和目录的详细资料 \n\n### 文件搜索\n1. find / -name file1 从 '/' 开始进入根文件系统搜索文件和目录\n2. find /home/user1 -name \\*.bin 在目录 '/home/user1' 中搜索带有'.bin' 结尾的文件\n3. find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 \n\n### 文件的权限\n1. ls -lh 显示权限\n2. chown -R user directory 改变一个目录的所有人属性并同时改变改目录下所有文件的属性\n3. chown user file 改变一个文件的所有人属性\n4. chmod ugo+rwx directory 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 \n\n### 查看文件内容\n1. cat file 从第一个字节开始正向查看文件的内容 \n2. tac file 从最后一行开始反向查看一个文件的内容\n3. more file 查看一个长文件的内容 \n4. tail -f /var/log/messages 实时查看被添加到一个文件中的内容 \n5. tail -2 file 查看一个文件的最后两行 \n6. head -2 file 查看一个文件的前两行\n\n### 文本处理\n1. grep Aug /var/log/messages 在文件 '/var/log/messages'中查找关键词\"Aug\"\n2. grep ^Aug /var/log/messages 在文件 '/var/log/messages'中查找以\"Aug\"开始的词汇\n3. sed 's/stringa1/stringa2/g' example.txt 将example.txt文件中的 \"string1\" 替换成 \"string2\"\n4. sed -n '/stringa1/p' 查看只包含词汇 \"string1\"的行    \n\n### 文件传输\n1. curl https://baidu.com   curl命令是一个利用URL规则在shell终端命令行下工作的文件传输工具；它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。\n2. tftp 218.28.188.288   ftp命令用于传输文件\n\n\n### 打包压缩\n1. zip file1.zip file1 创建一个zip格式的压缩包 \n2. zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包\n3. unzip file1.zip 解压一个zip格式压缩包 \n\n### 网络\n1. ssh 202.102.240.88  安全连接客户端, 可以给予ssh加密协议实现安全的远程登录服务器，实现对服务器的远程管理。\n2. ping baidu.com/202.102.240.88     测试主机间网络连通性\n3. netstat -a          显示网络状态\n4. ipconfig            显示或设置网络设备\n\n### 进程\n1. ps -a | grep helloworld 查看特定进程  \n2. ps -ef  显示所有进程信息，连同命令行\n3. kill -9 pid 杀掉进程\n4. lsof -i:端口号  查看端口号被那个进程所占用\n\n\n### 软链接 和 硬链接\n1. Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln 命令产生硬链接\n2. 验证硬链接和软链接关系\n```bash\ntouch f1          #创建一个测试文件f1    \nln f1 f2          #创建f1的一个硬连接文件f2\nln -s f1 f3       #创建f1的一个符号连接文件f3\nls -li            # -i参数显示文件的inode节点信息\ntotal 0\n9797648 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f1\n9797648 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f2\n9797649 lrwxrwxrwx  1 oracle oinstall 2 Apr 21 08:11 f3 -> f1\n\necho \"I am f1 file\" >>f1\ncat f1\nI am f1 file\ncat f2\nI am f1 file\ncat f3\nI am f1 file\nrm -f f1\ncat f2\nI am f1 file\ncat f3\ncat: f3: No such file or directory\n```\n3. 结论：\n  1. 当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f3 文件无效\n  2. 删除符号连接f3,对f1,f2无影响；\n  3. 删除硬连接f2，对f1,f3也无影响；\n  4. 删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；\n  5. 同时删除原文件f1,硬连接f2，整个文件会真正的被删除。 \n\n\n\n[资料来源于](https://www.cnblogs.com/fnlingnzb-learner/p/5831284.html)","tags":["linux命令行","linux操作"]},{"title":"前端负责人技术图谱","url":"/2021/07/09/前端负责人技术图谱/","content":"\n\n### 综合能力\n\n#### 硬能力\n\n- 技术能力\n- 业务能力\n- 框架/架构能力\n- 规划能力\n\n#### 软能力\n\n- 沟通能力\n- 协作能力\n- 判断能力\n- 心理能力\n\n\n\n### 硬能力细分\n\n#### 技术能力\n\n- 基础技能： js、node、vue、react 、css、http、linux等\n- 工程技能：脚手架cli、cicd\n- 学习和接纳新技术能力\n- 指导和帮助组员解决技术问题\n\n#### 业务能力\n\n- 明确团队业务目标和风险\n- 梳理业务流程：泳道图\n- 业务评审： 结合业务和技术\n\n#### 规划能力\n\n- 技术体系规划： 技术选型、文档输出和沉淀\n- 人力资源规划： 人才梯队建设， 人力数量规划\n- 任务拆分规划： 任务难易度、时间、人员配备\n- 风险预判： 安全生产（质），高效交付（量）\n- 突发情况应对\n\n#### 框架/架构能力\n\n- 脚手架\n- 公共库\n- 应用监控、业务监控\n- CICD\n- 熟练驾驭相关技术（js、node、linux、容器、缓存）\n\n### 软能力细分\n\n#### 沟通能力\n\n- 沟通方式： 明确沟通主题\n- 沟通对象：领导侧重进度和风险、部门人员共享信息、团队人员统一方向和技术细节\n- 沟通结果： 让沟通对象接受什么消息（输入）、达到什么目的（输出）\n\n#### 协作能力\n\n- 对内： 产品评审、系分文档、任务拆分、任务风险、进度看板、晨会周报\n- 对外： 信息同步和共享 、 统一技术栈 \n\n#### 判断能力\n\n- 风险判断： 任务延期、业务技术实现方向出错\n- 决策判断：某个时间做什么、 事情的优先级\n- 技术判断：根据经验对技术的复杂度和方向有把控\n\n#### 心理能力\n\n- 抗压能力\n- 自我肯定\n- 自我反省\n\n\n参考：https://mp.weixin.qq.com/s/UuiHmSNXD2xU6mduIN4R0g","tags":["前端技术图谱","leader技术","前端负责人"]},{"title":"egg洋葱模型","url":"/2021/07/05/egg洋葱模型/","content":"\n### 模型介绍\n洋葱圈模型：所有的请求经过一个中间件的时候都会执行两次，对比Express形式的中间件，**洋葱圈的模型可以非常方便的实现后置处理逻辑**。 代表有egg、koa框架\n\n<img src=\"/img/middle2.png\" height = \"auto\" style=\"margin: 0 0 20px 0;\" align=center />\n<img src=\"/img/middle1.png\" height = \"auto\" align=center />\n\n\n### 代码执行顺序\n\n```\nconst Koa = require('koa');\n\nconst app = new Koa();\nconst PORT = 3000;\n\n// #1\napp.use(async (ctx, next)=>{\n    console.log(1)\n    await next();\n    console.log(1)\n});\n// #2\napp.use(async (ctx, next) => {\n    console.log(2)\n    await next();\n    console.log(2)\n})\n\napp.use(async (ctx, next) => {\n    console.log(3)\n})\n\napp.listen(PORT);\nconsole.log(`http://localhost:${PORT}`);\n\n// 打印结果\n// 1\n// 2\n// 3\n// 2\n// 1\n\n```\n\n### 使用案例\n\n\n### 原理实现\n1. 每个中间件都接收了一个next参数，在next函数运行之前的中间件代码会在一开始就执行，next函数之后的代码会在内部的中间件全部运行结束之后才执行。\n2. 实现中间件的步骤 \n   1. **首先我们要知道当前中间件的数组集合**\n   2. **然后构建一个组合方法，对这些中间件按照洋葱的结构进行组合，并执行**\n\n\n```\n// middleware用来保存中间件\napp.use = (fn) => {\n    this.middleware.push(fn)\n    return this\n}\n\n// compose组合函数来规定执行次序\nfunction compose (middleware) {\n  // context：上下文，next：传入的接下来要运行的函数\n  return function (context, next) {\n    function dispatch (i) {\n      index = i\n      // 中间件\n      let fn = middleware[i]\n      if (!fn) return Promise.resolve()\n      try {\n        // 我们这边假设和上文中的例子一样，有A、B、C三个中间件\n        // 通过dispatch(0)发起了第一个中间件A的执行\n        // A中间件执行之后，next作为dispatch(1)会被执行\n        // 从而发起了下一个中间件B的执行，然后是中间件C被执行\n        // 所有的中间件都执行了一遍后，执行Promise.resolve()\n        // 最里面的中间件C的await next()运行结束，会继续执行console.log(\"C2\")\n        // 整个中间件C的运行结束又触发了Promise.resolve\n        // 中间件B开始执行console.log(\"B2\")\n        // 同理，中间件A执行console.log(\"A2\")\n        return Promise.resolve(fn(context, () => {\n          return dispatch(i + 1)\n        }))\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n    return dispatch(0)\n  }\n}\n```\n\n[文章来源参考](https://segmentfault.com/a/1190000013981513)","tags":["egg","洋葱模型","中间件"]},{"title":"egg多进程模型和通讯","url":"/2021/06/23/egg多进程模型和通讯/","content":"\n### **名称解释**\n\n#### **cluster是啥**\n\ncluster可以通过一个父进程管理一坨子进程的方式来实现集群的功能。\n\n#### **cluster具体内容**\n\n1. 在服务器上同时启动多个进程(**一个master和多个worker; master不做具体的工作，只负责启动其他进程; worker它们接收请求，对外提供服务**)\n\n2. 每个进程里都跑的是同一份源代码（好比把以前一个进程的工作分给多个进程去做）\n\n3. 这些进程可以同时监听一个端口\n\n   \n\nnodejs实现多进程代码示例：\n\n```js\n\nconst cluster = require('cluster');\n\nconst http = require('http');\n\nconst numCPUs = require('os').cpus().length;\n\n\n\nif (cluster.isMaster) {\n\n  // Fork workers.\n\n  for (let i = 0; i < numCPUs; i++) {\n\n​    cluster.fork();\n\n  }\n\n  cluster.on('exit', function(worker, code, signal) {\n\n​    console.log('worker ' + worker.process.pid + ' died');\n\n  });\n\n} else {\n\n  // Workers can share any TCP connection\n\n  // In this case it is an HTTP server\n\n  http.createServer(function(req, res) {\n\n​    res.writeHead(200);\n\n​    res.end(\"hello world\\n\");\n\n  }).listen(8000);\n\n}\n\n```\n\n\n\n### **egg框架多进程模型**\n\n#### **进程守护**\n\n#####  node进程退出分类和解决方案\n\n- 未捕获异常\n\n  当代码抛出了异常没有被捕获到时，进程将会退出，此时 Node.js 提供了 `process.on('uncaughtException', handler)` 接口来捕获它，但是当一个 Worker 进程遇到 [未捕获的异常](https://nodejs.org/dist/latest-v6.x/docs/api/process.html#process_event_uncaughtexception) 时，它已经处于一个不确定状态，此时我们应该让这个进程优雅退出:\n\n   流程图： **1.关闭异常 Worker 进程所有的 TCP Server  --> 2. Master 立刻 fork 一个新的 Worker 进程，保证在线的『工人』总数不变  --> 3. 异常 Worker 等待一段时间，处理完已经接受的请求后退出**\n\n  ```\n  +---------+                 +---------+\n  |  Worker |                 |  Master |\n  +---------+                 +----+----+\n       | uncaughtException         |\n       +------------+              |\n       |            |              |                   +---------+\n       | <----------+              |                   |  Worker |\n       |                           |                   +----+----+\n       |        disconnect         |   fork a new worker    |\n       +-------------------------> + ---------------------> |\n       |         wait...           |                        |\n       |          exit             |                        |\n       +-------------------------> |                        |\n       |                           |                        |\n      die                          |                        |\n                                   |                        |\n                                   |                        |\n  ```\n\n- OOM(内存溢出)、系统异常\n\n  当一个进程出现异常导致 crash 或者 OOM 被系统杀死时，不像未捕获异常发生时我们还有机会让进程继续执行，只能够让当前进程直接退出，Master 立刻 fork 一个新的 Worker。  \n\n\n\n\n\n#### **agent机制**\n\n##### 背景\n\n1. 有些工作其实不需要每个 Worker 都去做，如果都做，一来是浪费资源，更重要的是可能会导致多进程间资源访问冲突。举个例子：生产环境的日志文件我们一般会按照日期进行归档。\n\n2. 对于这一类后台运行的逻辑，我们希望将它们放到一个单独的进程上去执行，这个进程就叫 Agent Worker，简称 Agent。Agent 好比是 Master 给其他 Worker 请的一个『秘书』，它不对外提供服务，只给 App Worker 打工，专门处理一些公共事务。\n\n   ```\n                   +--------+          +-------+\n                   | Master |<-------->| Agent |\n                   +--------+          +-------+\n                   ^   ^    ^\n                  /    |     \\\n                /      |       \\\n              /        |         \\\n            v          v          v\n   +----------+   +----------+   +----------+\n   | Worker 1 |   | Worker 2 |   | Worker 3 |\n   +----------+   +----------+   +----------+\n   ```\n\n\n\n##### egg启动时序图\n\n1. Master 启动后先 fork Agent 进程\n2. Agent 初始化成功后，通过 IPC 通道通知 Master\n3. Master 再 fork 多个 App Worker\n4. App Worker 初始化成功，通知 Maste\n5. 所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功\n\n```\n+---------+           +---------+          +---------+\n|  Master |           |  Agent  |          |  Worker |\n+---------+           +----+----+          +----+----+\n     |      fork agent     |                    |\n     +-------------------->|                    |\n     |      agent ready    |                    |\n     |<--------------------+                    |\n     |                     |     fork worker    |\n     +----------------------------------------->|\n     |     worker ready    |                    |\n     |<-----------------------------------------+\n     |      Egg ready      |                    |\n     +-------------------->|                    |\n     |      Egg ready      |                    |\n     +----------------------------------------->|\n```\n\n\n\n\n\n#### **agent用法**\n\n你可以在应用或插件根目录下的 `agent.js` 中实现你自己的逻辑（和[启动自定义](https://eggjs.org/zh-cn/basics/app-start.html) 用法类似，只是入口参数是 agent 对象）\n\n```js\n// agent.js\nmodule.exports = agent => {\n  // 在这里写你的初始化逻辑\n\n  // 也可以通过 messenger 对象发送消息给 App Worker\n  // 但需要等待 App Worker 启动成功后才能发送，不然很可能丢失\n  agent.messenger.on('egg-ready', () => {\n    const data = { ... };\n    agent.messenger.sendToApp('xxx_action', data);\n  });\n};\n\n// app.js\nmodule.exports = app => {\n  app.messenger.on('xxx_action', data => {\n    // ...\n  });\n};\n```\n\n\n\n#### **master和agent和worker**\n\n1. master 俗称包工头: 不做业务逻辑，只做进程管理、任务分配\n\n2. agent  俗称秘书: 定时器、打印错误日志\n\n3. worker 俗称工人: 具体业务代码\n\n| 类型   | 进程数量            | 作用                         | 稳定性 | 是否运行业务代码 |\n| ------ | ------------------- | ---------------------------- | ------ | ---------------- |\n| Master | 1                   | 进程管理，进程间消息转发     | 非常高 | 否               |\n| Agent  | 1                   | 后台运行工作（长连接客户端） | 高     | 少量             |\n| Worker | 一般设置为 CPU 核数 | 执行业务代码                 | 一般   | 是               |\n\n##### Master\n\n​    Master 进程的稳定性是极高的，线上运行时我们只需要通过 [egg-scripts](https://github.com/eggjs/egg-scripts) 后台运行通过 `egg.startCluster` 启动的 Master 进程就可以了，不再需要使用 [pm2](https://github.com/Unitech/pm2) 等进程守护模块。\n\n##### Agent\n\n在大部分情况下，我们在写业务代码的时候完全不用考虑 Agent 进程的存在，但是当我们遇到一些场景，只想让代码运行在一个进程上的时候，Agent 进程就到了发挥作用的时候了。\n\n由于 Agent 只有一个，而且会负责许多维持连接的脏活累活，因此它不能轻易挂掉和重启，所以 Agent 进程在监听到未捕获异常时不会退出，但是会打印出错误日志，**我们需要对日志中的未捕获异常提高警惕**。\n\n\n\n##### Worker\n\nWorker 进程负责处理真正的用户请求和[定时任务](https://eggjs.org/zh-cn/basics/schedule.html)的处理。而 Egg 的定时任务也提供了只让一个 Worker 进程运行的能力，**所以能够通过定时任务解决的问题就不要放到 Agent 上执行**。\n\n\n\n\n\n\n\n### **egg框架进程间通讯（IPC）**\n\n#### node进程通讯      \n\n```js\n'use strict';\nconst cluster = require('cluster');\n\nif (cluster.isMaster) {\n  const worker = cluster.fork();\n  worker.send('hi there');\n  worker.on('message', msg => {\n    console.log(`msg: ${msg} from worker#${worker.id}`);\n  });\n} else if (cluster.isWorker) {\n  process.on('message', (msg) => {\n    process.send(msg);\n  });\n}\n```\n\n细心的你可能已经发现 cluster 的 IPC 通道只存在于 Master 和 Worker/Agent 之间，Worker 与 Agent 进程互相间是没有的。那么 Worker 之间想通讯该怎么办呢？是的，通过 Master 来转发\n\n```\n广播消息： agent => all workers\n                  +--------+          +-------+\n                  | Master |<---------| Agent |\n                  +--------+          +-------+\n                 /    |     \\\n                /     |      \\\n               /      |       \\\n              /       |        \\\n             v        v         v\n  +----------+   +----------+   +----------+\n  | Worker 1 |   | Worker 2 |   | Worker 3 |\n  +----------+   +----------+   +----------+\n\n指定接收方： one worker => another worker\n                  +--------+          +-------+\n                  | Master |----------| Agent |\n                  +--------+          +-------+\n                 ^    |\n     send to    /     |\n    worker 2   /      |\n              /       |\n             /        v\n  +----------+   +----------+   +----------+\n  | Worker 1 |   | Worker 2 |   | Worker 3 |\n  +----------+   +----------+   +----------+\n```\n\n#### 发送\n\n- `app.messenger.broadcast(action, data)`：发送给所有的 agent / app 进程（包括自己）\n\n- ```\n  app.messenger.sendToApp(action, data)\n  ```\n\n  发送给所有的 app 进程\n\n  - 在 app 上调用该方法会发送给自己和其他的 app 进程\n  - 在 agent 上调用该方法会发送给所有的 app 进程\n\n- ```\n  app.messenger.sendToAgent(action, data)\n  ```\n\n  发送给 agent 进程\n\n  - 在 app 上调用该方法会发送给 agent 进程\n  - 在 agent 上调用该方法会发送给 agent 自己\n\n- ```\n  agent.messenger.sendRandom(action, data)\n  ```\n\n  - app 上没有该方法（现在 Egg 的实现是等同于 sentToAgent）\n  - agent 会随机发送消息给一个 app 进程（由 master 来控制发送给谁）\n\n- `app.messenger.sendTo(pid, action, data)`: 发送给指定进程\n\n  ```js\n  // app.js\n  module.exports = app => {\n    // 注意，只有在 egg-ready 事件拿到之后才能发送消息\n    app.messenger.once('egg-ready', () => {\n      app.messenger.sendToAgent('agent-event', { foo: 'bar' });\n      app.messenger.sendToApp('app-event', { foo: 'bar' });\n    });\n  }\n  ```\n\n  \n\n#### 接收\n\n在 messenger 上监听对应的 action 事件，就可以收到其他进程发送来的信息了。\n\n```js\napp.messenger.on(action, data => {\n  // process data\n});\napp.messenger.once(action, data => {\n  // process data\n});\n```\n\n\n\n[文章来源参考](https://eggjs.org/zh-cn/core/cluster-and-ipc.html)\n\n\n","tags":["node多进程","cluster","egg进程通讯","egg多进程"]},{"title":"mysql日常命令行和优化规则","url":"/2021/06/16/mysql日常命令行和优化规则/","content":"\n## 日常命令\n\n1. 链接远程数据库\n\n```js\nmysql -h主机地址 -P端口 -u用户名 -p用户密码\nmysql -h127.0.0.1 -P1234 -u\"myname\" -p\"test123\"\n```\n\n\n\n2. 显示所有库\n\n```js\nshow databases;\n```\n\n\n\n3. 进入数据库\n\n```js\nuse database_name;\n```\n\n\n\n4. 显示当前库中所有的表\n\n```js\nshow tables;\n```\n\n\n\n5. 显示表字段\n\n```js\ndesc table_name;\n```\n\n\n\n6. 创建表\n\n```js\ncreate table table_name (name char(100), path char(100), count int(10), firstName char(100), firstMD5 char(100), secondName char(100), secondMD5 char(100), thirdName char(100), thirdMD5 char(100));\n```\n\n\n\n7. 修改表名\n\n```js\nrename table table_name_old to table_name_new\n```\n\n\n\n8. 插入数据\n\n```js\ninsert into table_name (name, path, count, firstName, firstMD5, secondName, secondMD5, thirdName, thirdMD5) VALUES ('test', 'test', 1, 'name1', 'md1', 'name2', 'md2', 'name3', 'md3');\n```\n\n\n\n9. 查询表中数据\n\n```mysql\n  select * from table_name;\n\n  select * from table_name where name = 'test';\n\n  select * from table_name order by id limit 0,2;\n```\n\n9. where、group by和having区别\n\n```mysql\n// 1) 在SQL语句中，where子句并不是必须出现的\n// 2) where子句是对检索记录中每一行记录的过滤\n// 3) having子句出现在group by子句后面\n// 4) 如果在一句SQL语句中，where子句和group by……having子句同时都有的话，必须where子句在前，group by……having子句在后。（where先执行，再groupby分组；groupby先分组，having再执行）\n// 5) group by子句是对检索记录的分组，后面跟随的字段名是分组的依据。根据语法，在select子句中，除聚合函数语句外，SELECT子句中的每个列名称都必须在GROUP BY子句中作为分组的依据。\n\n\nselect vend_id, count(*) , sales from products group by vend_id;\n这个语句，其中sales字段，在group by中没有，所以查询的结果，sales的值是错误的！\n\n```\n\n\n\n10. 更新表中某一行数据\n\n```mysql\nupdate table_name set folderName ='Mary' where id=1;\n```\n\n\n\n11. 删除表中某一行数据\n\n```mysql\ndelete from table_name where folderName = 'test';\n```\n\n\n\n12. 添加表字段\n\n```mysql\nalter table table_name add id int auto_increment not null primary key;\n```\n\n\n\n13. 删除字段\n\n```mysql\nalter table table_name drop folderName;\n```\n\n## 优化规则\n### 核心\n1. 字段名不要使用‘key' ‘index’ ‘like’‘time’ 等等关键字\n2. 表字段尽量少，上限控制在20~50个，适当可以冗余(平衡范式和冗余)。\n3. 不在数据库做强运算，不要使用存储过程、触发器等，数据库主要负责存储，不承担大量业务逻辑。\n4. 拒绝大sql，大事务。批量删除时，请控制在操作行数1万以内的小事务。批量插入时，请控制并发，并发搞很容易死锁。\n\n### 索引\n1. 能不加的索引尽量不加，最好不超过字段数的20%(如：性别不加)，结合核心SQL优先考虑覆盖索引(https://my.oschina.net/BearCatYN/blog/476748)\n2. 字符字段必须建前缀索引。由于字符串很长，通常可以索引开始的几个字符，而不是全部值，以节约空间并得到好的性能。(http://www.educity.cn/wenda/402373.html)\n4. 不在索引列进行数学运算和函数运算(会导致无法使用索引 => 全表扫描)，如where id+1 = 100 和 id = 100 - 1，效率差很远\n5. 自增列或全局ID做INNODB的主键\n6. 尽量不用外键(由程序保证约束)，高并发的时候容易死锁。\n\n### sql语句\n1. 尽量少用select *，只取需要数据列，为使用覆盖索引提供可能性，减少临时表生成，更安全\n2. 用in()代替or，因为or的效率是O(n)，而in()的效率是O(Log n)。如：where a = 1 OR a = 100 与 where a IN (1, 100)\n3. 尽量避免负向查找，如NOT、!=等\n4. 减少COUNT(*)，使用COUNT(col)，前者资源开销大，尽量少用。\n5. 大批量更新凌晨操作，避开高峰，零点附近往往定时任务量比较大，如果可以，尽量安排在03:00-07:00.\n6. LIMIT高效分页：传统的方法是select * from t limit 10000, 10，推荐的方法是select * from t where id > 23423 limit 10。LIMIT的偏移量越大则越慢。还有一些高效的方法有：先取id来LIMIT偏移，减少整体的数据偏移；取到需要的id，与原表JOIN；程序取ID，然后用IN来填写。select * from t where id >= (select id from t limit 10000, 1) limit 10 , select * from t INNER JOIN (select id from t limit 10000, 10) USING (id) , select id from t limit 10000, 10; select * from t where id in (123, 456...)\n7. 尽量避免%前缀模糊查询，由于使用的是B+ Tree，前缀模糊使用不了索引，导致全表扫描(后缀模糊速度相对快很多)\n\n### 优化总结\n1. SQL语句优化，尽量精简，去除非必要语句\n2. 索引优化，让所有SQL都能够走索引\n3. 如果是表的瓶颈问题，则分表，单表数据量维持在1000W以内\n4. 如果是单库瓶颈问题，则分库，读写分离\n5. 如果是物理机器性能问题，则分多个数据库节点\n\n## mysql执行过程\n<img src=\"/img/mysql.png\" alt=\"\" />  \n绿色部分为SQL实际执行部分，主要分为两步：\n\n解析：词法解析->语法解析->逻辑计划->查询优化->物理执行计划，过程中会检查缓存是否可用，如果没有可用缓存则进入下一步mysql_execute_command执行\n\n执行：检查用户、表权限->表加上共享读锁->取数据到query_cache->取消共享读锁","tags":["mysql","mysql命令","mysql优化"]},{"title":"脚本async和defer的区别","url":"/2021/05/13/脚本async和defer的区别/","content":"\n### 概念\n\n async和defer都是脚本异步加载的方式\n\n\n\n### 原理\n\n1.  async: \n<img src=\"/img/async.png\" width = \"700\" height = \"auto\" alt=\"async\" align=center />\n\n1.  defer: \n<img src=\"/img/defer.png\" width = \"700\" height = \"auto\" alt=\"defer\" align=center />\n\n\n\n### 共同点和区别\n\n1. async: 异步加载， 加载完毕立即执行js代码， 有可能阻塞页面\n\n2. defer：异步加载， 等dom树构建完成（DOMContentLoaded）才执行代码\n","tags":["async","defer"]},{"title":"团队管理总结","url":"/2021/04/02/团队管理总结/","content":"\n## 什么是团队管理?\n\n### 1. 角色认知\n\n> 角色认知：从团队角度去看某个问题和事情, 从个人到leader角色转变，带领团队实现目标和价值\n>\n> - 改变工作价值、工作职责， 关注目标和结果\n> - 改变自己的核心竞争力， 技术评估、技术运用、技术管理\n\n1.  管理规划。 也是团队方向，到达什么目标\n   1. 团队定位\n   2. 团队价值\n   3. 团队目标\n   4. 团队资源， 目标实现路径\n2. 团队建设。 也是就管理人，增强团队战斗力\n   1. 动力\n      1. 员工个人能力\n      2. 员工激励\n   2. 合力（共同方向）\n      1. 分工： 团队组员分工\n      2. 协作：团队成员默契程度和合作融洽\n   3. 耐力（持续输出）\n      1. 梯队建设： 后备力量\n      2. 文化建设：团队的认可和归属\n3. 任务管理。 也就是管理事情\n   1. 事前管理： 做什么？ 优先级？\n   2. 事中管理：怎么做？执行落地？\n   3. 事后管理：以后怎么做？ 建立流程机制？\n\n### 2. 管理沟通\n\n1. 向上沟通\n\n2. 向下沟通\n\n3. 团队合作\n\n   1. 授信\n   2. 沟通\n\n   \n\n### 3. 行为分析\n\n1. 认知\n   1. 理解概念：认知就是知不知，知道不知道这是个问题\n   2. 解决方案：拓展认知\n2. 意愿\n   1. 理解概念： 意愿就是想不想， 愿意不愿意去做\n   2. 解决方案： 激发意愿， 团队激励机制\n3. 能力\n   1. 理解概念： 能力就是能不能， 有没有能力完成这个任务\n   2. 解决方案：团队梯度培养\n\n\n## 技术管理具体案例\n### leader负责对象，从中挖掘自己的价值\n#### 1. 公司\n视公司规模和格局，责任会不一样。 相同的职称在不同公司会扮演不同的角色。\n\n中小公司由于业务发展需求，要的是快速灵活，也就是效率和质量，其次才是性能。\n\n#### 2. 团队， 不是指某个具体组员\n\n### leader职责\n**主动发现、分析和解决问题。** 包含了：主动发现问题意愿，带领团队解决问题的能力。\n\n发现线上问题不断、业务需求急着开发、精力不够；按照发现问题、分析问题、解决问题和迭代和固化步骤进行；\n\n一、发现问题，代码庞大老旧、接手的人对代码不熟悉、解决线上问题耗费大量时间\n\n二、分析问题，对代码不熟悉、不能提前发现线上问题、线上定位问题耗时\n\n三、解决问题，拆分模块、画流程图和时序图，周会上进行分享掌握的知识；新增监控和告警手段\n\n四、迭代和固化，对现在解决问题的方法进行优化更新，形成可传授、可复制的流程且固化下来 \n\n\n### 团队好坏的评判标准\n\n#### 一、好团队\n  1. 稳，不出现事故，业务方对你们团队放心\n  2. 活力，内部沟通交流频繁\n  3. 人才涌现，团队在真正解决问题的时候会不自觉的培养出一批人才\n\n\n#### 二、坏团队\n  1. 瞎忙\n  2. 没活力，心态闭塞\n  3. 例行公事\n  4. 甩手掌柜\n\n### 向上管理\n1. 沟通思路\n2. 争取资源支持\n3. 及时同步进度和问题\n\n### 向下管理 \n1. 工作安排\n2. 经验传承（经验转化为能力）\n3. 信息同步，及时反馈\n\n","tags":["团队管理"]},{"title":"前端工程化和自动化","url":"/2020/10/12/前端工程化和自动化/","content":"\n### 前端工程化内容\n1. 技术选型\n2. 开发框架搭建\n3. 业务架构设计\n4. 自动化测试\n5. 分支管理\n6. 构建\n7. 集成\n8. 部署\n\n### 社区提供的解决方案\n\n### \n\n\n\n[资料来源于](https://ke.sifou.com/course/1650000024420877/section/1500000024421005)\n\n","tags":["前端工程化","前端自动化"]},{"title":"nodejs相关","url":"/2020/08/17/nodejs相关/","content":"\n### nodejs平滑重启\n1. pm2(restart, reload 以及 gracefulReload)\n   1. restart: 直接关闭旧服务然后启动新服务，会造成已建立的连接失效\n   2. reload: 平滑更新，先启动若干个新服务，同时停止旧服务接收请求。等待旧服务都停止服务后，关闭旧服务。和 cluster 的代码原理类似，有可能因为要等待连接关闭造成重启时间比较长。\n   3. gracefulReload: 平滑更新，和 reload 的区别是 gracefulReload 会发送一个 shutdown 消息给旧服务，具体的停服逻辑可以由程序自己实现，比较灵活。\n\n2. 多机器 + nginx负载均衡模块\n   1. 更新服务时只需要逐台部署，保证同一时刻至少有一台机器在提供服务，nginx 就会将流量自动分配到正常服务的机器上\n\n3. Node 本身的 cluster 模块\n    1. 发一个重启信号给 Master，例如 kill -USR2 MASTER_PID\n    2. Master 起 n 个新的服务，开始监听请求\n    3. Master 停止原先旧服务的监听，并等待旧服务的所有连接结束\n    4. 关闭旧服务\n\n    ```js\n        var cluster = require('cluster');\n        var http = require('http');\n\n        if (cluster.isMaster) {\n            cluster.fork();\n\n            cluster.on('exit', function(worker, code, signal) {\n                console.log('worker ' + worker.process.pid + ' 退出');\n            });\n\n            cluster.on('listening', function(worker, code, signal) {\n                console.log('worker ' + worker.process.pid + ' 开始服务');\n            });\n\n            cluster.on('disconnect', function(worker, code, signal) {\n                console.log('worker ' + worker.process.pid + ' 停止服务');\n            });\n\n            process.on('SIGUSR2', function () {\n                // 保存旧 worker 的列表，cluster.workers 是个 map\n                var oldWorkers = Object.keys(cluster.workers).map(function (idx) {\n                    return cluster.workers[idx];\n                });\n\n                // 起新服务\n                cluster.fork();\n\n                // 当新服务起起来之后，关闭所有的旧 worker\n                cluster.once('listening', function (worker) {\n                    oldWorkers.forEach(function (worker) {\n                        // disconnect 会停止接收新请求，等待旧请求结束后再结束进程\n                        worker.disconnect();\n                    });\n                });\n            });\n        } else {\n            http.createServer(function(req, res) {\n                // 模拟慢速请求\n                setTimeout(function () {\n                    res.writeHead(200);\n                    res.end(\"hello world\\n\");\n                }, 15000);\n            }).listen(8000);\n        }\n    ```\n\n### nodejs runtime架构\n\n#### 什么是runtime\n1. 程序分为几个状态，编辑时－>编译时->静态时->运行时\n2. 比如有些错误在编译的时候是不会出现的，就是程序在语法上没有问题。但在运行时，因为缺少资源等因素可能出现运行时错误。叫做runtime error!\n   \n#### nodejs runtime架构\n<img src=\"/img/noderuntime.jpeg\"  alt=\"runtime\" height=\"auto\"/>\n\n1. ***用户代码***：由程序员编写的 Javascript 应用程序代码。\n2. ***Node.js API***： Node 提供的内置方法，可以在用户代码中使用（例如 用于使用 HTTP 方法的 HTTP  modules、crypto module、用于文件系统操作的 fs module、用于网络请求的 net 等……）。 有关 Node 提供的方法的完整列表，您可以在此处查看文档。 此外，您可以在此处找到源代码实现。 Node 的 API 是用 Javascript 编写的。\n3. ***Bindings 和 C++扩展插件***： 在阅读 Node 时，您会看到 V8 是用 C++ 编写的，Libuv 是用 C 编写的，等等。 基本上，所有模块都是用 C 或 C++ 编写的，因为这些语言在处理底层任务和使用 OS API 方面非常出色和快速。 但是上层的Javascript代码怎么可能用其他语言去写代码呢？ 这就是 bindings 的作用。 它们充当两层之间的粘合剂，因此 Node 可以顺利使用 C 或 C++ 编写的低级代码。 那么，如果我们想自己添加一个C++模块应该怎么做呢？ 我们首先用 C++ 实现模块，然后为此编写 bindings代码。 我们编写的这段代码称为扩展插件。 更多信息可以在这里找到。\n4. ***Node’s 依赖***: 这一层代表 Node 使用的底层库。 最大的依赖是谷歌的 V8 引擎和 Libuv。 其他库包括 OpenSSL（用于 SSL、TLS 和其他基本加密功能）、HTTP 解析器（用于解析 HTTP 请求和响应）、C-Ares（用于异步 DNS 请求）和 Zlib（用于快速压缩和解压缩）。\n5. ***操作系统***: 这是表示上述库所使用的 OS API（系统调用）的最底层。 由于 OS-es 不同，这些库包括 Windows 和 Unix 变体的实现，这使得 Node 平台独立。\n\n\n\n来源于：https://juejin.cn/post/6979790275879125006\n","tags":["nodejs平滑重启","nodejs runTime架构"]},{"title":"egg学习文档","url":"/2020/06/27/egg学习文档/","content":"### Egg介绍\n\n#### Egg设计原则\n##### 插件机制\n1. 可以通过插件根据自己的业务定制配置。 例如MySQL数据库封装成了 egg-mysql, Nunjucks 模板封装成了 egg-view-nunjucks.\n\n##### 约定优先于配置\n1. 插件开发、配置、使用约定\n```js\n// package.json\n{\n  \"dependencies\": {\n    \"egg\": \"^2.0.0\",\n    \"egg-mysql\": \"^3.0.0\"\n  }\n}\n\n// config/plugin.js\n// config/plugin.${env}.js/plugin.js\nmodule.exports = {\n  mysql: {\n    enable: true,\n    package: 'egg-mysql',\n  },\n}\n```\n2. 项目目录结构约定\n```js\negg-project\n├── package.json\n├── app.js (可选)\n├── agent.js (可选)\n├── app\n|   ├── router.js  //用于配置 URL 路由规则\n│   ├── controller  //用于解析用户的输入，处理后返回相应的结果\n│   |   └── home.js\n│   ├── service (可选)  //用于编写业务逻辑层\n│   |   └── user.js\n│   ├── middleware (可选) //用于编写中间件\n│   |   └── response_time.js\n│   ├── schedule (可选)  //用于定时任务\n│   |   └── my_task.js\n│   ├── public (可选)  //放置静态资源\n│   |   └── reset.css\n│   ├── view (可选)    //用于放置模板文件\n│   |   └── home.tpl\n│   └── extend (可选)   //用于框架的扩展\n│       ├── helper.js (可选)\n│       ├── request.js (可选)\n│       ├── response.js (可选)\n│       ├── context.js (可选)\n│       ├── application.js (可选)\n│       └── agent.js (可选)\n├── config\n|   ├── plugin.js  //用于配置需要加载的插件\n|   ├── plugin.local.js\n|   ├── config.default.js //用于编写配置文件\n│   ├── config.prod.js\n|   ├── config.test.js (可选)\n|   ├── config.local.js (可选)\n|   └── config.unittest.js (可选)\n└── test\n    ├── middleware\n    |   └── response_time.test.js\n    └── controller\n        └── home.test.js\n```\n\n### Egg功能\n#### Egg内置对象\n##### 继承Koa\n###### 1. Application\n1. 介绍\n   * Application 对象几乎可以在编写应用时的任何一个地方获取到\n\n2. 获取方式\n```js\n// app.js\nmodule.exports = app => {\n  app.cache = new Cache();\n};\n\n// app/controller/user.js\nclass UserController extends Controller {\n  async fetch() {\n    //第一种方法  \n    this.ctx.body = this.app.cache.get(this.ctx.query.id);\n\n    //第二种方法： 和Koa一样 通过Context对象\n    //this.ctx.body = this.ctx.app.cache.get(this.ctx.query.id);\n  }\n}\n```\n\n###### 2. Context\n1. 介绍：\n   * Context 是一个请求级别的对象，继承自 Koa.Context。在每一次收到用户请求时，框架会实例化一个 Context 对象，这个对象封装了这次用户请求的信息，并提供了许多便捷的方法来获取请求参数或者设置响应信息。框架会将所有的 Service 挂载到 Context 实例上，一些插件也会将一些其他的方法和对象挂载到它上面\n\n2. 获取方式\n```js\n// app.js\nmodule.exports = app => {\n  app.beforeStart(async () => {\n    const ctx = app.createAnonymousContext();\n    // preload before app start\n    await ctx.service.posts.load();\n  });\n}\n\n// app/middleware/index.js\n...\n\n// app/controller/home.js\nconst Controller = require('egg').Controller;\nclass HomeController extends Controller {\n  async index() {\n    const { ctx } = this;\n    await ctx.render('index');\n  }\n}\n\n\n// app/schedule/refresh.js\nexports.task = async ctx => {\n  await ctx.service.posts.refresh();\n};\n```\n\n###### 3. Request & Response\n1. 介绍\n   * Request & Response是一个请求级别的对象，继承自 Koa.Request & Koa.Response\n2. 获取方式\n```js\n// app/controller/user.js\nclass UserController extends Controller {\n  async fetch() {\n    const { app, ctx } = this;\n    const id = ctx.request.query.id;\n    ctx.response.body = app.cache.get(id);\n  }\n}\n```\n\n##### Egg框架扩展\n######  1. Controller\n######  2. Service\n######  3. Helper\n######  4. Config\n######  5. Logger\n######  6. Subscription\n\n\n[文章来源于egg中文文档](https://eggjs.org/zh-cn/basics/objects.html)","tags":["Egg.js","Node.js框架"]},{"title":"npm私有包管理","url":"/2020/05/25/npm私有包管理/","content":"## verdaccio私有npm服务器\n### 介绍\n1. verdaccio（读：韦尔搭桥）是一个 Node.js创建的轻量的私有 npm proxy registry\n\n### 背景\n1. 希望有个统一管理公司公共包平台，且有相应的权限访问和配置\n2. 希望下载公共包走公共仓库， 私有包走内部私有仓库\n3. 与npm、yarn兼容\n\n\n### 安装\n1. npm全局安装： npm install -g verdaccio\n2. docker安装: docker pull verdaccio/verdaccio （官方的docker镜像）\n\n\n### 使用\n```js\n//1. 添加用户\nnpm adduser --registry http://localhost:4873\n\n\n//2. 发布本地包\n进入包目录  ==> npm publish --registry http://localhost:4873\n\n//3. 安装已发布的包\nnpm install <包名>  npm publish --registry http://localhost:4873\n\n//4. 删除已发布的包\nnpm unpublish <包名> --force --registry http://fankyc.cn:4873\n```\n\n\n### 配置\n1. 全局配置\n```js\nnpm config set @youdao:registry \"http://111.11.11.1:4100/\"\n```\n\n2. 项目根目录配置\n```js\n//项目根目录中新建文件.npmrc来指定@youdao/xxxx包安装源\n@youdao:registry \"http://111.11.11.1:4100/\n```\n\n### 部署\n1. pm2进程守护\n2. nginx配置\n\n## Nrm管理镜像源\n### 背景\n1. npm包有很多的镜像源，有的是私有包、有的源有的时候访问失败、有的源可能没有最新的包等等，所以有时需要切换npm的源，nrm包就是解决快速切换问题的。\n\n### 安装\nnpm install -g nrm\n\n### 使用\n```js\n// 列出可选择的源\nnrm ls\n\n//切换正在使用的源\nnrm use npm\n\n\n//添加一个源\n//下面以本地verdaccio私有仓库为例\nnrm add verdaccio http://127.0.0.1:4873\n\n\n//删除一个源\nnrm del verdaccio\n\n\n//测试本地所有源的速度\nnrm test\n\n```\n\n## lerna多包管理\n\n### 背景\n\n## npx\n## 介绍\n### npx和npm的区别\n1. npm是永久存在，npx是临时安装，用完后删除\n2. npx会帮你执行依赖包里面的二进制文件，侧重于执行命令； npm会帮你下载包到项目中，侧重于包的管理\n\n### 原理\n1. 执行node-modules包\n```js\n// 方法一：在项目脚本或 package.json 的 scripts 字段中对其调用进行定义\n{\n \"scripts\": {\n    \"mocha\": 'mocha --version'\n  },\n}\nnpm run mocha\n\n// 方法二: 必须要要定位到 node_modules 中用繁琐的命令才能实现在命令行中对其进行调用\n./node-modules/.bin/mocha --version\n```\n2. npx执行原理\n```js\nnpx mocha --version\n// 1. npx 会自动查找当前依赖包中的可执行文件 \n// 2. 如果找不到，就会去 PATH 里找 \n// 3. 如果依然找不到，就会帮你安装\n```\n\n### 使用场景\n#### 1. 避免全局安装，执行一次性命令\n```js\n// npx 将 create-react-app 下载到一个临时目录，使用以后再删除\nnpx create-react-app my-react-app\n```\n\n#### 2. 指定 Node 执行版本\n```js\n// npx -p 参数，我们可以指定要安装的模块，后面继续跟着要执行的命令\nnpx -p node@0.12.8 node -v\n```\n#### 3. 执行gitHub源码\n```js\n// 执行仓库代码\nnpx github:piuccio/cowsay helloyo\n\n// 一个标准模块定义至少应该包含一个 package.json 文件，并指定 bin 脚本入口，例如下面这样\n{\n    \"name\": \"cowsay\",\n    \"version\": \"0.0.0\",\n    \"bin\": \"./index.js\"\n}\n```\n\n## nvm\n#### 介绍\nnvm: 多版本nodejs管理工具","tags":["verdaccio私有npm服务器","nrm","lerna","npx","nvm"]},{"title":"gitlab持续集成","url":"/2020/05/23/gitlab持续集成/","tags":["gitlab-ci","ci","cd"]},{"title":"npm包管理机制","url":"/2020/05/11/npm包管理机制/","content":"\n## package.json介绍\n### 目录、文件\n1. 程序入口\n```js\n// package.json文件 \n// 例如： import { notification } from 'antd'; 实际上引入的就是./index.js中暴露出去的模块\n{\n    \"main\": \"./index.js\"\n}\n```\n\n2. 规范项目目录，一个 node.js 模块是基于 CommonJS 模块化规范实现的，严格按照 CommonJS 规范，模块目录下除了必须包含包描述文件 package.json 以外，还需要包含以下目录：\n * bin：存放可执行二进制文件的目录\n * lib：存放js代码的目录\n * doc：存放文档的目录\n * test：存放单元测试用例代码的目录\n * ...\n\n## npm版本管理\n###  SemVer规范\n#### 标准版本\nSemVer规范的标准版本号采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号\n1. 主版本号(major)：当你做了不兼容的API 修改\n2. 次版本号(minor)：当你做了向下兼容的功能性新增\n3. 修订号(patch)：当你做了向下兼容的问题修正。\n\n#### 先行版本\n当某个版本改动比较大、并非稳定而且可能无法满足预期的兼容性需求时，你可能要先发布一个先行版本。\n1. 内部版本(alpha):\n2. 公测版本(beta):\n3. 正式版本的候选版本rc: 即 Release candiate\n```js\n  npm view vue versions  //查看vue发布的所以版本记录\n```\n\n\n### 版本工具使用\n```js\n//下载\nnpm i semver\n\n//判断版本号是否合法\nsemver.valid('1.2.3') // '1.2.3'\n\n//强制转化成semver版本号\nsemver.valid(semver.coerce('v2')) // '2.0.0'\nsemver.valid(semver.coerce('42.6.7.9.3-alpha')) // '42.6.7'\n```\n\n### 锁定版本依赖\n#### lock文件\n#### 定期更新依赖\n使用 npm outdated 可以帮助我们列出有哪些还没有升级到最新版本的依赖：\n1. 黄色表示不符合我们指定的语意化版本范围 - 不需要升级\n2. 红色表示符合指定的语意化版本范围 - 需要升级\n\n执行 npm update 会升级所有的红色依赖。\n\n## npm原理\n\n### npm install 运行流程\n![image](/img/npm.png)\n1. 检查.npmrc文件，优先级： 项目基本.npmrc文件 > 用户的 > 全局的 > npm内置\n2. 检查项目中有无lock文件\n3. 无lock文件\n   1. 不存在缓存就去网上下载, 将下载的包复制到npm缓存目录, 依赖结构解压到 node_modules\n   2. 存在缓存，将缓存依赖结构解压到node_modules\n   3. 检验包的完整性\n   4. 如果检验通过\n   5. 构建依赖树，不管其是直接依赖还是子依赖的依赖，优先将其放置在 node_modules 根目录；当遇到相同模块时，判断已放置在依赖树的模块版本是否符合新模块的版本范围，如果符合则跳过，不符合则在当前模块的 node_modules 下放置该模块\n   6. 生成lock文件\n4. 有lock文件\n   1. 检查lock和package中依赖是否有冲突， 如有冲突以package为准\n   2. 如果没有冲突，直接跳过获取包信息、构建依赖树过程， 开始在缓存中查找包信息，后续过程和上面的一样\n\n### node_modules结构\n#### 嵌套结构\n1. 早期的npm处理依赖的方式就递归，形成了嵌套的结构。\n2. 优点： node_modules的结构和package.json一一对应。\n3. 缺点： 依赖模块非常多node_modules将非常庞大； 如果不同层级依赖相同的模块导致大量的冗余\n\n\n#### 扁平化结构\n1. npm3.x改用了扁平化结构；\n2. 安装方法： 安装模块时，不管其是直接依赖还是子依赖的依赖，优先将其安装在 node_modules 根目录；当安装到相同模块时，判断已安装的模块版本是否符合新模块的版本范围，如果符合则跳过，不符合则在当前模块的 node_modules 下安装该模块。\n3. 优点： 减少了部分重复模块冗余问题； 消除了嵌套层级过深的问题。\n4. 缺点： npm3.x版本并没有根本解决模块冗余问题，\n\n### lock文件\n1. 为了解决 npm install 的不确定性问题，在 npm 5.x 版本新增了 package-lock.json 文件，而安装方式还沿用了 npm 3.x 的扁平化的方式。\n\n### 缓存\n1. 在执行 npm install 或 npm update命令下载依赖后，除了将依赖包安装在node_modules 目录下外，还会在本地的缓存目录缓存一份。\n\n### 文件的完整性\n1. 下载npm包之后本地计算文件hash值， 和下载之前拿到的文件hash对比（npm info）\n\n\n[本文参考](https://mp.weixin.qq.com/s/gtsnxFOYRZ4i-Id_9Gr6Aw)","tags":["npm","package.json"]},{"title":"Jenkins打造前端自动化工作流","url":"/2020/05/08/Jenkins打造前端自动化工作流/","content":"\n### Jenkis安装\n#### 安装Docker和 Docker Compose\n#### 通过Docker安装Jenkis\n\n### 初始化Jenkis\n1. jenkins的默认端口是8080,启动成功后在浏览器打开。如果是阿里云或者腾讯云要在安全组添加对外访问端口。\n2. 需要的插件选择默认即可。\n3. 创建一个管理员账户。\n\n### 前端自动化工作流\n#### 创建任务\n#### 实现git钩子\n1. 打开刚创建的任务，选择配置，添加git远程仓库地址，配置登录名及密码及分支。\n2. 安装Generic Webhook Trigger Plugin插件。\n3. 添加触发器。\n   1. 第2步安装的Webhook触发器插件功能很强大，可以根据不同的触发参数触发不同的构建操作，比如我向远程仓库提交的是master分支的代码，就执行代码部署工作，我向远程仓库提交的是某个feature分支，就执行单元测试，单元测试通过后合并至dev分支。灵活性很高\n\n\n#### 实现自动化构建\n1. jenkins添加NodeJS Plugin插件，在构建环境选择“Provide Node & npm bin/ folder to PATH”\n2. 点击构建，把要执行的命令输进去，多个命令使用&&分开。\n3. 此时本地修改一下代码push测试一下，就可以触发任务。\n\n\n#### 实现自动化部署\n1. Jenkins上装一个插件Publish Over SSH，我们将通过这个工具实现服务器部署功能。\n2. 增加构建后操作步骤，选择send build artificial over SSH\n3. 自己新增构建后自动化脚本\n```bash\ncd /usr/local/src/myspace/myVue\ntar -zxvf dist.tar.gz\nrm -rf dist.tar.gz\n```\n\n\n\n#### 实现邮件提醒\n","tags":["Jenkis安装","前端自动化工作流"]},{"title":"ES6变量解构赋值","url":"/2020/04/27/ES6变量解构赋值/","content":"\n### 数组的解构赋值\n```js\nlet [foo, [[bar], baz]] = [1, [[2], 3]];\nfoo // 1\nbar // 2\nbaz // 3\n\nlet [ , , third] = [\"foo\", \"bar\", \"baz\"];\nthird // \"baz\"\n\nlet [x, , y] = [1, 2, 3];\nx // 1\ny // 3\n\nlet [head, ...tail] = [1, 2, 3, 4];\nhead // 1\ntail // [2, 3, 4]\n\nlet [x, y, ...z] = ['a'];\nx // \"a\"\ny // undefined\nz // []\n```\n\n### 对象的解构赋值\n```js\nlet { bar, foo, baz } = { foo: 'aaa', bar: 'bbb' };\nfoo // \"aaa\"\nbar // \"bbb\"\nbaz // undefined\n\n//用途\nconst { log } = console;\nlog('hello') // hello\n```\n\n### 字符串的解构赋值\n```js\nlet [a, b, c, d, e] = 'world';\n\n//字符串有length属性\nlet {length : len} = 'hello';\nlen  // 5\n```\n### 函数参数的解构赋值\n\n### 圆括号的解构赋值\n\n### 数值和布尔值解构赋值\n\n\n### 用途\n#### 从函数返回多个值\n```js\nfunction example() {\n  return {\n    foo: 1,\n    bar: 2\n  };\n}\nlet { foo, bar } = example();\n```\n\n#### 提取 JSON 数据\n```js\nlet jsonData = {\n  id: 42,\n  status: \"OK\",\n  data: [867, 5309]\n};\nlet { id, status, data: number } = jsonData;\nlet { id, status, data } = jsonData;\nconsole.log(id, status, number);\n// 42, \"OK\", [867, 5309]\nlet { id, status, data } = jsonData;\nconsole.log(id, status, data);\n// 42, \"OK\", [867, 5309]\n```\n\n#### 输入模块的指定方法\n```js\n//require加载方法\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```","tags":["解构赋值"]},{"title":"Set和Map","url":"/2020/04/20/Set和Map/","content":"\n### Set\n#### 定义\n1. set类似数组， 成员是唯一且无序，也就是值不能重复。\n2. 可以遍历， 方法有：add、delete、has、clear等\n\n### WeakSet\n#### 定义\n1. 成员都是对象\n2. 成员都是弱引用，可以随时消失。 可以保持DOM节点，不易造成内存泄露\n3. 不能遍历\n\n### Map\n#### 定义\n1. 本质上是键值对的集合，类似集合\n2. 可以遍历，方法很多可以跟各种数据格式转换\n\n#### 类型转换\n1. map ==> array\n```js\nconst map = new Map([[1, 1], [2, 2], [3, 3]])\nconsole.log([...map])\t// [[1, 1], [2, 2], [3, 3]]\n```\n2. array ==> map\n```js\nconst map = new Map([[1, 1], [2, 2], [3, 3]])\nconsole.log(map)\t// Map {1 => 1, 2 => 2, 3 => 3}\n```\n3. map ==> object\n```js\nfunction mapToObj(map) {\n    let obj = Object.create(null)\n    for (let [key, value] of map) {\n        obj[key] = value\n    }\n    return obj\n}\nconst map = new Map().set('name', 'An').set('des', 'JS')\nmapToObj(map)  // {name: \"An\", des: \"JS\"}\n```\n4. object ==> map\n```js\nfunction objToMap(obj) {\n    let map = new Map()\n    for (let key of Object.keys(obj)) {\n        map.set(key, obj[key])\n    }\n    return map\n}\n\nobjToMap({'name': 'An', 'des': 'JS'}) // Map {\"name\" => \"An\", \"des\" => \"JS\"}\n```\n5. map ==> json\n```js\nfunction mapToJson(map) {\n    return JSON.stringify([...map])\n}\n\nlet map = new Map().set('name', 'An').set('des', 'JS')\nmapToJson(map)\t// [[\"name\",\"An\"],[\"des\",\"JS\"]]\n```\n\n6. json ==> map\n```js\nfunction jsonToStrMap(jsonStr) {\n  return objToMap(JSON.parse(jsonStr));\n}\n\njsonToStrMap('{\"name\": \"An\", \"des\": \"JS\"}') // Map {\"name\" => \"An\", \"des\" => \"JS\"}\n```\n\n### WeakMap\n#### 定义\n1. WeakMap 对象是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。\n2. 不能遍历","tags":["Set","Map","WeakSet","WeakMap"]},{"title":"CommonJS和ES6 Module","url":"/2020/04/16/CommonJS和ES6-Module/","content":"### 使用介绍\n#### CommonJS\n##### 使用\n1. 使用场景：**nodejs服务器端居多**\n2. 导出\n```js\n// 导出一个对象\nmodule.exports = {\n    name: \"蛙人\",\n    age: 24,\n    sex: \"male\"\n}\n\n// 导出任意值\nmodule.exports.name = \"蛙人\"\nmodule.exports.sex = null\nmodule.exports.age = undefined\n\n// 混合导出\nexports.name = \"蛙人\"\nmodule.exports.age = 24\n```\n3. 导入\n```js\n// index.js\nmodule.exports.name = \"蛙人\"\nmodule.exports.age = 24\n\nlet data = require(\"./index.js\")\nconsole.log(data) // { name: \"蛙人\", age: 24 }\n\n```\n\n#### ES6 Module\n##### 使用\n1. 使用场景：后来ES6版本正式加入了ES Module模块，成为浏览器和服务器通用的模块解决方案\n2. 导出\n```js\n// 导出变量\nexport const name = \"蛙人\"\nexport const age = 24\n\n// 导出方法也可以\nexport function fn() {}\nexport const test = () => {}\n\n\n// 如果有多个的话\nconst name = \"蛙人\"\nconst sex = \"male\"\nexport { name, sex }\n```\n3. 导入\n```js\n// index,js\nexport const name = \"蛙人\"\nexport const age = 24\n\nimport { name, age } from './index.js' //这里的花括号跟解构不一样\nconsole.log(name, age) // \"蛙人\" 24\n\n// 如果里面全是单个导出，我们就想全部直接导入则可以这样写\nimport * as all from './index.js'\nconsole.log(all) // {name: \"蛙人\", age: 24}\n```\n4. 混合导入\n```js\n// index,js\nexport const name = \"蛙人\"\nexport const age = 24\nexport default {\n    msg: \"蛙人\"\n}\n\nimport msg, { name, age } from './index.js'\nconsole.log(msg) // { msg: \"蛙人\" }\n```\n### 运行原理 \n#### CommonJS\n##### 模块查找、加载、解析\n1. 对于核心模块，node将其已经编译成二进制代码，直接书写标识符fs、http就可以\n2. 对于自己写的文件模块，需要用‘./’'../'开头，require会将这种相对路径转化为真实路径，找到模块\n3. 对于第三方模块，也就是使用npm下载的包，就会用到paths这个变量，会依次查找当前路径下的node_modules文件夹，如果没有，则在父级目录查找no_modules，一直到根目录下，找到为止。\n\n##### 模块重复引用和循环引用\n1. 重复引用问题。\n   1. 模块加载是以绝对路径为key写入cache（require.cache）中，缓存可以解决重复查找和重复加载的问题。\n2. 循环引用问题。\n   1. 我们可以看到，在 CommonJS 规范中，当遇到 require() 语句时，会执行 require 模块中的代码，并缓存执行的结果，当下次再次加载时不会重复执行，而是直接取缓存的结果。正因为此，出现循环依赖时才不会出现无限循环调用的情况。虽然这种模块加载机制可以避免出现循环依赖时报错的情况，但稍不注意就很可能使得代码并不是像我们想象的那样去执行。\n   2. CommonJS通过模块缓存来解决：每一个模块都先加入缓存再执行，每次遇到require都先检查缓存，这样就不会出现死循环；借助缓存，输出的值也很简单就能找到了。\n\n#### ES6 Module\n\n##### 查找、加载、解析\n##### 模块重复引用和循环引用\n1. 重复引用问题。\n   1. 模块加载是以绝对路径为key写入cache（require.cache）中，缓存可以解决重复查找和重复加载的问题。\n1. 循环引用问题。\n   1. 跟 CommonJS 模块一样，ES6 不会再去执行重复加载的模块。ES Module借助模块地图，已经进入过的模块标注为获取中，遇到import语句会去检查这个地图，已经标注为获取中的则不会进入，地图中的每一个节点是一个模块记录，上面有导出变量的内存地址，导入时会做一个连接——即指向同一块内存。\n\n### 两者区别\n#### 加载运行的时机\n* Commonjs是运行时候加载。因为导出是个对象，只有在运行时候才能生成，所以使用时可以放在地方。对外是动态定义。\n\n* ES6 Module是编译时候加载。编译时候就确定模块依赖关系以及输入、输出的变量。对外导出只是个静态定义。所以使用的时候import必须放在文件的最开始，且前面不允许有其他逻辑代码。\n\n\n#### 模块导出的值不一样\n* commonjs是值的拷贝（注意浅拷贝基本数据类型和对象数据类型区别）， 可以修改导出的值，这在代码出错时，不好排查引起变量污染\n```js\n// dep.js\nlet a = 1\nmodule.exports = {\n    a: a\n}\nsetTimeout(() => a += 1, 500)\n\n// app.js\nlet a = require('dep');\nsetTimeout(function () {\n  console.log(a) // 输出：1\n}, 1000)\n```\n\n* es6是值的引用, 值都是可读的，不能修改\n```js\n// dep.js\nexport let a = 1\nsetTimeout(() => a += 1, 500)\n\n// app.js\nimport { a } from 'dep'\nsetTimeout(function () {\n  console.log(a)   //输出：2\n}, 1000)\n```\n\n\n<br />\n\n[参考文章1](https://juejin.cn/post/6938581764432461854#heading-17)\n\n[参考文章2](https://es6.ruanyifeng.com/#docs/module)","tags":["commonjs","es6 module"]},{"title":"vue原理分析watch和computed","url":"/2020/04/12/vue原理分析watch和computed/","content":"\n### 使用用法\n#### watch（侦听属性）\n```js\nwatch: {\n    obj: {\n        handler(val){\n\n        },\n        immediate: true, //初始立即执行， 不然只有当obj改变的时候才会触发handler\n        deep: true //是否深度遍历，性能会差。建议用字符串“obj.a.b”\n    }\n}\n```\n\n#### computed（计算属性）\n```js\ncomputed: {\n    data: function(){\n        return {\n            msg: 'hello world',\n        }\n    },\n    //仅读取\n    reverseMsg: function(){\n        return this.msg.split('').reverse().join('');\n    },\n    //读取和设置\n    //vm.reverseMsg2 = 'set'\n    //console.log(this.msg) \"hello worldset\"\n    reverseMsg2: {\n        get: function(){\n            return this.msg.split('').reverse().join('');\n        },\n        set: function(v){\n            this.msg = v;\n        }\n    }\n}\n\n```\n\n### 使用场景\n#### watch\n1. watch函数接受oldValue和newValue参数\n2. \b其他的操作依赖当前的值变化，不会产生新的值(data、props)\n\n#### computed\n1. 当模板中某个新的值依赖一个或者多个数据(data、props)时， 计算值会被缓存(依赖的属性值不变就不触发，源码中根据dirty字段判断要读取缓存)\n2. computed函数不接受参数\n\n\n### computed实现原理\n#### 流程\n对data的set操作  ==> Dep.notfiy()通知  ===> watcher ===> update更新视图。\n\n#### 案例\n```js\n\n//因为other值的改变引起视图的变化，视图的变化肯定会读取sum的值。\n//我们希望每次other的半会不会重新计算sum的值\n\n<div id=\"app\">\n  <span @click=\"sumAdd\">{{sum}}</span>\n  <span @click=\"change\">{{other}}</span>\n</div>\n<script>\n  new Vue({\n    el: \"#app\",\n    data() {\n      return {\n        count: 1,\n        other: 'Hello World'\n      }\n    },\n    methods: {\n      sumAdd() {\n        this.count = 2;\n      },\n      change() {\n        this.other = 'wtf'\n      }\n    },\n    computed: {\n      // 非常耗时的计算属性\n      sum() {\n        let i = 9999999999999999\n        while(i > 0) {\n            i--;\n        }\n        return this.count + 1\n      },\n    },\n  })\n</script>\n```\n\n#### 总结\n##### 不缓存\n1. 更新count的值就会重新算sum的值,不会读取缓存。\n\n##### 缓存\n1. 更改other的值不会重新计算sum的值，读取缓存。","tags":["computed原理","watch原理","vue原理"]},{"title":"抽象语法树AST","url":"/2020/04/02/抽象语法树AST/","content":"\n### 含义\n* 抽象语法树，是源码语法结构的抽象表示。以树状的形式表现编程语言的语法结构。\n\n### 用途\n1. ESLint、JSLint对代码错和风格的检测 \n2. vue模块、jsx模板、typescript转化为原生的javascript\n3. webpack代码打包\n4. babel库es6转化为es5做兼容\n\n\n### 原理\n#### AST过程\n1. 读取源码\n2. 词法分析，字节流转为生成Token流\n> 例如 const 这三个字符，它只能作为一个整体，语义上不能再被分解，因此它是一个 Token。\n3. 语法分析parse。语法分析的任务是在词法分析的基础上将单词序列组合成语法树。类似虚拟dom的语法树结构\n4. 生成AST\n\n### 案例","tags":["AST","抽象语法树"]},{"title":"https工作原理和握手过程","url":"/2020/03/29/https工作原理和握手过程/","content":"\n### 协议\n1. https 相对于http多了一个SSL/TLS一层（ip -> tcp -> ssl/tls -> http）\n\n### 加密算法\n#### 对称算法\n1. 加密和解密都是使用的同一个密钥。\n\n#### 非对称算法\n1. 公钥和私钥。 公钥和公钥算法是公开， 私钥是保密的。 安全性好但是性能差。\n\n### https工作原理\n\n\n\n### https握手过程\n#### TCP三次握手\n1. client -> server  (syn)\n\n2. server -> client  (syn + ack)\n\n3. client -> server  (ack + 内容) \n\n#### SSL握手\n1. clinet -> server \n   1. 客户端版本号、32字节随机值、客户端支持的加密算法\n\n2. server -> client \n   1. 客户端版本号、32字节随机值、客户端支持的加密算法\n   2. 服务端公钥、证书颁发机构\n\n3. client -> server\n   1. 根据之前服务器发送来的公钥进行加密\n   2. 告诉服务器以后信息都是用协商好的密钥和算法\n\n4. server -> client\n  1. 告诉客户端会使用协商好的密钥来加密","tags":["https工作原理","https握手过程"]},{"title":"javascript内存泄漏","url":"/2020/03/29/javascript内存泄漏/","content":"\n### 内存的介绍\n* 内存的生命周期： 申请内存 --> 使用内存 -->  释放内存\n\n\n### 什么是内存泄露\n* 内存泄露就是不在被应用需要的内存，由于某种原因，没有归还给操作系统。\n\n### 垃圾回收算法\n#### 引用计数法： \n1. 如果该对象没有引用就被回收。 \n2. 缺点就是在循环引用情况下无法回收。\n```js\n  function  test（）{\n       var  obj1  = {};\n       var  obj2  = {};\n       obj1.x  =  obj2 ; // obj1引用obj2\n       obj2.x  =  obj1 ; // obj2引用obj1\n   }\n```\n####  标记清除法\n  1. 创建垃圾回收器对象， 浏览器宿主对象window， 检测它所有的子对象是否存在。\n  2. 所有子对象递归检测，如果从window开始能到达标记为激活，就不视为垃圾\n  3. 所有子对象递归检测，如果从window开始不能到达就视为垃圾，归还给操作系统\n\n\n### 内存泄露的场景\n#### 全局变量\n```js\n//案例\nfunction test(){\n    name = 'hello'; //name将变成全局变量，泄露到全局\n}\n\n//原因\n全局变量是根据定义无法被垃圾回收机制。如果是临时需要存放大量数据的全局变量，\n必须指定为null或者使用完重新分配内存\n\n//解决方案\n使用js严格模式\n\n\n```\n\n#### 被遗忘的定时器和回调函数\n```js\n//案例\nsetInterval(function(){\n    var dom = document.getElementById('DOM');\n    if(dom){\n        dom.innerText = 'hello world';\n    }\n    //1， dom 无法被回收  2， 整个定时器一直在运行没有清除\n}, 1000)\n\n\n//解决方法\n在定时器完成工作时候，手动清楚定时器\n```\n\n#### DOM外引用\n```js\n//案例\nvar refA = document.getElementById('test');\ndocument.body.removeChild(refA); // dom删除了\nconsole.log(refA, \"refA\");  // 但是还存在引用 能console出整个div 没有被回收\n\n//原因: \n保留了DOM节点的引用,导致GC没有回收\n\n//解决办法：\nrefA = null;\n```\n\n\n#### 闭包\n```js\n//闭包本身不会造成内存泄露，使用不当才会导致\n//案例\n\n\n//解决方法\n在退出函数之前，将不使用的局部变量全部删除\n```\n### 内存泄露检测\n#### 浏览器\n1. chrome开发者工具memory \n2. 点击take snapshot进行对比\n\n#### node环境\n1. process.memoryUsage方法","tags":["内存泄露场景","内存泄露检测"]},{"title":"前端原生函数和部分原理实现","url":"/2020/03/17/前端原生函数和部分原理实现/","content":"\n### 实现 Array.isArray\n```js\n//思路  利用Object.prototype.toString.call()\n\n//实现\nArray.prototype.myIsArray = function(obj){\n    return Object.prototype.toString.call(obj) === '[object Array]';\n}\n```\n\n### 实现 Object.create()\n```js\n//思路Object.create方法是不继承原型链上的属性和方法\n\n//纯净的o = {a : 1}对象， 无任何继承原型链(toString、hasOwnProperty、...)\nvar o = Object.create(null, {\n    a:{\n        writable:true,\n        configurable:true,\n        value:'1'\n    }\n})\n\n//和var o = {a: 1} 类似，  但是多了一层__proto__\nvar o = Object.create({},{\n    a:{\n        writable:true,\n        configurable:true,\n        value:'1'\n    }\n})\n\n//等于 var o = {a: 1}\nvar o = Object.create(Object.prototype,{\n    a:{\n        writable:true,\n        configurable:true,\n        value:'1'\n    }\n})\n\n\n//自己实现Object.create()\nif(typeof Object.create !== 'function'){\n   Object.create = function(o){\n        let F = function(){};  \n        F.prototype = o;  //F原型链指向o\n        return new F();   //返回创建的新对象\n   }\n}\n```\n\n\n### 实现 new F()\n```js\n//思路\n1. 创建一个空对象\n2. 将空对象指向和构造函数原型\n3. 以空对象为this上下文且执行构造函数\n4. 返回构造函数结果\n\n//实现\nfunction creatObject(fn){\n    // 创建一个空对象，并将空对象的原型设置为构造函数的原型\n   let obj = Object.create(fn.prototype);\n   \n   // 以obj为上下文执行构造函数\n   let result = fn.call(obj);\n   \n   // 如果构造函数有返回结果，则返回，若无直接返回obj\n   if(typeof result === 'object'){\n      return result;\n   }else{\n      return obj;\n   }\n}\n\n//使用\nfunction Person(){\n    this.name = 'cha';\n    this.age = 10;\n}\n\n//new 实现\n//var res = new Person();\n\n//模拟实现\nvar res = creatObject(Person);\n\n```\n\n\n### 实现 call、apply\n```js\n//思路\n1. 改变函数this的指向\n2. 执行函数\n\n\n//实现\nFunction.prototype.myCall = function(context){\n    context = context || window;\n\n    //将我们传入函数挂载到context上\n    context.fn = this;\n\n    //处理传入参数，除去第一位，转换为数组\n    //console.log([...[2, 3, 4]]) ==> [2, 3, 4]\n    const args = [...arguments].slice(1);\n\n    //执行函数 context.fn = this， 参数数组转换为多个字符串\n    //console.log(...[2, 3, 4])  ==> 2, 3, 4\n    const result =  context.fn(...args);\n    \n    //删除对象上属性\n    delete context.fn;\n   \n    //将结果返回\n    return result;\n}\n\n\n//和call不相同的地方就是参数\nFunction.prototype.apply = function(context){\n  context = context || window;\n\n  context.fn = this;\n\n  let result;\n\n  if(arguments[1]){\n     //console.log(...[2, 3, 4])  ==> 2, 3, 4\n     result = context.fn(...arguments[1]);\n  }else{\n     result = context.fn(); \n  }\n\n  delete context.fn;\n\n  return result;\n}\n\n```\n\n### 实现 bind\n```js\n//思路\n1. 用bind改变this指向的函数\n2. 如果用new操作符调用会失效\n\n\n//实现\nFunction.prototype.myBind = function(){\n  //保存函数  \n  const _this = this;\n\n  //保存目标函数\n  const context = arguments[0] || window;\n\n  //保存函数中除了目标函数的其他参数\n  const rest = Array.prototype.slice.call(arguments, 1);\n  \n  //返回一个待执行函数\n  return function F(){\n    const rest2 = [...arguments];  //将argments转换为真正数组  Array.prototype.slice.call(arguments)\n\n    if(this instanceof F){\n      //判断是否通过new操作符,则直接用new 调用原函数,并用扩展运算符传递参数\n      return new _this(...rest2); \n    }else{\n      //用apply调用第一步保存的函数，并绑定this，传递合并的参数数组 rest.concat(rest2) \n      return _this.apply(context, [...rest,...rest2]);\n    }\n  }\n}\n```\n\n\n### 实现函数柯里化\n```js\n//思路\n1.  参数复用，例如用于累加函数\n2.  延迟执行,类似bind改变this指向，待执行函数\n\n\n//实现\nfunction myCurrying(fn, args){\n   let _this = this;\n   let len = fn.length;\n   let args = args || [];\n\n   return function (){\n       let _args = Array.prototype.slice.call(arguments);\n       Array.prototype.push.call(args, _args);  //es6写法： args.push(..._args)/ [...args, ..._args]\n    \n        // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数\n       if(_args.length < len){\n          return myCurrying.call(this, fn, _args);\n       }\n\n       return fn.apply(this, _args);\n   }\n}\n\n```\n\n\n### 实现EventEmitter\n```js\n//原理\n1. on(event, fn) //监听event事件， 调用fn回调函数\n2. once(event, fn)  //指定事件注册单个监听器\n3. emit(event, arg1, arg2, arg3...) //触发event事件， \n4. off(event, fn) //停止监听某个事件\n\n//实现\nclass EventEmit{\n  constructor(){\n     this._events = {}; \n  }\n \n  on(event, fn){\n    // 这里的数组是队列， 遵循先进先出\n    let callback = this._events[event] || [];\n    if(callback.indexOf(fn) !== -1){\n       callback.push(fn);\n    }\n    this._events[event] = callback;\n    return this;\n  }\n\n  off(event, fn){\n    let callback = this._events[event];\n    this._events[event] = callback && callback.filter(fn => {\n      fn !== callback;\n    })\n    return this;\n  }\n\n  emit(...args){\n    let event = args[0];\n    let params = [].slice.call(args, 1); //除了event的参数==[...args].slice(1);\n    let callback = this._events[event];\n    callback.forEach((fn)=>{\n       fn.apply(this, params);\n    });\n    return this;\n  }\n\n\n  once(event, fn){\n    let wrapFn = (...args) =>{\n       fn.apply(this, args);\n       this.off(event, wrapFn);\n    }\n    this.on(event, wrapFn);\n    return this;\n  }\n\n}\n\n```\n\n### 实现Promise\n```js\n//原理\n1. 三种状态 pedding fulfilled rejected\n2. 实例then方法（静态方法、catch、finally 没实现)\n3. 链式调用 \n\n//实现\nclass Promise{\n  constructor(fn){\n    this.state = 'pedding';\n    this.value = '';\n    this.reason = '';\n\n    let resolve = (value) =>{\n       if(this.state == 'pedding'){\n         this.state = 'fulfilled';\n         this.value = value;\n       }\n    }\n\n    let reject = (value) => {\n       if(this.state == 'pedding'){\n         this.state = 'rejected';\n         this.reason = value;\n       }\n    }\n\n    try{\n      fn(resolve, reject);\n    }catch(e){\n      reject(e);\n    }\n  }\n\n  then(onFulfilled, onRejected){\n     switch(this.state){\n        case 'fulfilled':\n         onFulfilled(this.value);\n         break\n        case 'rejected':\n          onRejected(this.value);\n          break\n     }\n     return this;    //返回自身链式调用\n  }\n}\n```\n\n### 实现Array.prototype.flat\n```js\n//原理\n1. flat将多维数组转为指定深度数组\n    [1, 2, [3, 4, [5, 6]]].flat() ===>  [1, 2, 3, 4, [5, 6]]\n    [1, 2, [3, 4, [5, 6]]].flat(2) ===> [1, 2, 3, 4, 5, 6]\n\n//实现\nArray.prototype.myFlat = function (deep = 1){\n if(Array.isArray(this)){\n   let arr = [];\n   if(!Numnber(deep) || Number(deep) < 1){\n       return this;\n   }\n\n   this.forEach((item)=>{\n     if(Array.isArray(item)){\n        arr = arr.conact(item.myFlat(--deep));\n     }else{\n        arr.push(item);\n     }\n   })\n\n   return arr;\n\n }else{\n     console.error(`请输入数组`);\n }  \n}\n```\n### 实现 Array.prototype.reduce\n```js\n//原理\n1. Array.prototype.reduce(callback(accumulator, currentValue[, index[, array]])[,initialValue])  //参数：回调函数[accumulator累加值， currentValue当前值， index索引， array源数组]（必填）、初始值（选填）\n2. \n\n//实现\nArray.prototype.myReduce = function(cb, initVal){\n  let accumulator = initVal ? initVal : this[0];  //获取数组中带个元素当初始值\n  for(let i=initVal ? 0 : 1; i<this.length; i++){\n     accumulator = cb(accumulator, this[i], i, this); \n  }\n  return accumulator;\n}\n\n//用法\n[1, 2, 3, 4].myReduce((acc, current)=>{\n    acc+=current;\n    return acc;\n}, 5); //15\n```\n\n### 实现 Array.prototype.map\n```js\n//原理\nlet newArr = arr.map(function callback(currentValue[, index[, array]){\n\n}[, thisArg])  //参数: currentValue当前值  index索引值  array调用的函数  thisArg执行callback函数时值被用作this。\n\n[1, 2, 3].map(parseInt) => [1, NaN, NaN] //parseInt(1, 0) parseInt(2, 1) parseInt(3, 2)\n\n//实现\nArray.prototype.myMap = function(callback, thisArg){\n  let arr = [];\n  for(let i=0; i<this.length; i++){\n     arr.push(callback.call(thisArg, this[i], i, this));\n  }\n  return arr;\n}\n\n```\n\n### 实现Object.defineProperty\n```js\n//原理\n\n\n//双向绑定实现\nconst data = {\n  text: 'init'\n}\n\nvar input = document.getElementById('input');\nvar span = document.getElementById('span');\n\nObject.defineProperty(data, 'text', {\n  //数据变化修改视图\n  set(newValue){\n     span.innerText = newValue;\n  },\n  get(){\n    alert('触发了 get');\n    return 'get';  //此时text = 'get'\n  }\n})\n\ninput.addEventListener('keyup', function(e){\n   //触发set\n   data.text = e.target.value;\n})\n\n```\n\n### 实现 new Proxy\n```js\n//原理\n\n//双向绑定实现\nconst data = {\n  text: 'init'\n}\n\nvar input = document.getElementById('input');\nvar span = document.getElementById('span');\n\nconst handler = {\n  set(target, key, value){\n     target[key] = value;\n     span.innerText = value;\n     return value;\n  },\n  get(target, key){\n     return key in target ? target[key] : '';\n  }\n}\n\nconst proxy = new Proxy(data,handler);\n\ninput.addEventListener('keyup', function(e){\n   //触发set\n   proxy.text = e.target.value;\n})\n```\n\n### 实现ajax\n```js\n\n```","tags":["原生函数重写"]},{"title":"BFC相关","url":"/2020/03/12/BFC相关/","content":"\n### 什么是BFC?\n1. BFC(block formatting context) 块级格式化上下文。 \n2. 也可以理解BFC就是一个作用范围。可以把它理解成是一个独立的容器，并且这个容器的里box的布局，与这个容器外的毫不相干。\n\n### 如何产生BFC?\n1. html根元素\n2. float不为none（默认值）\n3. display:table-cell/inline-block\n4. overflow不为visible（默认值）\n5. position不为static/releative\n\n\n### BFC的作用？\n1. 解决不和浮动元素重叠（浮动元素跟随非浮动元素）\n```html\n<div style=\"float:left;\"></div>\n<div></div>\n```\n2. 清除元素内部浮动\n\n3. 解决上下相邻2个元素重叠\n","tags":["BFC","清除浮动","元素重叠"]},{"title":"现代浏览器工作","url":"/2020/03/11/现代浏览器工作/","content":"\n### 现代浏览器多进程架构\n1. 浏览器进程。 包括地址栏、前进后退、书签、文件访问\n2. 渲染进程。 负责一个网页tab的所有工作， 可以开启多个tab\n3. GPU进程。 负责GPU相关工作\n4. 插件进程。 例如词典的网页端划词插件\n5. 公共进程。\n\n\n### 现代浏览器工作原理","tags":["浏览器进程、线程"]},{"title":"vuex原理","url":"/2020/02/21/vuex原理/","content":"\n### 什么是vuex\nvuex是用于vue状态管理库， 将共享的数据抽离到全局， 以单例的方式存放， 形成单向数据流，同时利用vue响应式机制进行高效的管理和更新。\n\n\n### vuex流程\nVue Component进行 Dispatch 操作   ==>  触发Vuex Action（异步获取服务器数据， action无法直接改变state）  ==>  通过Mutation改变state   ==>  根据state的变化渲染Vue Component视图\n\n\n### vuex使用\n```js\n//store.js\nVue.use(Vuex)\n\n//将store放入到Vue创建时的option中（注入到vue实例中\nnew Vue({\n   el: '#app',\n   store\n}) \n```\n\n### vuex原理\n\n#### Vuex是怎样把store注入到Vue实例中？\n```js\n/*\n   暴露给外部的插件install方法，供Vue.use调用安装vuex。做了一下2件事情：\n      1. 保存Vue 同时检测是否重复安装\n      2. 将VueInit(Vuex的init钩子)混淆进Vue的beforeCreate(vue2.0) / _init(vue1.0)\n*/\n\n/*暴露给外部的插件install方法，供Vue.use调用安装插件*/\nexport function install (_Vue) {\n  if (Vue) {\n    /*避免重复安装（Vue.use内部也会检测一次是否重复安装同一个插件）*/\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(\n        '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n      )\n    }\n    return\n  }\n  /*保存Vue，同时用于检测是否重复安装*/\n  Vue = _Vue\n\n  /*将vuexInit混淆进Vue的beforeCreate(Vue2.0)或_init方法(Vue1.0)*/\n  applyMixin(Vue)\n}\n\nfunction applyMixin (Vue) {\n  var version = Number(Vue.version.split('.')[0]);\n\n  if (version >= 2) {\n    Vue.mixin({ beforeCreate: vuexInit });\n  } else {\n    var _init = Vue.prototype._init;\n    Vue.prototype._init = function (options) {\n      if ( options === void 0 ) options = {};\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit;\n      _init.call(this, options);\n    };\n  }\n\nfunction vuexInit () {\n    var options = this.$options;\n    // store injection（store注入到vue中\n    if (options.store) {\n      this.$store = typeof options.store === 'function'\n        ? options.store()\n        : options.store;\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store;\n    }\n  }\n}\nVuex源码：https://github.com/vuejs/vuex/blob/dev/dist/vuex.esm.js\n```\n\n#### Store的实现\n```js\n//传入根组件的Store\nexport default new Vuex.Store({\n  modules: {\n    modulesA,\n    modulesB,\n  },\n});\n\n//Store的构造函数\nconstructor (options = {}) {\n   \n    ...\n  \n    /* 存放action */\n    this._actions = Object.create(null)\n    /* 存放mutation */\n    this._mutations = Object.create(null)\n    /* 存放getter */\n    this._wrappedGetters = Object.create(null)\n    /* module收集器 */\n    this._modules = new ModuleCollection(options)\n    /* 根据namespace存放module */\n    this._modulesNamespaceMap = Object.create(null)\n    /* 存放订阅者 */\n    this._subscribers = []\n    /* 用以实现Watch的Vue实例 */\n    this._watcherVM = new Vue()\n\n    ...\n\n   /*初始化根module*/\n  installModule(this, state, [], this._modules.root)\n\n  /* 通过vm重设store，新建Vue对象使用Vue内部的响应式实现注册state以及computed */\n  resetStoreVM(this, state)\n  \n  /* 调用插件 */\n  plugins.forEach(plugin => plugin(this))\n\n  /* devtool插件 */\n  if (Vue.config.devtools) {\n    devtoolPlugin(this)\n  }  \n}\n```","tags":["vuex原理"]},{"title":"webpack相关","url":"/2020/02/14/webpack相关/","content":"\n## webpack核心概念\n\n1. entry : webpack项目入口\n2. module ： webpack一个模块对应一个文件， webpack从entry开始递归找出所有依赖模块\n3. chunk ： 代码块， 一个chunk由多个模块组成， 主要用于代码合并和分割\n4. loader ： 模块转换器， 用于将制定的模块内容转换为所需要的内容\n5. plugins ： 拓展插件， 用于在webpack构建过程中特定的时机广播对应的事件， 插件可以监听这些事件发生，做特定的事情\n\n## webpack流程\n\n### 初始化\n   1. 初始化相关参数： 从webpack.config.js和shell语句中读取\n\n### 编译\n   1. 开始编译： 用上一步读取到的配置参数初始化compiler对象， 加载所有的插件， 通过执行对象run方法进行编译\n   2. 确定入口： 根据entry找出所有的入口文件\n   3. 编译模块： 从入口文件出发， 调用所有的配置loader(从右到左，从下到上)对模块进行编译，再找出该模块依赖的模块，进行递归处理\n   4. 完成编译： 经过上一步， 得到每个模块被编译之后的最终内容以及他们的依赖关系\n### 输出\n   1. 输出资源： 根据入口和模块之间的依赖关系， 组装一个个包含多个模块的chunk, 再将每个chunk转换一个单独的文件到输出列表中， 这一步是修改输出内容的最后一步\n   2. 输出完成：根据上一步确定好输出内容之后， 根据webpack.config.js配置确定输出文件的路径和名称， 将文件写入磁盘(fs)\n\n## webpack原理\n1. 读取文件分析模块依赖\n2. 对模块进行解析执行(深度遍历)\n3. 对不同的模块使用相应的loader\n4. 编译模块，生成抽象语法树AST\n5. 循环遍历AST树，拼接输出js\n> webpack输出的js文件：1. __webpack_require__是模块加载函数， 2. 每个模块都有唯一的id(0, 1, 2,...)， 3. __webpack_require__.e是异步加载模块函数（Promise实现）， 4. webpackJsonp用于从异步加载的文件中安装模块\n\n## webpack模块打包原理\n### webpack打包出来的代码为啥能在浏览器上运行\n1. webpack对于ES模块/CommonJS模块的实现，是基于自己实现的webpack_require，所以代码能跑在浏览器中。\n2. 从 webpack2 开始，已经内置了对 ES6、CommonJS、AMD 模块化语句的支持。但不包括新的ES6语法转为ES5代码，这部分工作还是留给了babel及其插件。\n3. 在webpack中可以同时使用ES6模块和CommonJS模块。 因为 module.exports很像export default，所以ES6模块可以很方便兼容 CommonJS：import XXX from 'commonjs-module'。反过来CommonJS兼容ES6模块，需要额外加上default：require('es-module').default。\n\n### webpack最终精简代码\n```js\n(function(modules) { \n    /**\n     *  主要实现功能：\n     *  1. 定义模块缓存\n     *  2. 实现浏览器支持的require方法\n     *     1. 根据moduleId判断是否已缓存模块， 如果有缓存就返回缓存模块\n     *     2. 缓存模块相关信息\n     *     3. 调用模块函数\n     *     4. 标记已加载\n     *     5. 返回module.exports\n     *  3. 实现异步加载方法\n     *     1. require.ensure() 通过回调函数执行接下来的流程\n     *     2. webpack4 推荐 import(需要配合@babel/plugin-syntax-dynamic-import插件)  通过promise执行接下来的流程\n     *  4. ...\n     * **/\n     function __webpack_require__(moduleId) {\n        // 判断是否已缓存模块\n        if(installedModules[moduleId]) {\n            return installedModules[moduleId].exports;\n        }\n        //缓存模块\n        var module = installedModules[moduleId] = {\n            i: moduleId,\n            l: false,\n            exports: {}\n        };\n        //调用模块函数\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        //标记模块为已加载\n        module.l = true;\n        // 返回module.exports\n        return module.exports;\n    }\n})({\n    \"./src/bar.js\":\n    (function(module, exports, __webpack_require__) {\n        //bar.js代码\n    }),\n    \"./src/index.js\":\n    (function(module, exports, __webpack_require__) {\n        //index.js代码\n    })\n});\n\n```\n\n\n\n## webpack优化\n### 打包速度优化\n#### 缩小文件查找范围\n1. include指定查找范围、exclude排除文件查找范围\n\n#### 减小编译的文件内容\n1. 动态链接库DLL（webpack4可以用splitChunks, 不然代码会重复\n\n#### 充分利用电脑多核性能\n1. 多进程之HappyPack。 HappyPack就能让Webpack把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程，其中子进程的个数为cpu的个数减去1,需要在loader处修改如下\n\n### 项目代码优化\n#### 懒加载\n1. require.ensure();\n2. import();\n\n#### tree shaking\n1. 目的：消除无用到的代码， 推荐使用方法 { name } form './module.js' \n2. 原理：ES6引入模块是静态分析，所以编译的时候知道我们加载了哪些代码；进而分析哪些变量未用到，从而删除掉\n3. 有一些副作用（babel转换代码、自执行函数、函数里面使用外部变量\n\n<img src=\"/img/treeShaking.webp\" width=\"95%\" />\n\n#### 代码合并和分离(splitChunks)\n1. 分离部分第三方库（vue、vuex、vue-router）功能，类似于动态链接库DLL\n2. 合并公共代码（common\n\n## webpack插件\n### 插件相关概念\n1. Tapable: webpack自己写的基础类Tapable, Compiler、Compilation等都是继承于Tabable类\n2. Compiler: Webpack 环境所有的的配置信息，包含 options，loaders，plugins 这些信息\n3. Compilation: 包含了当前的模块资源、编译生成资源、变化的文件等\n\n### 插件创建流程\n1. 创建一个javascript构造函数\n2. 在他的原型定义apply方法\n3. 指定触发webpack的事件钩子\n4. 在钩子里面实现自己的业务逻辑\n5. 功能实现完成，调用webpack提供的callback\n\n### 使用案例\n```js\n//webpack1\n\nfunction AddHeadTextPlugin(options) {\n  this.options = options;\n}\n\nAddHeadTextPlugin.prototype.apply = function (compiler) {\n  const self = this;\n  compiler.plugin('emit', function(compilation, callback){\n      let outputfile = compilation.options.output;\n      let assets = compilation.assets;\n      let keys = Object.keys(assets);\n\n      callback();\n  });\n\n  compiler.plugin('done', function (compilation) {\n\n  });\n\n}\n\n```","tags":["webpack优化","webpack原理"]},{"title":"数据结构和算法","url":"/2020/02/05/数据结构和算法/","content":"\n## 算法\n\n#### 洗牌算法\n```js\n//要求：新生产的数组元素下标和原数组元素下标不能重复\n\n//思路\n// 1. 倒序循环这个数组\n// 2. 取值范围从1-N(数组的长度)随机数K\n// 3. K 与 N 交换\n// 4. 直到循环到数组的第一位\n\n\n//代码(大概率出现位置没有改变)\nArray.prototype.Shuffle = function(){\n  for(let i = this.length-1; i >= 0; i--){\n      let randomIndex = Math.floor(Math.random() * (i+1));\n      let itemIndex = this[randomIndex];\n      this[randomIndex] = this[i];  //交换\n      this[i] = itemIndex;\n  }\n  return this;\n}\n\n\n//代码改进\n\n```\n\n#### 判断正整数是否对称\n```js\n//要求：12321、 1234321\n\n\n//思路： 原数和倒序数相等则可以判断对称\n\n\n//代码实现：\nfunction reverse(n){\n  let result = 0;\n  //对数字依次求模，从右至左求出数字每一位\n  while(n){\n    result = result * 10 + n % 10;  //%10得到最后一位数，  %100得到最后二位数\n    n = parseInt(n / 10);     //去除个位数其他的数\n  }\n  return result;\n}\n\nfunction isMirror(n){\n  if(n === reverse(n))return true;\n  return false;\n}\n```\n\n\n#### 判断10进制整数包含多少个n[0 - 9]\n```js\n//要求： 不能通过转换为String，然后通过循环来判断\n\n//思路： 一位一位数进行对比\n\n//代码实现：\nfunction count(num, n){\n   let count = 0;\n   while(num){\n      let currNum = num % 10;   //求模得到最后一个数\n      num = parseInt(num / 10);  //去除最后一位数\n      if(currNum === n){\n         count++;\n      }\n   }\n   return count;\n}\n```\n\n#### 寻找重复数\n```js\n\n//要求：从一个数组找出重复数\n\n//思路：  1. 利用sort()进行从排序  2. 前面和后面进行对比\n\n//代码实现：\nfunction findDuplicate(arr){\n  let newArr = [];\n  arr.sort();\n  for(let i=0; i<arr.length; i++){\n     if(arr[i] === arr[i+1] && newArr.indexOf(arr[i]) < 0){\n        newArr.push(arr[i]);\n     }\n  }\n  return newArr;\n}\n```\n\n#### 寻找2个字符串最大公共子串\n```js\n//要求：\n\n//思路： 1. 2个字符串构成矩阵结构（行列结构）  2. 对矩阵中每一项进行对比看是否匹配（1匹配0不匹配 3. 然后求出对角线最长为1的那一段序列，即为最大公共子串\n\n\n//代码实现：\nfunction findMaxSubStr(str1, str2){\n  if(str1.length === 0 || str2.length ===0){\n    return '';\n  }\n  \n  let len1 = str1.length;\n  let len2 = str2.length;\n  let arr = [];\n  let maxLen = 0;  //公共子串长度\n  let maxPos = 0;  //公共子串最后一个字符位置\n\n  for(let i=0; i<len1; i++){\n    for(let j=len2-1; j>=0; j--){\n       if(str1.charAt(j) == str2.charAt(i)){\n         //匹配\n         if(i===0 || j===0){\n           arr[j] = 1;\n         }else{\n           arr[j] = arr[j-1]+1;\n         }\n       }else{\n         //不匹配\n         arr[j] = 0;\n       }\n       if(arr[j] > maxLen){\n           maxLen = arr[j];\n           maxPos = j;\n       }\n    }\n  }\n   return str1.substr(maxPos - maxLen + 1, maxLen);\n}\n\n//代码优化\n//思路： 公共子串肯定<=Math.min(str1, str2)、 而且还是连续的、而且还是str1和str2的子串\n\nfunction findMaxSubstr(str1 = '', str2 = ''){\n    if (str1 == '' || str2 == '') {\n        return '';\n    }\n    let maxSubStr = '';\n    let len1 = str1.length;\n    let len2 = str2.length;\n\n    //找出str1、str2中较小字符串; \n    //如果str1.length > str2.length, 就强制让str1变为最小字符串\n    if (len1 > len2) {\n        let temp = str1;\n        str1 = str2;\n        str2 = temp;\n        len1 = str1.length;\n        len2 = str2.length;\n    }\n\n    for (let i = len1; i > 0; i--) {\n        for (let j = 0; j <= len1 - i; j++) {\n            maxSubStr = str1.substr(j, i);  //j:开始位置， i:长度\n            if (str2.indexOf(maxSubStr) > -1) {\n                return maxSubStr;\n            }\n        }\n    }\n    return '';\n}\n```\n\n\n#### 对比版本号大小\n```js\n//思路\n1. 通过位数一个个对比\n\n//实现\nfunction compareVersion(curVer, oldVer){\n   if(curVer && oldVer){\n       let arr1 = curVer.split('.');\n       let arr2 = oldVer.split('.');\n       let minLen = Math.min(arr1.length, arr2.length);\n       let position = 0;\n       let diff = 0;\n       \n       //循环位数对比\n       while(position < minLen){\n         diff = parseInt(arr1[position]) - parseInt(arr2[position]);\n         //相同的位数指不一样就跳出循环体， 比较diff\n         if(diff != 0){\n            break;\n         }\n         position++;\n       }\n\n       if(diff == 0){\n           //curVer位数大于oldVer，且前面的值相等\n          return (arr1.length - arr2.length) > 0;\n       }else{\n          //curVer和oldVer中间位数指不相等\n          return diff > 0;\n       }\n\n   }else{\n     console.error('请输入版本号');\n     return false;\n   }\n}\n```\n#### 爬楼梯算法\n```js\n//题目\n假设在爬楼梯，需要n阶才能到达楼顶，每次可以爬1或者2个台阶， 有多少不同方法爬到楼顶？\n\n//思路\n1. 运用递归思路， 就是自己间接或者直接调用自己。 （递归可能会导致内存的溢出）\n2. 用循环的方式减少递归的内存消耗\n\n//解法\nconst climbing = function(n){\n   if(n < 1) return 0;\n   if(n === 1 || n === 2){\n      return n;\n   }else{\n      return climbing(n-2) + climbing(n-1);\n   }\n\n}\n\n\nconst climbing = function(n){\n   if(n < 1) return 0;\n   if(n === 1 || n === 2){\n      return n;\n   }\n   \n   let sum = 0;  //累计\n   let preStep = 2; //2个台阶\n   let prepreStep = 1; //一个台阶\n   for(let i=3; i<=n; i++){\n      sum = preStep + prepreStep;  //累计\n      prepreStep = preStep;   //\n      preStep = sum;\n   }\n   return sum;\n}\n\n```\n#### 有序数组旋转求出最小值\n```js\n//题目\n原 array：[0, 1, 2, 4, 5, 6, 7]\nrotate 之后就是：[4, 5, 6, 7, 0, 1, 2]\n输出：最小值 0\n\n//思路\n1. 遍历所有值，\b用一个变量记录最小值\n2. 二分查找(每次排除一半数据，留下另一半再进行对比)\n\n//具体实现\nexample: arr = [4, 5, 6, 7, 0, 1, 2];\n\n1. 中间值和最右边值进行对比， 如果中间值大于最右边值则认为最小值在右边区域。 left = middle + 1 (+1因为right > middle)\n2. 中间值和最右边值进行对比， 如果中间值小于最右边值则认为最小值在左边区域。 right = middle (最小值可能是middle本身)\n3. while终止条件: left == right\n\nconst findMin = function (arr = []){\n   if(arr.length <= 0){\n        return -1;\n   }\n   let left = 0;\n   let right = arr.length - 1;\n   while(left < right){\n      let middle = left + Math.floor((right - left) / 2);\n      if(arr[middle] > arr[right]){\n         left = middle + 1;\n      }\n      else if (nums[mid] == nums[right]){ //[2, 2, 1, 2]  middle == right\n         right --;\n      }\n      else{\n         right = middle;\n      }\n   }\n   return arr[left]; // arr[left] = arr[right]\n}\nfindMin([4, 5, 6, 7, 0, 1, 2]);\n```\n\n### 链表\n#### 链表介绍\n1. 线性结构。 数组、链表。 数组在内存中是连续的，所以通过下标查找性能好，但是删除和新增会导致整个数组变化性能反而不好。链表就反之。\n2. 非线性结构。树、堆。\n#### 反转链表\n```js\n//题目\n输入：1->2->3->4->null;\n输出：4->3->2->1->null;\n//思路\n1. 把当前节点的next属性指向它的前一个节点\n\n\n//实现\nfunction listNode(val){\n   this.val = val;   //当前节点\n   this.next = null;  //该节点指向下一个节点\n}\n\nconst reverseList = function (list){\n   if(list === null || list.next === null){\n       return list;\n   }\n   let pre = null, cur = list;\n   while(cur !== null){\n      let next = cur.next;  //保存临时变量\n      cur.next = pre;  //当前节点next指向前一个\n      pre = cur;\n      cur = next;\n   }\n\n   return pre;\n}\n\n```\n#### 删除链表中第N个节点\n```js\n\n```","tags":["数据结构","算法","链表"]},{"title":"vue相关疑点解析","url":"/2020/01/08/vue相关疑点解析/","content":"\n### 如何理解vue中的key\n#### 作用\n* v-for遍历时， 用id作为key， 唯一标识节点加速虚拟DOM的渲染\n```js\n//有相同父元素的子元素必须有独特的key。重复的key会造成渲染错误。\n<ul>\n  <li v-for=\"item in items\" :key=\"item.id\">...</li>\n</ul>\n```\n* 强制替换节点或者组件（component），而不重复使用它。\n```js\n<transition>\n  <span :key=\"abc\">{{ abc }}</span>\n</transition>\n//abc发生变化时，<span>会被替换，而不会patched(修复)，因此transition会被触发。    \n```\n\n#### 原理\n##### 加速虚拟DOM的渲染\n* 如果不用key，Vue会用一种算法（就地更新策略）：最小化element的移动，并且会尝试尽最大程度在同适当的地方对相同类型的element，做patch(修复)或者reuse（重用）。\n* 如果使用了key，Vue会根据keys的顺序记录element，曾经拥有了key的element如果不再出现的话，会被直接remove或者destoryed。\n* 如果使用key, 它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。\n\n##### 强制替换节点或者组件\n* 如果使用了key，Vue会根据keys的顺序记录element，曾经拥有了key的element如果不再出现的话，会被直接remove或者destoryed。\n* 完整地触发组件的生命周期钩子\n* 触发过渡\n\n\n### vue中组件数据传递\n#### 父组件到子组件\n* props\n```js\n//父\n <users :users=\"katty\"></users>\n\n//子\nexport default {\n  props:{\n    users:{           //这个就是父组件中子标签自定义名字\n      type:String,\n      required:true\n    }\n  }\n}\n```\n\n* $parent / $children / ref \n```js\n//父\n<compent ref=\"compent1\"></compent>\nexport default {\n   data: function(){\n      return {\n\n      }\n   },\n   methods: {\n     test: function(){\n\n     }\n   },\n   mounted(){\n     this.$refs.compent1.name //获取子组件compent的data\n   }\n}\n\n//子\nexport default {\n  data: function(){\n    return {\n      name: ''\n    }\n  }\n  created(){\n    this.$parent.test(); //获取父组件methods\n  }\n}\n```\n\n#### 子组件到父组件\n* 通过事件形式$emit\n```js\n//父\n\n\n//子\n```\n\n\n#### 祖父组件到孙组件","tags":["vue中key","vue组件数据传递"]},{"title":"js中的call、apply、bind的作用、应用场景以及区别","url":"/2019/12/22/js中的call、apply、bind的作用、应用场景以及区别/","content":"\n### call、apply、bind的作用与应用\n\n#### apply\n##### 介绍 \n* apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。\n\n##### 例子\n```js\nfunction sum(num1, num2){\n    return num1 + num2;\n}\n \nfunction callSum1(num1, num2){\n    return sum.apply(this, arguments);        // this== window   传入arguments对象\n}\n \nfunction callSum2(num1, num2){\n    return sum.apply(this, [num1, num2]);    // this == window    传入数组\n}\n \nalert(callSum1(10,10));   //20\nalert(callSum2(10, 10)); //20\n\n//第一个参数（当前例子中this）出现的四种情况\n（1） 不传，或者传null,undefined， 函数中的this指向window对象\n（2） 传递另一个函数的函数名，函数中的this指向这个函数的引用\n（3） 传递字符串、数值或布尔类型等基础类型，函数中的this指向其对应的包装对象，如 String、Number、Boolean\n（4） 传递一个对象，函数中的this指向这个对象\n```\n\n#### call\n\n##### 介绍 \n* call()方法接收多个\b参数：第一个是在其中运行函数的作用域，其他都是参数都直接传递给函数。\n\n##### 例子\n```js\n\nwindow.color = \"red\";\nvar o = { color: \"blue\" };\n \nfunction sayColor(){\n    alert(this.color);\n}\n \nsayColor();                //red\n//sayColor里面的this指向了this == window\nsayColor.call(this);       //red\nsayColor.call(window);     //red\n//sayColor里面的this指向了o\nsayColor.call(o);          // blue  \n\n```\n\n##### [].slice.call(arguments) 和 Array.prototype.slice.call(arguments)\n```js\n// 类数组: 可以通过索引访问元素，并且拥有 length 属性; 没有数组的其他方法，例如 push ， forEach ， indexOf 等.\nconst likeArr =  {\n    0: \"test\",\n    1: \"测试\",\n    length: 2\n}\n\n// 转换\n[].slice.call(likeArr);\n\n// \nvar args = []; \nfor (var i = 0; i < likeArr.length; i++) { \n    args.push(likeArr[i]);\n}\nconsole.log(args); // [\"test\", \"测试\"];\n\n/**\n * 原理\n */\n// [].slice()\nconsole.log([1,2,3].slice(0,1)) // [1]\nconsole.log([1,2,3].slice()) // [1,2,3]\n\n// Function.call()\nfunction func(name, price) {\n  this.name = name;\n  this.price = price;\n}\nvar food = {name:\"apple\",price:10};\nfunc.call(food,\"orange\",15);\nconsole.log(food); // {name: \"orange\", price: 15}\n\n\n//为了提高性能，减少一层对原型链的追溯，一般我们会采用以下的写法\n[].slice.call(arguments) --> Array.prototype.slice.call(arguments)\n```\n\n\n\n#### bind\n##### 介绍 \n* 这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。 便于后期调用， 不同于call、apply立即调用。\n\n##### 例子\n```js\nvar bar=function(){   \n  console.log(this.x);   \n}\nvar foo={ \n     x:3   \n}   \nbar();  \nbar.bind(foo)();\n /*或*/\nvar func=bar.bind(foo);\nfunc();\n\n输出：\nundefined\n3\n```","tags":["call","apply","bind"]},{"title":"Websocket协议","url":"/2019/12/08/Websocket协议/","content":"\n\n### Websocket介绍\nHTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。基于TCP这些应用程序需要与服务器进行双向通信，而不依赖于打开多个HTTP连接。\n\n\n### Websocket优缺点\n#### 优点\n1. 支持双向通信，实时性更强。\n2. 可以发送文本，也可以发送二进制数据。\n3. 较少的控制开销，通信性能更高。http1.x协议每次通信都需要携带完整的头部；websocket协议头部包含的较小。\n4. 允许跨域\n\n#### 缺点\n1. 对于客户端来说兼容性差。\n2. 对服务器来说开发者要求更高，长连接需要服务业务更加稳定（不能随便把进程和框架crash）。\n\n\n### Websocket协议流程\n#### 握手阶段\n1. WebSocket客户端的握手是一个HTTP Upgrade请求\n2. Sec-WebSocket-Key（请求头）以及Sec-WebSocket-Accept（响应头）。 目的：Websocket协议需要保证客户端发起的Websocket连接请求只会被能理解Websocket协议的服务器所识别。\n```js\n//相比传统的http多了这个2个值\nUpgrade: websocket\nConnection: Upgrade\n```\n\n\n\n#### 数据传输阶段\n客户端与服务器之间互相传输数据的的基本单位根据规格说明书里我们称为“Messages”。在实际网络中，这些Message由一个或多个Frames组成。解决了http的被动性、无状态性。\n\n\n### Websocket使用\n#### 客户端使用\n```js\nconst ws = new WebSocket(\"wss://127.0.0.1\"); //ws默认端口:80， wss默认端口:443\n\n//建立连接\nws.onopen = function(evt) { \n  console.log(\"Connection open ...\"); \n  ws.send(\"Hello WebSockets!\");\n};\n\n//接受服务器信息调用\nws.onmessage = function(evt) {\n  console.log( \"Received Message: \" + evt.data);\n  ws.close();\n};\n\n//连接出错时候调用\nws.onerror = function(){\n\n}\n\n//连接终止是调用\nws.onclose = function(evt) {\n  console.log(\"Connection closed.\");\n};\n```\n\n#### 服务器使用\n1. 常用的Node实现有:Socket.IO、WebSocket-Node。\n\n\n#### 检测心跳\n1. 在使用websocket的过程中，有时候会遇到客户端网络关闭的情况，而这时候在服务端并没有触发onclose事件。这样会：\n   1. 多余的连接\n   2. 服务端会继续给客户端发数据\n\n\n#### 身份认证\n1. 大体上Websocket的身份认证都是发生在握手阶段，通过请求中的内容来认证。一个常见的例子是在url中附带参数token。\n\n#### 解决ws与wss共存\n1. nginx配置\n\n\n#### websocket和http2服务器推送的区别\n1. websocket是全双工同学， 消息可以直接推送给webapp, 也就是说webapp有API来获取服务器推送的数据\n2. http2虽然也支持server push，但是服务器只会主动把资源推送到客户端缓存，并不直接推送到webapp本身。 也可以说webapp本身没有直接响应这些数据的API接口。","tags":["websocket协议"]},{"title":"Nodejs进程和线程相关","url":"/2019/11/18/Nodejs进程和线程相关/","content":"### 进程\n#### 介绍\n进程是资源分配的最小单位。我们启动一个服务、运行一个实例，就是开一个服务进程，Node.js 里通过 node app.js 开启一个服务进程，多进程就是进程的复制（fork），fork 出来的每个进程都拥有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享。\n\n#### Node.js默认主进程创建\n1. node app.js\n```js\nconst server = http.createServer();\nserver.listen(3000,()=>{\n    process.title='测试进程';\n    console.log('进程id',process.pid);\n})\n```\n#### Node.js多进程创建\n##### child_process模块\n1，api使用\n  1. child_process.spawn()：适用于返回大量数据，例如图像处理，二进制数据处理。\n  2. child_process.exec()：适用于小量数据，maxBuffer 默认值为 200 * 1024 超出这个默认值将会导致程序崩溃，数据量过大可采用 spawn。\n  3. child_process.execFile()：类似 child_process.exec()，区别是不能通过 shell 来执行，不支持像 I/O 重定向和文件查找这样的行为。\n  4. child_process.fork()：衍生新的进程，进程之间是相互独立的，每个进程都有自己的 V8 实例、内存，系统资源是有限的，不建议衍生太多的子进程出来，通常根据系统 * CPU 核心数 * 设置（cpu核心数的获取方式 constcpus=require('os').cpus()）。\n\n2，fork开启子进程代码Demo\n```js\n//app.js文件\nconst http = require('http');\nconst fork = require('child_process').fork;\n\nconst server = http.createServer((req, res) =>{\n    if(req.url === '/test'){\n        const fork = require('./fork.js');\n        fork.send('开启一个新的子进程');\n\n        // 当一个子进程使用 process.send() 发送消息时会触发 'message' 事件\n        fork.on('message', (sum)=>{\n            res.send(`Sum is ${sum}`);\n            fork.kill();\n        });\n\n        // 子进程监听到一些错误消息退出\n        fork.on('close', (code, signal)=>{\n            console.log(`收到close事件，子进程收到信号 ${signal} 而终止，退出码 ${code}`);\n            fork.kill();\n        });\n\n    }else{\n        res.send(`ok`);\n    }\n})\n\nserver.listen(3001, ()=>{\n    console.log(`server started at http://127.0.0.1:3001`)\n});\n\n\n//fork.js文件\nconst computation = () =>{\n    let sum = 0;\n    console.log(`计算开始`);\n    console.time(`计算耗时开始`);\n    for(let i = 0; i < 100000; i++){\n        sum += 1;\n    }\n    console.log(`计算结束`);\n    console.time(`计算耗时结束`);\n    return sum;\n}\n\n\nprocess.on('message', msg => {\n   console.log(`${msg}; process.pid:${process.pid}`);\n   const sum = computation();\n   process.send(sum);  //发送消息给父进程\n});\n\n```\n\n\n##### cluster模块\n1，cluster开启子进程代码Demo\n```js\n//app.js\nconst http = require('http');\nconst cpusNum = require('os').cpus().length;\nconst cluster = require('cluster');\n\nif(cluster.isMaster){\n   console.log(`Master process id is: ${process.pid}`);\n   for(let i = 0; i < cpusNum; i++){\n      cluster.fork();\n   }\n\n   cluster.on('exit', (work, code, signal)=>{\n      console.log(`worker process died,id: ${worker.process.pid}`);\n   })\n}else{\n   http.createServer((req, res)=>{\n       res.writeHead(200);\n       res.end(`hello world`);\n   }).listen(3001);\n}\n\n```\n\n> 在单核 CPU 系统之上我们采用 单进程 + 单线程 的模式来开发。在多核 CPU 系统之上，可以通过 child_process.fork 开启多个进程（Node.js 在 v0.8 版本之后新增了Cluster 来实现多进程架构） ，即 多进程 + 单线程 模式。注意：开启多进程不是为了解决高并发，主要是解决了单进程模式下 Node.js CPU 利用率不足的情况，充分利用多核 CPU 的性能。\n\n#### Node.js进程通信原理\n##### IPC(进程间通信)\n1. ipc创建过程\n  1. 主进程  ==> 生成工作进程\n  2. 工作进程  ==> 连接IPC   \n  3. 主进程  ==> 监听/接受IPC\n\n#### process模块\n##### 介绍\nNode.js 中的进程 Process 是一个全局对象，无需 require 直接使用，给我们提供了当前进程中的相关信息：\n1. process.env：环境变量，例如通过 process.env.NODE_ENV 获取不同环境项目配置信息\n1. process.nextTick：这个在谈及 EventLoop 时经常为会提到\n1. process.pid：获取当前进程id\n1. process.ppid：当前进程对应的父进程\n1. process.cwd()：获取当前进程工作目录，\n1. process.platform：获取当前进程运行的操作系统平台\n1. process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值\n1. 进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听\n1. 三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出\n1. process.title 指定进程名称，有的时候需要给进程指定一个名称\n\n\n### 线程\n#### 介绍\n线程是操作系统能够进行运算调度的最小单位，首先我们要清楚线程是隶属于进程的，被包含于进程之中。一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的。\n\n#### nodejs线程\n1. Node.js 虽然是单线程模型，但是其基于事件驱动、异步非阻塞模式，可以应用于高并发场景，避免了线程创建、线程之间上下文切换所产生的资源开销。\n2. 当你的项目中需要有大量计算，CPU 耗时的操作时候，要注意考虑开启多进程来完成了。\n3. Node.js 开发过程中，错误会引起整个应用退出，应用的健壮性值得考验，尤其是错误的异常抛出，以及进程守护（Pm2、Forever）是必须要做的。\n4. 单线程无法利用多核CPU，但是后来Node.js 提供的API以及一些第三方工具相应都得到了解决。\n\n\n[资料来源于1](https://mp.weixin.qq.com/s/VzXnnfn4gCBMd5wea3LRIg)\n[资料来源于2](https://www.shengshunyan.xyz/2021/03/31/Node.js%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/#cluster)","tags":["nodejs","nodejs进程、nodejs线程"]},{"title":"Dart语法","url":"/2019/11/09/Dart语法/","content":"\n### 相关概念\n1. 所有能够使用变量引用的都是对象， 每个对象都是一个类的实例。在 Dart 中 甚至连数字、方法和 null 都是对象。所有的对象都继承于 Object 类\n2. 使用静态类型( String, int,  bool, num) 可以更清晰的表明你的意图，并且可以让静态分析工具来分析你的代码， 但这并不是强制性的。（在调试代码的时候你可能注意到 没有指定类型的变量的类型为 dynamic。）\n3. Dart 在运行之前会先解析你的代码。你可以通过使用 类型或者编译时常量来帮助 Dart 去捕获异常以及 让代码运行的更高效\n4. Dart 支持顶级方法 (例如 main())，同时还支持在类中定义函数。 （静态函数和实例函数）。 你还可以在方法中定义方法 （嵌套方法或者局部方法）。\n5. 同样，Dart 还支持顶级变量，以及 在类中定义变量（静态变量和实例变量）。 实例变量有时候被称之为域（Fields）或者属性（Properties）。\n6. 和 Java 不同的是，Dart 没有 public、 protected、 和 private 关键字。如果一个标识符以 (_) 开头，则该标识符 在库内是私有的\n\n### 变量（variables）\n#### 变量赋值 \n```\nvar name = 'chao';  //上面名字为 name 的变量引用了 一个内容为 “chao” 的 String 对象\n```\n#### 默认值\n```\n//没有初始化的变量自动获取一个默认值为 null。\n//类型为数字的变量如何没有初始化其值也是 null，不要忘记了数字类型也是对象。\nint age;  \n```\n#### 可选的类型\n在声明变量的时候，你可以选择加上具体 类型：\n```\nString name = 'chao';\n```\n\n#### final and const\n如果你以后不打算修改一个变量，使用 final 或者 const。 一个 final 变量只能赋值一次；一个 const 变量是编译时常量。 （const 变量同时也是 final 变量。） 顶级的 final 变量或者类中的 final 变量在 第一次使用的时候初始化。\n\n1. const 只能被设一次值，在声明处赋值，且值必须为编译时常量；用于修饰常量。\n```dart\nconst bar = 1000000;       // 定义常量值\n// bar =13;   // 出现异常，const修饰的变量不能调用setter方法，即：不能设值，只能在声明处设值\nconst atm = 1.01325 * bar; // 值的表达式中的变量必须是编译时常量（bar）;\n\nvar c = 12;\n//  atm = 1 * c;  //出错，因为c不是一个编译时常量，即：非const修饰的变量（只有const修饰的变量才是编译时常量）\n```\n\n2. final：只能被设一次值，在声明处赋值，值和普通变量的设值一样，可以是对象、字符串、数字等，用于修饰值的表达式不变的变量；\n  1. 对象成员值能被修改，对于能够添加成员的类（如List、Map）则可以添加或删除成员。(类似js中const)\n  2. 变量本身实例不能被修改。(类似js中const)\n\n> 注意： 实例变量可以为 final 但是不能是 const 。\n```dart\n//const就不能用在表达实例对象上\nfinal wordPair = new WordPair.random(); \n```\n\n\n### 内置的类型(Built-in types)\n#### 类型\n##### number\n1. 分为：int、double\n2. strings和numbers转换\n```dart\n// String -> int\nvar one = int.parse('1');\nassert(one == 1);\n\n// String -> double\nvar onePointOne = double.parse('1.1');\nassert(onePointOne == 1.1);\n\n// int -> String\nString oneAsString = 1.toString();\nassert(oneAsString == '1');\n\n// double -> String\nString piAsString = 3.14159.toStringAsFixed(2);\nassert(piAsString == '3.14');\n```\n\n##### string\n1. 可以在字符串中使用表达式，用法是这样的： ${expression}。如果表达式是一个比赛服，可以省略 {}。 如果表达式的结果为一个对象，则 Dart 会调用对象的 toString() 函数来获取一个字符串。\n```dart\nvar s = 'string interpolation';\nassert('Dart has $s, which is very handy.' ==\n       'Dart has string interpolation, ' +\n       'which is very handy.');\nassert('That deserves all caps. ' +\n       '${s.toUpperCase()} is very handy!' ==\n       'That deserves all caps. ' +\n       'STRING INTERPOLATION is very handy!');\n```\n2. 可以使用 + 操作符来把多个字符串链接为一个，也可以把多个 字符串放到一起来实现同样的功能：\n```\nvar s1 = 'String ' 'concatenation'\n         \" works even over line breaks.\";\nassert(s1 == 'String concatenation works even over '\n             'line breaks.');\nvar s2 = 'The + operator '\n         + 'works, as well.';\nassert(s2 == 'The + operator works, as well.');\n```\n3. 使用三个单引号或者双引号也可以 创建多行字符串对象：\n```\nvar s1 = '''\nYou can create\nmulti-line strings like this one.\n''';\nvar s2 = \"\"\"This is also a\nmulti-line string.\"\"\";\n```\n\n##### boolean\n1. 当 Dart 需要一个布尔值的时候，只有 true 对象才被认为是 true。 所有其他的值都是 false。这点和 JavaScript 不一样， 像 1、 \"aString\"、 以及 someObject 等值都被认为是 false。\n\n\n##### list (也被称之为 array)\n1. 也许 array （或者有序集合）是所有编程语言中最常见的集合类型。 在 Dart 中数组就是 List 对象。所以 通常我们都称之为 lists。\n```\nvar list = [1, 2, 3];\nassert(list.length == 3);\nassert(list[1] == 2);\nlist[1] = 1;\nassert(list[1] == 1);\n```\n2. 在 list 字面量之前添加 const 关键字，可以 定义一个不变的 list 对象（编译时常量）：\n```\nvar constantList = const [1, 2, 3];\n// constantList[1] = 1; // Uncommenting this causes an error.\n```\n\n\n#####  map\n1. 通常来说，Map 是一个键值对相关的对象。 键和值可以是任何类型的对象。每个 键 只出现一次， 而一个值则可以出现多次。\n```dart\nvar gifts = {\n  'first' : 'partridge',\n  'second': 'turtledoves',\n  'fifth' : 'golden rings'\n};\n\nvar gifts = new Map();\ngifts['first'] = 'partridge';\ngifts['second'] = 'turtledoves';\n\n```\n\n2. 同样使用 const 可以创建一个 编译时常量的 map：\n```\nfinal constantMap = const {\n  2: 'helium',\n  10: 'neon',\n  18: 'argon',\n};\n// constantMap[2] = 'Helium'; // Uncommenting this causes an error.\n```\n\n\n##### rune (用于在字符串中表示 Unicode 字符)\n##### symbol\n\n### Function\n#### \b介绍\n1. Dart 是一个真正的面向对象语言，方法也是对象并且具有一种 类型， Function。 这意味着，方法可以赋值给变量，也可以当做其他方法的参数。 也可以把 Dart 类的实例当做方法来调用。\n```\nbool isNoble(int atomicNumber) {\n  return _nobleGases[atomicNumber] != null;\n}\n\n//可以选择忽略类型定义\nisNoble(atomicNumber) {\n  return _nobleGases[atomicNumber] != null;\n}\n```\n#### 可选参数、默认参数、命名参数\n1. 使用\n```dart\n /**\n  * 方法的可选参数 []\n  * 方法的形参默认值 sex = '男'\n  */\nString say(String from = 'china', String msg, [String device]) {\n  var result = '$from says $msg';\n  if (device != null) {\n    result = '$result with a $device';\n  }\n  return result;\n}\n\n\n/**\n* 定义一个命名参数的方法\n*/\nString printUserInfoByObject(String username, {int age = 10, String sex = '女'}){\n   if(sex == '女'){\n      return '我是非常可爱，姓名：$username --- 性别：$sex --- 年龄：$age';\n   }\n   return '我是非常帅气，姓名：$username --- 性别：$sex --- 年龄：$age';\n}\nprint(printUserInfoByObject('超超', age: 10, sex: '男'));\n```\n#### main() 入口函数\n```\nvoid main() {\n  querySelector(\"#sample_text_id\")\n    ..text = \"Click me!\"\n    ..onClick.listen(reverseText);\n}\n//.. 语法为 级联调用（cascade）。 使用级联调用语法， 你可以在一个对象上执行多个操作。\n```\n\n\n#### 静态作用域（scope）\n```\nvar topLevel = true;\nmain() {\n  var insideMain = true;\n\n  myFunction() {\n    var insideFunction = true;\n\n    nestedFunction() {\n      var insideNestedFunction = true;\n      assert(topLevel);\n      assert(insideMain);\n      assert(insideFunction);\n      assert(insideNestedFunction);\n    }\n  }\n}\n//nestedFunction() 可以访问所有的变量， 包含顶级变量\n```\n#### 自执行方法、箭头函数\n```dart\n/**\n  自执行方法\n**/\n((int num){\n   print('我就是自执行方法: $num');\n})(29)\n\n/**\n   箭头函数\n**/\n    List list=[4,1,2,3,4];\n    //匿名函数\n    var newList=list.map((value){\n      if(value>2){\n        return value*2;\n      }\n      return value;\n    });\n    print(newList.toList());\n\n    //箭头函数\n    var newList=list.map((value)=>value>2?value*2:value);\n```\n\n#### 闭包（closures）\n一个 闭包 是一个方法对象，不管该对象在何处被调用， 该对象都可以访问其作用域内 的变量\n```dart\n/**\n 闭包的特点：\n  1. 常驻内存\n  2. 内部变量，不污染全局\n*/\nFunction makeAdder(num addBy) {\n  return (num i) => addBy + i;\n}\nmain() {\n  var add2 = makeAdder(2);\n  add2(2);  // 4\n  add2(2);  // 6\n}\n```\n\n#### 返回值\n所有的函数都返回一个值。如果没有指定返回值，则 默认把语句 return null; 作为函数的最后一个语句执行。\n\n\n### 操作符\n#### 算术操作符\n```\nvar a, b;\n\na = 0;\nb = ++a;        // Increment a before b gets its value.\nassert(a == b); // 1 == 1\n\na = 0;\nb = a++;        // Increment a AFTER b gets its value.\nassert(a != b); // 1 != 0\n\na = 0;\nb = --a;        // Decrement a before b gets its value.\nassert(a == b); // -1 == -1\n\na = 0;\nb = a--;        // Decrement a AFTER b gets its value.\nassert(a != b); // -1 != 0\n```\n\n#### 级联操作符（..）\n级联操作符 (..) 可以在同一个对象上连续调用多个函数以及访问成员变量。 使用级联操作符可以避免创建 临时变量， 并且写出来的代码看起来 更加流畅：\n正确使用：\n```\nquerySelector('#button') // Get an object.\n  ..text = 'Confirm'   // Use its members.\n  ..classes.add('important')\n  ..onClick.listen((e) => window.alert('Confirmed!'));\n\n//上面代码和下面一样效果\nvar button = querySelector('#button');\nbutton.text = 'Confirm';\nbutton.classes.add('important');\nbutton.onClick.listen((e) => window.alert('Confirmed!'));\n```\n\n错误使用：\n```\nvar sb = new StringBuffer();\nsb.write('foo')..write('bar');\n//sb.write() 函数返回一个 void， 无法在 void 上使用级联操作符。\n```\n\n### 异常（Exceptions）\n#### 异常类型\n1. Error\n2. Exception\n\n#### 异常调用\n1. Throw\n```\nthrow new FormatException('Expected'); \nthrow 'Expected'; //任意对象\n```\n\n2. Catch\n捕获异常可以避免异常继续传递（你重新抛出rethrow异常除外）\n```dart\ntry{\n\n}on Exception catch (e){  //指定exception类型错误\n\n}catch(e){  //如果捕获语句没有指定类型，则可以捕获任意类型\n\n}\n```\n\n3. rethrow\n把捕获的异常给重新抛出。\n```dart\nfinal foo = '';\nvoid misbehave() {\n  try {\n    foo = \"You can't change a final variable's value.\";\n  } catch (e) {\n    print('misbehave() partially handled ${e.runtimeType}.');\n    rethrow; // Allow callers to see the exception.\n  }\n}\n\nvoid main() {\n  try {\n    misbehave();\n  } catch (e) {\n    print('main() finished handling ${e.runtimeType}.');\n  }\n}\n```\n\n4. Finally\n要确保某些代码执行，不管有没有出现异常都需要执行，可以使用 一个 finally 语句来实现。如果没有 catch 语句来捕获异常， 则在执行完 finally 语句后， 异常被抛出了：\n```dart\ntry {\n  breedMoreLlamas();\n} catch(e) {\n  print('Error: $e');  // Handle the exception first.\n} finally {\n  cleanLlamaStalls();  // Then clean up.\n}\n```\n\n### Class\n#### 介绍\nDart 是一个面向对象编程语言，同时支持基于 mixin 的继承机制。 每个对象都是一个类的实例，所有的类都继承于 Object.。 基于 Mixin 的继承 意味着每个类（Object 除外） 都只有一个超类，一个类的代码可以在其他 多个类继承中重复使用\n\n#### 基本语法\nA: 含义： 定义一个和类名字一样的方法就定义了一个构造函数\n```dart\n// dart中类的基本使用\n\nclass Person{\n  //公共属性\n  String name = 'chao';\n  int age = 10;\n  \n  //私有属性\n  String _sex = '男';\n\n  //默认构造方法\n  //初始化属性\n  Person(String name, int age):name='超',age=10{\n     this.name = name;\n     this.age = age;\n  }\n  \n  //默认构造方法简写\n  //Person(this.name, this.age);\n\n  //命名构造函数\n  Person.eat(){\n    print('我是命名构造函数');\n  }\n  \n  //公共方法\n  String say(){\n     return '我叫${this.name}, 我今年${this.age}';\n  }\n  \n  //私有方法\n  void _cry(){\n    print('我是私有方法')\n  }\n  \n\n  get myName{\n    return this.name;\n  }\n\n  set myAge(int age){\n    this.age = age;\n  }\n  \n  //私有方法\n  void _think(){\n     print('我是私有方法， ${this.name}正在思考中....');\n  }\n\n}\nPerson a = new Person('chao', 20);\nprint(a.myName);\na.myAge = 300;\nprint(a.say());\nprint(a.age);\n```\n\n#### 继承\n```dart\nclass Person {\n  String name;\n  int age;\n  String myWork;\n  Person(this.name, this.age, this.myWork);\n  void work(){\n    print('我来父类 ---- 我的工作是: ${this.myWork}');\n  }\n  void say(){\n    print('我的名字是:${this.name}, 我今年:${this.age}');\n  }\n}\n\n/**\n * 1. extends 继承关键词\n * 2. 子类会继承父类里面可见的属性和方法 但是不会继承构造函数\n * **/\nclass Stundent extends Person {\n  String sex;\n  /*\n      1. 构造方法无法继承\n      2. 可以通过super调用父类构造方法\n  */\n  Stundent(String name, int age, String myWork, String sex) : super(name, age, myWork){\n    this.sex = sex;\n  }\n\n  void run(){\n    //调用父类的方法\n    super.say();\n  }\n  \n  /**\n   *  1. 静态方法和静态属性通过类名方法，不能实例化访问\n   *  2. 静态方法不能访非静态属性和方法\n   *  3. 非静态方法可以方法静态属性和方法\n  */\n  static int score = 10;\n\n  static void cry(){\n    print('我好伤心的哭了, 因为我的分数是：$score');\n  }\n  \n  //重写父类的方法\n  @override\n  void work(){\n     print('我来子类 ---- 我的工作是: ${this.myWork}');\n  }\n}\n\nStundent s = new Stundent('chao', 10, '写代码', '男');\ns.run();\nStundent.cry();\n```\n\n#### 特点\n##### ?. 来替代 . \n```dart\n//?. 来替代 . 可以避免当左边对象为 null 时候 抛出异常\nvar p = new Point(2, 2);\np?.y = 4;\n```\n#####  级联操作..\n```dart\nvar p = new Point(2, 2);\np.y = 4\n ..printInfo()\n ..x = 5;\n```\n##### is 类型判断\n##### as 类型转换\n\n### 抽象类、接口\n#### 定义\n1. 抽象类主要是定义标准，子类可以继承抽象类，也可以实现抽象类接口。\n2. 抽象类通过abstract关键字来定义，定义没有方法体的方法我们称为抽象方法\n3. 抽象类不能被实例化，只有继承它的子类可以\n4. 如果子类继承抽象类必须得实现里面的抽象方法\n5. 子类可以实现多个接口（class C implements A,B{}）\n\n\n#### 使用\n##### extends和implements区别\n1. 如果要复用抽象类里面可见的方法和属性，并且要用抽象方法约束自类的话我们就用extends继承抽象类\n2. 如果只是把抽象类当做标准的话我们就用implements实现抽象类\n\n##### 代码实现\n```dart\n// Db.dart\nabstract class Db{   //当做接口   接口：就是约定 、规范\n    String URL;      //数据库的链接地址\n    add(String data);\n    save();\n    delete();\n    printInfo(){\n      print('我是Db类的打印方法');\n    }\n}\n\n//MySql.dart\n//如果只是把抽象类当做标准的话我们就用implements实现抽象类， 无法继承父类printInfo方法\nclass Mysql implements Db{\n  \n  @override\n  String URL;\n\n  Mysql(this.URL);\n\n  @override\n  add(data) {   \n    print('这是mysql的add方法'+data);\n  }\n\n  @override\n  delete() {   \n    return null;\n  }\n\n  @override\n  save() {   \n    return null;\n  }  \n}\n\n//NoSql.dart\n//只有在extends才会继承父类的printInfo方法\nclass NoSql extends Db{\n  @override\n  String URL;\n\n  NoSql(this.url);\n\n  @override\n  add(String data) {\n    print('这是NoSql的add方法'+data);\n  }\n\n  @override\n  delete() {\n    // TODO: implement delete\n    return null;\n  }\n\n  @override\n  save() {\n    // TODO: implement save\n    return null;\n  }  \n}\n\nNoSql nosql=new NoSql('xxxxxx');\nnosql.add('1243214');\nnosql.printInfo(); \n```\n\n### mixins\n#### 介绍\n##### 用途\n1. 可以实现类似extends的功能，但是不是继承\n2. 可以mixins多个类\n\n##### 使用条件\n1. 作为mixins的类只能继承自Object，不能继承其他类\n2. 作为mixins的类不能有构造函数\n3. mixins的实例类型就是超类的子类型\n4. with为mixins的关键字\n\n\n#### 使用\n```dart\n\nclass Person{\n  String name;\n  num age;\n  Person(this.name,this.age);\n  printInfo(){\n    print('${this.name}----${this.age}');\n  }\n  void run(){\n    print(\"Person Run\");\n  }\n}\n\n//B和A不能有构造函数， 也不能继承其他的类\nclass A {\n  String info=\"this is A\";\n  void printA(){\n    print(\"A\");\n  }\n  void run(){\n    print(\"A Run\");\n  }\n}\n\nclass B {  \n  void printB(){\n    print(\"B\");\n  }\n  void run(){\n    print(\"B Run\");\n  }\n}\n\n// C继承Person(可有构造方法)，但是Mixins了B、A\n// 每个类中有同样的方法和属性， 后面一个会覆盖前面， 也就是A会覆盖前面的B和Person\nclass C extends Person with B,A{\n  C(String name, num age) : super(name, age);\n}\n```\n\n### 泛型\n#### 泛型作用\n在Dart中类型是可选的，你可以选择不用泛型，使用泛型有下面几个好处：\n1. 有些情况下你可能想使用类型来表明你的意图，不管是使用泛型还是具体类型。\n2. 可以使用检查模式和静态分析工具提供的代码分析功能，提高代码健壮和安全性。\n3. 减少重复的代码。一个方法可以实现多种不同类型的作用。\n\n\n#### 泛型具体使用\n##### 方法\n```dart\nT getRawData<T>(T value){\n  return value;\n}\ngetRawData<num>(111);\n```\n##### 类\n```dart\nclass GetClass<T>{\n  List list = new List<T>();\n  add(T value){\n    this.list.add(value);\n  }\n  printClass(){\n    for(var i=0; i<this.list.length; i++){\n        print(this.list[i]);\n    }\n  }\n}\n```\n##### 接口\n```dart\nabstract class Cache<T>{\n   void getByKey(String key);\n   T setByKey(String key, T val);\n}\n\nclass FileCache<T> implements Cache<T>{\n  @override\n  void getByKey(String key) {\n     print('我是FileCache接口  key --- $key'); \n  }\n\n  @override\n  T setByKey(String key, T val) {\n    print('我是FileCache接口  key --- $key; val --- $val'); \n    return val;\n  }\n  \n}\n\nclass MemoryCache<T> implements Cache<T>{\n  @override\n  void getByKey(String key) {\n    print('我是MemoryCache接口  key --- $key'); \n  }\n\n  @override\n  T setByKey(String key, T val) {\n    print('我是MemoryCache接口  key --- $key; val --- $val'); \n    return val;\n  }\n}\n```\n\n\n### 库\n1. 内置库和包管理器提供的库pub\n```dart\nimport 'dart:io';  //内置库\nimport 'package:mylib/mylib.dart'; //包管理器库\nimport 'package:utils/utils.dart';\n```\n\n2. 导入库的一部分\n```dart\n// Import only foo.\nimport 'package:lib1/lib1.dart' show foo;\n\n// Import all names EXCEPT foo.\nimport 'package:lib2/lib2.dart' hide foo;\n```\n\n3. 延迟载入库\n```dart\n//deferred as\nimport 'package:deferred/hello.dart' deferred as hello;\n\n//使用库标识符调用 loadLibrary() 函数来加载库\n//await 关键字暂停代码执行一直到库加载完成\ngreet() async {\n  await hello.loadLibrary();\n  hello.printGreeting();\n}\n```\n\n### 异步流程\n#### 介绍\n有两种方式可以使用 Future 对象中的 数据：\n1. 使用 async 和 await\n2. 使用 Future API\n\n同样，从 Stream 中获取数据也有两种 方式：\n1. 使用 async 和一个 异步 for 循环 (await for)\n2. 使用 Stream API \n\n\n##### 使用\n```dart\ncheckVersion() async {\n  var version = await lookUpVersion();\n  if (version == expectedVersion) {\n    // Do something.\n  } else {\n    // Do something else.\n  }\n}\n```\n可以使用 try, catch, 和 finally 来处理使用 await 的异常\n\n\n[文字来源于](http://dart.goodev.org/guides/language/language-tour)","tags":["Dart"]},{"title":"async/await相关","url":"/2019/10/27/async-await相关/","content":"\n### async函数\n\n#### async介绍\n1. 返回值是Promise， 可以直接使用 then() 方法进行调用。\n2. 更好的语义。async 和 await 相较于 * 和 yield 更加语义化\n3. 让异步代码看起来更像同步代码\n\n#### async使用\n\n\n### await函数\n#### await使用\n1. await这个关键字只能在使用async定义的函数里面使用。\n2. \n\n#### await错误处理\n1. 推荐await命令放在try/catch\n2. Promise的catch()捕获错误\n\n\n### async缺点以及优化方法\n\n#### 缺点\n大量使用await函数，每个await将等待前一个Promise完成，这样会导致代码变慢（而实际上你想要的是promises同时开始处理，只对结果做同步处理）。\n\n\n#### 解决方案\n方案： 在这里，我们将三个Promise对象存储在变量中，这样可以同时启动它们关联的进程。\n```\nfunction timeoutPromise(interval) {\n  return new Promise((resolve, reject) => {\n    setTimeout(function(){\n      resolve(\"done\");\n    }, interval);\n  });\n};\n\n//优化前\nasync function timeTest() {\n  await timeoutPromise(3000);\n  await timeoutPromise(3000);\n  await timeoutPromise(3000);\n}\n\n\n//优化后\nasync function timeTest() {\n  const timeoutPromise1 = timeoutPromise(3000);\n  const timeoutPromise2 = timeoutPromise(3000);\n  const timeoutPromise3 = timeoutPromise(3000);\n\n  await timeoutPromise1;\n  await timeoutPromise2;\n  await timeoutPromise3;\n}\n\n\n//测试\nlet startTime = Date.now();\ntimeTest().then(() => {\n  let finishTime = Date.now();\n  let timeTaken = finishTime - startTime;\n  alert(\"Time taken in milliseconds: \" + timeTaken);\n})\n\n```","tags":["async","await"]},{"title":"Promise使用和原理","url":"/2019/10/26/Promise使用和原理/","content":"\n### Promise是什么？\nPromise是JS异步编程中的重要概念，异步抽象处理对象，是目前比较流行Javascript异步编程解决方案之一。这句话说的很明白了，Promise是一种用于解决异步问题的思路、方案或者对象方式。\n\n### Promise基本Api\n1. Promise.resolve()\n1. Promise.reject()\n1. Promise.prototype.then()\n1. Promise.prototype.catch()\n1. Promise.prototype.finally()\n1. Promise.all()  // 所有的完成\n1. Promise.race() // 竞速，完成一个即可\n\n\n\n### Promise用法\n1. 首先，Promise是一个对象，因此，我们使用new的方式新建一个。\n2. 然后给它传一个函数作为参数，这个函数呢也有两个参数，一个叫resolve(决定)，一个叫reject(拒绝)，这两个参数也是函数。\n3. 紧接着，我们使用then来调用这个Promise。\n\n参考代码\n```js\nnew Promise(function (resolve, reject) {\n  setTimeout(()=>{\n    let num = Math.ceil(Math.random() * 10)\n    if (num > 2) {\n      resolve(num)\n    } else {\n      reject(num)\n    }\n  },2000);\n}).then((res)=>{\n  console.log(res); //reslove()\n},(err)=>{\n  console.log(err); //reject()\n})\n```\n\n### Promise原理\n\n在Promise的内部，有一个状态管理器的存在，有三种状态：pending、fulfilled、rejected。\n  1. promise 对象初始化状态为 pending\n  2. 当调用resolve(成功)，会由pending => fulfilled\n  3. 当调用reject(失败)，会由pending => rejected\n\npromsie状态 只能由 pending => fulfilled/rejected, 一旦修改就不能再变（记住，一定要记住)；  当状态为fulfilled（rejected反之）时，then的成功回调函数会被调用，并接受上面传来的num，进而进行操作；promise.then方法每次调用，都返回一个新的promise对象 所以可以链式写法（无论resolve还是reject都是这样）。\n\n\n### Promise方法\n#### then\nthen方法用于注册当状态变为fulfilled或者reject时的回调函数：\n\n#### catch\n1. catch能捕获reject(err)中返回的错误。\n2. catch还能捕获链式调用then(()=>{}, ()=>{})中里面代码异常。\n```js\nconst fn = new Promise(function (resolve, reject) {\n  let num = Math.ceil(Math.random() * 10)\n  if (num > 10) {\n    resolve(num)\n  } else {\n    reject(num)\n  }\n})\nfn.then((res)=>{\n  console.log(res1)\n}).catch((err)=>{\n  console.log(`err==>${err}`)  //会提示res1未定义\n})\n```\n\n#### resolve、reject\nPromise.resolve 返回一个fulfilled状态的promise对象，Promise.reject 返回一个rejected状态的promise对象\n```\nPromise.resolve('hello').then(function(value){\n    console.log(value);\n});\n\nPromise.resolve('hello');\n// 相当于\nconst promise = new Promise(resolve => {\n   resolve('hello');\n});\n```\n#### all\n1. 大概就是作为参数的几个promise对象一旦有一个的状态为rejected，则all的返回值就是rejected。\n```\nvar   p1 = Promise.resolve(1),\n      p2 = Promise.reject(2),\n      p3 = Promise.resolve(3);\nPromise.all([p1, p2, p3]).then((res)=>{\n    //then方法不会被执行\n    console.log(results);\n}).catch((err)=>{\n    //catch方法将会被执行，输出结果为：2\n    console.log(err);\n});\n```\n2. 当这几个作为参数的函数的返回状态为fulfilled时，至于输出的时间就要看谁跑的慢了：\n\n\n#### race\n##### 介绍：\npromise.race()方法也可以处理一个promise实例数组但它和promise.all()不同，从字面意思上理解就是竞速，那么理解起来上就简单多了，也就是说在数组中的元素实例那个率先改变状态，就向下传递谁的状态和异步结果。但是，其余的还是会继续进行的。\n```\nlet p1 = new Promise((resolve)=>{\n  setTimeout(()=>{\n    console.log('1s') //1s后输出\n    resolve(1)\n  },1000)\n})\nlet p10 = new Promise((resolve)=>{\n  setTimeout(()=>{\n    console.log('10s') //10s后输出\n    resolve(10) //不传递\n  },10000)\n})\nlet p5 = new Promise((resolve)=>{\n  setTimeout(()=>{\n    console.log('5s') //5s后输出\n    resolve(5) //不传递\n  },5000)\n})\nPromise.race([p1, p10, p5]).then((res)=>{\n    console.log(res); // 最后输出\n})\n\n//输入结果\n1s\n1\n5s\n10s\n```\n\n##### 使用场景： 超时处理\n图片超时\n```\n//请求某个图片资源\nlet requestImg = new Promise(function(resolve, reject){\n        var img = new Image();\n        img.onload = function(){\n            resolve(img);\n        }\n    });\n//延时函数，用于给请求计时\nlet timeOut = new Promise(function(resolve, reject){\n        setTimeout(function(){\n            reject('图片请求超时');\n        }, 5000);\n    });\n\nPromise.race([requestImg, timeout]).then((res)=>{\n    console.log(res);\n}).catch((err)=>{\n    console.log(err);\n});\n```\n### Promise面试题\n1. 1，Promise状态一旦改变，无法在发生变更\n```\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('success')\n    reject('error')\n  }, 1000)\n})\npromise.then((res)=>{\n  console.log(res)\n},(err)=>{\n  console.log(err)\n})\n//输出结果：success\n```\n\n2. 2，Promise的then方法的参数期望是函数，传入非函数则会发生值穿透。\n```\nPromise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .then(console.log)\n//输出结果：1\n```\n\n\n3. 3，实现一个简单的Promise\n```\nfunction Promise(fn){\n  var status = 'pending'\n  function successNotify(){\n      status = 'fulfilled'//状态变为fulfilled\n      toDoThen.apply(undefined, arguments)//执行回调\n  }\n  function failNotify(){\n      status = 'rejected'//状态变为rejected\n      toDoThen.apply(undefined, arguments)//执行回调\n  }\n  function toDoThen(){\n      setTimeout(()=>{ // 保证回调是异步执行的\n          if(status === 'fulfilled'){\n              for(let i =0; i< successArray.length;i ++)    {\n                  successArray[i].apply(undefined, arguments)//执行then里面的回掉函数\n              }\n          }else if(status === 'rejected'){\n              for(let i =0; i< failArray.length;i ++)    {\n                  failArray[i].apply(undefined, arguments)//执行then里面的回掉函数\n              }\n          }\n      })\n  }\n  var successArray = []\n  var failArray = []\n  fn.call(undefined, successNotify, failNotify)\n  return {\n      then: function(successFn, failFn){\n          successArray.push(successFn)\n          failArray.push(failFn)\n          return undefined // 此处应该返回一个Promise\n      }\n  }\n}\n```\n解题思路：Promise中的resolve和reject用于改变Promise的状态和传参，then中的参数必须是作为回调执行的函数。因此，当Promise改变状态之后会调用回调函数，根据状态的不同选择需要执行的回调函数。\n\n[文章来源于掘金](https://juejin.im/post/5ad3fa47518825619d4d3a11#heading-0)","tags":["Promise原理","Promise使用"]},{"title":"计算机和网络基础","url":"/2019/10/17/计算机和网络基础/","content":"\n### Dns解析过程\n#### 递归查询\n1. 客户端(求问XXX的IP地址是多少)  --> 本地DNS服务器 (我不知道，但是根域名服务器可能会知道，我替去问他吧)\n2. 本地DNS服务器(求问XXX的IP地址是多少) --> 根域名服务器 (不知道，但是A域名服务器可能会知道，我替去问他吧)\n3. 根域名服务器(求问XXX的IP地址是多少)  --> A顶级域名服务器 （查到XXX的IP地址是192.168.168.6）\n4. 根域名服务器（查到XXX的IP地址是192.168.168.6） --> 本地DNS服务器\n5. 本地DNS服务器 （查到XXX的IP地址是192.168.168.6） --> 客户端\n\n\n\n#### 迭代查询\n1. 客户端(求问XXX的IP地址是多少) --> 本地dns服务器（我不知道，但是你可以问根域名服务器）\n2. 客户端(求问XXX的IP地址是多少) --> 根域名服务器 (我不知道， A顶级域名服务器可能会知道)\n3. 客户端(求问XXX的IP地址是多少) --> A顶级域名服务器 (查到XXX的IP地址是192.168.167.1)\n\n#### Dns解析过程\n1. 浏览器缓存查询\n2. 本地host文件是否映射\n3. 本地dnf服务器是否缓存（电脑上网时IPv4或者IPv6设置中填写的那个DNS，但是最终都会到网络运营商）\n4. 顶级服务器查询\n5. 迭代/递归查询 \n\n\n<img src=\"/img/dns.png\" width = \"700\" height = \"auto\" alt=\"dns解析\" align=center />\n\n### Ping过程\n\n#### 局域网（同一网段）\n1. 主机A封装二层报文，查找自己的的MAC地址表，如果没有主机B的MAC地址就向外发送ARP广播包\n2. 交换机收到报文，检索有没有保存主机B的MAC地址。 如果有会返回给A； 如果没有就向所有的端口发送ARP广播，其他主机收到纷纷丢弃，直到主机B收到报文就立即响应，同时学到主机A的MAC地址，并按同样的ARP报文格式返回给主机A。\n3. 主机A学到了主机B的MAC地址，就把这个MAC地址封装到ICMP协议的二层报文中向主机B发送。\n4. 当主机B收到了这个报文后，发现是主机A 的ICPM回显请求，就按同样的格式，返回一个值给主机A，这样就完成了同一网段内的ping过程。\n\n#### 外网 （跨网段）\n1. 主机A发现主机B和自己不是在同一网段，就去网关转发； 如果不知道网关mac地址，则发送一个ARP广播，学到网关的MAC地址，再发封装ICMP报文给网关路由器。\n2. 当路由器收到主机A发过来的ICMP报文，发现自己的目的地址是其本身MAC地址，然后得到出口，加上自己的mac向主机B转发。\n3. 主机B学习到路由器mac, 然后就将ICMP请求回复给主机A。\n\n\n[参考来源](https://blog.csdn.net/guoweimelon/article/details/50859658)\n\n\n### 操作系统内存管理\n\n\n\n### 进程和线程\n1. 进程是相互独立，线程是进程一个子集\n2. 进程拥有独立资源， 线程共享内存和资源\n3. 进程有独立的内存地址， 线程共享内存地址空间（共享进程上下文）","tags":["网络","计算机"]},{"title":"TCP三次握手和四次挥手","url":"/2019/10/08/TCP三次握手和四次挥手/","content":"\n### 三次握手过程理解\n1. 第一次握手； 建立连接时， 客户端发送syn包（同步序列编号[Synchronize Sequence Numbers]）到服务器，并进入SYN_SENT状态，等待服务器确认；\n2. 第二次握手; 服务器收到syn包，必须确认客户的ACK, 同时自己也发送一个SYN包，此时服务器进入SYN_RECV状态；\n3. 第三次握手；客户端收到服务器的SYN包，向服务器发送确认包ACK，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。\n\n\n<img src=\"/img/tcp.webp\" style=\"max-width:95%\" />\n\n\n### 四次挥手过程理解\n1. 客户端发送fin，请求关闭连接（fin类似连接时候的syn)\n2. 服务器收到fin, 回发一个ack确认\n3. 如果服务器也想断开连接，发送fin给客户端\n4. 客户端收到fin一样用ack作为应答\n\n\n\n\n### 为什么不能用两次握手进行连接？\n1. 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认\n2. 为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤\n\n### 为什么是4次挥手？\n1. 关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。\n\n\n### 如果已经建立了连接，但是客户端突然出现故障了怎么办？\n1. TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。\n\n\n<br>\n[文章参考](https://zhuanlan.zhihu.com/p/494612464)","tags":["tcp"]},{"title":"macOs相关","url":"/2019/10/06/macOs相关/","content":"\n### 线程之间通信\n#### performSelector\n1. - (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;  //返回主线程\n2. - (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait; //返回指定线程\n\n\n### load和initialize方法分别在调用时机\n#### + load\n1. 它应该是在一个类进行装载的时候触发，就是不管这个类有没有被调用，只要它被装载，那么它就会运行这个方法，只要被添加到编译源下面就会执行。\n2. 不管子类有没有写load方法，父类的load都只会执行一次。\n3. load方法执行的时候，系统为脆弱状态，如果我们在load里面需要调用其它类的实例对象(或类对象)的属性或者方法，必须要确保那个依赖类的load方法执行完毕\n4. 当加载资源过大会造成性能问题（用户体验、系统抖动）\n\n#### + initialize\n1. 如果没有用到该类，就算加载完毕也不会执行该方法（这点与load方法不同，load方法是只要加载就执行，initialize方法必须是第一次使用该类的时候才触发且触发一次）\n2. 以懒加载的方式被调用的，不是启动程序就调用。\n\n\n\n### runloop和线程的关系\n1. 每条线程都有唯一的一个 RunLoop 对象与之对应的\n2. 主线程的 RunLoop 是自动创建并启动\n3. 子线程的 RunLoop 需要手动创建(懒加载,只创建一次)\n4. RunLoop保存在一个全局的Dictionary里，线程作为key,RunLoop作为value\n5. RunLoop在第一次获取时创建，在线程结束时销毁\n```\n //启动RunLoop\n[[NSRunLoop currentRunLoop] run];\n\n\n//第一个参数:指定运行模式\n//第二个参数:指定 RunLoop 的过期时间,即:到了这个时间后RunLoop 就失效了\n[[NSRunLoop currentRunLoop] runMode:kCFRunLoopDefaultModebeforeDate:[NSDate distantFuture]];\n```\n\n\n### block的实质是什么？__block修饰的变量为什么能在block里面能改变其值？\n1. block其实也是一个oc对象，内部有一个isa指针\n2. __block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。\n3. block不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。栈区是红灯区，堆区才是绿灯区。\n\n\n### 创建线程的方法是什么?如果在主线程中执行代码，方法是什么? 如果想延时执行代码、方法又是什么? \n#### 创建线程\n   1. NSThread创建\n   2. GCD的dispatch创建\n   3. 使用子类化的NSOperation,然后将其加入NSOperationQueue;\n\n#### 在主线程执行代码\n   1. performSelectorOnMainThread 或者 GCD中 dispatch_main\n\n#### 延迟执行\n   1. performSelectorOnMainThread:onThread:withObject:waitUntilDone: 或者 GCD中 dispatch_after\n\n\n### delegate和notification区别和场景\n#### 区别\n   1. delegate效率高于notification\n   2. delegate比notification更加直观\n#### 场景\n   1. nofification适合2个不是很紧密的模块， 例如多线程传值。\n   2. delegate是一种简单的回调，且主要集中在一个模块。例如想把值从底层传到上层。\n","tags":["mac","ios"]},{"title":"富文本AttributedString的使用","url":"/2019/09/26/富文本AttributedString的使用/","content":"\n### 介绍\nAttributedString可以分为NSAttributedString和NSMutableAttributedString两种。在使用中通过将AttributedString赋值给控件的 attributedText 属性来添加文字样式\n\n### 使用方式\n\n#### 使用方式一\n\n1. 添加超链接、设置颜色\n```object-c\nNSString *string = @\"欢迎使用,这是测试哦\";\nNSMutableAttributedString *colorTitle = [[NSMutableAttributedString alloc] initWithString:string];\n\n//设置超链接\n[colorTitle addAttributes:@{\n                                NSUnderlineStyleAttributeName:@1,\n                                NSLinkAttributeName: [NSURL URLWithString:@\"https://baidu.com\"],\n                                } range:NSMakeRange(string.length-9, 4)];\n\n//设置字体大小\n[colorTitle addAttribute:NSFontAttributeName value:[NSFont systemFontOfSize:13] range:NSMakeRange(0, [string length])];\n\n//设置文字颜色\n[colorTitle addAttribute:NSForegroundColorAttributeName value:[NSColor redColor] range:NSMakeRange(17, 7)];\n\n//设置文字背景色\n[colorTitle addAttribute:NSBackgroundColorAttributeName value:[NSColor whiteColor] range:NSMakeRange(17, 7)];\n\n//添加下划线\n[colorTitle addAttribute:NSUnderlineStyleAttributeName value:[NSNumber numberWithInteger:NSUnderlineStyleSingle] range:NSMakeRange(17, 7)];\n\nNSTextField.attributedStringValue = colorTitle;\n```\n\n\n#### 使用方式二\n创建属性字典，并将各种属性初始化。赋值，并利用方法appendAttributedString:添加入NSMutableAttributedString，将其赋给控件的attributedText属性。\n\n```object-c\n//初始化NSMutableAttributedString\nNSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc]init];\n\n//设置字体格式和大小\nNSString *str0 = @\"欢迎使用,这是测试哦\";\nNSDictionary *dictAttr0 = @{NSFontAttributeName:[NSFont systemFontOfSize:14]};\nNSAttributedString *attr0 = [[NSAttributedString alloc]initWithString:str0 attributes:dictAttr0];\n[attributedString appendAttributedString:attr0];\n\n\n\n//设置阴影属性，取值为NSShadow对象\nNSString *str7 = @\"欢迎使用,这是测试哦\";\nNSShadow *shadow = [[NSShadow alloc]init];\nshadow.shadowColor = [NSColor redColor];\nshadow.shadowBlurRadius = 1.0f;\nshadow.shadowOffset = CGSizeMake(1, 1);\nNSDictionary *dictAttr7 = @{NSShadowAttributeName:shadow};\nNSAttributedString *attr7 = [[NSAttributedString alloc]initWithString:str7 attributes:dictAttr7];\n[attributedString appendAttributedString:attr7];\n\n\n//设置字体倾斜度 NSObliquenessAttributeName\nNSString *str12 = @\"设置字体倾斜度\";\nNSDictionary *dictAttr12 = @{NSObliquenessAttributeName:@(0.5)};\nNSAttributedString *attr12 = [[NSAttributedString alloc]initWithString:str12 attributes:dictAttr12];\n[attributedString appendAttributedString:attr12];\n\n\n//段落样式\nNSMutableParagraphStyle *paragraph = [[NSMutableParagraphStyle alloc]init];\n//行间距\nparagraph.lineSpacing = 10;\n//段落间距\nparagraph.paragraphSpacing = 20;\n//对齐方式\nparagraph.alignment = NSTextAlignmentLeft;\n//添加段落设置\n[attributedString addAttribute:NSParagraphStyleAttributeName value:paragraph range:NSMakeRange(0, attributedString.length)];\n\nNSTextField.attributedStringValue = attributedString;  //uilabel则是attributedText\n\n```","tags":["macos富文本","AttributedString"]},{"title":"前端协作规范指南","url":"/2019/09/15/前端协作规范指南/","content":"### 为啥需要规范？\n1. 降低新成员融入团队成本，同时也避免挖坑。\n2. 提高开发效率、团队协作效率，降低沟通成功。\n3. 实现代码风格高度统一，方便review,可以提高代码可维护性。\n4. 规范是实现自动化基础。\n\n### 工作流规范\n#### 1.开发规范\n1. 版本规范，大小版本号\n2. 项目分支规范(mastet、dev、hotfix、feature-xxx)\n3. 提交信息规范，不符合规范的代码和git提交信息不能入库。有利于review和自动化生成CHANGELOG\n\n#### 2.构建规范\n1. 约定优先配置。\n2. 方便升级。可以参考vue-cli、create-react-app等等\n\n#### 3.发布工作流规范\n1. 代表变更\n2. 提交代码变更到远程版本库\n3. 程序通过CI(持续集成)测试\n4. 合并到master分支\n5. 生成和提交CHANGELOG\n6. 打上Tag\n7. 推送\n\n\n#### 4.CD持续交付/部署规范\n\n\n#### 5.任务管理规范\n1. 看板是目前最为流行的任务管理工具。\n2. 图标类：甘特图。\n3. 工具类：Trello等\n\n\n### 技术栈规范\n#### 从技术框架角度\n1. 选择成长性的技术框架，要面向未来面向未来。例如选择Vue、React等有大厂支撑、社区的活跃度、开发活跃度。\n2. API稳定。考虑业务升级改造的成本。\n3. 生态系统是否完善。相关的组件是否齐全，社区的开发人员贡献。\n\n#### 从团队角度\n1. 选择团队最熟悉的技术；很好的控制使用过程中的风险，方便对程序进行调优。\n2. 从团体成长角度上看，可以选择新技术。作为leader需要考虑的是：\n   1. 学习成本。考虑团队成员的接纳能力。如果成本小于收获的利益，在团队里面推行估计阻力会比较大\n   2. 收益。是否能够解决当前的某些痛点\n   3. 风险。一般我们不能将一个实验阶段的技术使用的生产环境中\n\n#### 从业务角度\n1. 理解当前的业务，理解用户的需求，当下需要解决的首要问题，以及可能有的风险是那些。\n将目标进行分解，进行具体技术选型、模式设计、架构设计。\n\n### 项目组织规范\n#### 项目组织结构\n1. README.md:\n2. CHANGELOG.md:\n3. package.json:\n4. .gitignore: \n5. .gitattributes: git配置，有一些跨平台差异的行为可能需要在这里配置一下，如换行规则\n6. docs/: 项目的细化文档, 可选.\n7. build: 项目工具类脚本放置在这里，非必须。如果使用统一构建工具，则没有这个目录\n8. dist/: 项目构建结果输出目录\n9. src/: 源代码目录\n10. tests/: 单元测试目录. 按照Jest规范, __tests__目录通常和被测试的模块在同一个父目录下\n11. envConfig: 环境变量配置 \n\n\n### 编码规范\n#### 1.javascript\n1. 工具：eslint\n2. 规范：业界Airbnb规范\n3. 类型检测：Flow、Typescript(个人推荐)\n\n#### 2.css\n1. 工具：stylelint\n2. 规范： Airbnb css/ Sass Styleguide\n3. 方法论： BEM命名规范\n\n#### 3.html\n\n#### 4.代码格式化\n1. 工具：Prettier,代码格式化都可以交给他。\n\n#### 5.Code Review\n1. code review好处\n   1. 让其他成员快速熟悉代码\n   2. 让开发者提高自的代码质量\n   3. 提高成员的编码质量\n\n### 文档规范\n\n### 前后端协作规范\n\n### 技术沉淀\n\n\n[资料来源于掘金](https://juejin.im/post/5d3a7134f265da1b5d57f1ed)","tags":["前端规范","团队协作"]},{"title":"苹果内购","url":"/2019/09/11/苹果内购/","content":"\n### 支付状态\n* SKPaymentTransactionStatePurchasing：正在支付\n* SKPaymentTransactionStatePurchased：已支付\n* SKPaymentTransactionStateFailed：支付失败\n* SKPaymentTransactionStateRestored：恢复购买, 例如非消耗商品在iPad已经购买了，在iPhone恢复，或者卸载了App，重装没有及时更新状态，可以用这个恢复，用于非消耗品\n* SKPaymentTransactionStateDeferred：未确定状态, 由于外部原因导致的（如家长控制，未测试）\n\n\n### 支付流程\n#### 1. 直接和Apple服务器进行购买和验证\n#### 2. 自己架设服务器进行验证\n1. 用户进入购买虚拟物品页面， APP从后台服务器获取产品列表展示给用户\n2. 用户点击购买某一虚拟物品，app就把该虚拟物品productionIdentifier发送到Apple服务器\n3. Apple服务器根据app发送过来的productionIdentifier返回相应物品的信息（描述、价格等等）\n4. 用的点击确认购买，购买请求就发送到Apple服务器\n5. Apple服务器完成购买，返回给用户一个完成购买凭证\n6. app根据Apple服务器返回的购买凭证，拿到后台服务器验证\n7. 后台服务器把凭证发送到Apple服务器验证，Apple返回一个字段给后台服务器表明该凭证是否有效\n8. 后台服务器把验证结果发送到app，app根据验证结果做相应的处理\n\n\n### 虚拟物品类型\n1. 消耗品（Consumable products）：比如游戏内金币等。\n2. 不可消耗品（Non-consumable products）：简单来说就是一次购买，终身可用（用户可随时从App Store restore）。\n3. 自动更新订阅品（Auto-renewable subscriptions）：和不可消耗品的不同点是有失效时间。比如一整年的付费周刊。在这种模式下，开发者定期投递内容，用户在订阅期内随时可以访问这些内容。订阅快要过期时，系统将自动更新订阅（如果用户同意）\n4. 非自动更新订阅品（Non-renewable subscriptions）：一般使用场景是从用户从IAP购买后，购买信息存放在自己的开发者服务器上。失效日期/可用是由开发者服务器自行控制的，而非由App Store控制，这一点与自动更新订阅品有差异。\n5. 免费订阅品（Free subscriptions）：在Newsstand中放置免费订阅的一种方式。免费订阅永不过期。只能用于Newsstand-enabled apps。\n\n> 类型2、3、5都是以Apple ID为粒度的。比如小张有三个iPad，有一个Apple ID购买了不可消耗品，则三个iPad上都可以使用。\n> 类型1、4一般来说则是现买现用。如果开发者自己想做更多控制，一般选4\n\n\n### iap注意事项\n1. ios7之后，苹果的票据保存在Bundle.main.appStoreReceiptURL,票据只有一份且加密。\n2. SKPaymentTransactionObserver监听支付结果；当客户端调用finishTransaction时，则表示订单已经完成，则客户端不再接收到支付成功的回调，如果没有finishTransaction，则苹果会一直回调（每次打开App(监听)就会回调，直到调用finishTransaction完成订单）\n<img src=\"/img/iap.png\" width = \"700\" height = \"auto\" alt=\"离线日志\" align=center />\n3. purchasing状态下还没有唯一标识transactionIdentifier，只有在purchased和restore状态下才有\n4. 同一个商品，如果上次支付用户支付成功SKPaymentTransactionStatePurchased，但是没有调用finishTransaction），再次下单购买的时候，会提示恢复购买，只会调用Purchasing，不会监听到其他状态，并且用户不会扣钱，如果重新打开App，重新监听SKPaymentTransactionObserver，会收到多条回调，并且对应的transactionId一样，也就是同一个商品，再未完成前，不会重复扣款，只有上一个订单完成后，才会继续支付扣款\n\n\n[有道云笔记iap](http://note.youdao.com/noteshare?id=a5d076c025d7970d5047fb83753a80ee)\n[有道云笔记mac](https://note.youdao.com/ynoteshare1/index.html?id=d549ec4ee4b562974e2bfa4952c07a47&type=note)","tags":["iap","苹果内购流程"]},{"title":"2019 腾讯 LIVE 开发者大会有感","url":"/2019/08/21/2019-腾讯-LIVE-开发者大会有感/","content":"\n### 当天参加场次\n1. [聊聊技术管理成长中的对与错 - By winter(程邵非)](https://github.com/iv-web/ppts/blob/master/2019_TLC_ppts/ppt/%E4%B8%BB%E4%BC%9A%E5%9C%BA/winter%EF%BC%88%E7%A8%8B%E9%82%B5%E9%9D%9E%EF%BC%89/%E8%81%8A%E8%81%8A%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E6%88%90%E9%95%BF%E4%B8%AD%E7%9A%84%E5%AF%B9%E4%B8%8E%E9%94%99.pdf)\n2. [打造前端监控体系 - By 何方舟](https://github.com/iv-web/ppts/blob/master/2019_TLC_ppts/ppt/IVWEB%E6%8A%80%E6%9C%AF%E4%B8%93%E5%9C%BA/%E4%BD%95%E6%96%B9%E8%88%9F/%E6%89%93%E9%80%A0%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB.pdf)\n3. [Vue 高效开发之路 - By 蒋豪群](https://github.com/iv-web/ppts/blob/master/2019_TLC_ppts/ppt/%E5%A4%A7%E5%89%8D%E7%AB%AF%E4%B8%93%E5%9C%BA/%E8%92%8B%E8%B1%AA%E7%BE%A4/Vue%20%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF.pdf)\n4. [Flutter on Desktop - By 郭力恒](https://github.com/iv-web/ppts/blob/master/2019_TLC_ppts/ppt/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF%E4%B8%93%E5%9C%BA/%E9%83%AD%E5%8A%9B%E6%81%92/Flutter%20on%20Desktop.pdf)\n5. [Serverless 中的 Node.js 实践 - By 龙佳文](https://github.com/iv-web/ppts/blob/master/2019_TLC_ppts/ppt/%E5%A4%A7%E5%89%8D%E7%AB%AF%E4%B8%93%E5%9C%BA/%E9%BE%99%E4%BD%B3%E6%96%87/Serverless%20%E4%B8%AD%E7%9A%84%20Node.js%20%E5%AE%9E%E8%B7%B5.pdf)\n\n\n### 场次一：技术管理成长有感\n#### A: 公司、团队、个人三者之间关系\n![公司、团队、个人三者之间关系](/img/personAndTeam.png)\n\n##### 三者关系\n1. 员工： 可以从团体那边获取成长、薪酬；为团体付出了技术和劳动\n2. 团队： 可以从公司那边获取资源；为公司产出业务；为员工提供成长\n3. 公司： 可以从团体那边得到业务增长；提供团队各种资源\n\n\n#### B: 前端创造价值路径\n![公司、团队、个人三者之间关系](/img/rice.png)\n1. 质量和效率 ==> 业务价值  ==> 创新\n\n\n#### C: 数据驱动的思考方式\n![数据驱动的思考方式](/img/teacker.png)\n\n##### 步骤\n1. 目标\n   1. 分析业务目标，拆分目标模块、定数据\n2. 现状\n   1. 根据当前的现状采集数据\n3. 方案\n   1. 设计技术方案，预估最终数据\n4. 实施\n   1. 小规模实施，\n   2. 推广整个部门，甚至整个公司\n   3. 最终形成制度或者规范\n5. 结果\n   1. 对比之前现状的数据看成效\n\n#### D: 对前端全栈的另一种理解\n1. 全栈 => 赋能。 让服务器也能写前端\n2. 让后端也能写前端[参考飞冰](https://ice.work/)\n\n\n### 场次二：打造前端监控体系\n<img src=\"/img/moniter.png\" style=\"width:500px;\" alt=\"端监控维度\" align=center />\n#### A: 监控的维度\n##### 1.异常监控\n   1. 全局函数兜底：\n     1. window.onerror = function(message, source, lineno, colno, error) { ... }\n     2. Promise -> unhandledrejection （当Promise被reject并且没有得到处理的时候，会触发unhandledrejection事件。目前只有chrome49实现）\n     ```\n       window.addEventListener(\"unhandledrejection\", function(e){});\n     ```\n     3. VUE errorHandler\n     4. React componentDidCatch\n     \n   2. 跨域引起的Script Error\n      1. js脚本添加crossorigin=”anonymous” *这一步告诉浏览器，目标脚本通过匿名方式获取。这意味着请求脚本时没有潜在的用户身份信息(如cookies、HTTP 证书等)发送到服务端*\n      2. 添加跨域HTTP响应头 \n      ```\n      Access-Control-Allow-Origin: *\n      ``` \n\n   3. sourceMap\n      1. sourceMap只能内部开发人员看到，其他人不允许看到。\n      2. 线上调试可以把sourceMap文件放内网，我们可以通过vpn看到。\n      3. 服务器解析错误信息问题\n         1. 接下来就是考虑监控系统了，监控系统是用来收集前端的异常信息，并在达到一定阈值后向自动告诉开发人员（虽然这得让开发人员出于 on call 状态），上面我们说到了用户上报过来的信息是压缩后的行、列号信息，这样的信息本质上对于开发人员来说意义是不大的，因此需要在服务端将行列号解析一遍，这个工作看起来貌似没法完成呀，不过感谢 mozilla 开源的 source-map，这可以让这个工作变得异常简单，只要读取生成的 sourcemap，将行列号信息作为参数传递即可\n      4. 参考我的[例子](https://github.com/fanky-c/simple-monitor)\n               \n   4. 崩溃和卡顿\n      1. 情况：\n         1. 卡顿js无法及时执行\n         2. 崩溃js就运行不了\n      2. 解决方法\n         1. window 中 load 与 beforeunload 事件\n         2. 基于 Service Worker *(1：有自己独立的线程；2：生命周期比网页长)* \n         3. 解决方案[参考](https://juejin.im/entry/5be158116fb9a049c6434f4a?utm_source=gold_browser_extension)\n\n   5. 客户端代码报错\n      1. 是因为WebviewJSBridge插入时机不对。\n   6. Patch 原⽣异步⽅法\n      1. setTimeout\n      2. setInterval\n      3. requestAnimationFrame\n      4. EventTarget    \n\n\n##### 2.资源监控\n     1. 全局函数兜底：\n      1. window.addEventListener('error',function(){}, false); *图片资源加载错误。此时只有window.addEventListener('error')可以捕获到*\n      2. 为了避免和window.onerror重复，只有event.srcElement inatanceof HTMLScriptElement或HTMLLinkElement或HTMLImageElement时才上报\n##### 3.性能监控\n   1. 异步接口数据上报\n      1. xmlHttpRequest\n      2. fetch\n   2. 图片测速\n   3. 首屏时间\n      1. 分类：\n         1. ssr页面 -> DOMContentload作为⾸屏时间点\n         2. 非ssr页面 —> 异步数据请求完成后，第⼀次渲染，作为⾸屏时间点\n      2. 面对的问题：\n         1. 侵入式业务开发\n         2. 手动打点\n         3. 首屏打点标准不一致\n      3. 尝试解决方案\n         1. 记录DOM节点变化\n         2. 当DOM节点不再突增，认为首页渲染成功   \n      \n##### 4.安全监控\n\n##### 5.日志上报\n![维度](/img/moniterjs.png)\n###### 日志收集\n1. 白名单\n2. 抽样\n3. 日志等级\n###### 离线日志\n<img src=\"/img/offlinelog.png\" width = \"700\" height = \"auto\" alt=\"离线日志\" align=center />\n1. 用户端存储：IndexDB、localStorage\n###### 日志上报发送 \n1. 合并上报\n2. 压缩上报内容\n3. navigator.sendBeacon\n > navigator.sendBeacon这个方法主要用于满足统计和诊断代码的需要，这些代码通常尝试在卸载（unload）文档之前向web服务器发送数据。过早的发送数据可能导致错过收集数据的机会。不受浏览器行为限制：即使浏览器关闭请求也能照样发出。\n > IE浏览器不支持，兼容性不好。\n4. new Image().src\n   1. 优点： 可以跨域、不怕被屏蔽JS、执行过程无阻塞\n   2. 缺点： 有丢失情况、GET请求大小有限制\n\n\n\n### 场次三：Vue ⾼效开发之路\n#### Vue设计理念\n##### 模板DSL\n###### 为什么要专门的模板语法\n   1. 模板语法优点\n      1. 专为渲染服务\n      2. 可静态分析\n      3. 可自定义语法扩展\n   1. 优先使用.vue文件\n      1. 预编译模板可以带来更多性能优化  \n      > 当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法\n      > 预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串\n      2. 预编译可以提供更好的报错提示   \n\n##### 响应式数据\n###### 优势\n   1. 减少操作，提高性能\n   2. 减少不必要的概念\n\n###### 劣势（vue3.0有做优化）\n   1. 超大数据集的性能问题\n   2. js语言限制\n\n###### 响应式数据注意\n   1. 响应式数据最终都是为渲染服务\n   2. 不必要的数据不要放到 data 中\n   3. 使⽤ Object.freeze 阻⽌不必要数据响应\n\n###### 优化代码技巧\n   1. 错误处理（errorHandler & warnHandler & errorCaptured & renderError）\n   2. 减少重复\n   3. 尽量使用computed\n   4. 使⽤ immediate watcher(立即执行可以去掉在created中定义的方法)\n\n###### 调试代码技巧\n   1. 时间旅行调试方法\n      1. 实现思路\n         1. 记下所有数据操作\n         2. 回退 = 当然的状态一直回放到上一步操作\n      2. 核心要点\n         1. 操作的原子性\n          > 要么完整的被执行,要么完全不执行。这种特性就叫原子性\n         2. 操作可以记录\n\n##### 渐进式框架\n> 渐进式框架的大概意思就是你可以只用我的一部分，而不是用了我这一点就必须用我的所有部分","tags":["TLC","会议有感"]},{"title":"ios中定义属性atmoic","url":"/2019/08/20/ios中定义属性atmoic/","content":"\n### 定义\n定义属性中的特性有atomic、nonatomic、copy、assign、strong、weak等，一般格式如下：\n```js\n@property (nonatomic, strong) NSString *name; \n```\n\n### 使用\n\n#### atomic\n1. 默认属性\n2. 当前进程进行到一半，其他线程来访问当前线程，可以保证先执行完毕当前线程\n3. 只是保证setter/getter 完整，不是线程安全\n\n\n#### nonatomic\n1. 非默认属性\n2. 两个线程同时访问同一个属性将会导致无法预计的结果\n3. 优点是程序运行速度快\n\n\n#### copy\n1. 是owner，不是reference（引用）。当对象可变时，可设置为copy，用于获取此时值的副本\n2. 使用copy创建的新对象也是强引用，使用完成后需要负责释放该对象\n\n\n#### assign\n1. 与copy相反，只是reference，不是owner。只返回指针\n2. 用于float、int、BOOL等类型\n3. 释放后再发送消息会导致程序崩溃\n\n\n#### strong\n1. 默认属性\n2. strong = retain iOS引入ARC后，用strong替代了retain\n3. 所有实例变量、局部变量默认都是strong\n4. 创建一个强引用的指针，引用对象引用计数加1\n5. 如果有多个对象同时引用一个属性，任一对象对该属性的修改都会影响其他对象获取的值\n\n\n\n#### weak\n1. 只是reference，不是owner。即引用计数不会加1\n2. IBOutlet常用weak\n3. 可将weak对象设为nil，向nil发送消息，什么都不会执行，程序也不会崩溃\n4. 代理使用weak。delegate几乎一直own代理对象，所以代理对象应该对代理使用weak，否则会形成循环引用（retain cycle）。但也有例外，如果代理对象的生命周期比代理短，代理对象也可以使用strong\n\n\n#### readonly\n1. 非默认属性\n2. 只有可读方法，也就是只有getter方法","tags":["nonatomic","assign","strong","weak"]},{"title":"Vue内部运行机制","url":"/2019/07/15/Vue内部运行机制/","content":"\n### new Vue() 内部流程图\n\n<img src=\"/img/newVue.png\" width = \"700\" height = \"auto\" alt=\"离线日志\" align=center />\n\n#### 初始化及挂载\n在 new Vue() 之后。 Vue 会调用 _init 函数进行初始化，也就是这里的 init 过程，它会初始化生命周期、事件、 props、 methods、 data、 computed 与 watch 等。其中最重要的是通过 Object.defineProperty 设置 setter 与 getter 函数，用来实现「响应式」以及「依赖收集」。\n> 初始化之后调用 $mount 会挂载组件，如果是运行时编译，即不存在 render function 但是存在 template 的情况，需要进行「编译」步骤。\n\n\n#### 编译(如果用了vue-loader则直接生成render function字符串)\ncompile编译可以分成 parse、optimize 与 generate 三个阶段，最终需要得到 render function。\n** 如果是用vue-loader实现预编译就直接生成了render function 字符串；如果是运行时编译就不会生成render function。**\n> 1. parse 会用正则等方式解析 template 模板中的指令、class、style等数据，形成AST。\n> 2. optimize 的主要作用是标记 static 静态节点，这是 Vue 在编译过程中的一处优化，后面当 update 更新界面时，会有一个 patch 的过程， diff 算法会直接跳过静态节点，从而减少了比较的过程，优化了 patch 的性能\n> 3. generate 是将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串。\n\n\n#### 响应式\n1. getter 跟 setter 已经在之前介绍过了，在 init 的时候通过 Object.defineProperty 进行了绑定，它使得当被设置的对象被读取的时候会执行 getter 函数，而在当被赋值的时候会执行 setter 函数。\n2. 当 render function 被渲染的时候，因为会读取所需对象的值，所以会触发 getter 函数进行「依赖收集」，「依赖收集」的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。\n3. 在修改对象的值的时候，会触发对应的 setter， setter 通知之前「依赖收集」得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来更新视图，当然这中间还有一个 patch 的过程以及使用队列来异步更新的策略。\n\n\n#### Virtual DOM\nrender function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（ VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等\n```js\n{\n    tag: 'div',                 /*说明这是一个div标签*/\n    children: [                 /*存放该标签的子节点*/\n        {\n            tag: 'a',           /*说明这是一个a标签*/\n            text: 'click me'    /*标签的内容*/\n        }\n    ]\n}\n```\n渲染后成真实DOM\n```html\n<div>\n    <a>click me</a>\n</div>\n```\n实际上的节点有更多的属性来标志节点，比如 isStatic （代表是否为静态节点）、 isComment （代表是否为注释节点）等\n\n\n#### 更新视图\n前面提到通过 setter -> Watcher -> update 的流程来修改对应的视图，那么最终是如何更新视图的呢？\n\n当数据变化后，执行 render function 就可以得到一个新的 VNode 节点，我们如果想要得到新的视图，最简单粗暴的方法就是直接解析这个新的 VNode 节点，然后用 innerHTML 直接全部渲染到真实 DOM 中。但是其实我们只对其中的一小块内容进行了修改，这样做似乎有些「浪费」。\n\n那么我们为什么不能只修改那些「改变了的地方」呢？这个时候就要介绍我们的「patch」了。我们会将新的 VNode 与旧的 VNode 一起传入 patch 进行比较，经过 diff 算法得出它们的「差异」。最后我们只需要将这些「差异」的对应 DOM 进行修改即可\n\n### 响应式系统依赖收集追踪原理\n\n### 实现Virtual DOM下的一个VNode节点\n\n\n### template模板怎么通过Compile编译\n#### 1.parse，利用正则解析template、class、style等数据，生成ast语法树\nAST语法树结构如下：\n```js\n{\n    /* 标签属性的map，记录了标签上属性 */\n    'attrsMap': {\n        ':class': 'c',\n        'class': 'demo',\n        'v-if': 'isShow'\n    },\n    /* 解析得到的:class */\n    'classBinding': 'c',\n    /* 标签属性v-if */\n    'if': 'isShow',\n    /* v-if的条件 */\n    'ifConditions': [\n        {\n            'exp': 'isShow'\n        }\n    ],\n    /* 标签属性class */\n    'staticClass': 'demo',\n    /* 标签的tag */\n    'tag': 'div',\n    /* 子标签数组 */\n    'children': [\n        {\n            'attrsMap': {\n                'v-for': \"item in sz\"\n            },\n            /* for循环的参数 */\n            'alias': \"item\",\n            /* for循环的对象 */\n            'for': 'sz',\n            /* for循环是否已经被处理的标记位 */\n            'forProcessed': true,\n            'tag': 'span',\n            'children': [\n                {\n                    /* 表达式，_s是一个转字符串的函数 */\n                    'expression': '_s(item)',\n                    'text': '{{item}}'\n                }\n            ]\n        }\n    ]\n}\n```\n#### 2.optimize，优化静态内容\n这个涉及到后面要讲 patch 的过程，因为 patch 的过程实际上是将 VNode 节点进行一层一层的比对，然后将「差异」更新到视图上。那么一些静态节点是不会根据数据变化而产生变化的，这些节点我们没有比对的需求，是不是可以跳过这些静态节点的比对，从而节省一些性能呢？\n```js\n{\n    'attrsMap': {\n        ':class': 'c',\n        'class': 'demo',\n        'v-if': 'isShow'\n    },\n    'classBinding': 'c',\n    'if': 'isShow',\n    'ifConditions': [\n        'exp': 'isShow'\n    ],\n    'staticClass': 'demo',\n    'tag': 'div',\n    /* 静态标志 */\n    'static': false,\n    'children': [\n        {\n            'attrsMap': {\n                'v-for': \"item in sz\"\n            },\n            'static': false,\n            'alias': \"item\",\n            'for': 'sz',\n            'forProcessed': true,\n            'tag': 'span',\n            'children': [\n                {\n                    'expression': '_s(item)',\n                    'text': '{{item}}',\n                    'static': false\n                }\n            ]\n        }\n    ]\n}\n```\n1. isStatic函数；判断的标准是当 type 为 2（表达式节点）则是非静态节点，当 type 为 3（文本节点）的时候则是静态节点，当然，如果存在 if 或者 for这样的条件的时候（表达式节点），也是非静态节点。\n```js\nfunction isStatic (node) {\n    if (node.type === 2) {\n        return false\n    }\n    if (node.type === 3) {\n        return true\n    }\n    return (!node.if && !node.for);\n}\n```\n2. markStatic函数；遍历所有节点通过 isStatic 来判断当前节点是否是静态节点，此外，会遍历当前节点的所有子节点，如果子节点是非静态节点，那么当前节点也是非静态节点。\n\n\n#### 3.generate,生成render function字符串\ngenerate 会将 AST 转化成 render funtion 字符串，最终得到 render 的字符串以及 staticRenderFns 字符串。\nVue.js编译得到结果\n```js\nwith(this){\n    return (isShow) ? \n    _c(\n        'div',\n        {\n            staticClass: \"demo\",\n            class: c\n        },\n        _l(\n            (sz),\n            function(item){\n                return _c('span',[_v(_s(item))])\n            }\n        )\n    )\n    : _e()\n}\n```\n\n### 数据状态更新时差异diff以及patch机制\n首先说一下 patch 的核心 diff 算法，我们用 diff 算法可以比对出两颗树的「差异」，我们来看一下，假设我们现在有如下两颗树，它们分别是新老 VNode 节点，这时候到了 patch 的过程。\n\n<img src=\"/img/diff.png\" width = \"700\" height = \"auto\" alt=\"\" align=center />\n\n\ndiff 算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有 O(n)，是一种相当高效的算法，如下图。\n\n<img src=\"/img/path.png\" width = \"700\" height = \"auto\" alt=\"\" align=center />\n\n这张图中的相同颜色的方块中的节点会进行比对，比对得到「差异」后将这些「差异」更新到视图上。因为只进行同层级的比对，所以十分高效。\n\n```js\nfunction patch (oldVnode, vnode, parentElm) {\n    if (!oldVnode) \n    {\n        //老VNode节点不存在，向父元素中添加新VNode节点\n        addVnodes(parentElm, null, vnode, 0, vnode.length - 1);\n    } \n    else if (!vnode) \n    {\n        //没有新的VNode节点，就从父元素中把旧的VNode节点删除掉\n        removeVnodes(parentElm, oldVnode, 0, oldVnode.length - 1);\n    } \n    else \n    {  \n        if (sameVnode(oldVNode, vnode)) {\n            //新VNode和老VNode都存在且相同，比对 VNode\n            patchVnode(oldVNode, vnode); \n        } \n        else \n        {\n            //新VNode和老VNode都存在且不同，删除老节点，增加新节点\n            removeVnodes(parentElm, oldVnode, 0, oldVnode.length - 1);\n            addVnodes(parentElm, null, vnode, 0, vnode.length - 1);\n        }\n    }\n}\n```\n#### patch四种情况\n##### 1.老VNode节点不存在，就向父元素中添加新VNode节点。\n##### 2.新VNode节点不存在，就从父元素中把旧的VNode节点删除掉。\n##### 3.新VNode和老VNode都存在且相同，比对 VNode。\n1. 怎么判断两个VNode是否为相同节点？\n   1. sameVnode 其实很简单，只有当 key、 tag(div、p)、 isComment（是否为注释节点）、 data同时定义（或不定义），同时满足当标签类型为 input 的时候 type 相同（某些浏览器不支持动态修改<input\\>类型，所以他们被视为不同类型）即可\n      ```js\n      function sameVnode () {\n        return (\n            a.key === b.key &&\n            a.tag === b.tag &&\n            a.isComment === b.isComment &&\n            (!!a.data) === (!!b.data) &&\n            sameInputType(a, b)\n        )\n      }\n\n        function sameInputType (a, b) {\n            if (a.tag !== 'input') return true\n            let i\n            const typeA = (i = a.data) && (i = i.attrs) && i.type\n            const typeB = (i = b.data) && (i = i.attrs) && i.type\n            return typeA === typeB\n        }\n      ```\n    2. patchVnode过程\n       1. test\n\n##### 4.新VNode和老VNode都存在且不同，删除老节点，增加新节点。\n\n\n\n### 批量异步更新策略和nextTick原理\n#### 为啥什么要异步更新\n通过前面几个章节我们介绍，相信大家已经明白了 Vue.js 是如何在我们修改 data 中的数据后修改视图了。简单回顾一下，这里面其实就是一个“setter -> Dep -> Watcher -> patch -> 视图”的过程。\n\nVue.js在默认情况下，每次触发某个数据的 setter 方法后，对应的 Watcher 对象其实会被 push 进一个队列 queue 中，在下一个 tick 的时候将这个队列 queue 全部拿出来 run（ Watcher 对象的一个方法，用来触发 patch 操作） 一遍\n\n<img src=\"/img/vueWatcher.png\" style=\"width:300px; margin:0 auto;display:block;\" alt=\"离线日志\" align=center />\n\n那么什么是下一个 tick 呢？\n\n#### nextTick\nVue.js 实现了一个 nextTick 函数，传入一个 cb ，这个 cb 会被存储到一个队列中，在下一个 tick 时触发队列中的所有 cb 事件。\n\n因为目前浏览器平台并没有实现 nextTick 方法，所以 Vue.js 源码中分别用 Promise、setTimeout、setImmediate 等方式。目的是在当前调用栈执行完毕以后（不一定立即）才会去执行这个事件。\n\n\n### Vuex状态管理的原理\n\n\n\n\n[本文来源参考](https://juejin.im/book/5a36661851882538e2259c0f/section/5a37bbb35188257d167a4d64)","tags":["vue","vue运行机制"]},{"title":"从web前端看macOs开发","url":"/2019/07/10/从web前端看macOs开发/","content":"\n### 1: Native与webview交互\n\n#### A:Native取得window对象\n```\njs:\nwindow.location.href = 'http://spring-studio.net';\n\noc:\n[[webView windowScriptObject] setValue:@\"http://spring-studio.net\"forKeyPath:@\"location.href\"];\n```\n\n\n#### B:Native调用JavaScript Function\n##### js调用Native\n```\noc:\n[[webView windowScriptObject] evaluateWebScript:@\"function x(x) { return x + 1;}\"];\n\njs:\nwindow.x(1);\n```\n##### Native调用js\n```\noc:\n[[webView windowScriptObject] evaluateWebScript:[NSString stringWithFormat:@\"showPromoAd('%@','%@');\",self.word, computerSerialNumber()]];\n\njs:\nfunction showPromoAd(word, id){\n    console.log(word, id);\n};\n```\n\n#### C:Native操作DOM\n* WebKit 里头，所有的 DOM 对象都继承自 DOMObject，DOMObject 又继承自 WebScriptObject，所以我们在取得了某个 DOM 对象之后，也可以从 Objective-C 程序中，要求这个 DOM 对象执行 JS 程序\n```\njs:\ndocument.querySelector('#s').focus();\n\noc:\nDOMDocument *document = [[webView mainFrame] DOMDocument];\n[[document querySelector:@\"#s\"] callWebScriptMethod:@\"focus\"withArguments:nil];\n```\n\n### 2:Native和web页面jsbridge通信\n\n#### 原理\n* 在windows下面添加webviewJsbridge对象\n* 然后在webview中动态的创建一个Iframe\n* Native内部通过iframe的src进行通信，每次注册方法和调用方法动态的改变src\n* 调用 js 中的方法_handleMessageFromObjC 进行数据交互\n\n#### 工作流\n* JS 端加入 src 为 https://bridge_loaded 的 iframe\n* Native 端检测到 Request，检测如果是 bridge_loaded 则通过当前的 WebView 组件注入 WebViewJavascriptBridge_JS 代码\n* 注入代码成功之后会加入一个 messagingIframe，其 src 为 https://wvjb_queue_message\n* 之后不论是 Native 端还是 JS 端都可以通过 registerHandler 方法注册一个两端约定好的 HandlerName 的处理，也都可以通过 callHandler 方法通过约定好的 HandlerName 调用另一端的处理（两端处理消息的实现逻辑对称）\n\n\n#### 用法\n//Native端\n\n```\n1. 引入依赖库文件\n#import \"WebViewJavascriptBridge.h\"\n\n2. 实例化一个对象\nself.bridge = [WebViewJavascriptBridge bridgeForWebView:webView];\n\n3. 注册前端方法+主动推送给前端\n//供前端调用\n[self.bridge registerHandler:@\"OCTest\" handler:^(id data, WVJBResponseCallback responseCallback) {\n    NSLog(@\"ObjC Echo called with: %@\", data);\n    responseCallback(data);\n}];\n\n//主动推送给前端\n[self.bridge callHandler:@\"JsTest\" data:nil responseCallback:^(id responseData) {\n    NSLog(@\"ObjC received response: %@\", responseData);\n}];\n```\n\n//web端\n```\nfunction setupWebViewJavascriptBridge(callback) {\n    if (window.WebViewJavascriptBridge) { return callback(WebViewJavascriptBridge); }\n    if (window.WVJBCallbacks) { return window.WVJBCallbacks.push(callback); }\n    window.WVJBCallbacks = [callback];\n    var WVJBIframe = document.createElement('iframe');\n    WVJBIframe.style.display = 'none';\n    WVJBIframe.src = 'https://__bridge_loaded__';\n    document.documentElement.appendChild(WVJBIframe);\n    setTimeout(function() { document.documentElement.removeChild(WVJBIframe) }, 0)\n}\n\nsetupWebViewJavascriptBridge(function(bridge) {\n\t //主动调用\n    bridge.registerHandler('JsTest', function(data, responseCallback) {\n        console.log(\"JS Echo called with:\", data)\n        responseCallback(data)\n    })\n\t//接受oc端主动推送的消息\n    bridge.callHandler('OCTest', {'key':'value'}, function responseCallback(responseData) {\n        console.log(\"JS received response:\", responseData)\n    })\n})\n```\n\n### 3: Native和web本地缓存数据区别\n\n#### web本地数据缓存方式\n* cookie\n* sessionStorage\n* localStorage\n* indexedDB\n* pwa离线解决方案(serviceWorker子线程、无法操作DOM)\n \n#### Native本地数据缓存\n* NSUserDefaults\n  * 一般应用来存储应用设置信息，文件放在perference目录下。\n* FMDB\n  * FMDB是iOS平台的SQLite数据库框架，FMDB以OC的方式封装了SQLite的C语言API，使用起来更加面向对象\n* 直接写文件\n  * Documents:(iTunes同步设备时会备份该目录)\n  * tmp\n  * Library\n    *Caches (不会被同步)\n    *Preference(应用设置，iTunes同步设备时会备份该目录) \n\n### 4: Native和web多页面之间通信区别\n\n#### web多页面通信(同源多tab，不同源父子页面)\n##### 原理\n* 获取页面句柄，定向通信。\n* 共享内存，完成相应的业务。\n\n##### 方法\n* window.open()、postMessage\n* BroadcastChannel\n* SharedWorker\n* cookie、localStorage。(sessionStorage不支持多页面通信)\n\n#### Native多页面通信\n* 属性传值\n* 单例传值\n* NSUserDefaults(本地设置)\n* 代理传值\n* block传值\n* NSNotificationCenter(通知中心)\n```\n//先监听\n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(updateValue:) name:@\"postValue\" object:nil];\n\n-(void)updateValue:(NSNotification*)not{\n    self.lable.text = not.userInfo[@\"val\"];\n}\n\n//发送广播\n [[NSNotificationCenter defaultCenter] postNotificationName:@\"postValue\" object:nil userInfo:@{@\"val\":self.inputText}];\n```\n\n\n### 5: Native和web多线程和异步流程控制\n\n#### web多线程\n* new worker(work.js)，把耗时较长的任务交给子线程处理，主线程处理ui操作，任务完成worker.postMessage()告诉给主线程。\n* worker和主线程不在同一上下文，使用限制：不能访问DOM、BOM、同源策略\n* [demo](https://github.com/mdn/simple-web-worker)\n\n#### web异步\n* ajax\n* setTimeout\n* Promise\n\n\n#### Native多线程和流程控制\n* GCD\n  * 同步/异步、串行/并行\n  * dispath_get_global_queue & dispatch_get_main_queue\n  * dispatch_group_async\n  * dispatch_once\n  * dispatch_afte，将任务添加到队列延迟执行，类似setTimeout。\n\n* NSOperation\n  * 实现方式:\n     * NSInvocationOperation & NSBlockOperation（同步阻塞）\n     * 自定义类继承NSOperation\n     \n* NSThread","tags":["macOs开发","web和mac对比"]},{"title":"flutter学习","url":"/2019/06/03/flutter学习/","content":"\n### Flutter使用命令\n1. 创建flutter项目\n   1. 运行命令行： flutter create projectName\n\n2. 从pub下载包\n   1. 打开 pubspec.yaml 文件，然后在dependencies下添加需要下载的包名\n   2. 运行命令行：flutter packages get\n\n3. 更新包的版本\n   1. 运行命令行：flutter packages upgrade\n\n### import导入文件的方式\n1. import 'dart:xxx'; 引入Dart标准库\n2. import 'xxx/xxx.dart';引入相对路径的Dart文件\n3. import 'package:xxx/xxx.dart'; 引入Pub仓库pub.dev(或者pub.flutter-io.cn)中的第三方库\n4. import 'package:project/xxx/xxx.dart';引入自定义的dart文件\n5. import 'xxx' show compute1，compute2; 只导入compute1，compute2\n6. import 'xxx' hide compute3; 除了compute都引入\n7. import 'xxx' as compute4; 将库重命名，当有名字冲突时\n\n\n\n### Widget框架\n#### 基础的Widget包括常用\n1. Text： 该 widget 可让创建一个带格式的文本。\n2. Row、 Column：这些具有弹性空间的布局类Widget可让您在水平（Row）和垂直（Column）方向上创建灵活的布局。其设计是基于web开发中的Flexbox布局模型。\n3. Stack:  取代线性布局 (译者语：和Android中的LinearLayout相似)，Stack允许子 widget 堆叠， 你可以使用 Positioned 来定位他们相对于Stack的上下左右四条边的位置。Stacks是基于Web开发中的绝度定位（absolute positioning )布局模型设计的\n4. Container: Container 可让您创建矩形视觉元素。container 可以装饰为一个BoxDecoration, 如 background、一个边框、或者一个阴影。 Container 也可以具有边距（margins）、填充(padding)和应用于其大小的约束(constraints)。另外， Container可以使用矩阵在三维空间中对其进行变换\n5. Scaffold： Material Design布局结构的基本实现。此类提供了用于显示drawer、snackbar和底部sheet的API。\n6. Image： 一个显示图片的widget。\n7. Icon: A Material Design icon。\n8. RaisedButton: Material Design中的button， 一个凸起的材质矩形按钮。\n9. Placeholder： 一个绘制了一个盒子的的widget，代表日后有widget将会被添加到该盒子中\n\n#### Widget运行原理\n1. Widget的主要工作是实现一个build函数，用以构建自身。\n2. 一个Widget通常由一些较低级别widget组成。Flutter框架将依次构建这些widget，直到构建到最底层的子widget时，这些最低层的widget通常为RenderObject，它会计算并描述widget的几何形状。\n\n#### Widget分类\n1. StatelessWidget\n\n2. StatefulWidget\n\n#### Material组件\n1. Scaffold是Material中主要的布局组件. 包含了appBar、body、title等等\n\n\n### State\n#### State介绍\n1. State对象在多次调用build()之间保持不变，允许它们记住信息(状态)。\n\n\n### Navigation & Router(导航与路由)\n\n#### 静态路由\n1. 静态路由，它不可以向下一个页面传递参数。\n2. 静态路由，它可以接收下一个页面的返回值的\n```dart\nreturn new MaterialApp(\n      title: 'Flutter Demo',\n      theme: new ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: new MyHomePage(title: 'Flutter实例'),\n      routes: <String, WidgetBuilder> {\n        // 这里可以定义静态路由，不能传递参数\n        '/router/second': (_) => new SecondPage(),\n        '/router/home': (_) => new RouterHomePage(),\n      },\n    );\n\n//push一个新页面,pushNamed方法是有一个Future的返回值的，\n//所以静态路由也是可以接收下一个页面的返回值的。但是不能向下一个页面传递参数。\nNavigator.of(context).pushNamed('/router/second');\nNavigator.of(context).pushNamed('/router/second').then((value) {\n   // dialog显示返回值\n   _showDialog(context, value);\n})\n\n//pop回上一个页面\nNavigator.of(context).pop('这个是要返回给上一个页面的数据')\n\n```\n\n#### 动态路由\n1. 动态路由：自己生成页面对象，所以可以传递自己想要的参数。\n2. Navigation.push();  //打开新页面\n   1. Navigator.push(BuildContext context, Route route) //静态方法\n   2. Navigator.of(context).push(Route route)  //实例方法，和上面的静态方法用途相同\n3. Navigation.pop();   //退出当前页面\n   1. Navigation.pop(BuildContext context, [ result ])\n   2. Navigation.of(context).pop('传给上一个页面消息')\n4. Navigator.replace()\n\n\n\n### 为何选择Flutter\n1. 性能（Rn Web 原生）\n\n2. 跨平台多样性\n\n3. dart语法\n\n4. 综合评比\n    优势： 1. dart语(易用、语法糖)  2. 性能(项目运行性能、崩溃率万分5)  3.  跨平台(开发效率高)\n    劣势： 1. 资源管理    2. 无法热更新    \n\n\n### 工程架构\n1. 技术选型： Flutter为核心，负责界面绘制、数据请求解析。分别嵌入ios和安卓平台发布。\n\n\n\n\n### 项目优化\n1. 控件的创建和绘制\n   1. build()方法耗时\n   2. 避免不参与动画树参与动画\n   3. 重绘区域优化RepaintBoundary\n\n\n2. 其他优化\n   1. flutter单线程优化， 耗时任务放在isolate\n\n\n### 现实遇到问题\n1. 异常报错\n    1. 原生端传 messageChanle\n    2. flutter报错不会引起应用崩溃\n2. flutter版本管理\n3. 平台兼容问题（ui、文件读写路径、网络数据)","tags":["flutter"]},{"title":"vue插件原理及实现","url":"/2019/05/26/vue插件原理及实现/","content":"### 插件使用场景\n1. 添加全局方法或者属性，例如：[vue-custom-element](https://github.com/karol-f/vue-custom-element)\n2. 添加全局资源：指令/过滤器/过渡等, 例如：[vue-touch](https://github.com/vuejs/vue-touch)\n3. 通过全局混入来添加一些组件选项, 例如：[vue-router]()\n4. 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现\n5. 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。 例如：[vue-route](https://github.com/vuejs/vue-router)\n\n```js\nMyPlugin.install = function (Vue, options) {\n  // 1. 添加全局方法或属性\n  Vue.myGlobalMethod = function () {\n    // 逻辑...\n  }\n\n  // 2. 添加全局资源\n  Vue.directive('my-directive', {\n    bind (el, binding, vnode, oldVnode) {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 3. 注入组件选项\n  Vue.mixin({\n    created: function () {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 4. 添加实例方法\n  Vue.prototype.$myMethod = function (methodOptions) {\n    // 逻辑...\n  }\n}\n```\n\n### 插件使用\n1. 通过Vue.use(myPlugin)使用， 本质是调用myPlugin.install(Vue)\n2. 使用插件前必须在new Vue()启动应用之前完成，实例化之前就要配置好\n3. 如果使用多次Vue.use多次注册相同的插件，那只会注册一次\n\n### 原理\n#### Vue.use()源码\n```js\nVue.use = function (plugin) {   \n    // 忽略已注册插件\n    if (plugin.installed) {\n      return\n    }\n    \n    // 集合转数组，并去除第一个参数\n    var args = toArray(arguments, 1);\n    \n    // 把this（即Vue）添加到数组的第一个参数中\n    args.unshift(this);\n    \n    // 调用install方法\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    \n    // 注册成功\n    plugin.installed = true;\n    return this;\n  };\n```\n\n#### 通过mixin实现rules公共方法\n1. 示例\n```js\nconst vm = new Vue({\n    data: function(){\n        return {\n            foo: 10\n        }\n    },\n    rules: {\n        foo: {\n           validate: value => value > 1,\n           message: 'foo must be greater than one'\n        }\n    }\n})\nvm.foo = 0 // 输出 foo must be greater than one\n```\n\n2. 实现步骤\n   1. 实现rules插件\n      ```js\n       import Vue from 'vue'\n       const RulesPlugin = {\n           //插件应该有一个公开方法install\n           //install方法第一个参数：Vue构造器， 第二个参数可选的选项对象\n           install: function(Vue){\n               Vue.mixin({\n                   created(){\n                    //获取rules对象\n                    const rules = this.$options.rules;\n                    if(rules){\n                        Object.keys(rules).forEach((key)=>{\n                            //获取所有的rules\n                            const {validate, message} = rules[key];\n                            \n                            //监听， 键是变量， 值函数\n                            this.$watch(key, newValue => {\n                                const valid = validate(newValue);\n                                if(valid){\n                                console.log(message);\n                                }\n                            })\n                        })\n                    }                       \n                   }\n               })\n           }\n       }\n\n       export default RulesPlugin;\n      ```\n   2. 验证rules插件  \n     ```js\n       import Vue from 'vue'\n       import RulePlugin from 'RulePlugin';\n       \n       Vue.use(RulePlugin);\n\n       const vm = new Vue({\n            data: function(){\n                return {\n                    foo: 10\n                }\n            },\n            rules: {\n                foo: {\n                  validate: value => value > 1,\n                  message: 'foo must be greater than one'\n                }\n            },\n            created(){\n                //获取rules对象\n                const rules = this.$options.rules;\n                if(rules){\n                    Object.keys(rules).forEach((key)=>{\n                        //获取所有的rules\n                        const {validate, message} = rules[key];\n                        \n                        //监听， 键是变量， 值函数\n                        this.$watch(key, newValue => {\n                            const valid = validate(newValue);\n                            if(valid){\n                               console.log(message);\n                            }\n                        })\n                    })\n                }\n            }           \n       })\n     ```","tags":["vue","vue插件"]},{"title":"javascript类型检测","url":"/2019/05/22/javascript类型检测/","content":"\n#### typeof\n\n1. 基本类型（number、string、undefined、boolean）\n```js\ntypeof 1 //\ntypeof '1' //\ntypeof true //  \ntypeof x // undefined \nif(typeof x == 'undefined') // true\nif(x)  //直接报错\n```\n2. function(函数)\n```js\ntypeof function(){}\ntypeof class C {}\ntypeof Math.sin \n```\n\n3. object\n```js\ntypeof null // 当时设计的原因\ntypeof [] //\ntypeof {} //\n```\n\n#### instanceof\n1. 判断某个对象的是另外一个对象实例\n```js\n\n// A 的 __proto__ 指向 B 的 prototype 时，就认为 A 就是 B 的实例\n[] instanceof Array; //true\n({}) instanceof Object;//true\nnew Date() instanceof Date;//true\n\n//无法判断继承\nfunction Parent(){};\nfunction Child(){};\nfunction Other(){};\nChild.prototype = new Parent();\nlet child = new Child();\nchild instanceof Child; // true\nchild instanceof Parent; // true\nchild instanceof Object; // true\nchild instanceof Other;  //false\n\n//Child.prototype.__proto__ = Parent.prototype\n//Parent.prototype.__proto__ = Object.prototype\n//Object.prototype.__proto__ = null\n```\n\n\n#### Object.prototype.toString.call(obj).slice(8, -1)","tags":["js类型检测","typeof","instanceof"]},{"title":"js继承","url":"/2019/05/18/js继承/","content":"\n### 定义父类\n```js\nfunction Person(name, age){\n   //属性 \n   this.name = name || 'zhao';\n   this.age = age || 25;\n   \n   //实例方法\n   this.showName = function(){\n      console.log(this.name + '正在睡觉');\n   }\n}\n//原型属性和方法\nPerson.prototype.friends  = ['dog', 'cat'];\nPerson.prototype.showAge = function(){\n     console.log('年龄是：'+this.age);\n}\n```\n### 原型式继承\n#### 使用\n```js\nfunction Ming(){\n\n}\nMing.prototype = Person.prototype;\n\n```\n#### 问题\n1. 只能继承父类原型对象方法和属性\n2. 子类和父类原型共享\n3. 无法给父构造函数传参\n\n\n\n### 原型链继承\n#### 使用\n```js\nfunction Ming(){\n}\nMing.prototype = new Person();\n//修改子构造函数的原型的构造器属性\nMing.prototype.constructor = Ming;\n\nvar subClass = new Ming();\nconsole.log(subClass.name);\nconsole.log(subClass.age);\nconsole.log(subClass.friends);\n\n// 当我们改变friends的时候, 父构造函数的原型对象的也会变化\nsubClass.friends.push('小王八');\nconsole.log(subClass.friends); //[\"dog\", \"cat\", \"小王八\"]\nvar father = new Person();\nconsole.log(father.friends); //[\"dog\", \"cat\", \"小王八\"]\n\n```\n#### 问题\n1. 父子原型和实例对象共享\n2. 不能给父构造函数传参\n\n\n### 构造函数call、apply\n#### 使用\n```js\nfunction Ming(name, age){\n     Person.call(this, name, age); //Person.apply(this, [name, age]);\n}\n\nvar subClass = new Ming('ming', 21);\nsubClass.showName();\nsubClass.friends.push('小王八');  //报错\nconsole.log(subClass.friends)    //报错\n```\n\n#### 问题\n1. 可以传参\n2. 解决父子原型共享问题\n3. 获取不到父类原型成员\n\n\n### 组合继承(原型式+构造函数)\n#### 使用\n```js\nfunction Ming(name, age){\n     Person.call(this, name, age); //Person.apply(this, [name, age]);\n}\n\nMing.prototype = Person.prototype;\nMing.prototype.constructor = Ming;\n```\n\n#### 问题\n1. 解决传参\n2. 继承父类原型对象上的方法和属性\n3. 但是共享了父类原型对象\n\n\n### 构造函数+深拷贝\n#### 使用\n```js\nfunction Ming(name, age){\n   Person.call(this, name, age);\n}\n\n//深拷贝\ndeepCopy(Ming.prototype,Person.prototype);\n\nMing.prototype.constructor = Ming;\n\n//对象深拷贝\nfunction deepCopy(source){\n  let result = null;\n  let type = checkType(source);\n  \n  if(type === 'Object'){\n      result = {};\n  }else if(type === 'Array'){\n     result = [];\n  }else{\n      return result;\n  }\n  \n  for(let i in source){\n      let value = source[i];\n      if(checkType(value) === 'Object' || checkType(value) === 'Array'){\n        result[i] = deepCopy(value);\n      }else{\n        result[i] = value;\n      }\n  }\n  return result;\n}\n\n//返回具体类型\nfunction checkType(obj){\n    return Object.prototype.toString.call(obj).slice(8, -1); //[object,String] => String\n}\n\n```","tags":["js继承"]},{"title":"javascript中toString()和valueOf()","url":"/2019/05/14/javascript中toString-和valueOf/","content":"\n### 介绍\n1. 所有的对象原型都有这个2个方法。\n2. Object.prototype会返回这2个方法。\n\n\n### toString()\n\n#### 介绍\n1. toString() 返回对象字符串表示\n\n#### 案例\n```js\n 3.toString(); // \"3\"\n '3'.toString(); // \"3\"\n true.toString(); // \"true\"\n {test: 3, app: \"test\"}.toString(); //\"[object Object]\"\n function(){console.log(3)}.toString(); // \"function(){console.log(3)}\"\n ['test', 'test2'].toString(); //\"test,test2\"  相当于调用Array.join(',')\n /\\d/.toString();  // \"/\\d/\"\n```\n\n### valueOf()\n\n#### 介绍\n1. valueOf() 如果对象存在任意原始值，它就默认将对象转换为表示它的原始值，如果对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的valueOf( )方法简单地返回对象本身，而不是返回一个原始值。\n\n#### 案例\n```js\n 3.valueOf(); // 3  返回原始值\n '3'.valueOf(); // \"3\"  返回原始值\n true.valueOf(); // true  返回原始值\n {test: 3, app: \"test\"}.valueOf(); //{test: 3, app: \"test\"} 返回自身\n function(){console.log(3)}.valueOf(); // function(){console.log(3)} 返回自身\n ['test', 'test2'].valueOf(); //[\"test,test2\"]  返回自身\n```\n\n\n### 调用时机\n1. 案例\n```\n//案例一\nvar a = '31';\nconsole.log(+a);// 31\n\n//案例二\nvar example = {test:'123'};\nconsole.log(+example);// NaN\n\n//案例三\nconsole.log('test'+{}); //\"test[object Object]\"\n\n//案例四\nvar example = {test:'1232'};\nalert(example);// \"[object Object]\"\n```\n2. 结论： \n   1. 案例一二：一元加操作符在操作对象的时候，会先调用对象的valueOf方法来转换，最后再用Number( )方法转换\n   2.  案例三：对象和字符串相加，肯定转换为字符串啊，所以调用了对象的toString方法，变为[object Object]了\n   3. alert是调用toString()方法，和字符串和对象相加一样\n   4. \n\n\n","tags":["toString()","valueOf()"]},{"title":"web安全及预防","url":"/2019/05/11/web安全及预防/","content":"\n### web常见安全漏洞分类\n#### 跨站脚本攻击(XSS)\n1. 介绍： 攻击者在web在页面通过表单等方式插入script代码，当用户浏览网页时候，script代码会被执行，从而达到攻击目的。\n2. 分类：\n   1. 反射型（服务器渲染）。用户访问带xxs脚本url请求，服务端接受数据发送给浏览器，浏览器解析造成xss漏洞。\n   2. 存储型。用户输入带XSS脚本的数据，服务端把数据存进数据库，页面被其他用户正常请求时，返回带XSS的数据。\n   3. DOM类型。运用恶意脚本通过DOM动态地检查和修改页面内容。\n3. 危害：\n   1. 修改网页内容\n   2. 盗取cookie\n   3. 页面重定向\n   4. 收集用户浏览器信息\n4. 措施：\n   1. 检测输入参数，对应<、>等字符进行过滤或者编码。\n   2. 对输出参数进行htmlEncode编码或转义\n   3. 设置httpOnly防御js获取cookie\n   4. 设置csp(content-security-policy), 就是为了页面内容安全而制定的一系列防护策略. 通过CSP所约束的的规责指定可信的内容来源（这里的内容可以指脚本、图片、iframe、font、style等等可能的远程的资源）\n\n#### SQL注入\n1. 介绍：SQL注入是利用WEB服务，把精心设计的SQL命令注入到后台数据库执行。\n2. 危害：\n   1. 对数据库非法读取、删除、添加等\n   2. 盗取用户铭感信息\n3. 措施：\n   1. 不应直接用前端传过来的sql做拼接，而应该用预编译语句，绑定变量，不改变sql语义。\n   2. 用户输入参数验证\n   3. 对关键数据库设置只读，减少风险。\n\n#### 跨站点请求伪造（CSRF）\n1. 介绍：攻击者盗用你的身份，以你的名义发送恶意请求。\n\n2. 满足条件：\n   1. 登录受信用网站A，并在本地生成Cookie\n   2. 在不登出A网站情况下，访问危险的B网站。\n   3. 案例：\n      1. 如果登录电商网站赠送积分或者礼物，接口：http://www.mybank.com/Transfer.php？money=1000&to=zhangsan\n      2. 攻击者在评论区发表：<img src=http://www.mybank.com/Transfer.php?money=1000&who=hacker>。 然后就源源不断收到礼物。\n      3. 送礼物或礼物是有记录的，然后攻击者找到删除记录接口（发现是post方式），自己构造一个页面通过form表单删除，然后同window.location = 'XXXX' 返回之前网页。\n\n3. 措施：\n   1. 验证HTTP referer字段，判断连接从哪个页面跳转过来。\n   2. 不用get请求，改用post。\n   3. 在http请求参数添加随机token，在服务器建立拦截器，如果请求中无token或者错误的token则拒绝请求。\n   4. 添加验证码、滑块验证。\n   5. chrome51版本以上 cookie设置Same-site，直接禁止第三方访问\n\n\n\n<br >\n[参考一](https://tech.meituan.com/2018/09/27/fe-security.html)\n[参考二](https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html)","tags":["web安全","web安全措施"]},{"title":"javascript中event loop原理","url":"/2019/05/02/javascript中event-loop原理/","content":"\n### 介绍\nEvent Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。\n\n### js任务广义分类\n\n#### 同步任务\n1. 同步任务：进入主线程，一个一个执行。\n\n#### 异步任务\n1. 异步任务：进入  `event table ` , 注册回调函数 ` callback `, 任务完成之后，将 `callback` 移入  `event queue`， 等待主线程调用。\n\n### js任务细致分类\n\n#### 宏任务（MacroTask）\n   1. setTimeout、setInterval、script、I/O、UI Rendering\n\n#### 微任务（MicroTask）,优先于宏任务\n   1. Process.nextTick（Node独有）、Promise\n\n### 浏览器中Event Loop\n\n#### 事件循环\n<img src=\"/img/eventloop.webp\" />\n*** 事件循环 负责执行代码、收集和处理事件以及执行队列中的子任务: ***\n1. Javascript 有一个主线程和执行栈，所有的任务都会被放到调用栈等待主线程执行\n2. 同步任务会被放在调用栈中，按照顺序等待主线程依次执行\n3. 主线程之外存在一个任务队列，所有任务在主线程中以执行栈的方式运行\n4. 同步任务都在主线程上执行，栈中代码在执行的时候会调用 Web API，此时会产生一些异步任务\n5. 异步任务会在有了结果（比如被监听的事件发生时）后，将注册的回调函数放入任务队列中\n6. 执行栈中任务执行完毕后，此时主线程处于空闲状态，会从任务队列中获取任务进行处理\n\n以上过程会不断重复，这就是浏览器的运行机制，也是Event Loop\n\n\n**更加详细的流程：**\n\n```js\nJavaScript中的事件循环机制基于异步执行，用于处理非阻塞 I/O 操作、定时器等异步任务。以下是事件循环机制的基本流程：\n\n1. 执行全局同步代码： 当 JavaScript 程序开始执行时，首先执行全局同步代码，将同步任务推入执行栈（Call Stack）中。\n\n2. 执行栈（Call Stack）： 执行栈是一个存储函数调用的栈结构。每当调用一个函数，它会被推入执行栈的顶部；\n当函数执行完毕，它会从栈顶弹出。执行栈是同步执行的。\n\n3. 执行异步任务： 当遇到异步任务时，将异步任务的回调函数推入任务队列（Task Queue）中。\n异步任务包括定时器、事件监听器、Ajax 请求等。\n\n4. 事件循环开始： 当执行栈为空时，事件循环开始工作。\n事件循环会检查任务队列是否有任务。如果有，将任务推入执行栈中执行。\n\n5. 执行异步任务回调： 异步任务的回调函数在执行栈中执行。\n如果异步任务中有新的异步任务，它们会被推入任务队列中，等待下一轮事件循环。\n\n6. 重复： 重复以上过程，形成一个循环。每轮事件循环称为一个 tick。\n```\n\n#### 任务队列图\n<img src=\"/img/event_loop.png\"  alt=\"任务队列\" height=\"auto\"/>\n\n#### 案例\n```js\nconsole.log(1);\nsetTimeout(() => {\n    console.log(2)\n    new Promise((resolve, reject) => {\n        console.log(3)\n        resolve()\n    }).then(() => {\n        console.log(4)\n    })\n}, 0)\n\nnew Promise((resolve, reject) => {\n    console.log(5); // 为啥5会立即执行？---> 虽然位于Promise的构造函数中，但在这个例子构造函数没有任何触发异步操作的地方，所以它也会同步执行。\n    resolve()\n}).then(() => {\n    console.log(6)\n})\n\nconsole.log(10)\n\n// 1 5 10 6 2 3 4\n\n```\n1. 第一轮事件循环\n   1. 进入主线程遇到console.log(1), 输出 1\n   2. 遇到setTimeout,将其回调函数推入macro task的event queue， 并且标记任务setTimeout1\n   3. 遇到promise 微任务， 直接执行 new Promise的构造函数 输出 5， 将then函数的回调函数推入 micro Task 的 event queue 中，记为 promise1\n   4. 执行 console.log(10), 输出 10\n   5. 第一轮事件结束，主线程会去检查是否有微任务，会输出then函数 console.log(6)\n2. 第二轮事件循环\n   1. 首先setTimeout1，输出 2\n   2. 然后碰到 promise 微任务， 直接执行 new Promise 输出 3, 同理将 回调函数推入 micro Task 的 event queue 中， 记为 promise2\n   3. 执行 微任务 promise2， 输出 4, 微任务执行完成，\n   4. 检查event queue队列是否还有任务没执行，所以任务执行完成\n\n### NodeJS中Event Loop\n\nNode.js 的事件循环机制建立在 V8 引擎之上，并且采用了 libuv 库来处理事件循环。以下是 Node.js 事件循环机制的基本原理：\n\n1、Node.js 的单线程： Node.js 是单线程的，但它通过事件循环机制实现了异步操作，使其能够处理大量并发请求。\n\n2、事件循环的阶段： Node.js 的事件循环被分为不同的阶段。每个阶段都有一个 FIFO 队列，用于存放相应的回调函数。事件循环的阶段包括：\n\n  1. timers（定时器）： 执行 setTimeout 和 setInterval 中到期的回调函数。\n  2. pending callbacks： 执行某些系统操作的回调函数，如TCP错误之类的操作。\n  3. idle, prepare： 仅用于内部操作。\n  4. poll（轮询）： 处理 I/O 事件。当轮询队列不为空时，事件循环会遍历队列执行回调。如果轮询队列为空且有 setImmediate 回调，事件循环会直接进入下一阶段。\n  5. check： 执行 setImmediate 的回调函数。\n  6. close callbacks： 执行关闭的回调函数，例如 socket.on('close', ...)。\n\n3、事件循环的执行过程： 当 Node.js 启动时，它会执行全局脚本，并且事件循环开始。每个阶段的执行都是一个循环。在每个循环中，事件循环会执行当前阶段的所有回调函数，然后移动到下一个阶段。\n\n4、异步操作的触发： 在 Node.js 中，异步操作的触发通常包括 I/O 操作、定时器到期、以及其他异步操作（如 setImmediate、process.nextTick 等）。\n\n5、触发异步操作后的回调： 当异步操作完成后，相应的回调函数会被推入到相应的事件队列中，等待事件循环执行。\n\n6、事件队列和回调的执行： 每个阶段都有一个事件队列，用于存放相应阶段的回调函数。当事件循环进入某个阶段时，会依次执行该阶段队列中的回调函数。\n\n总体来说，Node.js 事件循环机制通过事件队列和不同的阶段来实现异步非阻塞的执行模型。这使得 Node.js 能够高效地处理大量并发请求，而不会阻塞整个应用程序。\n\n<br>\n文章来源：\n1. [参考1](https://juejin.im/post/5c3d8956e51d4511dc72c200#heading-25)\n2. [参考2](https://mp.weixin.qq.com/s/omqXH1SxJyvl7N8y-6Zp3Q)","tags":["event loop","内存堆","调用栈"]},{"title":"浏览器事件机制","url":"/2019/05/02/浏览器事件机制/","content":"\n### 浏览器事件机制三个阶段\n#### 事件捕获阶段\n```js\n//捕获阶段注册事件\n   document.getElementById(\"button\").addEventListener(\"click\",function(event){\n            console.log(\"button\");\n            event.stopPropagation(); //阻止事件捕获\n            event.stopImmediatePropagation(); //阻止其他事件（包括默认事件）\n        },true);\n```\n\n#### 处于目标阶段\n#### 事件冒泡阶段\n```js\n//冒泡阶段注册事件\n   document.getElementById(\"button\").addEventListener(\"click\",function(event){\n            console.log(\"button\");\n            event.stopPropagation(); //阻止冒泡\n        },false);\n```\n\n### 事件委托\n#### 原理\n1. 利用事件冒泡机制\n\n#### 优势\n1. 减少内存\n2. 动态注册事件","tags":["浏览器事件机制","捕获、目标、冒泡"]},{"title":"构造函数和原型以及原型链","url":"/2019/04/24/构造函数和原型以及原型链/","content":"### 什么是构造函数？\n构造函数本身就是一个函数，与普通函数没有任何区别，不过为了规范一般将其首字母大写。构造函数和普通函数的区别在于，使用 new 生成实例的函数就是构造函数，直接调用的就是普通函数。\n\n\n### constructor\n1. constructor 返回创建实例对象时构造函数的引用。此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。\n  1. 构造函数\n    ```js\n    function Parent(age) {\n        this.age = age;\n    }\n    var p = new Parent(50);\n    p.constructor === Parent; // true\n    p.constructor === Object; // false\n    ```\n  2. 普通函数\n    ```js\n    function parent1(age) {\n        return {\n            age: age\n        }\n    }\n    var p = parent1(20);\n    p.constructor === Object; // true\n    ```\n2. 对于基本类型(String、Number、Boolean、Symbol、null、undefined)constructor只读，当然null、undefined没有构造属性；对于引用类型constructor可修改。\n\n### new Class()详解\n#### 案例\n1. 代码：\n```js\n  function Person(name, age){\n    this.name = name;\n    this.age = age;\n  }\n  var p = new Person('chao', 12);\n```\n#### new Person('chao', 12)一个对象的4个过程\n1. 创建一个空对象\n```\nvar obj = new Object();\n```\n2. 让实例对象中this指向obj， 并且执行Person函数体\n```\nvar result = Person.call(this);\n```\n3. 设置原型链，将obj的__proto__指向实例化对象的prototype成员对象\n```\nobj.__proto__ = Person.prototype;\n```\n4. 判断实例化返回类型\n```\nif(typeof(result) === 'object'){\n   p = result;\n}else{\n  p = obj;\n}\n```\n### 模拟实现new\n```js\nfunction create() {\n\t// 1、获得构造函数，同时删除 arguments 中第一个参数\n    Con = [].shift.call(arguments);\n\t// 2、创建一个空的对象并链接到原型，obj 可以访问构造函数原型中的属性\n    var obj = Object.create(Con.prototype);\n\t// 3、绑定 this 实现继承，obj 可以访问到构造函数中的属性\n    var ret = Con.apply(obj, arguments);\n\t// 4、优先返回构造函数返回的对象\n\treturn ret instanceof Object ? ret : obj;\n};\n```\n### 原型\n#### prototype\n#### \\__proto\\__\n#### 原型链\n1. 含义：每个对象拥有一个原型对象，通过 \\__proto\\__ 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null。这种关系被称为原型链 (prototype chain)\n```js\n  function Person(name, age){\n    this.name = name;\n    this.age = age;\n  }\n  var p = new Person('chao', 12);\n  p  //Person\n  p.__proto__ ===  Person.prototype // true\n  p.__proto__.__proto__ === Object.prototype //true  \n  p.__proto__.__proto__.__proto__ === null //true\n```\n\n\n### 总结\n1. Symbol 作为构造函数来说并不完整，因为不支持语法 new Symbol()，但其原型上拥有 constructor 属性，即 Symbol.prototype.constructor。\n2. 引用类型 constructor 属性值是可以修改的，但是对于基本类型来说是只读的，当然 null 和 undefined 没有 constructor 属性。\n3. \\__proto\\__ 是每个实例上都有的属性，prototype 是构造函数的属性，这两个并不一样，但 p.\\__proto\\__ 和 Parent.prototype 指向同一个对象。\n4. \\__proto\\__ 属性在 ES6 时被标准化，但因为性能问题并不推荐使用，推荐使用 Object.getPrototypeOf()。\n5. 每个对象拥有一个原型对象，通过 \\__proto\\__ 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null，这就是原型链。\n\n\n### 思考题\n1. js无限累计\n```js\nfunction add(a){\n   function sum(b){\n      a += b;\n      return sum;\n   }\n\n   //重写toString\n   sum.toString = function(){\n      console.log('======');\n      return a;\n   }\n\n   return sum; //返回函数\n}\nadd(1)(2)(3)\n```\n*我们知道打印函数时会自动调用 toString()方法，函数 add(a) 返回一个闭包 sum(b)，函数 sum() 中累加计算 a = a + b，只需要重写sum.toString()方法返回变量 a 就OK了*","tags":["原型链","原型","构造函数"]},{"title":"JS内存机制","url":"/2019/04/18/JS内存机制/","content":"\n### 内存回收\n\n#### 手动回收（对象设置为null）\n  1. a = null;\n\n#### 自动回收（对象没有被引用就视为垃圾回收）\n1. 局部变量和全部变量\n   1. 局部变量当函数执行完成垃圾回收器就回收。\n   2. 全部变量什么时候需要自动释放很难判断，所以尽量少用全局变量。\n\n### 垃圾回收算法\n1. 引用计数算法\n2. 标记清楚算法\n\n### 内存泄露如果避免\n1. 意外的全局变量\n   1. 解决方法： \n      1. 尽量少用全局变量\n      2. 在 JavaScript文件头部加上 'use strict'，使用严格模式避免意外的全局变量。\n      3. 局部变量一定要用var、let\n    ```\n          function foo(arg) {\n            bar = \"this is a hidden global variable\";\n        }\n    ```   \n2. 被遗忘的定时器\n3. 脱离了DOM的引用\n   1. 表现：如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。那么将来需要把两个引用都清除\n   2. 解决方法\n      1. DOM树、字典或者数组同时要删除\n4. 闭包\n","tags":["内存机制"]},{"title":"JS内存空间分配","url":"/2019/04/18/JS内存空间分配/","content":"### js数据类型\n\n#### 基本数据\n  1. Null、Bollean、String、Number、Undefined、Symbol\n\n#### 引用数据\n  1. Object\n     1. Array、Function、RegExp、Date\n\n#### 内存分布\n  <img src=\"/img/heap.png\"  alt=\"内存分布\" height = \"auto\"/>\n  1. 闭包中变量不会存放在栈。（函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。）\n  ```\n    function A() {\n    let a = 1\n    function B() {\n        console.log(a)\n    }\n    return B\n    }\n  ```\n\n\n### js内存生命周期\n1. 分配所需的内存\n2. 使用分配的内存（读、写）\n3. 不需要将内存释放（自动：对象不引用即释放\\手动： a = null）\n\n\n### 例子详解\n#### 基本数据复制、修改\n```\n    var a = 20;\n    var b = a;\n    b = 30;\n    // 这时a的值是多少？\n```\n\n#### 引用数据复制、修改\n```\n    var m = { a: 10, b: 20 }\n    var n = m;\n    n.a = 15;\n    // 这时m.a的值是多少\n```","tags":["js内存","栈、堆"]},{"title":"构建高性能web应用","url":"/2019/02/17/构建高性能web应用/","content":"\n####  什么是高性能web前端应用？\n1. 打开慢\n   1. 白屏、无样式时间长 -> css、图片、字体等加载和页面渲染时间太长\n   2. 可用时间晚 -> js加载时间长\n2. 反应慢\n   1. 响应时间慢 -> 网络延迟、不稳定\n   2. 操作没反应 -> \n   3. 动画卡顿、不顺畅 -> 内存占用高、内存泄露\n3. 耗电\n\n#### 在浏览器输入url到显示网页的过程:\nDNS查询->tcp连接->http请求->服务器响应->客户端加载渲染\n\n#### 浏览器工作过程(客户端加载渲染)\n##### A:浏览器加载\n1. 加载过程：\n   1. 浏览器接受完整的html或者一个chunk资源。\n   2. 当遇到请求外链css、js、image等资源，浏览器发送请求来获取相应的资源。这是个异步的请求过程，但是当js请求会阻塞后面的请求、解析、渲染。\n    > 原因是js当初设计就是简单修改网页内容，所以会改变DOM、CSS，也就是说当js执行前后面所有资源的下载都是不必要的。当js加载、解析、执行完成后才进行html后面的渲染。\n   3. css文件虽然不会阻塞js文件下载，但是会阻塞js文件执行。\n    > var height = $('#id').height(); 浏览器必须保证css下载、解析完成后才执行这段代码。 \n   4. css会阻塞DOM树解析吗？css会阻塞DOM树渲染吗？\n2. 了解浏览器如何进行加载，我们可以在引用外部样式文件，外部css、js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。\n\n##### B:浏览器解析\n1. 解析过程：\n   1. DOM解析(DOM树)：html文档解析生成解析树即dom树，是由dom元素及属性节点组成，树的根是document对象。![image](https://image-static.segmentfault.com/323/594/3235942180-5960e0d629942_articlex)\n   2. CSS解析：将css文件解析为样式表对象。该对象包含css规则，该规则包含选择器和声明对象。![image](http://upload-images.jianshu.io/upload_images/94752-a88c7ccbb30a132c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/630/format/webp)\n2. 了解浏览器如何进行解析，我们可以在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。\n   \n\n##### C:浏览器渲染\n1. 渲染过程：\n   1. 根据CSS树和DOM树，生成布局（flow），即将所有渲染树的所有节点进行平面合成\n   2. 将布局绘制（paint）在屏幕上\n2. 了解浏览器如何进行渲染，明白渲染的过程，我们在设置元素属性，编写js文件时，可以减少”重绘“”重排“的消耗。\n> 1. 重绘: 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程。\n> 2. 重排: 当DOM的变化影响了元素的几何信息(DOM对象的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置。由于浏览器渲染界面是基于流式布局的，所以影响范围有全局和局部之分。\n\n  \n##### 网页生成的过程总结：\n![image](/img/brower.webp)\n\n\n#### 性能优化方案\n1. DNS查询:\n   1. 拆分域名增加并行下载量，可以按照静态和动态资源进行域名划分\n   2. 首页提前预获取DNS(dns-prefetch)，提前解析页面所需的域名：\n   ![image](http://user-gold-cdn.xitu.io/2018/5/28/163a4d01ff02c0c5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n2. http连接和服务器响应：\n   1. 减少和合并请求(http2可以不用这一步)\n      1. 稍微大一点的图标可以用css雪碧图\n      2. 小的图标用Base64编码，可以节约请求数\n      3. 如果服务器支持（nginx-http-concat插件）可以把多个请求合并成一个：http://localhost/my-web/static/css??a.css,b.css，\n   2. 减少传输资源的大小\n      1. 服务器开启GZIP压缩\n      2. js混淆压缩、图片压缩或者用更小的WebP图片格式以及css压缩  \n      3. 减少不必要的cookie传输，禁用静态资源域名下的cookie(和上面的拆分域相配合)\n   3. 充分利用浏览器缓存，减少重新请求服务器数据\n      1. 缓存存储：Cache-Control: max-age=31536000\n      2. 缓存过期：过期头 (Expires)\n      3. 缓存对比：Last-Modified、E-Tag\n      <img src=\"/img/expires\" width=\"100%\" alt=\"缓存\">\n      ![image](/img/expires1.png)\n      >只有当ctrl+f5才会强制刷新，开发的时候一般建议用文件hash值避免这种修改的文件也被强缓存\n   4. 单页面应用可以在webpack打包的时候使用code split和bundle split将代码分离动态加载\n   > Bundle splitting: 实际上就是创建多个更小的文件，并行加载，以获得更好的缓存效果；主要的作用就是使浏览器并行下载，提高下载速度。并且运用浏览器缓存，只有代码被修改，文件名中的哈希值改变了才会去再次加载。\n   > \n   > Code splitting: 只加载用户最需要的部分，其余的代码都遵从懒加载的策略；主要的作用就是加快页面加载速度，不加载不必要加载的东西。(require.ensure / Dynamic Imports)\n   > [参考](https://mp.weixin.qq.com/s/LCqnIoRzIiy8zTyw6_avqA)\n   5. nginx搭建反向代理，进行有效的负载均衡。nginx配置截取：\n   ```\n    http {\n      upstream video {\n        ip_hash;\n        server 127.0.0.1:3000 weight = 2; //权重的值，越大被命中几率越大\n        server 127.0.0.1:3001 weight = 1;\n        server 127.0.0.1:3002 weight = 0.5;\n      }\n      server {\n        listen: 8080;\n        location / {\n            proxy_pass: http://video\n       }\n     }\n    }\n   ```\n3. 客户端加载渲染\n   1. js阻塞浏览器其他资源加载，所以不是必须尽量放在页面底部或者async/defer等异步加载\n      1. async是js和后续文档并行加载，加载完就串行执行。（加载是并行，执行就阻塞后面文档的加载）\n      2. defer是js和后续文档并行加载， 等到后续文档解析之后才执行。\n   2. 优化关键渲染路径就是要优先显示和用户先关内容，可以把关键的css样式内联在页面，其他完成的样式可以异步加载\n   3. DOM和样式结构嵌套不用太深，减少解析耗时\n   4. 减少重排(回流)\n      1. 在js中尽量减少DOM操作，尽量缓存访问DOM的样式信息，可以用操作class方式改变样式或者渲染动画，避免多次回流\n      2. 如果一个文档区域要大量操作DOM，可以让当前区域脱离文档流(absolute、fixed、float)或者固定当前区域大小、位置。\n      3. 由于隐藏的元素不会影响重新渲染，如果对一个元素进行复杂的操作，可以先隐藏再显示，这样只会重排二次。\n      4. 现在流行的框架vue、reactjs都引入Virtual DOM。\n         > 1，innerHTML: render html string O(template size) + 重新创建所有 DOM 元素 O(DOM size)\n         > \n         > 2，Virtual : render Virtual DOM + diff O(template size) + 必要的 DOM 更新 O(DOM change)\n   5. 减少重绘\n      1. 利用缓存把多次的操作合并在一起，不要在循环中直接调用。\n   6. 涉及到动画尽量开启GPU，js做动画会阻塞代码执行。transform: translateZ(0);\n   7. 防止内存泄露（如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存）\n      1. 全局变量。有时候业务需求要在模块定义全局变量，模块销毁的时候让变量等于null\n      2. 定时器没被销毁。\n      3. 脱离 DOM 的引用。\n      4. 闭包，匿名函数可以访问父级作用域。\n   8. 在开发的过程， 对于连续行为及短时间会触发很多次的浏览器事件,例如：scroll,resize, mousemove,我们急需对其进行性能优化。两种方式可以去优化我们的性能 函数节流(throttle) 和 函数去抖(debounce)[参考](http://demo.nimius.net/debounce_throttle/)\n      >throttle策略的电梯。保证如果电梯第一个人进来后，15秒后准时运送一次，不等待。如果没有人，则待机\n\n      ```js\n        // 方法一\n         var throttle = (function(){\n             var statTime = 0,\n              return function(fn, wait){\n                 var currentTime = new Date();\n                 if(currentTime - statTime > wait){\n                    fn && fn();\n                    statTime = currentTime;\n                 }\n              }\n         })()\n\n\n\n        //方法二\n        var throttle = function (fn, wait){\n           let timer = null;\n           return function(){\n              const that = this;\n              const args = arguments;\n              if(!timer){\n                 timer = setTimeout(funciton(){\n                     fn.apply(that, args);  //fn.call(that,arg1, arg2,...);\n                     clearTimeout(timer);\n                     timer = null;\n                 }, wait)\n              }\n           }\n        }\n      ```\n\n      >debounce策略的电梯。如果电梯里有人进来，等待15秒。如果又人进来，15秒等待重新计时，直到15秒超时，开始运送。\n\n      ```js\n         var dubounce = (function(){\n           var timer = null;\n           return function(func, wait){\n             timer && clearTimeout(timer);\n\n             timer = setTimeout(function(){\n                func()\n             }, wait)\n           }   \n        })()\n       ```\n  4. 耗电\n     1. 主要是网络模块耗电。\n     2. 整个UI可用用黑白色调节省电。","tags":["性能","async、defer"]},{"title":"vue源码分析下二","url":"/2019/01/04/vue源码分析下二/","content":"\n## 组件化介绍\n\n1. 所谓组件化，就是把页面拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。\n\n## 组件化相关\n### createComponent\n1. 首先判断是否是真正html标签还是component。如果是html标签会是渲染普通VNode节点，负责渲染通过createComponent方法创建一个组件VNode\n2. createComponent实现:\n   1. 构造子类构造函数\n   2. 安装组件钩子函数\n   3. 实例化VNode\n\n### Patch\n1. 当我们通过 createComponent 创建了组件 VNode，接下来会走到 vm._update，执行 vm.__patch__ 比较新生成的VNode和旧的VNode，最后将差异（变化的节点）更新到真实的DOM树上。如果组件 patch 过程中又创建了子组件，那么DOM 的插入顺序是先子后父。\n```\nfunciton patch(oldVnode,vnode,...){\n    ...\n}\n//oldVnode: 旧的VNode或旧的真实DOM节点\n//vnode: 新的VNode\n//hydrating: 是否要和真实DOM混合\n//removeOnly: 特殊的flag，用于<transition-group>\n//parentElm: 父节点\n//refElm: 新节点将插入到refElm之前\n```\n\n#### patch流程处理\n1. 如果vnode不存在，但是oldVnode存在，说明是需要销毁旧节点，则调用invokeDestroyHook(oldVnode)来销毁oldVnode。\n2. 如果vnode存在，但是oldVnode不存在，说明是需要创建新节点，则调用createElm来创建新节点。\n3. 当vnode和oldVnode都存在时 \n   1.\n4. 返回VNode.elm\n\n\n### 合并配置\n\n### 生命周期\n\n### 组件注册\n\n#### 全局注册\n```\nVue.component(tagName, options)\n```\n\n#### 局部注册\n```\nimport HelloWorld from './components/HelloWorld'\n\nexport default {\n  components: {\n    HelloWorld\n  }\n}\n```\n\n### 异步组件\n\n1. 方法一，普通异步组件：\n```\nVue.component('async-example', function (resolve, reject) {\n    // 这个特殊的 require 语法告诉 webpack\n    // 自动将编译后的代码分割成不同的块，\n    // 这些块将通过 Ajax 请求自动下载。  \n   require(['./my-async-component'], resolve)\n})\n```\n2. 方法二，promise异步组件\n```\nVue.component(\n  // 该 `import` 函数返回一个 `Promise` 对象。\n  () => import('./my-async-component')\n)\n```\n3. 方法三，高级异步组件\n```\nconst AsyncComp = () => ({\n  // 需要加载的组件。应当是一个 Promise\n  component: import('./MyComp.vue'),\n  // 加载中应当渲染的组件\n  loading: LoadingComp,\n  // 出错时渲染的组件\n  error: ErrorComp,\n  // 渲染加载中组件前的等待时间。默认：200ms。\n  delay: 200,\n  // 最长等待时间。超出此时间则渲染错误组件。默认：Infinity\n  timeout: 3000\n})\nVue.component('async-example', AsyncComp)\n```\n4. 总结：异步组件实现的本质是2次渲染，除了 0 delay 的高级异步组件第一次直接渲染成 loading 组件外，其它都是第一次渲染生成一个注释节点，当异步获取组件成功后，再通过forceRender强制重新渲染，这样就能正确渲染出我们异步加载的组件了。\n\n\n[本文来源](https://ustbhuangyi.github.io/vue-analysis/components/)","tags":["vue","vue组件化"]},{"title":"js浅克隆和深克隆","url":"/2018/12/27/js浅克隆和深克隆/","content":"\n### js数据类型\n\n#### 基本类型\n1. Null、String、Bool、Number、Symbol、Undefined\n   1. Symbol: 如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。[参考](http://es6.ruanyifeng.com/#docs/symbol)\n\n#### 引用类型\n1. Object\n   1. Array、Date、RegExp、Function\n\n#### 区别\n1. 基本数据类型的特点：直接存储在栈(stack)中的数据\n2. 引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里。\n\n### 拷贝\n\n#### 浅拷贝\n1. Object.assign();\n1. 自己实现方法:\n```\n function shallowClone(source = {}){\n  var target = {};\n  for ( let i in source) {\n    target[i] = source[i];\n  }\n  return target;   \n }\n```\n1. 缺点就对象虽然被复制但是还是会指向相同内存，修改任何一方都影响另一方。\n\n\n\n#### 深拷贝\n1. JSON.parse方法\n```\nconst oldObj = {\n  a: 1,\n  b: [ 'e', 'f', 'g' ],\n  c: { h: { i: 2 } }\n};\n\nconst newObj = JSON.parse(JSON.stringify(oldObj));\n```\n  1. 缺点：无法拷贝Function、RegExp；循环引用错误； \n\n\n1. 自己实现方法\n```\nfunction checkType(obj){\n    retrun Object.prototype.toString.call(obj).slice(8, -1);  //[object,String]\n}\n\n\nfunction deepClone(target) {\n  let result, targetType = checkedType(target)\n\n  if (targetType === 'object') {\n    result = {}\n  } else if (targetType === 'Array') {\n    result = []\n  } else {\n    return target\n  }\n\n  for (let i in target) {\n    let value = target[i]\n    if (checkedType(value) ==='Object' || checkedType(value) ==='Array') {\n      result[i] = deepClone(value)\n    } else {\n      result[i] = value;\n    }\n  }\n\n  return result\n}\n\n```","tags":["js拷贝","js数据类型"]},{"title":"Event Bus实现原理","url":"/2018/12/23/Event-Bus实现原理/","content":"### vue、react不同组件怎么通信\n\n#### Vue\n1. 父子组件：props、$refs、$children\n2. 子父组件：$parent、$emit自定义事件\n3. 如果项目够复杂,可能需要Vuex等全局状态管理库通信\n4. 非父子组件用Event Bus通信（$emit、$on）\n```\n  //main.js\n  var eventBus = {\n    install(Vue,options) {\n        Vue.prototype.$bus = vue\n    }\n  };\n  Vue.use(eventBus);\n\n  //children.js\n  this.$bus.$emit('dosth', params);\n\n  //children.js\n  this.$bus.$on('dosth , (params)=>{}); \n  beforeDestory(){\n    this.$bus.$off('dosth');\n  } \n```\n5. $dispatch(vue2已经废除)和$broadcast(vue2已经废除)\n\n#### React\n1. 父子组件：props，如果父组件与子组件之间不止一个层级，可通过...运算符（Object 剩余和展开属性）。\n```\nclass Child_1 extends Component{\n  render() {\n    return <div>\n      <p>{this.props.msg}</p>\n      <Child_1_1 {...this.props}/>\n    </div>\n  }\n}\nclass Child_1_1 extends Component{\n  render() {\n    return <p>{this.props.msg}</p>\n  }\n}\n```\n2. 子父组件：props回调方法\n3. 项目复杂的话用Redux、Mobx等全局状态管理管库\n4. 非父子组件,用发布订阅模式的Event模块\n5. 用新的Context Api\n   1. 父组件首先声明自己可以支持 context，定义 childContextTypes 方法。\n   2. 父组件需要定义方法，返回 context 对象，定义 getChildContext 方法。\n   3. 子组间声明自己需要使用 context，定义 contextTypes 方法。\n\n#### Event Bus\n1. 它实际上是发布订阅模式。\n2. 实现流程\n   1. 实现类class\n   ```\n     class EventEmeitter{\n         constructor(){\n            this._evt = this._evt || new Map();\n            this._maxListener = this._maxListener || 10;\n         }\n     }\n   ```\n   2. 监听和触发\n   ```\n     class EventEmeitter{\n       emit(type, ...args){\n            let handler;\n            handler = this._evt.get(type); //new Map()方法\n            if (args.length > 0) {\n                handler.apply(this, args);\n            } else {\n                handler.call(this);\n            }\n            return true;\n       }\n       on(type, fn){\n            if (!this._evt.get(type)) {\n                this._evt.set(type, fn);\n            }\n     }\n   ```","tags":["vue/react通信","Event Bus"]},{"title":"Proxy和defineProperty对比","url":"/2018/12/21/Proxy和defineProperty对比/","content":"\n### 双向绑定\n1. 发布-订阅\n2. 脏检测\n3. 数据劫持\n  1. Object.definePropery (es5）\n  2. Proxy (es6)\n  3. Object.observe(废弃)\n4. 数据模型\n\n\n### definePropery\n\n#### 1. 不能检测数组长度变化，准确的说是通过改变Length而增加的长度不能检测。\n\n> [length 和数字下标之间的关系](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#Relationship_between_length_and_numerical_properties) —— JavaScript 数组的 length 属性和其数字下标之间有着紧密的联系。数组内置的几个方法（例如 join、slice、indexOf 等）都会考虑 length 的值。另外还有一些方法（例如 push、splice 等）还会改变 length 的值。[为什么defineProperty不能检测到数组长度的“变化”](https://iming.work/detail/5b0cb1f17f6fd30063942cd5)\n\n  1. 当你利用索引直接设置一个项时，vm.items[indexOfItem] = newValue\n    1. 解决方法：Vue.set(vm.items, indexOfItem, newValue) / vm.$set(vm.items, indexOfItem, newValue) / vm.items.splice(indexOfItem, 1, newValue)\n  2. 当你修改数组的长度时，vm.items.length = newLength\n    1. 解决方法：vm.items.splice(newLength)\n\n#### 2. 为什么defineProperty不能检测到数组长度的“变化”\n1. \n\n#### 3. vue对数组方法的hack\n```\nconst arrayProto = Array.prototype\n// 复制了数组构造函数的原型\n// 这里需要注意的是数组构造函数的原型也是个数组\n// 实例中指向原型的指针__proto__也是个数组\n// 数组并没有索引，因为length = 0\n// 相反的拥有属性，属性名为数组方法，值为对应的函数\nexport const arrayMethods = Object.create(arrayProto)\n\n// 对以下方法重写\nconst methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  const original = arrayProto[method]\n  // 这里的def很重要，其实也就是用object.defineProperty重新定义属性\n  // 但这里的arrayMethods是个数组，这就是为什么上面我们解释\n  // 数组构造函数原型是个空数组但是默认了属性方法\n  // 所以这里的定义是很巧妙的\n  def(arrayMethods, method, function mutator (...args) {\n    const result = original.apply(this, args)\n    // ob就是observe实例\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      // 为什么对push和unshift单独处理？\n      // 我们在上看解释过，这2中方法会增加数组的索引，但是新增的索引位需要手动observe的\n      case 'push':\n      case 'unshift':\n        inserted = args\n        break\n      // 同理，splice的第三个参数，为新增的值，也需要手动observe\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    // 其余的方法都是在原有的索引上更新，初始化的时候已经observe过了\n    if (inserted) ob.observeArray(inserted)\n    // notify change\n    // 然后通知所有的订阅者触发回调\n    ob.dep.notify()\n    return result\n  })\n})\n```\n#### 4. Vue 不能检测对象属性的添加或删除\n1. 对于已经创建的实例，Vue 不能动态添加根级别的响应式属性\n```\nvar vm = new Vue({\n  data: {\n    a: 1\n  }\n})\n// `vm.a` 现在是响应式的\n\nvm.b = 2\n// `vm.b` 不是响应式的\n```\n1. 解决方法：\n   1. Vue.set(vm.userProfile, key, value)\n   2. vm.$set(vm.userProfile, key, value)\n   3. Object.assign()\n\n#### 5. definePropery缺点\n1. 无法监听数组变化\n2. 无法检测对象属性的添加和删除\n3. 性能差。只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历\n\n\n### Proxy\n\n#### Proxy可以直接监听对象而非属性\n```\nconst input = document.getElementById('input');\nconst p = document.getElementById('p');\nconst obj = {};\n\nconst newObj = new Proxy(obj, {\n  get: function(target, key, receiver) {\n    return Reflect.get(target, key, receiver);\n  },\n  set: function(target, key, value, receiver) {\n    if (key === 'text') {\n      input.value = value;\n      p.innerHTML = value;\n    }\n    return Reflect.set(target, key, value, receiver);\n  },\n});\n\ninput.addEventListener('keyup', function(e) {\n  newObj.text = e.target.value;\n});\n```\n\n#### Proxy可以直接监听数组的变化\n\n#### 优缺点\n1. 优点：对数组和对象支持非常好，不需要hask；性能比definePropery好，初始化很多数据，当用到才会被监听。\n2. 缺点：兼容性不太好，而且无法用polyfill磨平","tags":["双向绑定","Proxy","defineProperty"]},{"title":"vue3.0特征","url":"/2018/12/07/vue3-0特征/","content":"### 新特征\n1. 编译时候会对原生元素(div)和组件元素(component)进行分析对比，运行时候原生元素直接生成vitrual dom，组件元素就直接生成组件代码。\n2. 优化slots生成，生成新的组件依赖关系，避免不必要的组件渲染。之前版本如果slots模板自身发生变化，会通知调用的父组件更新。现在利用scoped(范围、作用域)只更新子组件本身了。\n3. 静态属性的提取。之前v2.x只对静态内容做直接输出，但是静态属性可以和静态内容一样不做比对直接输出。\n```\n<div id=\"test\" class=\"test\">{{ msg }}</div>\n```\n#### 数据监听由object.defineProperty变为Proxy。\n  1. Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。\n  ```\n    obj：必需。目标对象 \n    prop：必需。需定义或修改的属性的名字\n    descriptor：必需。目标属性所拥有的特性\n  ```\n  2. Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）:[参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\n     1. Proxy是lazy by default，初始化整个对象数据，当用某个属性用到才会被监听。\n\n\n#### runTime资源会更小（源码支持tree-shaking）  \n   1. 源码支持tree-shaking结构, 之前的所有的功能都挂在vue对象上，vue3.x把不是必须的功能编译打包的时候按需引入。最最最基本核心代码大概10kg gziped压缩。\n   ```\n   //Vue2.0\n   import Vue from 'vue'\n   Vue.nextTick(() => {})\n   const obj =  Vue.observable({})\n   \n   //Vue3.0\n   import { nextTick, observable } from 'vue'\n   nextTick(() => {})\n   const obj = observable({})\n   ```\n\n#### 时间分片\n1. cpu运行web程序机制是：主队列（主线程）需要完成所有主要任务（脚本的加载、渲染等），才能响应用户的操作。 这样用户的体验取决于Vue组件加载或者重新渲染的时间。\n2. Vue3的时间分片做法：将脚本运算过程切换成小段，并在每段执行完之后查看是否有用户输入处理。这样无论多少次渲染和重新渲染，应用程序都保持这响应状态。\n\n#### flow变为type-script\n#### 编译器重构\n   1. 插件化设计，便于开发者参与其中。\n   2. 带位置的信息parser(source maps), 具体某个模板具体某一块出错信息。\n   3. 更好的IDE工具链（eslint、vscode）","tags":["vue","vue3.0"]},{"title":"macOs开发笔记","url":"/2018/12/05/macOs开发笔记/","content":"\n* 入门参考：https://www.jianshu.com/p/be92a0a0f1a0\n* 个人练习：https://github.com/fanky-c/OcTest\n\n### 1: objective-c与javascript交互\n\n####  用 Objective-C 取得与设定 JavaScript 对象\n```\njs:\nwindow.location.href = 'http://spring-studio.net';\n\noc:\n[[webView windowScriptObject] setValue:@\"http://spring-studio.net\"forKeyPath:@\"location.href\"];\n```\n1. JS 虽然是 OO，但是并没有 class，所以将 JS 对象传到 Obj C 程序里头，除了基本字串会转换成 NSString、基本数字会转成 NSNumber，像是 Array 等其他对象，在 Objective-C 中，都是 WebScriptObject 这个 Class。意思就是，JS 的 Array 不会帮你转换成 NSArray。\n2. 从 JS 里头传一个空对象给 Objective-C 程序，用的不是 Objective-C 里头原本表示「没有东西」的方式，像是 NULL、nil、NSNull 等，而是专属 WebKit 使用的 WebUndefined。\n\n####  用 Objective C 调用 JavaScript function\n1. js调用oc\n```\noc:\n[[webView windowScriptObject] evaluateWebScript:@\"function x(x) { return x + 1;}\"];\n\njs:\nwindow.x(1);\n```\n\n2. oc调用js\n```\noc:\n[[webView windowScriptObject] evaluateWebScript:[NSString stringWithFormat:@\"showPromoAd('%@','%@');\",self.word, computerSerialNumber()]];\n\njs:\nfunction showPromoAd(word, id){};\n```\n\n#### DOM\n1. WebKit 里头，所有的 DOM 对象都继承自 DOMObject，DOMObject 又继承自 WebScriptObject，所以我们在取得了某个 DOM 对象之后，也可以从 Objective-C 程序中，要求这个 DOM 对象执行 JS 程序\n```\njs:\ndocument.querySelector('#s').focus();\n\noc:\nDOMDocument *document = [[webView mainFrame] DOMDocument];\n[[document querySelector:@\"#s\"] callWebScriptMethod:@\"focus\"withArguments:nil];\n```\n\n####  用 JavaScript 存取 Objective C 的 Value\n1. 要让网页中的 JS 程序可以调用 Objective-C 对象，方法是把某个 Objective-C 对象注册成 JS 中 window 对象的属性。之后，JS 便也可以调用这个对象的 method，也可以取得这个对象的各种 Value，只要是 KVC 可以取得的 Value，像是 NSString、NSNumber、NSDate、NSArray、NSDictionary、NSValue…等。JS 传 Array 到 Objective-C 时，还需要特别做些处理才能变成 NSArray，从 Obj C 传一个 NSArray 到 JS 时，会自动变成 JS Array。\n\n2. 首先我们要注意的是将 Objective-C 对象注册给 window 对象的时机，由于每次重新载入网页，window 对象的内容都会有所变动－毕竟每个网页都会有不同的 JS 程序，所以，我们需要在适当的时机做这件事情。我们首先要指定 WebView 的 frame loading delegate（用 setFrameLoadDelegate:），并且实作 webView:didClearWindowObject:forFrame:，WebView 只要更新了 windowScriptObject，就会调用这一段程序。\n\n####  用 JavaScript 调用 Objective C method\n1. Objective-C 的语法沿袭自 SmallTalk，Objective-C 的 selector，与 JS 的 function 语法有相当的差异。WebKit 预设的实事是，如果我们要在 JS 调用 Objective-C selector，就是把所有的参数往后面摆，并且把所有的冒号改成底线，而原来 selector 如果有底线的话，又要另外处理。\n\n\n### 2: jsbridge\n\n#### OC端\n1. 引入依赖文件\n```\n#import \"WebViewJavascriptBridge.h\"\n...\n@property WebViewJavascriptBridge* bridge;\n```\n2. 实例化一个对象\n```\nself.bridge = [WebViewJavascriptBridge bridgeForWebView:webView];\n```\n3. OC端 注册一个方法+ 调用该方法的函数\n```\n//供前端调用\n[self.bridge registerHandler:@\"OCTest\" handler:^(id data, WVJBResponseCallback responseCallback) {\n    NSLog(@\"ObjC Echo called with: %@\", data);\n    responseCallback(data);\n}];\n\n//主动推送给前端\n[self.bridge callHandler:@\"JsTest\" data:nil responseCallback:^(id responseData) {\n    NSLog(@\"ObjC received response: %@\", responseData);\n}];\n```\n\n#### JS端\n```js\nfunction setupWebViewJavascriptBridge(callback) {\n    if (window.WebViewJavascriptBridge) { return callback(WebViewJavascriptBridge); }\n    if (window.WVJBCallbacks) { return window.WVJBCallbacks.push(callback); }\n    window.WVJBCallbacks = [callback];\n    var WVJBIframe = document.createElement('iframe');\n    WVJBIframe.style.display = 'none';\n    WVJBIframe.src = 'https://__bridge_loaded__';\n    document.documentElement.appendChild(WVJBIframe);\n    setTimeout(function() { document.documentElement.removeChild(WVJBIframe) }, 0)\n}\n\nsetupWebViewJavascriptBridge(function(bridge) {\n\t //主动调用\n    bridge.registerHandler('JsTest', function(data, responseCallback) {\n        console.log(\"JS Echo called with:\", data)\n        responseCallback(data)\n    })\n\t//接受oc端主动推送的消息\n    bridge.callHandler('OCTest', {'key':'value'}, function responseCallback(responseData) {\n        console.log(\"JS received response:\", responseData)\n    })\n})\n```\n\n#### 原理\n1. 分别在OC环境和javascript环境都保存一个bridge对象，里面维持着requestId,callbackId,以及每个id对应的具体实现。\n2. OC通过javascript环境的window.WebViewJavascriptBridge对象来找到具体的方法，然后执行。\n3. javascript通过改变iframe的src来出发webview的代理方法，从而实现把javascript消息发送给OC这个功能。\n\n\n#### 工作流\n1. JS 端加入 src 为 https://__bridge_loaded__ 的 iframe\n2. Native 端检测到 Request，检测如果是 __bridge_loaded__ 则通过当前的 WebView 组件注入 WebViewJavascriptBridge_JS 代码\n3. 注入代码成功之后会加入一个 messagingIframe，其 src 为 https://__wvjb_queue_message__\n4. 之后不论是 Native 端还是 JS 端都可以通过 registerHandler 方法注册一个两端约定好的 HandlerName 的处理，也都可以通过 callHandler 方法通过约定好的 HandlerName 调用另一端的处理（两端处理消息的实现逻辑对称）\n\n### 3: ios本地缓存数据\n\n#### 直接写文件方式\n1. 可以存储的对象有NSString、NSArray、NSDictionary、NSData、NSNumber，数据全部存放在一个属性列表文件（*.plist文件）中。\n\n#### NSUserDefaults\n1. 一般应用来存储应用设置信息，文件放在perference目录下。\n\n#### 归档操作（NSkeyedArchiver）\n1. 不同于前面两种，它可以把自定义对象存放在文件中。\n\n#### coreData\n1. coreData是苹果官方iOS5之后推出的综合型数据库。\n\n#### FMDB\n1. FMDB是iOS平台的SQLite数据库框架，FMDB以OC的方式封装了SQLite的C语言API，使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码。\n\n\n### 4: 页面之间通信\n1. 属性传值\n   1. 正向传值：page1-->page2\n2. 单例传值\n```\n+(instancetype)sharedInstance{\n    static SharedInstance* _sharedInstance;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        _sharedInstance = [[SharedInstance alloc] init];\n    });\n    \n    return _sharedInstance;\n}\n```\n3. NSUserDefaults\n4. 代理传值\n  1. A:代理方(遵守协议、实现协议方法)   \n  2. B:委托方(制定持有协议，调用协议方法)\n  3. C:中间通讯（delegate）\n5. block传值\n6. 通知传值--NSNotificationCenter\n```\n//先监听\n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(updateValue:) name:@\"postValue\" object:nil];\n\n-(void)updateValue:(NSNotification*)not{\n    self.lable.text = not.userInfo[@\"val\"];\n}\n\n//发送广播\n [[NSNotificationCenter defaultCenter] postNotificationName:@\"postValue\" object:nil userInfo:@{@\"val\":self.inputText}];\n```\n7. [github参考](https://github.com/fanky-c/OcTest/tree/master/%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC/%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC)\n\n### 5: 文件操作\n1. NSFileHandle：文件内容的读取和写入\n2. NSFileManager：文件的删除和创建等\n3. [参考](https://github.com/fanky-c/OcTest/blob/master/IOS%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/IOS%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/ViewController.m)\n\n### 6: 多线程\n\n#### PThread(c框架，极少使用)\n1. [github参考](https://github.com/fanky-c/OcTest/blob/master/pThread/pThread/ViewController.m)\n\n#### NSThread\n1. 三种创建方式\n```\n//方式一\nNSThread *thread1 = [[NSThread alloc] initWithTarget: self selector:@selector(runThread1) object:nil];\n[thread1 setName:@\"name_thread1\"]; //在selector方法里面获取当前线程[NSThread currentThread].name;\n[thread1 setThreadPriority:0.5]; //优先级：0-1\n[thread1 start];\n\n\n//方式二\n[NSThread detachNewThreadSelector:@selector(runThread1) toTarget:self withObject:nil];\n\n\n//方式三\n//回到主线程：performSelectorOnMainThread\n[self performSelectorInBackground:@selector(runThread1) withObject:nil];\n```\n\n2. [github参考](https://github.com/fanky-c/OcTest/blob/master/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSThread/%E5%A4%9A%E7%BA%BF%E7%A8%8BNSThread/TicketMangager.m)\n\n#### GCD\n1. 介绍：\n   1. 类似前端的new worker(), 把耗时较长的任务交给子线程处理，主线程处理ui操作，任务完成worker.postMessage()告诉给主线程。\n2. 使用方式：   \n   1. 同步/异步、串行/并行\n   2. dispath_get_global_queue & dispatch_get_main_queue\n   3. dispatch_group_async\n   4. dispatch_once\n   5. dispatch_after\n\n\n2. [github参考](https://github.com/fanky-c/OcTest/blob/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B--GCD/%E5%A4%9A%E7%BA%BF%E7%A8%8B--GCD/ViewController.m)\n\n\n#### NSOperation\n\n1. 实现方式:\n   1. NSInvocationOperation & NSBlockOperation（同步阻塞）\n   2. 自定义类继承NSOperation\n2. 相关概念\n   1. NSOperationQueue（异步队列）\n      1. addOperation\n      2. setMaxConcurrentOperationCount\n   2.  状态\n      1. ready、 cancelled、 executing、 finished、 asynchronous\n   3. 依赖-- addDependency\n\n3. NSRunloop阻塞当然线程，让异步到达同步的效果。\n\n4. [github参考](https://github.com/fanky-c/OcTest/blob/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B--NSOperation/%E5%A4%9A%E7%BA%BF%E7%A8%8B--NSOperation/ViewController.m)  \n\n#### dispatch_semaphore（信号量）\n```\n- (NSInteger)methodSync {\n    __block NSInteger result = 0;\n    dispatch_semaphore_t sema = dispatch_semaphore_create(0);\n    [self methodAsync:^(NSInteger value) {\n        result = value;\n        dispatch_semaphore_signal(sema);\n    }];\n   // 这里本来同步方法会立即返回，但信号量=0使得线程阻塞\n   // 当异步方法回调之后，发送信号，信号量变为1，这里的阻塞将被解除，从而返回正确的结果\n    dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);\n    NSLog(@\"methodSync 结束 result:%ld\", (long)result);\n    return result;\n}\n```\n\n### 7: @property使用\n1. 使用方式\n```\n//test.h\n@property(nonatomic, readwrite, strong) NSString *test;\n\n//test.m\n@synthesize test;\n```\n\n2. 属性分类\n   1. **原子性**\n      1. atomic (默认、原子性) 只有一个线程访问实例，atmoic是线程安全的。\n      2. nonatomic (非原子性)， 可以被多个线程访问，效率比atomic高，但是不能保证在多线程的安全性。\n   2. **存取器控制**\n      1. readwrite (默认) 表示该属性同时拥有setter和getter。\n      2. readonly 表示只有getter没有setter。\n   3. **内存管理**\n      1. assign (默认) assign用于值类型，如int、float、double和NSInteger，CGFloat等表示单纯的复制。\n      2. strong strong是在IOS引入ARC的时候引入的关键字，是retain的一个可选的替代。表示实例变量对传入的对象要有所有权关系，即强引用。strong跟retain的意思相同并产生相同的代码，但是语意上更好更能体现对象的关系。\n      3. weak 在setter方法中，需要对传入的对象不进行引用计数加1的操作, 例如：IBOutlet、Delegate一般用的就是weak\n      4. copy 与strong类似，但区别在于实例变量是对传入对象的副本拥有所有权，而非对象本身","tags":["mac","xcode","oc","ios"]},{"title":"nginx","url":"/2018/11/14/nginx/","content":"\n### nginx常用操作\n\n#### 开启\n* 第一种方法  格式为： ngin地址 -c nginx配置文件位置\n* 例如：/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n\n#### 停止\n##### A:从容停止  需要知道进程号:\n* 1,查看nginx进程号命令为:ps -ef|grep nginx  只需要查看master的进程号\n* 2,停止命令 kill -QUIT  进程号\n\n##### B:强制停止\n* kill -9 进程号\n\n#### 配置文件校验\n* 步骤一：进入sbin目录  命令 cd /usr/local/nginx/sbin  步骤二： ./nginx -t\n* 或者 sudo /usr/local/nginx/sbin/nginx -t\n\n#### 重启\n* 步骤一：进入sbin目录  命令 cd /usr/local/nginx/sbin  步骤二：./nginx -s reload\n* 或者 sudo /usr/local/nginx/sbin/nginx -s reload \n\n\n### Nginx的web请求处理机制\nNginx结合多进程机制和异步机制对外提供服务，异步机制使用的是异步非阻塞方式。Nginx的master进程会生成多个worker进程，master进程负责管理这些worker进程的生命周期、接受外部命令、解析perl脚本等。而worker进程则用于接受和处理客户端请求。\n\n每个worker进程能够使用异步非阻塞方式处理多个客户端请求。当某个worker进程接收到客户端的请求后，会调用IO进程处理，如果不能立即得到结果，worker进程就去处理其他的请求。当IO返回结果后，就会通知worker进程，而worker进程得到通知后，就会挂起当前正在处理的事务，拿IO返回结果去响应客户端请求，worker进程采用的是epoll事件驱动模型与IO进行通信的。epoll模型底层采用的是“回调callback”代替里轮询，使效率高于select模型。\n### 正向代理和反向代理\n1. 正向代理： \n正向代理服务器是服务器的用户(客户端)架设的主机，与服务器无关，被访问的服务不知道用户真正的地址。 例如vpn访问\n2. 反向代理： \n反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址，用户不知道访问的服务真正的地址。 例如proxy_pass\n\n<img src=\"/img/ng1.png\" style=\"max-width:95%\" />\n\n\n### server_name 和 upstream 和 proxy_pass\n\n#### server_name\n ***1. 介绍***\n server name 为虚拟服务器（单一主机或主机群上运行多个网站或服务的技术）的识别路径。因此不同的域名会通过请求头中的HOST字段（http1.1以上支持），匹配到特定的server块，转发到对应的应用服务器中去。\n \n > 虚拟主机，就是将一台物理服务器虚拟为多个服务器来使用，从而实现在一台服务器上配置多个站点，即可以在一台物理主机上配置多个域名。Nginx中，一个server标签就是一台虚拟主机，配置多个server标签就虚拟出了多台主机。\n\n ***2. 使用***\n ```\nserver {\n\tlisten 80;\n\tserver_name www.123.com;\n\tlocation / {\n\t\tdefault_type text/html;\n\t\tcontent_by_lua '\n\t\t\tngx.say(\"<p>first</p>\")\n\t\t';\n\t}\n}\n \nserver {\n\tlisten  80;\n\tserver_name www.zkh.com;\n\tlocation / {\n\t\tdefault_type text/html;\n\t\tcontent_by_lua '\n\t\t\tngx.say(\"<p>second</p>\")\n\t\t';        \n\t}\n\n}  \n\n访问：www.123.com  --> first\n访问：www.zkh.com --> second\n\n ```\n\n#### upstream\n ***1. 介绍***\n   常用负载均衡：能够将客户端的请求均匀地分发到后台各个应用服务器上，从而缓解服务器压力；并且当服务器出现宕机或者扩容时，也能正常运行。\n\n ***2. 使用***\n```\nhttp {\n   upstream web {\n    server 192.168.1.128:9200;\n    server 192.168.1.128:3000;\n   }\n   server {\n        listen       80;\n        server_name  localhost;\n        location /\n        {\n            proxy_pass http://web;\n        }\n    ｝\n}\n```\n\n#### proxy_pass\n***1. 介绍***\n反向代理：proxy_pass说明是动态请求，需要进行转发，比如代理到nodejs、java上\n### location 匹配规则\n#### 1. url匹配规则\n```js\nlocation [=|~|~*|^~|@] /uri/ {\n\t...\n}\n```\n* =： 精确匹配后面的url\n* ~： 正则匹配，区分大小写\n* ~*：正则匹配，不区分大小写\n* ^~：普通字符匹配， 如果该选项匹配，只匹配该选项， 一般用来匹配目录\n* @： \"@\" 定义一个命名的 location，使用在内部定向时，例如 error_page\n\n#### 2. 匹配规则的优先顺序\n* = 前缀的指令严格匹配这个查询。 如果找到则停止搜索\n* 所有剩下的常规字符串，最长的匹配。 如果这个匹配使用^~前缀，搜索停止\n* 正则表达式， 在配置文件中定义的顺序\n* 如果第3条规则产生匹配的话，结果被使用。 否则，使用第2条规则的结果\n\n\n#### 3. alias 和 root 的区别\n##### 1. root: 实际访问文件路径会拼接URL中的路径\n```js\nlocation ^~ /tea/ {  \n   root /usr/local/nginx/html/;  \n}\n// 请求：http://test.com/tea/tea1.html\n// 实际访问：/usr/local/nginx/html/tea/tea1.html 文件\n```\n##### 2. alias: 实际访问文件路径不会拼接URL中的路径\n```js\nlocation ^~ /tea/ {  \n   alias /usr/local/nginx/html/;  \n}\n// 请求：http://test.com/tea/tea1.html\n// 实际访问：/usr/local/nginx/html/tea1.html 文件\n```\n\n### rewrite使用\n#### rewrite 介绍\n1. 从功能看 rewrite 和 location 似乎有点像，都能实现跳转，主要区别在于 rewrite是在同一域名内更改获取资源的路径，而 location 是对一类路径做控制访问或反向代理，还可以proxy_pass（代理转发）到其他机器。\n\n2. rewrite只能放在server{ }，location{ }，if{ }中，并且默认只能对域名后边的除去传递的参数外的字符串起作用\n\n3. 例如http：//www.benet.com/abc/bbs/index.php?a=1&b=2 只对 /abc/bbs/index.php 重写\n\n#### rewrite使用\n##### 1、语法 \nrewrite <regex> <replacement> [flag]\n\n**flag不同参数：**\n\nlast ∶本条规则匹配完成后，继续向下匹配新的location URL规则，一般用在 server和if中。\n\nbreak ∶本条规则匹配完成即终止，不再匹配后面的任何规则，一般使用在 location 中。\n\nredirect ∶返回302临时重定向，浏览器地址会显示跳转后的URL地址。\n\npermanent ∶返回301永久重定向，浏览器地址栏会显示跳转后的URL地址。\n\n\n##### 2、案例\n```sh\nlocation / {\n    # 顺序执行如下两条rewrite指令 \n    rewrite ^/test1 /test2;\n    rewrite ^/test2 /test3;  # 此处发起新一轮 location 匹配 URI为/test3\n}\n\nlocation / {\n    rewrite ^/test1 /test2;\n    rewrite ^/test2 /test3 last;  # 此处发起新一轮location匹配 uri为/test3\n    rewrite ^/test3 /test4;\n    proxy_pass http://www.baidu.com;\n}\n\n\nlocation / {\n    rewrite ^/test1 /test2;\n    # 此处不会发起新一轮location匹配；当是会终止执行后续rewrite模块指令重写后的 URI 为 /more/index.html\n    rewrite ^/test2 /more/index.html break;  \n    rewrite /more/index\\.html /test4; # 这条指令会被忽略\n\n    # 因为 proxy_pass 不是rewrite模块的指令 所以它不会被 break终止\n    proxy_pass https://www.baidu.com;\n}\n\n\n# 由于最后加了个 ?，原来的请求参数将不会被追加到 rewrite 之后的 URI 后面*\nrewrite ^/users/(.*)$ /show?user=$1? last;\n\n```\n\n\n","tags":["nginx","正向代理和反向代理","负载均衡"]},{"title":"electron 学习笔记","url":"/2018/11/12/electron-学习笔记/","content":"\n#### 主进程和渲染进程、渲染进程和渲染进程通讯。\n\n##### 主进程和渲染进程通讯。\n\n* 使用 IPC 是很方便的\n\n\n##### 渲染进程和渲染进程通讯。\n* 使用全局共享属性(globald对象和remote.getGlobal方法)。\n```\n// In the main process.\nglobal.sharedObject = {\n  someProperty: 'default value'\n}\n// In page 1.\nrequire('electron').remote.getGlobal('sharedObject').someProperty = 'new value'\n// In page 2.\nconsole.log(require('electron').remote.getGlobal('sharedObject').someProperty)\n```\n\n* 利用主进程做消息中转。\n```\n// In the main process.\nipcMain.on('ping-event', (event, arg) => {\n  yourWindow.webContents.send('pong-event', 'something');\n}\n\n// In renderer process\n// 1\nipcRenderer.send('ping-event', (event, arg) => {\n    // do something\n  }\n)\n\n// 2\nipcRenderer.on('pong-event', (event, arg) => {\n    // do something\n  }\n)\n```\n\n* 利用 remote 接口直接获取渲染进程发送消息：\n```\n\n```\n\n* ipcRenderer.sendTo接口。\n```\nipcRenderer.sendTo(windowId, 'ping', 'someThing')\n```","tags":["electron"]},{"title":"es6扩展运算符和剩余运算符，三个点...","url":"/2018/11/11/es6扩展运算符，三个点/","content":"\n### 含义\n\n扩展运算符用...表示，它好比rest参数的逆运算，讲一个数组转为用逗号分隔的参数序列。\n```\nconsole.log(...[1, 2, 3])\n// 1 2 3\nconsole.log(1, ...[2, 3, 4], 5)\n// 1 2 3 4 5\n[...document.querySelectorAll('div')]\n//[<div>,<div>]\n```\n### 用途\n\n#### 1，函数调参,将一个数组，变为参数序列。\n```\nfunction f(v, w, x, y, z) { }\nvar args = [0, 1];\nf(-1, ...args, 2, ...[3]);\n```\n\n另外当 ...args 作为函数参数时，它允许我们传递任意数量的参数，而不需要提前声明参数的数量\n```\nfunction f(...args){\n   console.log(args);\n}\n\nf(1,2,3); // [1, 2, 3]\nf(\"a\", \"b\", \"c\") // [\"a\", \"b\", \"c\"]\n```\n\n#### 2，替换数组和apply相关方法\n* 由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。\n* 取代apply用法一：\n```\n\n// ES5 的写法\nfunction f(x, y, z) {\n// ...\n}\nvar args = [0, 1, 2];\nf.apply(null, args);\n// ES6 的写法\nfunction f(x, y, z) {\n// ...\n}\nvar args = [0, 1, 2];\nf(...args);\n```\n* 取代apply，应用Math.max方法用法二：\n```\n// ES5 的写法\nMath.max.apply(null, [14, 3, 77])\n// ES6 的写法\nMath.max(...[14, 3, 77])\n//  等同于\nMath.max(14, 3, 77);\n```\n* 数组合并和添加尾部三：\n```\n// ES5\n[1, 2].concat(more)\n// ES6\n[1, 2, ...more]\nvar arr1 = ['a', 'b'];\nvar arr2 = ['c'];\nvar arr3 = ['d', 'e'];\n// ES5 的合并数组\narr1.concat(arr2, arr3);\n// [ 'a', 'b', 'c', 'd', 'e' ]\n// ES6 的合并数组\n[...arr1, ...arr2, ...arr3]\n// [ 'a', 'b', 'c', 'd', 'e' ]\n// ES5 的写法\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\nArray.prototype.push.apply(arr1, arr2);\n// ES6 的写法\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\narr1.push(...arr2);\n```\n\n#### 3，与解构赋值结合（只能放在最后）\n```\nconst [first, ...rest] = [1, 2, 3, 4, 5];\nfirst // 1\nrest // [2, 3, 4, 5]\nconst [...butLast, last] = [1, 2, 3, 4, 5];\n//  报错\nconst [first, ...middle, last] = [1, 2, 3, 4, 5];\n//  报错\n```\n\n#### 4，将字符串转为真正的数组\n```\n[...'hello']\n// [ \"h\", \"e\", \"l\", \"l\", \"o\" ]\n```\n\n#### 5,实现了 Iterator 接口的对象\n```\nvar nodeList = document.querySelectorAll('div');\nvar array = [...nodeList];\n```\n任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。\n\n\n```\nlet arrayLike = {\n'0': 'a',\n'1': 'b',\n'2': 'c',\nlength: 3\n};\n// TypeError: Cannot spread non-iterable object.\nlet arr = [...arrayLike];\n```\n对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组，但是可以使用Array.from方法将arrayLike转为真正的数组。\n\n\n[参考](https://blog.csdn.net/qq_30100043/article/details/53391308)\n\n[参考二](https://www.freecodecamp.org/chinese/news/three-dots-operator-in-javascript/)","tags":["es6","...","扩展运算符","剩余运算符"]},{"title":"react学习笔记","url":"/2018/10/24/react学习笔记/","content":"### 事件处理\n\n#### 1，注意事项\n* React事件绑定属性的命名采用驼峰式写法，而不是小写。\n* 如果是用jsx的语法需要穿一个函数作为事件处理函数，而不是一个字符串\n```js\n<button onClick={activateLasers}>\n  Activate Lasers\n</button>\n```\n* 在 React 中另一个不同是你不能使用返回 false 的方式阻止默认行为。你必须明确的使用 preventDefault。\n```js\nfunction ActionLink() {\n  function handleClick(e) {\n    e.preventDefault();\n    console.log('The link was clicked.');\n  }\n  return (\n    <a href=\"#\" onClick={handleClick}>\n      Click me\n    </a>\n  );\n}\n```\n* ES6 class语法定义组件，事件处理器会成为类的一个方法。\n```js\nclass Toggle extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {isToggleOn: true};\n    // This binding is necessary to make `this` work in the callback\n    this.handleClick = this.handleClick.bind(this);\n  }\n  handleClick() {\n    this.setState(prevState => ({\n      isToggleOn: !prevState.isToggleOn\n    }));\n  }\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        {this.state.isToggleOn ? 'ON' : 'OFF'}\n      </button>\n    );\n  }\n}\n```\n\n\n#### 2，向事件处理程序传递参数\n* 下面两种方式是等价的，分别通过 arrow functions 和 Function.prototype.bind 来为事件处理函数传递参数。\n```js\n<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>\n<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>\n```\n* 箭头函数必须显示传递e, bind方式要隐示传递\n* 通过bind 方式向监听函数传参，在类组件中定义的监听函数，事件对象 e 要排在所传递参数的后面\n```js\nclass Popper extends React.Component{\n    constructor(){\n        super();\n        this.state = {name:'Hello world!'};\n    }\n    preventPop(name, e){    //事件对象e要放在最后\n        e.preventDefault();\n        alert(name);\n    }   \n    render(){\n        return (\n            <div>\n                <p>hello</p>\n                {/* Pass params via bind() method. */}\n                <a href=\"https://reactjs.org\" onClick={this.preventPop.bind(this,this.state.name)}>Click</a>\n            </div>\n        );\n    }\n}\n```\n\n### Redux\n\n####  1, 介绍\n* Store\n* State\n* Action\n* Action Creator\n* store.dispatch()\n* Reducer\n* store.subscribe()\n\n####  2, 工作流程\n* 首先，用户发出 Action\n```js\nstore.dispatch(action);\n```\n* 然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。\n```js\nlet nextState = todoApp(previousState, action);\n```\n* State 一旦有变化，Store 就会调用监听函数。\n```js\nstore.subscribe(listener)\n```\n* 可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。\n```js\n  let newState = store.getState();\n  component.setState(newState);\n```\n参考[http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html]\n\n#### 3,组件拆分和react-redux、Provider、connect(连接器)\n* 在组件开发中，按职责我们可以划分：容器类组件、展示类组件，前者负责从state获取属性，后者负责渲染界面和自身的状态控制。\n* react-redux 为 React 组件和 Redux 提供的 state 提供了连接。当然可以直接在 React 中使用 Redux：在最外层容器组件中初始化 store，然后将 state 上的属性作为 props 层层传递下去。但是这样并是我们推荐的状态管理方式。\n```\nclass App extends Component{\n  componentWillMount(){\n    store.subscribe((state)=>this.setState(state))\n  }\n  render(){\n    return <Comp state={this.state}\n                 onIncrease={()=>store.dispatch(actions.increase())}\n                 onDecrease={()=>store.dispatch(actions.decrease())}/>\n  }\n}\n```\n* 我们推荐的方式是react-redux：1，内容组件最外层包裹Provider，将之前创建的store作为prop传给Provider。Provider接收redux的createStore()的结果，并且放到context里，让子组件可以通过context属性直接获取到这个createStore的结果。且返回一个与store连接后的容器组件。2，Provider内的任何一个组件，如果需要使用state中的数据，就必须是「被 connect 过的」组件——使用connect方法对当前内容组件包装后的产物，connect会返回一个与store连接后的新组件。3，connect会返回一个与store连接后的新组件。会接收到mapStateToProps，会在内部subscribe全局state的改变，来判断props是否更改，如果需要更新，才触发更新。\n\n```\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\nimport { bindActionCreators } from 'redux';\nimport * as dictActions from '../../actions/dict';\n\nclass DictPage extends Component {\n  constructor(props){\n    super(props);\n\n  }\n  componentWillMount(){\n     const { getDictsResult } = this.props;\n     getDictsResult({\n       q: 'good',\n       lang: 'en'\n     })\n  }\n  componentDidMount(){\n    const { dict } = this.props;\n  }\n  render() {\n    return (<div>xxxxx</div>);\n  }\n}\n//创建输入逻辑mapStateToProps,是store、state映射\nfunction mapStateToProps(state) {\n  return {\n    dict: state.dict.data.data\n  };\n}\n\n//输出逻辑mapDispatchToProps，是dispatch映射\nfunction mapDispatchToProps(dispatch) {\n  return bindActionCreators(dictActions, dispatch);\n}\n\n//把容器组件和ui组件结合导出\nexport default connect(mapStateToProps, mapDispatchToProps)(DictPage);\n```\n#### 参考例子\n* 时间旅行案例：https://www.ibm.com/developerworks/cn/web/wa-manage-state-with-redux-p4-david-geary/index.html\n\n### React-router(v4版本)\n\n#### 1， 包的选择\n* 浏览器用的router在react-router-dom里。所以浏览器里使用的时候只需要import react-router-dom就可以。react-router-native供React Native应用使用。\n\n#### 2，路由不在集中存放一起，可以和Ui组件放在一起，成为组件的一部分。\n\n#### 3，包含式路由与exact\n* 如匹配 path=\"/users\" 的路由会匹配 path=\"/\"的路由，在页面中这两个模块会同时进行渲染，所以就多了exact。\n\n#### 4，独立路由Switch\n* 采用Switch 只有一个路由会被渲染，并且总是渲染第一个匹配到的组件。\n\n#### 5，link\n* to（string / object）：要跳转的路径或地址；\n* replace ：为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址。反之不会替换记录，默认为false。\n* NavLink ：<NavLink>是<Link>的一个特定版本，会在匹配上当前URL的时候会给已经渲染的元素添加样式参数。\n\n#### 6，异步加载路由和模块\n* [参考](https://www.jianshu.com/p/ba3c295be412)\n\n#### 7, 手动控制路由的跳转\n* 使用 withRouter高阶组件，提供了history让你使用\n```\nimport React from \"react\";\nimport {withRouter} from \"react-router-dom\";\n\nclass MyComponent extends React.Component {\n  ...\n  myFunction() {\n    this.props.history.push(\"/some/Path\");\n  }\n  ...\n}\nconst MyComponent=withRouter(connect(mapStateToProps,mapDispatchToProps)(MyComponent))\nexport default MyComponent;\n```\n* 使用Context,在Router组件中通过Contex暴露了一个router对象。context增加了耦合难度尽量少用或者用在全局登录状态、颜色等等。\n```\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\n\nclass MyComponent extends React.Component {\n  static contextTypes = {\n    router: PropTypes.object\n  }\n  ...\n  myFunction() {\n    this.context.router.history.push(\"/some/Path\");\n  }\n  ...\n}\n```\n* 引入Redirect，重定向。\n\n* 引入react-router-redux库，操作redux，进行时间旅行调试。\n```\nimport React from \"react\";\nimport { push } from 'react-router-redux'\nimport PropTypes from \"prop-types\";\n\nclass MyComponent extends React.Component {\n  static contextTypes = {\n    store: PropTypes.object\n  }\n  ...\n  myFunction() {\n    this.context.store.dispatch(push('path'))\n  }\n  ...\n}\n```\n\n### constructor(super(props))\n#### constructor( )——构造方法\n* ES6对类的默认方法，new命令生成实例自动调用，如果没有显示定义会默认添加空的constructor方法。\n* es5没有继承写法，通过prototype来达到目的。\n```\n//构造函数People\n   function People (name,age){\n        this.name = name;\n        this.age = age\n    }\n    People.prototype.sayName = function(){\n        return '我的名字是：'+this.name;\n    }\n```\n* ES6中，可以通过class来实现\n```\nclass People{\n        //构造方法constructor就等于上面的构造函数People\n        constructor(name,age){\n            this.name = name;\n            this.age = age;\n        }\n\n        sayName(){\n            return '我的名字是：'+this.name;\n        }\n    }\n```\n#### super() -- 继承。\n* 子类是没有自己的this对象的，它只能继承自父类的this对象，然后对其进行加工，而super( )就是将父类中的this对象继承给子类的。没有super，子类就得不到this对象\n```\nclass People{\n        constructor(name,age){\n            this.name = name;\n            this.age = age;\n        }\n        sayName(){\n            return '我的名字是：'+this.name;\n        }\n    }\n\n    class har extends People{\n        constructor(name,age,sex){\n            super(name,age);//调用父类的constructor(name,age)\n            this.sex = sex;\n        }\n        haha(){\n            return this.sex + ' ' + super.sayName();//调用父类的sayName() \n        }\n    }\n``` \n####  es5 new\n* 1.生成一个空的对象并将其作为 this；\n* 2.将空对象的 __proto__ 指向构造函数的 prototype；\n* 3.运行该构造函数；\n* 4.如果构造函数没有 return 或者 return 一个返回 this 值是基本类型，则返回this；如果 return 一个引用类型，则返回这个引用类型。\n\n#### es5和es6继承机制区别\n* es5先创建子类的实例对象this，然后再将父类的方法添加到this上（ Parent.apply(this) ） \n* ES6采用的是先创建父类的实例this（故要先调用 super( )方法），完后再用子类的构造函数修改this\n\n### 学习文章参考\n* https://juejin.im/post/5b4de4496fb9a04fc226a7af","tags":["react","react-router","react-redux"]},{"title":"http/1.x和http/2","url":"/2018/09/05/http-1-x和http-2/","content":"### http/1.x\n\n#### 基本介绍\n\n##### A:请求报文\n  1. 请求⾏ \n  2. 请求头\n  3. 空行\n  4. 请求体\n\n![报文](/img/http_request.png)  \n![报文](/img/http_request1.png)  \n\n##### B:方法\n  1. get \n     * 从服务器获取文档\n     * 可以被缓存\n     * 通过url请求，有长度限制\n     * url明文请求，安全得不到保障\n     * 对服务器无副作用，多次操作不会改变服务器状态\n  2. post\n     * 向服务器发送所需处理的数据\n     * 不能被缓存\n     * 没有长度限制\n     * 请求放在主体，不会被记录下来，安全性相对来说得到保障\n     * 有副作用，即非幂等\n  3. head\n     * 从服务器获取文档头部\n  4. put\n     * 请求的主体存到服务器中\n  5. options\n     * 查词可以服务器上执行那些方法,检查服务器性能（跨域请求用的多）\n\n##### C:响应报文\n  1. 响应行\n  2. 响应头\n  3. 响应体  \n\n\n![报文](/img/http_respond.png)  \n![报文](/img/http_respond1.png)  \n\n##### D：状态码\n  1. 1xx 信息性状态\n  2. 2xx 成功\n     * 206：Partial Content 分块内容\n  3. 3xx 重定向\n     * 301: 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替\n     * 304: 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源\n  4. 4xx 客户端错误\n     * 400: Bad Request 常⻅于请求时提交了错误的参数\n     * 401：Unauthorized 需要验证\n     * 403：Forbidden 禁⽌访问\n     * 404：Not Found\n  5. 5xx 服务端错误\n     * 500：Server Error 服务器出错\n     * 502：Bad Gateway 通常由代理服务器返回，表示上游服务器出错\n     * 503：Service Unavailable 服务暂不可⽤，但将来可⽤（例如服务当前负载太⾼） \n     * 504：Gateway Timeout 通常由代理服务器返回，表示上游服务器超时\n\n\n#### 常用header\n  \n#### cookie机制\n* HTTP是⼀个匿名、⽆状态的协议，但很多情况下服务器需要识别客户端的身份\n* 识别身份的⽅法:\n  1. Authentication⾸部 + WWW-Authentication⾸部\n  2. 胖URL，在URL⾥带上身份信息\n  3. Cookie ⽬前识别⽤户，实现持久会话的最好⽅式\n* cookie本质上是⼀些key-value数据，key是cookie名字，value是cookie的值\n  1. domain和path: 指定了哪些域名和路径会带上该cookie\n  2. HttpOnly属性阻⽌了javascript来访问cookie，可以防⽌⼀些XSS攻击\n* 会话期Cookie: 浏览器关闭之后它会被⾃动删除\n* 持久性Cookie: 指定了cookie过期时间\n\n![cookie](/img/http_cookie.png) \n\n#### 连接机制\n##### 介绍\n* HTTP使⽤TCP来传输数据，HTTP/1.0每个请求都新开⼀个连接，效率低下。\n  1. TCP握⼿导致⽐较⻓的延时\n  2. TCP拥塞控制算法在慢启动阶段带宽较⼩\n* HTTP/1.1默认使⽤⻓连接，即⼀个连接会保持⼀段时间，⽤于发送⼀系列的请求\n* 管道化请求：不等待前⼀个请求返回就在同⼀个连接发送下⼀个请求（⽬前都没实现）\n* 相关⾸部：Connection （客户端和服务端都使⽤）\n  1. Connection: keep-alive 在当前请求完成后，保持连接\n  2. Connection: close 在当前请求完成后，关闭连接\n\n##### HTTP/1.x 三种连接⽅式\n![三种连接⽅式](/img/http_live.png) \n\n#### 缓存\n\n##### 缓存存储策略\n1. cache-control\b:  public, max-age=31536000。响应数据会被缓存到客户端\n\n##### 缓存过期策略\n1. expires\n  * 表示存在时间，允许客户端在这个时间之前不去检查（发请求），等同max-age的\n效果。但是如果同时存在，则被Cache-Control的max-age覆盖\n\n##### 缓存对比策略\n1. last-modified:  Fri, 25 Nov 2016 08:15:46 GMT。 资源被修改的最后时间\n   * 浏览器会携带该值去服务器对比，对比成功在返回304，服务器提示浏览器从本地加载数据，否则返回200并响应数据。\n2. eTag:  \"Fpwrobxxh6n6-E2sDbMMA2znbN1i\"\n   * 对资源的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的，是资源的唯一标识\n\n#### HTTP 1.x 缺点\n* Head Of Line Blocking 队头阻塞\n  1. HTTP/1.1实际上没实现pipelining，⼀条连接同时只能进⾏⼀个HTTP请求，若该请求的响应很慢，则后续使⽤该连接的HTTP请求都被阻塞\n* ⾸部数据冗余：发往同⼀server的多个请求的Header重复发送\n  1. gzip只会压缩实体数据\n* 客户端请求-服务端响应模型（缺少服务端推送）  \n\n### http/2\n\n#### 连接复用\n* 多个请求和响应复⽤同⼀连接\n  1. 解决了HTTP/1.1中的队头阻塞问题\n  2. 基于新的⼆进制分帧层，客户端和服务端可以将多个HTTP消息分解为互不依赖的帧，交错发送，最后重新组装\n  3. 连接复⽤解决了HTTP/1.x存在的队头阻塞问题，减少连接数，更好利⽤了⽹络带宽（⻓连接避免了TCP拥塞控制的影响）\n\n#### 首部压缩\n* 压缩HTTP⾸部字段\n  1. 减少⾸部的传输开销\n  2. 每个HTTP传输都包含⼀系列⾸部，在HTTP/1.x中这些⾸部始终以纯⽂本形式传输，并且多个连接的⾸部都是重复的，例如User-Agent, Host，Cookie等。这些⾸部会给传输带上额外的开销，可能多达1kb\n  3. HTTP/2使⽤⼀种叫HPACK的⽅法来压缩⾸部数据\n\n#### 服务器推送\n* 服务端可以对⼀个客户端请求发送多个响应\n* 客户端可以限制服务端推送的数据量或停⽤服务端推\n\n** 注意：**\n1. HTTP/2 没有改动 HTTP 的应⽤语义。HTTP ⽅法、状态代码、URI 和标头字段等\n核⼼概念与HTTP/1.x⼀致，HTTP/2 修改了数据格式化（分帧）以及在客户端与服\n务器间传输的⽅式\n\n2. 因为引⼊新的⼆进制分帧层，HTTP/2⽆法向后兼容HTTP/1.x\n\n***参考我的同事java大神郎哥的非常感谢他。 ***","tags":["http","缓存"]},{"title":"css相对单位","url":"/2018/08/26/css相对单位/","content":"\n#### css无单位和line-height\n\n##### css无单位\n有一些属性可以接收不带单位的数值（意思就是一个不带长度单位的数字），如line-height、z-index和font-weight（700等于bold，400等于normal，如此类推）。你也可以在需要长度单位的地方（如px、em、rem）使用一个不带单位的0，因为长度已经是0了，带不带单位也无所谓了 —— 0px 等于 0% 等于 0em。\n\n***不带单位的0只可以表示长度单位和百分比的值，譬如padding、border和width。而对于一些特殊的情况，如度数（degrees）或者像秒这样基于时间的值（time-based values），是不可以使用不带单位的0的。*** \n\n\n\n##### line-height\nline-height属性最特别的地方，在于同时支持带单位和不带单位的值。你应该保持使用不带单位的数值，因为这样就可以从父元素继承。\n\n**浏览器默认的行高取决于用户代理。桌面浏览器（包括火狐浏览器）使用默认值，约为1.2，这取决于元素的font-family** \n\n代码案例：\n\n\n父级元素：line-height:150%;font-size:16px;\n\n\n子元素：  font-size:30px;\n\n* 单位是px（12px): 继承父元素行高12px。\n\n* 单位是% (150% * 16px浏览器默认字体大小)：字元素的行高等于16px * 150% = 24px。\n\n* 单位 （1.5em)：字元素的行高等于16px * 150% = 24px。\n\n* 无单位  (1.5)：字元素的行高等于30px * 150% = 45px。\n\n****总结：有单位时，子元素继承了父元素计算得出的行距；无单位时继承了系数，子元素会分别计算各自行距（推荐使用）。****\n\n\n#### 参考：\n* https://mp.weixin.qq.com/s/ilkmqnwVvPLjiVfEyNadHg\n* https://www.zhihu.com/question/20394889\n","tags":["css","line-height","样式无单位"]},{"title":"js异步","url":"/2018/08/12/js异步/","content":"\n### js异步使用方法：\n\n#### setTimeout/setInterval\n\n###### setTimeout\n\n```js\nfunction fn2 (f) {\n  setTimeout(() => {\n    console.log('Function 2')\n    f()\n  }, 500)\n}\n \nfn2(fn3)\n```\n\n\n#### 事件发布/订阅\n\n##### AsyncFunArr（异步函数数组）\n\n```js\nclass AsyncFunArr {\n  constructor (...arr) {\n    this.funcArr = [...arr]\n  }\n \n  next () {\n    const fn = this.funcArr.shift(); //返回头部删除第一个元素 \n    if (typeof fn === 'function') fn()\n  }\n \n  run () {\n    this.next()\n  }\n}\n \nconst asyncFunArr = new AsyncFunArr(fn1, fn2, fn3);\n\nasyncFunArr.run()/asyncFunArr.next(); //执行\n\n\n//队列方法\nfunction fn1 () {\n  console.log('Function 1')\n  asyncFunArr.next()\n}\n \nfunction fn2 () {\n  setTimeout(() => {\n    console.log('Function 2')\n    asyncFunArr.next()\n  }, 500)\n}\n \nfunction fn3 () {\n  console.log('Function 3')\n  asyncFunArr.next()\n}\n```\n\n#### Promise\n\n##### Promise概念：\nPromise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象。\n\n一个 Promise有以下几种状态:\n* pending: 初始状态，既不是成功，也不是失败状态。\n* fulfilled: 意味着操作成功完成。\n* rejected: 意味着操作失败。\n\n##### Promise方法：\n* Promise.all(iterable)==>这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败\n```js\nvar p1 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 500, 'P1');\n});\nvar p2 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 600, 'P2');\n});\n// 同时执行p1和p2，并在它们都完成后执行then:\nPromise.all([p1, p2]).then(function (results) {\n    console.log(results); // 获得一个Array: ['P1', 'P2']\n});\n```\n* Promise.race(iterable)==>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象\n```js\nvar p1 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 500, 'P1');\n});\nvar p2 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 600, 'P2');\n});\nPromise.race([p1, p2]).then(function (result) {\n    console.log(result); // 'P1' P1比P2先返回，然后就丢弃p2\n});\n```\n* Promise.reject(reason)==>返回一个状态为失败的Promise对象\n\n* Promise.resolve(value)==>返回一个状态由给定value决定的Promise对象\n\n##### Promise原型方法：\n* Promise.prototype.catch(onRejected)==>添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的promise\n\n* Promise.prototype.then(onFulfilled, onRejected)==>添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来resolve.\n```js\njob1.then(job2).then(job3).catch(handleError); //job1、job2和job3都是Promise对象。\n```\n\n* Promise.prototype.finally(onFinally)==>添加一个事件处理回调于当前promise对象，并且在原promise对象解析完毕后，返回一个新的promise对象。回调会在当前promise运行完毕后被调用，无论当前promise的状态是完成(fulfilled)还是失败(rejected)\n\n\n\n\n#### async/await\n\n##### async \n* 它作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为async就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行。\n* async 函数返回的是一个promise 对象，如果要获取到promise 返回值，我们应该用then方法。\n```js\nasync function timeout() {\n    return 'hello world'\n}\ntimeout().then(result => {\n    console.log(result);\n})\nconsole.log('虽然在后面，但是我先执行');\n```\n\n##### await\n* await是等待的意思，那么它等待什么呢，它后面跟着什么呢？其实它后面可以放任何表达式，不过我们更多的是放一个返回promise 对象的表达式。注意await 关键字只能放到async 函数里面。\n```js\n// 2s 之后返回双倍的值\nfunction doubleAfter2seconds(num) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve(2 * num)\n        }, 2000);\n    } )\n}\n\n//2s秒 输出 2 * 30\nasync function testResult() {\n    let result = await doubleAfter2seconds(30);\n    console.log(result);\n}\n\n//6s 输出 2 * 110\nasync function testResult() {\n    let first = await doubleAfter2seconds(30);\n    let second = await doubleAfter2seconds(50);\n    let third = await doubleAfter2seconds(30);\n    console.log(first + second + third);\n}\n```\n","tags":["异步","settimeout","Promise","async await"]},{"title":"js排序算法","url":"/2018/07/16/js排序算法/","content":"\n### 排序算法维度对比\n\n* 稳定。 如果a原本在b前面，而a=b，排序之后a仍然在b的前面；反之则不稳定\n* 时间复杂度。 运行完一个程序所需时间的长久\n* 空间复杂度。 运行完一个程序所需内存的大小\n\n排序对比：\n![排序对比](/img/sort1.webp)\n\n排序分类：\n![排序分类](/img/sort2.webp)\n\n### 冒泡排序\n\n#### 介绍\n冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n\n#### 算法描述\n<1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；\n<2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\n<3>.针对所有的元素重复以上的步骤，除了最后一个；\n<4>.重复步骤1~3，直到排序完成。\n\n#### 动态展示\n<img src=\"//www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif\" max-width=\"95%\">\n\n#### 代码实现\n```js\nfunction bubbleSort(arr) {\n    var len = arr.length;\n    for (var i = 0; i < len; i++) {\n        for (var j = 0; j < len - 1 - i; j++) {\n            if (arr[j] > arr[j+1]) {        //相邻元素两两对比\n                var temp = arr[j+1];        //元素交换\n                arr[j+1] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    return arr;\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n```\n\n#### 改进后方案\n\n改进冒泡排序原理： 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。\n\n```js\nfunction bubbleSort2(arr) {\n    console.time('改进后冒泡排序耗时');\n    var i = arr.length-1;  //初始时,最后位置保持不变\n    while ( i> 0) {\n        var pos= 0; //每趟开始时,无记录交换\n        for (var j= 0; j< i; j++)\n            if (arr[j]> arr[j+1]) {\n                pos= j; //记录交换的位置\n                var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp;\n            }\n        i= pos; //为下一趟排序作准备\n     }\n     console.timeEnd('改进后冒泡排序耗时');\n     return arr;\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(bubbleSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n```\n\n### 选择排序\n\n#### 介绍\n选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n\n#### 算法描述\n<1>. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。\n<2>. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n<3>. 重复第二步，直到所有元素均排序完毕。\n\n#### 动态展示\n<img src=\"//www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif\" max-width=\"95%\">\n\n#### 代码实现\n```js\nfunction selectionSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n    console.time('选择排序耗时');\n    for (var i = 0; i < len - 1; i++) {\n        minIndex = i;\n        for (var j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) {     //寻找最小的数\n                minIndex = j;                 //将最小数的索引保存\n            }\n        }\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n    console.timeEnd('选择排序耗时');\n    return arr;\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n```\n\n\n### 插入排序\n\n#### 介绍\n插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\n\n\n#### 算法实现\n\n<1>.从第一个元素开始，该元素可以认为已经被排序；\n<2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；\n<3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；\n<4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\n<5>.将新元素插入到该位置后；\n<6>.重复步骤2~5。\n\n#### 动态展示\n<img src=\"//www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif\" max-width=\"95%\">\n\n#### 代码实现\n```js\nfunction insertionSort(array) {\n    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') {\n        console.time('插入排序耗时：');\n        for (var i = 1; i < array.length; i++) {\n            var key = array[i];\n            var j = i - 1;\n            while (j >= 0 && array[j] > key) {\n                array[j + 1] = array[j];\n                j--;\n            }\n            array[j + 1] = key;\n        }\n        console.timeEnd('插入排序耗时：');\n        return array;\n    } else {\n        return 'array is not an Array!';\n    }\n}\n```\n\n#### 改进二分查找方案\n```js\nfunction binaryInsertionSort(array) {\n    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') {\n        console.time('二分插入排序耗时：');\n\n        for (var i = 1; i < array.length; i++) {\n            var key = array[i], left = 0, right = i - 1;\n            while (left <= right) {\n                var middle = parseInt((left + right) / 2);\n                if (key < array[middle]) {\n                    right = middle - 1;\n                } else {\n                    left = middle + 1;\n                }\n            }\n            for (var j = i - 1; j >= left; j--) {\n                array[j + 1] = array[j];\n            }\n            array[left] = key;\n        }\n        console.timeEnd('二分插入排序耗时：');\n\n        return array;\n    } else {\n        return 'array is not an Array!';\n    }\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n```\n\n### 快速排序\n\n#### 介绍\n快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。\n\n\n#### 算法实现\n快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：\n<1>.从数列中挑出一个元素，称为 \"基准\"（pivot）；\n<2>.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n<3>.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n#### 动态展示\n<img src=\"//www.runoob.com/wp-content/uploads/2019/03/quickSort.gif\" max-width=\"95%\">\n\n#### 代码实现\n```js\n/*方法说明：快速排序\n@param  array 待排序数组*/\n//方法一\nfunction quickSort(array, left, right) {\n    console.time('1.快速排序耗时');\n    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array' && typeof left === 'number' && typeof right === 'number') {\n        if (left < right) {\n            var x = array[right], i = left - 1, temp;\n            for (var j = left; j <= right; j++) {\n                if (array[j] <= x) {\n                    i++;\n                    temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n            quickSort(array, left, i - 1);\n            quickSort(array, i + 1, right);\n        }\n        console.timeEnd('1.快速排序耗时');\n        return array;\n    } else {\n        return 'array is not an Array or left or right is not a number!';\n    }\n}\n\n//方法二\nvar quickSort2 = function(arr) {\n    console.time('2.快速排序耗时');\n　　if (arr.length <= 1) { return arr; }\n　　var pivotIndex = Math.floor(arr.length / 2);\n　　var pivot = arr.splice(pivotIndex, 1)[0];\n　　var left = [];\n　　var right = [];\n　　for (var i = 0; i < arr.length; i++){\n　　　　if (arr[i] < pivot) {\n　　　　　　left.push(arr[i]);\n　　　　} else {\n　　　　　　right.push(arr[i]);\n　　　　}\n　　}\nconsole.timeEnd('2.快速排序耗时');\n　　return quickSort2(left).concat([pivot], quickSort2(right));\n};\n\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(quickSort(arr,0,arr.length-1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\nconsole.log(quickSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n```\n\n\n\n#### 算法实例\n\n### 查找两个字符串的最长公共子串\n```js\nfunction findSubStr(arr1, arr2) {\n  var sstr = '';\n  var L1 = arr1.length;\n  var L2 = arr2.length;\n  if (L1 > L2) {\n    var temp = arr1;\n    arr1 = arr2;\n    arr2 = temp;\n    L1 = arr2.length;\n  }\n  for (var j = L1; j > 0; j--)\n    for (var i = 0; i <= L1 - j; i++) {\n      sstr = arr1.substr(i, j);\n      if (arr2.indexOf(sstr) >= 0){\n        return sstr;\n      }\n    }\n  return '';\n}\n\n\nfunction findMaxSubstr(str1, str2){\n   var shorter = str1;\n   var longer = str2;\n   //判断长短\n   if(str1.length > str2.length){\n       shorter = str2;\n       longer = str1;\n   }else{\n       shorter = str1;\n       longer = str2;\n   }\n\n   //判断\n   for(var subLength=shorter.length; subLength>0; subLength--){\n       for(var i=0; i<=shorter.length-subLength; i++){\n           var subString = shorter.substring(i,i+subLength);\n           if(longer.indexOf(subString) >= 0){\n               var targetString = subString;\n               return targetString;\n           }\n       }\n   }\n}\n\n```\n\n\n### 统计一个字符串出现频率最高的字母/数字\n\n```js\nconst getMaxChar = str => {\n  let string = [...str];\n  let maxValue = '';\n  let obj = {};\n  let max = 0;\n\n  string.forEach(value => {\n    obj[value] = obj[value] == undefined ? 1 : obj[value] + 1\n    if (obj[value] > max) {\n      max = obj[value]\n      maxValue = value\n    }\n  })\n  return maxValue;\n}\n```\n\n### 颠倒字符串\n```js\nfunction reverseBySeparator(str) {\n  return str.split('').reverse().join('');\n}\n```\n\n\n### 判断大括号是否闭合\n```js\nfunction isBalanced(expression) {\n  var checkString = expression;\n  var stack = [];\n\n  // If empty, parentheses are technically balanced\n  if (checkString.length <= 0) return true;\n\n  for (var i = 0; i < checkString.length; i++) {\n    if(checkString[i] === '{') {\n      stack.push(checkString[i]);\n    } else if (checkString[i] === '}') {\n      // Pop on an empty array is undefined\n      if (stack.length > 0) {\n        stack.pop();\n      } else {\n        return false;\n      }\n    }\n  }\n\n  // If the array is not empty, it is not balanced\n  if (stack.pop()) return false;\n  return true;\n}\nisBalanced('{}{')\n```\n<br />\n来源于1：https://juejin.im/post/57dcd394a22b9d00610c5ec8\n来源于2：https://www.runoob.com/w3cnote/ten-sorting-algorithm.html\n","tags":["排序算法","常用算法"]},{"title":"vue源码分析下","url":"/2018/07/11/vue源码分析下/","content":"\n\n## 1，响应对象\n\n* Object.defineProperty\n\n```js\nObject.defineProperty(obj, prop, descriptor)\n```\n*重点是descriptor，有很多可选值但是我们关心的是set/get，get 是一个给属性提供的 getter 方法，当我们访问了该属性的时候会触发 getter 方法；set 是一个给属性提供的 setter 方法，当我们对该属性做修改的时候会触发 setter 方法。*\n\n* initState\n\n*在 Vue 的初始化阶段，_init 方法执行的时候，会执行 initState(vm) 方法，它的定义在 src/core/instance/state.js 中。*\n\n```js\nexport function initState (vm: Component) {\n  vm._watchers = []\n  const opts = vm.$options\n  if (opts.props) initProps(vm, opts.props)\n  if (opts.methods) initMethods(vm, opts.methods)\n  if (opts.data) {\n    initData(vm)\n  } else {\n    observe(vm._data = {}, true /* asRootData */)\n  }\n  if (opts.computed) initComputed(vm, opts.computed)\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch)\n  }\n}\n```\n\ninitState 方法主要是对 props、methods、data、computed 和 wathcer 等属性做了初始化操作。\n\n* proxy\n\n*首先介绍一下代理，代理的作用是把 props 和 data 上的属性代理到 vm 实例上，这也就是为什么比如我们定义了如下 props，却可以通过 vm 实例访问到它。*\n\n```js\nconst sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n}\n\nexport function proxy (target: Object, sourceKey: string, key: string) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  }\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition)\n}\n```\nproxy 方法的实现很简单，通过 Object.defineProperty 把 target[sourceKey][key] 的读写变成了对 target[key] 的读写。所以对于 props 而言，对 vm._props.xxx 的读写变成了 vm.xxx 的读写，而对于 vm._props.xxx 我们可以访问到定义在 props 中的属性，所以我们就可以通过 vm.xxx 访问到定义在 props 中的 xxx 属性了。同理，对于 data 而言，对 vm._data.xxxx 的读写变成了对 vm.xxxx 的读写，而对于 vm._data.xxxx 我们可以访问到定义在 data 函数返回对象中的属性，所以我们就可以通过 vm.xxxx 访问到定义在 data 函数返回对象中的 xxxx 属性了。\n\n\n* Observer\n\nObserver 是一个类，它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新\n\n\n* defineReactive\n\ndefineReactive 的功能就是定义一个响应式对象，给对象动态添加 getter 和 setter，它的定义在 src/core/observer/index.js 中：\n```js\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: ?Function,\n  shallow?: boolean\n) {\n  const dep = new Dep()\n\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  const getter = property && property.get\n  const setter = property && property.set\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key]\n  }\n\n  let childOb = !shallow && observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n        dep.depend()\n        if (childOb) {\n          childOb.dep.depend()\n          if (Array.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      const value = getter ? getter.call(obj) : val\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter()\n      }\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      childOb = !shallow && observe(newVal)\n      dep.notify()\n    }\n  })\n}\n```\ndefineReactive 函数最开始初始化 Dep 对象的实例，接着拿到 obj 的属性描述符，然后对子对象递归调用 observe 方法，这样就保证了无论 obj 的结构多复杂，它的所有子属性也能变成响应式的对象，这样我们访问或修改 obj 中一个嵌套较深的属性，也能触发 getter 和 setter。最后利用 Object.defineProperty 去给 obj 的属性 key 添加 getter 和 setter。\n\n\n#### 总结\n\n这一节我们介绍了响应式对象，核心就是利用 Object.defineProperty 给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新\n\n\n## 2，依赖收集\n\n\n## 3，派发更新\n\n\n## 4，nextTick\n\n### js运行机制：\n\nJS 执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤：\n\n（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。\n\n（2）主线程之外，还存在一个\"任务队列\"（task queue）。只要异步任务有了运行结果，就在\"任务队列\"之中放置一个事件。\n\n（3）一旦\"执行栈\"中的所有同步任务执行完毕，系统就会读取\"任务队列\"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n\n（4）主线程不断重复上面的第三步。\n\n主线程的执行过程就是一个 tick，而所有的异步结果都是通过 “任务队列” 来调度被调度。 消息队列中存放的是一个个的任务（task）。 规范中规定 task 分为两大类，分别是 macro task 和 micro task，并且每个 macro task 结束后，都要清空所有的 micro task。\n\n关于 macro task 和 micro task 的概念，这里不会细讲，简单通过一段代码演示他们的执行顺序：\n\n```js\nfor (macroTask of macroTaskQueue) {\n    // 1. Handle current MACRO-TASK\n    handleMacroTask();\n      \n    // 2. Handle all MICRO-TASK\n    for (microTask of microTaskQueue) {\n        handleMicroTask(microTask);\n    }\n}\n```\n在浏览器环境中，常见的 macro task 有 setTimeout、MessageChannel、postMessage、setImmediate；常见的 micro task 有 MutationObsever 和 Promise.then。\n\nvue的nextTick源码存放在src/core/util/next-tick.js（2.5+）\n\n## 5，计算属性(computed)和侦听属性(watch)\n\n\n*计算属性本质上是 computed watcher，而侦听属性本质上是 user watcher。就应用场景而言，计算属性适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。*\n\n\n## 6，组件更新 \n\n*原理图：*\n![原理图](/img/reactive.png)","tags":["vue","数据处理和双向绑定"]},{"title":"vue源码分析中","url":"/2018/07/09/vue源码分析中/","content":"\n### Virtual DOM 产生背景\n\nVirtual DOM 这个概念相信大部分人都不会陌生，它产生的前提是浏览器中的 DOM 是很“昂贵\"的，为了更直观的感受，我们可以简单的把一个简单的 div 元素的属性都打印出来，如图所示：\n![DOM元素](/img/dom.png)\n\n而 Virtual DOM 就是用一个原生的 JS 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多。在 Vue.js 中，Virtual DOM 是用 VNode 这么一个 Class 去描述，它是定义在 src/core/vdom/vnode.js 中的*（源码结构目录在上篇文章已经谈到）*。\n\n### 为什么Virtual DOM 更有好？\n* 首先参考尤雨溪[网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？](https://www.zhihu.com/question/31809713)\n* 如果没有 Virtual DOM，简单来想就是直接重置innerHTML。很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作... 真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。\n* 对innerHTML和Virtual进行对比:\n\t1，innerHTML: render html string O(template size) + 重新创建所有 DOM 元素 O(DOM size)\n\t2，Virtual  : render Virtual DOM + diff O(template size) + 必要的 DOM 更新 O(DOM change)\n\n显然Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。可以看到，innerHTML 的总计算量不管是 js 计算还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 的计算量里面，只有 js 计算和界面大小相关，DOM 操作是和数据的变动量相关的。前面说了，和 DOM 操作比起来，js 计算是极其便宜的。这才是为什么要有 Virtual DOM：它保证了: \n- 1）不管你的数据变化多少，每次重绘的性能都可以接受；\n- 2) 你依然可以用类似 innerHTML 的思路去写你的应用…\t\n\n\n### Virtual DOM到底是什么东西？\n* 首先和dom没啥关系，类似java和javascript关系\n* 它是一个数据结构，具体表现为有序的二叉树\n* 在javascript中，它表现为Object对象\n* 在UI映射方面，virtual Dom的对象节点跟DOM Tree每个位置属性一一对应\n* Virtual DOM是DOM Tree某一时刻的快照\n\n### Virtual DOM功能拆分\n* 生产虚拟dom对象的方法\n* 虚拟dom转化为真实dom的方法\n* 解析模板节点方法\n* 更新虚拟dom新旧节点方法\n* 对比虚拟dom新旧节点方法\n\n### Virtual DOM 在vue体现\n其实 VNode 是对真实 DOM \n的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其它属性都是都是用来扩展 VNode 的灵活性以及实现一些特殊 feature 的。由于 VNode 只是用来映射到真实 DOM 的渲染，不需要包含操作 DOM 的方法，因此它是非常轻量和简单的。\n\nVirtual DOM 除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。那么在 Vue.js 中，VNode 的 create 是通过之前提到的 createElement 方法创建的，我们接下来分析这部分的实现。[具体参考](https://ustbhuangyi.github.io/vue-analysis/data-driven/virtual-dom.html#%E6%80%BB%E7%BB%93)\n\n### createElement\nvue.js利用createElement来创建VNode,它存放在src/core/vdom/create-element.js文件中\n```js\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nexport function createElement (\n  context: Component,\n  tag: any,\n  data: any,\n  children: any,\n  normalizationType: any,\n  alwaysNormalize: boolean\n): VNode | Array<VNode> {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children\n    children = data\n    data = undefined\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n```\ncreateElement 方法实际上是对 _createElement 方法的封装，它允许传入的参数更加灵活，在处理这些参数后，调用真正创建 VNode 的函数是下面的_createElement\n```js\nexport function _createElement (\n  context: Component,\n  tag?: string | Class<Component> | Function | Object,\n  data?: VNodeData,\n  children?: any,\n  normalizationType?: number\n): VNode | Array<VNode> {\n  if (isDef(data) && isDef((data: any).__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\\n` +\n      'Always create fresh vnode data objects in each render!',\n      context\n    )\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if (process.env.NODE_ENV !== 'production' &&\n    isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n  ) {\n    if (!__WEEX__ || !('@binding' in data.key)) {\n      warn(\n        'Avoid using non-primitive value as key, ' +\n        'use string/number value instead.',\n        context\n      )\n    }\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {}\n    data.scopedSlots = { default: children[0] }\n    children.length = 0\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children)\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children)\n  }\n  let vnode, ns\n  if (typeof tag === 'string') {\n    let Ctor\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      )\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag)\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      )\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children)\n  }\n  if (Array.isArray(vnode)) {\n    return vnode\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) applyNS(vnode, ns)\n    if (isDef(data)) registerDeepBindings(data)\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n```\n\n\n*那么至此，我们大致了解了 createElement 创建 VNode 的过程，每个 VNode 有 children，children 每个元素也是一个 VNode，这样就形成了一个 VNode Tree，它很好的描述了我们的 DOM Tree。*\n\n\n### update\n\nVue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。_update 方法的作用是把 VNode 渲染成真实的 DOM，它的定义在 src/core/instance/lifecycle.js 中\n\n\n\n\n## 总结\n\n那么至此我们从主线上把模板和数据如何渲染成最终的 DOM 的过程分析完毕了，我们可以通过下图更直观地看到从初始化 Vue 到最终渲染的整个过程。\n![渲染真正的dom流程图](/img/virtualDom.png)\n\n\n","tags":["vue","虚拟 DOM","Virtual DOM"]},{"title":"vue源码分析上","url":"/2018/07/08/vue源码分析上/","content":"\n\n## 概论\n\n本文主要讲vue源码分析 -- **模板编译**\n\n*以v2.5.16版本为分析例子(https://github.com/vuejs/vue/tree/v2.5.16)*\n\n### vue的核心可以分为四个大块\n\n- 数据处理和双向绑定\n- 模板编译\n- 虚拟DOM\n- 组件化\n\n\n### vue的源码目录\n\n* circleci：是一个持续集成与部署服务。vue使用了这个服务来部署项目，该文件夹下为circleci部署所需的配置文件\nbenchmarks：这个文件夹里面，都是作者对于vue的性能测试。其中在性能测试代码中，有一个api大家可以关注下，window.performance.now()，该api经常在衡量代码运行时间，运行效率时被用到\n\n* example： 相当于vue的使用说明，里面都是尤大写的vue使用的小demo\n\n* flow: flow是一个用来进行静态类型检查的工具。它的作用是让现有的JavaScript语法可以事先作类型的声明(定义)，然后在开发过程中去进行自动检查。vue使用了该工具。该文件夹中，都是作者定义的静态类型。\n\n* test： 测试用例\n\n* src:  vue的所有重要代码，都写在了这里面。详细说一下其下的各个文件夹。\n  - compiler：模板解析模板编译的相关代码，也是本次组会要跟大家进行解读的部分\n  - core \n    * components： 全局组件定义的代码\n    * global-api： 添加在vue对象上的方法。比如Vue.use，Vue.enxtend等\n    * instance： vue实例相关的内容，比如生命周期，事件等。\n    * observer： vue双向绑定部分的代码\n    * vdom： 虚拟dom相关的代码\n    * util： vue的工具方法 \n  - platforms：一个是web平台，我们常用的就是这个。一个是weex平台，weex是一个用于开发原生应用的框架，也可以把它视作vue-native。  \n  - server：服务端渲染的相关代码。  \n  - shared： vue共享的工具和方法。        \n  - sfc： .vue 文件解析 \n\n\n### 模板编译代码解读 \n\n```js\nexport const createCompiler = createCompilerCreator(function baseCompile(\n  template: string,\n  options: CompilerOptions\n): CompiledResult {\n  const ast = parse(template.trim(), options)\n  if (options.optimize !== false) {\n    optimize(ast, options)\n  }\n  const code = generate(ast, options)\n  return {\n    ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n})\n``` \nvue模板编译的三个重要阶段都在上面的baseCompile函数中，这三个阶段分别是：\n* 生成AST\n* 优化静态内容\n* 生成render。\n\n\n\n#### a，生成AST\n\n*AST简介*\n\nAST即抽象语法树，我们的代码运行在浏览器的时候，浏览器首先就会把我们的代码解析为AST然后再进一步把语法树转化为字节码或者直接生成机器码。所以他对于浏览器很重要，同样的对于开发者来说，AST也很重要，我们通过ast可以精准定位到代码的任何地方，从而可以对代码进行一系列操作。比如代码的语法检查，压缩以及代码结构的改变等等。webpack、UglifyJS等工具的核心都是通过ast来操作代码的。语法树记录了其对应代码的所有信息。\n\n\n*JavaScript Parser*\n\n代码解析成AST，是通过js Parser来实现的，不同的parser，生成的AST格式是不同的。比如chrome和firefox，由于jsParser不同，其生成的AST格式也不同，优化AST的格式有时也是浏览器厂商提高浏览器效率的一种方式。\n\n[这个网站](https://astexplorer.net/)可以即时看到不同parser解析出的ast\n\n```js\nconst ast = parse(template.trim(), options)\n``` \n\n\n#### b，优化静态内容\n\n静态内容就是和数据没有关系，当数据更新时，不需要刷新的内容。比如{ { text } }就是非静态内容，当数据变化的时候，这里的内容也会被更新。\nbaseCompile函数中，通过下面这行代码实现了静态内容的优化\n\n```js\nif (options.optimize !== false) {\n    optimize(ast, options)\n  }\n``` \n这其中的optimize函数，其实主要做了两件事:\n* 标记静态&非静态节点\n* 标记静态根结点  \n\n```js\nmarkStatic(root) // 标记所有静态&非静态节点\n  \nmarkStaticRoots(root, false) // 标记静态根节点\n``` \n\n* 标记静态&非静态结点\n\n其标记的思路是从最底层往上一步一步的去标记静态节点。先标记最底层的叶子结点，再往上标记其父节点。一旦当前节点被标记为非静态节点，那么他所有的父节点都会被标记为非静态节点。\n\n每个结点是否为静态的判断依据是：isStatic(node)=true && 子节点是静态节点\n\nisStatic函数:\n\n```js\nfunction isStatic (node: ASTNode): boolean {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey) // node中的所有属性  是否isStaticKey()为true\n  ))\n}\n``` \n*其实就是先判断当前结点是否为表达式，是的话直接返回false，再判断是会否为纯为本，是的话直接返回true，如果都不是，再去判断是否绑定了v-for、v-if等属性。*\n\n* 标记静态根结点  \n\n与标记静态&非静态结点的方向正好相反，标记静态跟结点是从根结点，到叶子节点，上往下去标记的。\n\n每个结点是否为静态结点的标记依据是：\n\n该结点为静态结点&&（结点有多个子节点||有一个子节点，但是这个子节点不是纯文本）\n\n以上就是标记跟结点的实现思路。\n\n至此所有静态/非静态信息就标记完了。这些标记在每次vue更新DOM时都会起到很重要的优化作用，因为遇到静态节点，就知道，其自身以及子节点内容都无需更新，可直接跳过，由此很大的提高了vue的更新速度。\n\n\n\n\n#### c，生成render字符串\n\nbaseCompile函数中，下面这行为生成render字符串的代码\n\n```js\nconst code = generate(ast, options)  \n``` \n\n\n\n\n文档参考：https://ustbhuangyi.github.io/vue-analysis/prepare/directory.html   ","tags":["vue","模板编译"]},{"title":"vue-ssr","url":"/2018/07/06/vue-ssr/","content":"\n\n## 通过个人项目分享下面几个方面：\n\n* 构建流程\n* 运行流程\n* SSR的特点和利弊表\n\n## 流程图\n![流程图](/img/vue-ssr.png)\n\n## 目录结构\n\n```\t\n|- src 程序源文件\n    |- api  客户端和服务器api文件\n    |- assets  页面基础静态资源\n    |- commons 公共JS、CSS\n    |- components 公共的vue模块\n    |- config  配置项\n    |- directive 公共的vue指令\n    |- filter  全局filter方法   \n    |- router  路由控制 \n    |- util    工具方法     \n    |- store   状态存放          \n    |- pages   各个页面入口\n    |- plugin  扩展方法\n    |- vue$methods  vue实例方法    \n    |- app.js  创建vue实例\n    |- App.vue 总入口\n    |- entry-client.js 浏览器入口文件\n    |- entry-server.js 服务端入口文件\n    |- index.template.html 项目页面\n|- server.js 创建服务端渲染器\n|- node_modules node包文件\n|- public 公共静态资源\n|- build 开发环境和生产环境打包配置\n    |- setup-dev-server 开发环境启动服务器\n    |- webpack.client.config  打包浏览器端配置\n    |- webpack.server.config  打包服务器端配置\n|- dist 打包之后文件所在位置\n|- doc 项目说明文档\n    |- dev              \n|- test 开发期间功能测试(暂时未添加)\n    |- e2e \n    |- unit\n```\n*目录结构说明*\n1，app.js入口文件，它的作用就是构建一个Vue的实例以供服务端(entry-server.js)和客户端(entry-client.js)使用。\n2，entry-client.js  就是挂在Vue实例到DOM上。\n3，entry-server.js 就是主要负责调用组件内定义的获取数据的方法，获取到SSR渲染所需数据，并存储到上下文环境中。这个函数会在每一次的渲染中重复的调用。\n\n\n## webpack构建流程\n然后我们的服务端代码和客户端代码通过webpack分别打包，生成Server Bundle和Client Bundle。\n前者会运行在服务器上通过node生成预渲染的HTML字符串，发送到我们的客户端以便完成初始化渲染；\n而客户端bundle就自由了，初始化渲染完全不依赖它了。客户端拿到服务端返回的HTML字符串后，会去“激活”这些静态HTML，是其变成由Vue动态管理的DOM，以便响应后续数据的变化。\n\n## Vue SSR运行流程\n* 构建一个vue的实例。 app.js创建vue实例，用一个工厂函数去封装它，以便每一个用户的请求都能够返回一个新的实例，也就是官网说到的避免交叉污染了。\n* 服务端的entry.server.js拿到当前路由匹配的组件。调用组件中asyncData方法（也可以是自己定义的其他方法），此方法就是去调用我们vuex store中的方法去异步获取数据。\n* node服务器把刚刚构建好的Vue实例渲染成HTML字符串，然后将拿到的数据混入我们的HTML字符串中，最后发送到我们客户端。\n* 这里客户端拿到存在window中的数据混入我们客户端的vuex中，然后就是我们熟悉的客户端执行流程了。\n\n\n## Vue SSR核心\n* 数据预期和状态：在服务器端渲染(SSR)期间，我们本质上是在渲染我们应用程序的\"快照\"，所以如果应用程序依赖于一些异步数据，那么在开始渲染过程之前，需要先预取和解析好这些数据。\n* 本项目中用vuex存放预取数据，也可以自己实现EventBus来实现。\n\n\n## Vue SSR注意事项\n* 在SSR中，创建Vue实例、创建store和创建router都是套了一层工厂函数的，目的就是避免数据的交叉污染。\n* 在服务端只能执行生命周期中的created和beforeCreate，原因是在服务端是无法操纵dom的，所以可想而知其他的周期也就是不能执行的了。\n* 服务器要求html书写规范，它实际输出的是一大串字符串，并不会像浏览器那样智能添加标签，不规范书写会导致混淆后的HTML和浏览器渲染的HTML不匹配。例如table > tbody > tr > td。\n* asyncData()方法在子路由中获取不到异步数据，要放在顶级路由组件中。\n* SSR服务端请求不带cookie。解决方案参考（https://www.mmxiaowu.com/article/596cbb2d436eb550a5423c30）\n\n\n\n## Vue SSR优缺点：\n### 优点：\n   - SEO\n   - 首屏渲染\n\n### 缺点：\n  - 服务器压力大\n  - 性能问题\n  - 学习和开发成本大\n\n\n参考资料：https://ssr.vuejs.org/zh/  ","tags":["vue","同构"]},{"title":"浅谈前端中的二进制数据类型","url":"/2018/05/09/浅谈前端中的二进制数据类型/","content":"\n>目前在一个项目中，WebSocket部分由于后端使用了gzip压缩，前端处理起来废了一点时间，从而发现自己在二进制数据类型这个知识点还存在一定的盲区，因此这里进行总结。\n\n本文主要简单介绍ArrayBuffer对象、TypedArray对象、DataView对象以及Blob原始数据类型，和它们之间的互相转换方法。部分代码参考[这里](http://javascript.ruanyifeng.com/stdlib/arraybuffer.html#toc4)而非本人原创，仅做个人学习使用。\n\n这些类型化对象，一般会在以下场景中使用：\n\n* WebGL 中，浏览器和显卡之间需要使用二进制数据进行通信。\n* 在一些 Rest 接口或者 WebSocket 中，采用压缩过的数据进行通信，这个压缩和解压缩的过程可能需要借助二进制对象。\n* 在 Canvas 中，我们可能需要通过生成 Blob 的方式保存当前内容。\n* 在 Img 等资源文件中，URL 可以为 Blob 原始数据类型。\n* 在读取用户上传文件时，可能需要用到二进制数据类型进行中间转换。\n\n下文分两部分，前一部分概述各个二进制数据类型，后一部分将它们之间的互相转换。\n\n### 二进制数据类型概述\n\n#### ArrayBuffer\n\nArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。\n\nArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。\n\n```\nvar buf = new ArrayBuffer(32);\n```\n\n上面代码生成了一段32字节的内存区域，每个字节的值默认都是0。可以看到，ArrayBuffer构造函数的参数是所需要的内存大小（单位字节）。\n\n为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数。\n\n```\nvar buf = new ArrayBuffer(32);\nvar dataView = new DataView(buf);\ndataView.getUint8(0) // 0\n```\n\n上面代码对一段32字节的内存，建立DataView视图，然后以不带符号的8位整数格式，读取第一个元素，结果得到0，因为原始内存的ArrayBuffer对象，默认所有位都是0。\n\n另外，我们可以将ArrayBuffer生成的结果，传入TypedArray中：\n\n```\nvar buffer = new ArrayBuffer(12);\n\nvar x1 = new Int32Array(buffer);\nx1[0] = 1;\nvar x2 = new Uint8Array(buffer);\nx2[0]  = 2;\n\nx1[0] // 2\n```\n\nArrayBuffer实例的byteLength属性，返回所分配的内存区域的字节长度。\n\n```\nvar buffer = new ArrayBuffer(32);\nbuffer.byteLength\n// 32\n```\n如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。\n\n```\nif (buffer.byteLength === n) {\n  // 成功\n} else {\n  // 失败\n}\n```\n\nArrayBuffer实例有一个slice方法，允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象。\n\n```\nvar buffer = new ArrayBuffer(8);\nvar newBuffer = buffer.slice(0, 3);\n```\n\n上面代码拷贝buffer对象的前3个字节（从0开始，到第3个字节前面结束），生成一个新的ArrayBuffer对象。slice方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个ArrayBuffer对象拷贝过去。\n\nslice方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默认到原ArrayBuffer对象的结尾。\n\n除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。\n\nArrayBuffer有一个静态方法isView，返回一个布尔值，表示参数是否为ArrayBuffer的视图实例。这个方法大致相当于判断参数，是否为TypedArray实例或DataView实例。\n\n```\nvar buffer = new ArrayBuffer(8);\nArrayBuffer.isView(buffer) // false\n\nvar v = new Int32Array(buffer);\nArrayBuffer.isView(v) // true\n```\n\n#### TypedArray\n\n目前，TypedArray对象一共提供9种类型的视图，每一种视图都是一种构造函数。\n\n* Int8Array：8位有符号整数，长度1个字节。\n* Uint8Array：8位无符号整数，长度1个字节。\n* Uint8ClampedArray：8位无符号整数，长度1个字节，溢出处理不同。\n* Int16Array：16位有符号整数，长度2个字节。\n* Uint16Array：16位无符号整数，长度2个字节。\n* Int32Array：32位有符号整数，长度4个字节。\n* Uint32Array：32位无符号整数，长度4个字节。\n* Float32Array：32位浮点数，长度4个字节。\n* Float64Array：64位浮点数，长度8个字节。\n\n这9个构造函数生成的对象，统称为TypedArray对象。它们很像正常数组，都有length属性，都能用方括号运算符（[]）获取单个元素，所有数组的方法，在类型化数组上面都能使用。两者的差异主要在以下方面。\n\n* TypedArray数组的所有成员，都是同一种类型和格式。\n* TypedArray数组的成员是连续的，不会有空位。\n* Typed化数组成员的默认值为0。比如，new Array(10)返回一个正常数组，里面没有任何成员，只是10个空位；new Uint8Array(10)返回一个类型化数组，里面10个成员都是0。\n* TypedArray数组只是一层视图，本身不储存数据，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性。\n\n##### 构造函数\n\nTypedArray数组提供9种构造函数，用来生成相应类型的数组实例。\n\n构造函数有多种用法。\n\n* TypedArray(buffer, byteOffset=0, length?)\n\n同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图。\n\n```\n// 创建一个8字节的ArrayBuffer\nvar b = new ArrayBuffer(8);\n\n// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾\nvar v1 = new Int32Array(b);\n\n// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾\nvar v2 = new Uint8Array(b, 2);\n\n// 创建一个指向b的Int16视图，开始于字节2，长度为2\nvar v3 = new Int16Array(b, 2, 2);\n```\n\n对于以上代码，v1、v2和v3是重叠的：v1[0]是一个32位整数，指向字节0～字节3；v2[0]是一个8位无符号整数，指向字节2；v3[0]是一个16位整数，指向字节2～字节3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。\n\n注意，byteOffset必须与所要建立的数据类型一致，否则会报错。\n\n```\nvar buffer = new ArrayBuffer(8);\nvar i16 = new Int16Array(buffer, 1);\n// Uncaught RangeError: start offset of Int16Array should be a multiple of 2\n```\n\n上面代码中，新生成一个8个字节的ArrayBuffer对象，然后在这个对象的第一个字节，建立带符号的16位整数视图，结果报错。因为，带符号的16位整数需要两个字节，所以byteOffset参数必须能够被2整除。\n\n如果想从任意字节开始解读ArrayBuffer对象，必须使用DataView视图，因为TypedArray视图只提供9种固定的解读格式。\n\n* TypedArray(length)\n\n视图还可以不通过ArrayBuffer对象，直接分配内存而生成。\n\n```\nvar f64a = new Float64Array(8);\nf64a[0] = 10;\nf64a[1] = 20;\nf64a[2] = f64a[0] + f64a[1];\n```\n\n* TypedArray(typedArray)\n\n类型化数组的构造函数，可以接受另一个视图实例作为参数。\n\n```\nvar typedArray = new Int8Array(new Uint8Array(4));\n```\n\n上面代码中，Int8Array构造函数接受一个Uint8Array实例作为参数。\n\n注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。\n\n```\nvar x = new Int8Array([1, 1]);\nvar y = new Int8Array(x);\nx[0] // 1\ny[0] // 1\n\nx[0] = 2;\ny[0] // 1\n```\n\n上面代码中，数组y是以数组x为模板而生成的，当x变动的时候，y并没有变动。\n\n如果想基于同一段内存，构造不同的视图，可以采用下面的写法。\n\n```\nvar x = new Int8Array([1, 1]);\nvar y = new Int8Array(x.buffer);\nx[0] // 1\ny[0] // 1\n\nx[0] = 2;\ny[0] // 2\n```\n\n* TypedArray(arrayLikeObject)\n\n构造函数的参数也可以是一个普通数组，然后直接生成TypedArray实例。\n\n```\nvar typedArray = new Uint8Array([1, 2, 3, 4]);\n```\n\n注意，这时TypedArray视图会重新开辟内存，不会在原数组的内存上建立视图。\n\n上面代码从一个普通的数组，生成一个8位无符号整数的TypedArray实例。\n\nTypedArray数组也可以转换回普通数组。\n\n```\nvar normalArray = Array.prototype.slice.call(typedArray);\n```\n\n##### BYTES_PER_ELEMENT属性\n\n每一种视图的构造函数，都有一个BYTES_PER_ELEMENT属性，表示这种数据类型占据的字节数。\n\n```\nInt8Array.BYTES_PER_ELEMENT // 1\nUint8Array.BYTES_PER_ELEMENT // 1\nInt16Array.BYTES_PER_ELEMENT // 2\nUint16Array.BYTES_PER_ELEMENT // 2\nInt32Array.BYTES_PER_ELEMENT // 4\nUint32Array.BYTES_PER_ELEMENT // 4\nFloat32Array.BYTES_PER_ELEMENT // 4\nFloat64Array.BYTES_PER_ELEMENT // 8\n```\n\n##### ArrayBuffer与字符串的互相转换\n\nArrayBuffer转为字符串，或者字符串转为ArrayBuffer，有一个前提，即字符串的编码方法是确定的。假定字符串采用UTF-16编码（JavaScript的内部编码方式），可以自己编写转换函数。\n\n```\n// ArrayBuffer转为字符串，参数为ArrayBuffer对象\nfunction ab2str(buf) {\n  return String.fromCharCode.apply(null, new Uint16Array(buf));\n}\n\n// 字符串转为ArrayBuffer对象，参数为字符串\nfunction str2ab(str) {\n  var buf = new ArrayBuffer(str.length * 2); // 每个字符占用2个字节\n  var bufView = new Uint16Array(buf);\n  for (var i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n  return buf;\n}\n```\n\n##### TypedArray.prototype.set()\n\nTypedArray数组的set方法用于复制数组（正常数组或TypedArray数组），也就是将一段内容完全复制到另一段内存。\n\n```\nvar a = new Uint8Array(8);\nvar b = new Uint8Array(8);\n\nb.set(a);\n```\n\n上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。set方法还可以接受第二个参数，表示从b对象哪一个成员开始复制a对象。\n\n```\nvar a = new Uint16Array(8);\nvar b = new Uint16Array(10);\n\nb.set(a, 2)\n```\n上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。\n\n##### TypedArray.prototype.subarray()\n\nsubarray方法是对于TypedArray数组的一部分，再建立一个新的视图。\n\n```\nvar a = new Uint16Array(8);\nvar b = a.subarray(2,3);\n\na.byteLength // 16\nb.byteLength // 2\n```\n\nsubarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着b只包含a[2]一个成员，字节长度为2。\n\n##### TypedArray.prototype.slice()\n\nTypeArray实例的slice方法，可以返回一个指定位置的新的TypedArray实例。\n\n```\nlet ui8 = Uint8Array.of(0, 1, 2);\nui8.slice(-1)\n// Uint8Array [ 2 ]\n```\n\n\n上面代码中，ui8是8位无符号整数数组视图的一个实例。它的slice方法可以从当前视图之中，返回一个新的视图实例。\n\nslice方法的参数，表示原数组的具体位置，开始生成新数组。负值表示逆向的位置，即-1为倒数第一个位置，-2表示倒数第二个位置，以此类推。\n\n##### TypedArray.of()\n\nTypedArray数组的所有构造函数，都有一个静态方法of，用于将参数转为一个TypedArray实例。\n\n```\nFloat32Array.of(0.151, -8, 3.7)\n// Float32Array [ 0.151, -8, 3.7 ]\n```\n\n##### TypedArray.from()\n\n静态方法from接受一个**可遍历的数据结构（比如数组）**作为参数，返回一个基于这个结构的TypedArray实例。\n\n```\nUint16Array.from([0, 1, 2])\n// Uint16Array [ 0, 1, 2 ]\n```\n\n这个方法还可以将一种TypedArray实例，转为另一种。\n\n```\nvar ui16 = Uint16Array.from(Uint8Array.of(0, 1, 2));\nui16 instanceof Uint16Array // true\n```\n\nfrom方法还可以接受一个函数，作为第二个参数，用来对每个元素进行遍历，功能类似map方法。\n\n```\nInt8Array.of(127, 126, 125).map(x => 2 * x)\n// Int8Array [ -2, -4, -6 ]\n\nInt16Array.from(Int8Array.of(127, 126, 125), x => 2 * x)\n// Int16Array [ 254, 252, 250 ]\n```\n\n上面的例子中，from方法没有发生溢出，这说明遍历是针对新生成的16位整数数组，而不是针对原来的8位整数数组。也就是说，from会将第一个参数指定的TypedArray数组，拷贝到另一段内存之中（占用内存从3字节变为6字节），然后再进行处理。\n\n#### DataView\n\n如果一段数据包括多种类型（比如服务器传来的HTTP数据），这时除了建立ArrayBuffer对象的复合视图以外，还可以通过DataView视图进行操作。\n\nDataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。\n\nDataView视图本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。\n\n```\nDataView(ArrayBuffer buffer [, 字节起始位置 [, 长度]]);\n```\n下面是一个例子。\n\n```\nvar buffer = new ArrayBuffer(24);\nvar dv = new DataView(buffer);\n```\n\nDataView实例有以下属性，含义与TypedArray实例的同名方法相同。\n\n* DataView.prototype.buffer：返回对应的ArrayBuffer对象\n* DataView.prototype.byteLength：返回占据的内存字节长度\n* DataView.prototype.byteOffset：返回当前视图从对应的ArrayBuffer对象的哪个字节开始\n\nDataView实例提供8个方法读取内存。\n\n* getInt8：读取1个字节，返回一个8位整数。\n* getUint8：读取1个字节，返回一个无符号的8位整数。\n* getInt16：读取2个字节，返回一个16位整数。\n* getUint16：读取2个字节，返回一个无符号的16位整数。\n* getInt32：读取4个字节，返回一个32位整数。\n* getUint32：读取4个字节，返回一个无符号的32位整数。\n* getFloat32：读取4个字节，返回一个32位浮点数。\n* getFloat64：读取8个字节，返回一个64位浮点数。\n\n这一系列get方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。\n\n```\nvar buffer = new ArrayBuffer(24);\nvar dv = new DataView(buffer);\n\n// 从第1个字节读取一个8位无符号整数\nvar v1 = dv.getUint8(0);\n\n// 从第2个字节读取一个16位无符号整数\nvar v2 = dv.getUint16(1);\n\n// 从第4个字节读取一个16位无符号整数\nvar v3 = dv.getUint16(3);\n```\n\n上面代码读取了ArrayBuffer对象的前5个字节，其中有一个8位整数和两个十六位整数。\n\n如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。\n\n```\n// 小端字节序\nvar v1 = dv.getUint16(1, true);\n\n// 大端字节序\nvar v2 = dv.getUint16(3, false);\n\n// 大端字节序\nvar v3 = dv.getUint16(3);\n```\n\nDataView视图提供8个方法写入内存。\n\n* setInt8：写入1个字节的8位整数。\n* setUint8：写入1个字节的8位无符号整数。\n* setInt16：写入2个字节的16位整数。\n* setUint16：写入2个字节的16位无符号整数。\n* setInt32：写入4个字节的32位整数。\n* setUint32：写入4个字节的32位无符号整数。\n* setFloat32：写入4个字节的32位浮点数。\n* setFloat64：写入8个字节的64位浮点数。\n\n这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。\n\n```\n// 在第1个字节，以大端字节序写入值为25的32位整数\ndv.setInt32(0, 25, false);\n\n// 在第5个字节，以大端字节序写入值为25的32位整数\ndv.setInt32(4, 25);\n\n// 在第9个字节，以小端字节序写入值为2.5的32位浮点数\ndv.setFloat32(8, 2.5, true);\n```\n\n如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。\n\n```\nvar littleEndian = (function() {\n  var buffer = new ArrayBuffer(2);\n  new DataView(buffer).setInt16(0, 256, true);\n  return new Int16Array(buffer)[0] === 256;\n})();\n```\n\n#### Blob\n\nBlob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。\n\n要从其他非blob对象和数据构造一个Blob，请使用 Blob() 构造函数。要创建包含另一个blob数据的子集blob，请使用 slice()方法。要获取用户文件系统上的文件对应的Blob对象，请参阅 File文档。\n\n从Blob中读取内容的唯一方法是使用 FileReader。以下代码将 Blob 的内容作为类型数组读取：\n\n```\nvar reader = new FileReader();\nreader.addEventListener(\"loadend\", function() {\n   // reader.result 包含转化为类型数组的blob\n});\nreader.readAsArrayBuffer(blob);\n```\n\n更多关于Blob的内容，请直接查看[这里](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)\n\n### 数据格式转换\n\n#### String转Blob\n\n```\n//将字符串 转换成 Blob 对象\nvar blob = new Blob([\"Hello World!\"], {\n    type: 'text/plain'\n});\nconsole.info(blob);\nconsole.info(blob.slice(1, 3, 'text/plain'));\n```\n#### TypeArray转Blob\n\n```\n//将 TypeArray  转换成 Blob 对象\nvar array = new Uint16Array([97, 32, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33]);\n//测试成功\n//var blob = new Blob([array], { type: \"application/octet-binary\" });\n//测试成功， 注意必须[]的包裹\nvar blob = new Blob([array]);\n//将 Blob对象 读成字符串\nvar reader = new FileReader();\nreader.readAsText(blob, 'utf-8');\nreader.onload = function (e) {\n    console.info(reader.result); //a Hello world!\n}\n```\n\n#### ArrayBuffer转Blob\n\n```\nvar buffer = new ArrayBuffer(32);\nvar blob = new Blob([buffer]);       // 注意必须包裹[]\n```\n\n#### Blob转String\n\n这里需要注意的是readAsText方法的使用。\n\n```\n//将字符串转换成 Blob对象\nvar blob = new Blob(['中文字符串'], {\n    type: 'text/plain'\n});\n//将Blob 对象转换成字符串\nvar reader = new FileReader();\nreader.readAsText(blob, 'utf-8');\nreader.onload = function (e) {\n    console.info(reader.result);\n}\n```\n\n#### Blob转ArrayBuffer\n\n这里需要注意的是readAsArrayBuffer方法的使用。\n\n```\n//将字符串转换成 Blob对象\nvar blob = new Blob(['中文字符串'], {\n    type: 'text/plain'\n});\n//将Blob 对象转换成 ArrayBuffer\nvar reader = new FileReader();\nreader.readAsArrayBuffer(blob);\nreader.onload = function (e) {\n    console.info(reader.result); //ArrayBuffer {}\n    //经常会遇到的异常 Uncaught RangeError: byte length of Int16Array should be a multiple of 2\n    //var buf = new int16array(reader.result);\n    //console.info(buf);\n\n    //将 ArrayBufferView  转换成Blob\n    var buf = new Uint8Array(reader.result);\n    console.info(buf); //[228, 184, 173, 230, 150, 135, 229, 173, 151, 231, 172, 166, 228, 184, 178]\n    reader.readAsText(new Blob([buf]), 'utf-8');\n    reader.onload = function () {\n        console.info(reader.result); //中文字符串\n    };\n\n    //将 ArrayBufferView  转换成Blob\n    var buf = new DataView(reader.result);\n    console.info(buf); //DataView {}\n    reader.readAsText(new Blob([buf]), 'utf-8');\n    reader.onload = function () {\n        console.info(reader.result); //中文字符串\n    };\n}\n```\n\n","tags":["javascript"]},{"title":"[PWA实践]serviceWorker生命周期、请求代理与通信","url":"/2018/02/11/PWA实践-serviceWorker生命周期、请求代理与通信/","content":"\n本文主要讲 serviceWorker 生命周期和挂载、卸载等问题，适合对 serviceWorker 的作用有所了解但是具体细节不是特别清楚的读者\n\n**以下所有分析基于 Chrome V63**\n\n### serviceWorker的挂载\n\n先来一段代码感受serviceWorker注册:\n\n```\nif ('serviceWorker' in navigator) {\n      window.addEventListener('load', function () {\n          navigator.serviceWorker.register('/sw.js', {scope: '/'})\n              .then(function (registration) {\n                  // 注册成功\n                  console.log('ServiceWorker registration successful with scope: ', registration.scope);\n              })\n              .catch(function (err) {\n                  // 注册失败:(\n                  console.log('ServiceWorker registration failed: ', err);\n              });\n      });\n}\n```\n通过上述代码，我们定义在`/sw.js`里的内容就会生效(对于当前页面之前没有 serviceWorker 的情况而言，我们注册的 serviceWorker 肯定会生效，如果当前页面已经有了我们之前注册的 serviceWorker，这个时候涉及到 serviceWorker的更新机制，下文详述)\n\n如果我们在`sw.js`没有变化的情况下刷新这个页面，每次还是会有注册成功的回调以及相应的log输出，但是这个时候浏览器发现我们的 serviceWorker 并没有发生变化，并不会重置一遍 serviceWorker\n\n### serviceWorker更新\n\n我们如果想更新一个 serviceWorker，根据我们的一般web开发策略，可能会想到以下几种策略：\n\n* 仅变更文件名(比如把`sw.js`变成`sw-v2.js`或者加一个hash)\n* 仅变更文件内容(仅仅更新`sw.js`的内容，文件名不变)\n* 同时变更：同时执行以上两条\n\n在这里，我可以很负责的告诉你，**变更serviceWorker文件名绝对不是一个好的实践**，浏览器判断 serviceWorker 是否相同基本和文件名没有关系，甚至有可能还会造成浏览器抛出404异常(因为找不到原来的文件名对应的文件了)。\n\n所以我们只需要变更内容即可，实际上，我们每次打开或者刷新该页面，浏览器都会重新请求一遍 serviceWorker 的定义文件，如果发现文件内容和之前的不同了，这个时候:\n\n(*下文中，我们使用“有关 tab”来表示受 serviceWorker 控制的页面*，刷新均指普通刷新(F5/CommandR)并不指Hard Reload)\n\n* 这个新的 serviceWorker 就会进入到一个 “waiting to activate” 的状态，并且只要我们不关闭这个网站的所有tab(更准确地说，是这个 serviceWorker 控制的所有页面)，新的 serviceWorker 始终不会进入替换原有的进入到 running 状态(就算我们只打开了一个有关 tab，直接刷新也不会让新的替换旧的)。\n\n* 如果我们多次更新了 serviceWorker 并且没有关闭当前的 tab 页面，那么新的 serviceWorker 就会挤掉原先处于第二顺位(waiting to activate)的serviceWorker，变成`waiting to activate`状态\n\n也就是说，我们只有关闭当前旧的 serviceWorker 控制的所有页面 的所有tab，之后浏览器才会把旧的 serviveWorker 移除掉，换成新的，再打开相应的页面就会使用新的了。\n\n当然，也有一个特殊情况：如果我们在新的 serviceWorker 使用了`self.skipWaiting();`，像这样：\n\n```\nself.addEventListener('install', function(event) {\n    self.skipWaiting();\n});\n```\n\n这个时候，要分为以下两种情况：\n\n* 如果当前我们只打开了一个有关 tab，这个时候，我们直接刷新，发现新的已经替换掉旧的了。\n* 如果我们当前打开了若干有关 tab，这个时候，无论我们刷新多少次，新的也不会替换掉旧的，只有我们一个一个关掉tab(或者跳转走)只剩下最后一个了，这个时候刷新，会让新的替换旧的(也就是上一种情况)\n\nChrome 的这种机制，防止了同一个页面先后被新旧两个不同的 serviceWorker 接管的情况出现。\n\n#### 手动更新\n\n虽然说，在页面每次进入的时候浏览器都会检查一遍 serviceWorker 是否更新，但如果我们想要手动更新 serviceWorker 也没有问题：\n\n```\nnavigator.serviceWorker.register(\"/sw.js\").then(reg => {\n  reg.update();\n  // 或者 一段时间之后更新\n});\n```\n\n这个时候如果 serviceWorker 变化了，那么会重新触发 install 执行一遍 install 的回调函数，如果没有变，就不会触发这个生命周期。\n\n#### install 生命周期钩子\n\n我们一般会在 sw.js 中，添加`install`的回调，一般在回调中，我们会进行缓存处理操作，像这样：\n\n```\nself.addEventListener('install', function(event) {\n    console.log('[sw2] serviceWorker Installed successfully', event)\n\n    event.waitUntil(\n        caches.open('mysite-static-v1').then(function(cache) {\n            return cache.addAll([\n                '/stylesheets/style.css',\n                '/javascripts/common.39c462651d449a73b5bb.js',\n            ]);\n        })\n    )\n}    \n```\n\n如果我们新打开一个页面，如果之前有 serviceWorker，那么会触发`install`，如果之前没有， 那么在 serviceWorker 装载后会触发 `install`。\n\n如果我们刷新页面，serviceWorker 和之前没有变化或者 serviceWorker 已经处在 `waiting to activate`，不会触发`install`，如果有变化，会触发`install`，但不会接管页面(上文中提到)。\n\n#### activate 生命周期钩子\n\nactivate 在什么时候被触发呢？\n\n如果当前页面没有 serviceworker ，那么会在 install 之后触发。\n\n如果当前页面有 serviceWorker，并且有 serviceWorker更新，新的 serviceWorker 只会触发 install ，不会触发 activate\n\n换句话说，当前变成 active 的 serviceWorker 才会被触发这个生命周期钩子\n\n\n### serviceWorker 代理请求\n\nserviceWorker 代理请求相对来说比较好理解，以下是一个很简单的例子：\n\n```\nself.addEventListener('install', function(event) {\n    console.log('[sw2] serviceWorker Installed successfully', event)\n\n    event.waitUntil(\n        caches.open('mysite-static-v1').then(function(cache) {\n            return cache.addAll([\n                '/stylesheets/style.css',\n                '/javascripts/common.39c462651d449a73b5bb.js',\n            ]);\n        })\n    );\n});\n\nself.addEventListener('fetch', function(event) {\n    console.log('Handling fetch event for', event.request.url);\n    // console.log('[sw2]fetch but do nothing')\n\n    event.respondWith(\n        // caches.match() will look for a cache entry in all of the caches available to the service worker.\n        // It's an alternative to first opening a specific named cache and then matching on that.\n        caches.match(event.request).then(function(response) {\n            if (response) {\n                console.log('Found response in cache:', response);\n\n                return response;\n            }\n\n            console.log('No response found in cache. About to fetch from network...');\n\n            // event.request will always have the proper mode set ('cors, 'no-cors', etc.) so we don't\n            // have to hardcode 'no-cors' like we do when fetch()ing in the install handler.\n            return fetch(event.request).then(function(response) {\n                console.log('Response from network is:', response);\n\n                return response;\n            }).catch(function(error) {\n                // This catch() will handle exceptions thrown from the fetch() operation.\n                // Note that a HTTP error response (e.g. 404) will NOT trigger an exception.\n                // It will return a normal response object that has the appropriate error code set.\n                console.error('Fetching failed:', error);\n\n                throw error;\n            });\n        })\n    );\n});\n```\n\n有两点要注意的：\n\n我们如果这样代理了，哪怕没有 cache 命中，实际上也会在控制台写from serviceWorker，而那些真正由serviceWorker发出的请求也会显示，有一个齿轮图标，如下图：\n\n![](https://www.10000h.top/images/sw_1.png)\n\n第二点就是我们如果在 fetch 的 listener 里面 do nothing， 也不会导致这个请求直接假死掉的。\n\n另外，通过上面的代码我们发现，实际上由于现在我们习惯给我们的文件资源加上 hash，所以我们基本上不可能手动输入需要缓存的文件列表，现在大多数情况下，我们都是借助 webpack 插件，完成这部分工作。\n\n### serviceWorker 和 页面之间的通信\n\nserviceWorker向页面发消息：\n\n```\nsw.js:\n\nself.clients.matchAll().then(clients => {\n    clients.forEach(client => {\n        console.log('%c [sw message]', 'color:#00aa00', client)\n        client.postMessage(\"This message is from serviceWorker\")\n    })\n})\n\n主页面:\n\nnavigator.serviceWorker.addEventListener('message', function (event) {\n    console.log('[Main] receive from serviceWorker:', event.data, event)\n});\n```\n\n当然，这里面是有坑的：\n\n* 主界面的事件监听需要等serviceWorker注册完毕后，所以一般`navigator.serviceWorker.register`的回调到来之后再进行注册(或者延迟足够的时间)。\n* 如果在主界面事件监听还没有注册成功的时候 serviceWorker 发送消息，自然是收不到的。如果我们把 serviceWorker 直接写在 install 的回调中，也是不能被正常收到的。\n\n从页面向 serviceWorker 发送消息：\n\n```\n主页面:\n\nnavigator.serviceWorker.controller && navigator.serviceWorker.controller.postMessage('hello serviceWorker');\n\nsw.js:\nself.addEventListener('message', function (event) {\n    console.log(\"[sw from main]\",event.data); // 输出：'sw.updatedone'\n});\n```\n\n同样的，这也要求主界面的代码需要等到serviceWorker注册完毕后触发，另外还有一点值得注意， serviceWorker 的事件绑定代码要求主界面的serviceWorker已经注册完毕后才可以。\n\n也就是说，如果当前页面没有该serviceWorker 第一次注册是不会收到主界面接收到的消息的。\n\n记住，只有当前已经在 active 的 serviceWorker， 才能和主页面收发消息等。\n\n**以上就是和 serviceWorker 有关的一些内容，在下一篇文章中，我会对PWA 添加至主屏幕等功能进行总结**\n\n","tags":["PWA"]},{"title":"深入浏览器web渲染与优化-续","url":"/2017/08/31/深入浏览器web渲染与优化-续/","content":">本篇文章接上一篇继续分析浏览器web渲染相关内容，但是更侧重优化工作。当然，主要还是基于X5来分析\n\n上一篇文章我们主要是从浏览器内核的线程角度来分析相关工作的，对整体流程没有宏观清晰的分析，这次我们从宏观到微观，从整体到局部，来进行分析和探究可以优化的地方。\n\n首先，一个网页的加载，需要什么工作呢？\n\n![](https://www.10000h.top/images/data_img/webRender2/P1.png)\n\n这个工作可以分为三部分：云(云端)、管(传输链路)、端(客户端)，从云经过管传到端，然后经过加载解析排版渲染，从而完成网页从请求到呈现的工作(当然，我们这里没有涉及协议的分析，实际上根据协议不同，这个传输可能是多次传输)。\n\n数据到端之后，又经过以下过程，才最终显示出来：\n\n![](https://www.10000h.top/images/data_img/webRender2/P2.png)\n\n在这个过程中，我们怎么衡量性能呢？\n\n固然，我们有诸多浏览器提供的API，这些API能让我们获取到较多信息并且记录上报：\n\n![](https://www.10000h.top/images/data_img/webRender2/P3.png)\n\n但是这些具体数值表达的含义有限，并且他们实际上也不等于用户体验。\n\n所以，找到一个科学并且可以检测的标准，并且这个标准可以和用户体验有正相关关系，这个是至关重要的。\n\n目前这个标准是**首屏时间**(就之前自己的了解，具体的还区分首屏展示时间和首屏可交互时间，但是这里讲师不做区分，就下文提供的测算方法而言，显然这里指的是首屏展示时间，*另外，展示后到用户的第一次操作都会有一个至少1s的延时，毕竟用户手指按下的动作是会比较慢的，这个时间js的交互都能完成了，所以首屏展示时间更加重要--from dorsywang*)\n\n那么**首屏时间**怎么测量呢？\n\n**拿摄像机快速拍照测量的**。这个答案可能有些吃惊，但是目前X5内核业务的相关开发人员的确就是采用这种方式测算的，通过高速相机不断拍照，然后辅助图像识别，判断首屏是否已经加载完成，最终再通过人工回归校对。  \n因为如果采用程序检测的话，基本上都会对过程本身造成一定的影响，所以没有采用这种方式。\n当然，通过摄像+图像识别的这种方式也是有一定的弊端，比如说，假设首屏有一个图片，而图片的加载通常比较慢并且不影响css、js的加载，这个时候直接通过图片识别的话就可能会有一定的误判。\n\n知道了怎么测算，那么接下来分析影响这个指标的一些原因：\n\n* 资源阻塞内核线程\n\n我们知道，一般情况下，css和JS是阻塞页面的，当然也会对首屏时间造成影响。\n\n对这个问题，X5内核有关键子资源(阻塞资源)缓存，这里的关键资源，指的是内核经过统计判断得出的业务常用的关键子资源。\n\n当然，这个统计也可能缺乏一定的准确性，所以相关团队也正在推进这方面的内容规范化(比如写入Web App Manifest)\n\n* 中文Layout的时间过长\n\n这个问题我之前没有听说过，但是的确是这样子，实际上，浏览器在绘制文字的时候经历的过程非常的多，其中有一个环节是找到文字的宽度和高度(因为在英文状态下，每一个字符的宽度是不同的，所以每一个字符都要查找，但是英文总共只有26个字符)，而中文由于字符比较多，常用得就有6000多个，完整的更是有2万个以上，所以这个过程需要花费更多的时间。\n\n为了解决这个问题，X5内核考虑到中文文字几乎都是等宽等高的，所以这个过程对一个文字串来说只需要查询一次即可，实际上是节约了这个环节。\n\n* 首次渲染太慢\n\n为了解决这个问题，可以采用先绘制首屏的方式，这个也就是基于第一篇文章中讲到的浏览器的分块渲染机制\n\n* 一次解析内容过多\n\n采用首屏探测机制，优先解析首屏内容。\n\n另外，这里可以前端配合去做首屏优化：\n\n\n在首屏的位置插入首屏标签，内核解析到标签后立即终止解析并且排版上屏\n\n```\n<meta name=‘x5-pagetype’ content=‘optpage'>\n```\n然后在首屏分界的地方：\n\n```\n<first-screen/>\n```\n\n有了这，可以专门去优化首屏标签之前的内容(这个标签前尽量展现耗时少和不需要阻塞解析的资源)。\n\n另外，X5内核也提供了主资源预拉取的接口，并且考虑到预拉取的cookie问题，还提供了preconnect预链接。  \n*TIP:主资源中关联的子资源预拉取不用主动调用*\n\n* 预先操作\n\n另外为了提供更加极致的优化，X5内核(QQ浏览器、手Q Webview)还提供了如下诸多预操作：\n\n* 在\"黏贴并转到\"之前就开始进行网络请求和预渲染\n* 经常访问的站点可以预解析DNS\n* 点击地址栏时进行搜索预连接\n* 点击链接时，先预链接，再做跳转。\n* ......\n\n### 其他方式优化\n\n实际上上文主要讲了客户端方面的优化工作，实际上对于\"云\"、\"管\"两端，还是有很多优化工作可以讲的，但是由于这个和前端关系不是特别密切，我挑一部分讲一讲。这些在我们前端做个人项目的后台时候也可以参考\n\n##### 后台提速\n\n* 直接使用IP，节省dns的查询时间\n* 维持长连接\n* HTTP1.1启用包头节省\n* 服务器缓存\n* 文本资源压缩传输GZIP(6)\n* 图片尺寸压缩、图片质量压缩、支持webp和sharpp/hevc格式。\n\n##### 降低网络时延\n\n* 就快接入和就近接入\n\n在选择接入点的时候，如果采用就近接入，可以保持路由稳定，有利于负载均衡，并且实现简单，便于维护。但是也有一定的缺点：经验判断，准确度不够高 ； 无法自动切换路由。\n\n相比较而言，选择就快接入，是一个能够提效的方式。\n\n##### 内容防劫持\n\n运营商劫持对我们来说已经是不陌生的话题了，但是X5内核有一个比较新的防劫持手段，就是客户端和云加速服务器同时采用轻量级http加密，虽然这种方式普适性不强，但是的确可以解决腾讯自身业务的防劫持问题。\n\n#### QUIC和http2\n\nQUIC 基于UDP的协议通讯方式，有这些优势：\n\n* 延迟少\n* 前向纠错\n* 没有**线头阻塞[注1]**的多路复用\n* 通信通道的定义基于ID而不是IP+端口，使得切换网络后继续转发链接成为可能\n\n——————\n\n注1：线头阻塞：\n\n![](https://www.10000h.top/images/data_img/webRender2/P4.png)\n\n——————\n\n附1: 带宽和延迟对网页加载的影响：\n\n![](https://www.10000h.top/images/data_img/webRender2/X1.png)\n","tags":["性能优化"]},{"title":"深入浏览器web渲染与优化","url":"/2017/08/27/深入浏览器web渲染与优化/","content":">本文主要分析和总结web内核渲染的相关内容，以及在这方面前端可以做的性能优化工作。\n\n文章主要分为以下几个部分：\n\n* blink内核的渲染机制\n* chrome内核架构变迁\n* 分层渲染\n* 动画 & canvas & WebGl\n\n*这里的前两部分可能会有些枯燥，如果是前端工程师并且想立即获得实际项目的建议的，可以直接阅读第三部分和第四部分*\n\n### blink内核的渲染机制\n\nblink内核是Google基于Webkit内核开发的新的分支，而实际上，目前Chrome已经采用了blink内核，所以，我们接下来的有关分析大多基于blink内核的浏览器(Chrome)，就不再详细指明，当然，部分内容也会涉及到腾讯研发的X5内核(X5内核基于安卓的WebView，目前已经在手机QQ等产品中使用，基于X5内核的项目累计有数亿UV，上百亿PV)。\n\n一个页面的显示，实际上主要经历了下面的四个流程：\n\n加载 => 解析 => 排版 => 渲染\n\n实际上，这里的渲染主要是指排版之后到最后的上屏绘制(这个时候内容已经排版好了)，一部分前端工程师通常会把一部分的排版工作理解到“渲染”的流程中(也就是下图中全部工作)，实际上这个理解是不准确的。\n\n![](https://www.10000h.top/images/data_img/webRender/P6.PNG)\n\n目前，浏览器的渲染采用的是分块渲染的机制，所谓的分块渲染的机制，其实应该这么理解：\n\n* 浏览器首先把整个网页分成一些低分辨率的块，再把网页分成高分辨率的块，然后给这些块排列优先级。\n* 处在可视区域内的低分辨率块的优先级会比较高，会被较先绘制。\n* 之后浏览器会把高分辨率的块进行绘制，同样也是先绘制处于可视区域内的，再绘制可视区域外的(由近到远)。\n\n以上讲的这些策略可以使可以使得浏览器优先展示可视区域内的内容，并且先展示大致内容，再展示高精度内容(当然，由于这个过程比较快，实际上我们大多时候是感受不到的)。\n\n另外这里值得提醒的一点是，分块的优先级是会根据到可视区域的距离来决定的，所以有些横着的内容(比如banner的滚动实现，通常会设置横向超出屏幕来表示隐藏)，也是会按照到可视区域的距离来决定优先级的。\n\n绘制的过程，可以被硬件加速，这里硬件加速的主要手段主要是指：\n\n* 硬件加速合成上屏\n* 2D Canvas、Video的硬件加速\n* GPU光栅化\n\t* GPU光栅化速度更快，内存和CPU的消耗更少\n\t* 目前还没有办法对包含复杂矢量绘制的页面进行GPU光栅化\n\t* GPU光栅化是未来趋势\n\n\n### chrome内核架构变迁\n\n在渲染架构上，chrome也是经历了诸多变迁，早期的Chrome是这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P1.PNG)\n\n早期的chrome的架构实际上有以下缺点：\n\n* Renderer线程任务繁重\n* 无法实时响应缩放滑动操作\n* 脏区域与滑动重绘区域有冲突\n\t* 这里举个场景，假设一个gif，这个时候如果用户滑动，滑动新的需要绘制的内容和gif下一帧内容就会产生绘制冲突\n\n当然，经过一系列的发展，Chrome现在是这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P2.PNG)\n\n在安卓上，Android 4.4的 Blink内核架构如下(4.4之前并不支持OpenGL)\n\n![](https://www.10000h.top/images/data_img/webRender/P3.PNG)\n\n当然，这种架构也有如下缺点：\n\n* UI线程过于繁忙\n* 无法支持Canvas的硬件加速以及WebGL\n\n所以，后期发展成了这样：\n\n![](https://www.10000h.top/images/data_img/webRender/P4.PNG)\n\n总结看来，内核发展的趋势是：\n\n* 多线程化(可以充分利用多核心CPU)\n* 硬件加速(可以利用GPU)\n\n### 分层渲染\n\n在阅读这一章之前，我建议读者先去亲自体验一下所谓的“分层渲染”：\n\n>打开Chrome浏览器，打开控制台，找到\"Layers\"，如果没有，那么在控制台右上角更多的图标->More tools 找到\"Layers\"，然后随便找个网页打开即可\n\n网页的分层渲染流程主要是下面这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P7.PNG)\n\n(*注意：多个RenderObject可能又会对应一个或多个RenderLayer*)\n\n既然才用了分层渲染，那么肯定可以来分层处理，分层渲染有如下优点：\n\n* 减少不必要的重新绘制\n* 可以实现较为复杂的动画\n* 能够方便实现复杂的CSS样式\n\n当然，分层渲染是会很影响渲染效率的，可以有好的影响，使用不当也会有差的影响，我们需要合理的控制和使用分层：\n\n* 如果小豆腐块分层较多，页面整体的分层数量较大，会导致每帧渲染时遍历分层和计算分层位置耗时较长啊(比较典型的是腾讯网移动端首页)。\n* 如果可视区域内分层太多且需要绘制的面积太大，渲染性能非常差，甚至无法达到正常显示的地步(比如有一些全屏H5)。\n* 如果页面几乎没有分层，页面变化时候需要重绘的区域较多。元素内容无变化只有位置发生变化的时候，可以利用分层来避免重绘。\n\n那么，是什么原因可以导致分层呢？目前每一个浏览器或者不同版本的浏览器分层策略都是有些不同的(虽然总体差不太多)，但最常见的几个分层原因是：transform、Z-index；还有可以使用硬件加速的video、canvas；fixed元素；混合插件(flash等)。关于其他更具体的内容，可以见下文。\n\n```\n//注:Chrome中符合创建新层的情况：\nLayer has 3D or perspective transform CSS properties(有3D元素的属性)\nLayer is used by <video> element using accelerated video decoding(video标签并使用加速视频解码)\nLayer is used by a <canvas> element with a 3D context or accelerated 2D context(canvas元素并启用3D)\nLayer is used for a composited plugin(插件，比如flash)\nLayer uses a CSS animation for its opacity or uses an animated webkit transform(CSS动画)\nLayer uses accelerated CSS filters(CSS滤镜)\nLayer with a composited descendant has information that needs to be in the composited layer tree, such as a clip or reflection(有一个后代元素是独立的layer)\nLayer has a sibling with a lower z-index which has a compositing layer (in other words the layer is rendered on top of a composited layer)(元素的相邻元素是独立layer)\n```\n\n最后，我们总结一下如何合理的设计分层：分层总的原则是，减少渲染重绘面积与减少分层个数和分层总面积：\n\n* 相对位置会发生变化的元素需要分层(比如banner图、滚动条)\n* 元素内容更新比较频繁的需要分层(比如页面中夹杂的倒计时等)\n* 较长较大的页面注意总的分层个数\n* 避免某一块区域分层过多，面积过大\n\n(*如果你给一个元素添加上了-webkit-transform: translateZ(0);或者 -webkit-transform: translate3d(0,0,0);属性，那么你就等于告诉了浏览器用GPU来渲染该层，与一般的CPU渲染相比，提升了速度和性能。(我很确定这么做会在Chrome中启用了硬件加速，但在其他平台不做保证。就我得到的资料而言，在大多数浏览器比如Firefox、Safari也是适用的)*)\n\n另外值得一提的是，X5对分层方面做了一定的优化工作，当其检测到分层过多可能会出现显示问题的时候会进行层合并，牺牲显示性能换取显示正确性。\n\n最后再提出一个小问题：\n\n以下哪种渲染方式是最优的呢？\n\n![](https://www.10000h.top/images/data_img/webRender/P8.PNG)\n\n这里实际上后者虽然在分层上满足总体原则，但是之前讲到浏览器的分块渲染机制，是按照到可视区域的距离排序的，考虑到这个因素，实际上后者这种方式可能会对分块渲染造成一定的困扰，并且也不是最优的。\n\n### 动画 & canvas & WebGl\n\n讲最后一部分开始，首先抛出一个问题：CSS动画 or JS动画?\n\n对内核来说，实际上就是Renderer线程动画还是Compositor线程动画，二者实际上过程如下：\n\n![](https://www.10000h.top/images/data_img/webRender/P9.PNG)\n\n所以我们可以看出，Renderer线程是比Compositor线程动画性能差的(在中低端尤其明显)\n\n另外，无论是JS动画还是CSS动画，动画过程中的重绘以及样式变化都会拖慢动画执行以及引起卡顿\n以下是一些不会触发重绘或者排版的CSS动画属性：\n\n* cursor\n* font-variant\n* opacity\n* orphans\n* perspective\n* perspecti-origin\n* pointer-events\n* transform\n* transform-style\n* widows\n\n想要了解更多内容，可以参考[这里](https://csstriggers.com/)\n\n这方面最终的建议参考如下：\n\n* 尽量使用不会引起重绘的CSS属性动画，例如transform、opacity等\n* 动画一定要避免触发大量元素重新排版或者大面积重绘\n* 在有动画执行时，避免其他动画不相关因素引起排版和重绘\n\n\n#### requestAnimationFrame\n\n另外当我们在使用动画的时候，为了避免出现掉帧的情况，最好采用requestAnimationFrame这个API，这个API迎合浏览器的流程，并且能够保证在下一帧绘制的时候上一帧一定出现了：\n\n![](https://www.10000h.top/images/data_img/webRender/P11.PNG)\n\n### 3D canvas\n\n还有值得注意的是，有的时候我们需要涉及大量元素的动画(比如雪花飘落、多个不规则图形变化等)，这个时候如果用CSS动画，Animation动画的元素很多。，导致分层个数非常多，浏览器每帧都需要遍历计算所有分层，导致比较耗时、\n\n这个时候该怎么办呢？\n\n2D canvas上场。 \n\n和CSS动画相比，2D canvas的优点是这样的：\n\n* 硬件加速渲染\n* 渲染流程更优\n\n其渲染流程如下：\n\n![](https://www.10000h.top/images/data_img/webRender/P10.PNG)\n\n实际上以上流程比较耗时的是JS Call这一部分，执行opengl的这一部分还是挺快的。\n\nHTML 2D canvas 主要绘制如下三种元素：\n\n* 图片\n* 文字\n* 矢量\n\n这个过程可以采用硬件加速，硬件加速图片绘制的主要流程：\n\n![](https://www.10000h.top/images/data_img/webRender/P12.PNG)\n\n硬件加速文字绘制的主要流程：\n\n![](https://www.10000h.top/images/data_img/webRender/P13.PNG)\n\n但对于矢量绘制而言，简单的图形，比如点、直线等可以直接使用OpenGL渲染，复杂的图形，如曲线等，无法采用OpenGL绘制。\n\n对于绘制效率来说，2D Canvas对绘制图片效率较高，绘制文字和矢量效率较低(**所以建议是，我们如果能使用贴图就尽量使用贴图了**)\n\n还有，有的时候我们需要先绘制到离屏canvas上面，然后再上屏，这个可以充分利用缓存。\n\n### 3D canvas(WebGL)\n\n目前，3D canvas(WebGL)的应用也越来越多，对于这类应用，现在已经有了不少已经成型的庫:\n\n\n* 通用引擎：threeJS、Pixi\n* VR视频的专业引擎：krpano、UtoVR\n* H5游戏引擎：Egret、Layabox、Cocos\n\nWebGL虽然包含Web，但本身对前端的要求最低，但是对OpenGL、数学相关的知识要求较高，所以如果前端工程师没有一定的基础，还是采用现在的流行庫。\n\nX5内核对于WebGl进行了性能上和耗电上的优化，并且也对兼容性错误上报和修复做了一定的工作。\n\n___\n\n本文参考腾讯内部讲座资料整理而成，并融入一部分笔者的补充，谢绝任何形式的转载。\n\n其他优质好文：\n\n[Javascript高性能动画与页面渲染](http://qingbob.com/javascript-high-performance-animation-and-page-rendering/)\n\n\n","tags":["性能优化"]}]