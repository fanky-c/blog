---
title: http/1.x和http/2
date: 2018-09-05 16:49:43
tags:
    - http
    - 缓存
---
### http/1.x

#### 基本介绍

##### A:报文
  1. 起始⾏ 
  2. ⾸部（header）
  3. 主体

![报文](/blog/img/http_content.png)  

##### B:方法
  1. get 
     * 从服务器获取文档
     * 可以被缓存
     * 通过url请求，有长度限制
     * url明文请求，安全得不到保障
     * 对服务器无副作用，多次操作不会改变服务器状态
  2. post
     * 向服务器发送所需处理的数据
     * 不能被缓存
     * 没有长度限制
     * 请求放在主体，不会被记录下来，安全性相对来说得到保障
     * 有副作用，即非幂等
  3. head
     * 从服务器获取文档头部
  4. put
     * 请求的主体存到服务器中
  5. options
     * 查词可以服务器上执行那些方法,检查服务器性能（跨域请求用的多）

##### C：状态码
  1. 1xx 信息性状态
  2. 2xx 成功
     * 206：Partial Content 分块内容
  3. 3xx 重定向
     * 301: 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
     * 304: 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
  4. 4xx 客户端错误
     * 400: Bad Request 常⻅于请求时提交了错误的参数
     * 401：Unauthorized 需要验证
     * 403：Forbidden 禁⽌访问
     * 404：Not Found
  5. 5xx 服务端错误
     * 500：Server Error 服务器出错
     * 502：Bad Gateway 通常由代理服务器返回，表示上游服务器出错
     * 503：Service Unavailable 服务暂不可⽤，但将来可⽤（例如服务当前负载太⾼） 
     * 504：Gateway Timeout 通常由代理服务器返回，表示上游服务器超时


#### 常用header
  
#### cookie机制
* HTTP是⼀个匿名、⽆状态的协议，但很多情况下服务器需要识别客户端的身份
* 识别身份的⽅法:
  1. Authentication⾸部 + WWW-Authentication⾸部
  2. 胖URL，在URL⾥带上身份信息
  3. Cookie ⽬前识别⽤户，实现持久会话的最好⽅式
* cookie本质上是⼀些key-value数据，key是cookie名字，value是cookie的值
  1. domain和path: 指定了哪些域名和路径会带上该cookie
  2. HttpOnly属性阻⽌了javascript来访问cookie，可以防⽌⼀些XSS攻击
* 会话期Cookie: 浏览器关闭之后它会被⾃动删除
* 持久性Cookie: 指定了cookie过期时间

![cookie](/blog/img/http_cookie.png) 

#### 连接机制
##### 介绍
* HTTP使⽤TCP来传输数据，HTTP/1.0每个请求都新开⼀个连接，效率低下。
  1. TCP握⼿导致⽐较⻓的延时
  2. TCP拥塞控制算法在慢启动阶段带宽较⼩
* HTTP/1.1默认使⽤⻓连接，即⼀个连接会保持⼀段时间，⽤于发送⼀系列的请求
* 管道化请求：不等待前⼀个请求返回就在同⼀个连接发送下⼀个请求（⽬前都没实现）
* 相关⾸部：Connection （客户端和服务端都使⽤）
  1. Connection: keep-alive 在当前请求完成后，保持连接
  2. Connection: close 在当前请求完成后，关闭连接

##### HTTP/1.x 三种连接⽅式
![三种连接⽅式](/blog/img/http_live.png) 

#### 缓存

##### 缓存存储策略
1. cache-control:  public, max-age=31536000。响应数据会被缓存到客户端

##### 缓存过期策略
1. expires
  * 表示存在时间，允许客户端在这个时间之前不去检查（发请求），等同max-age的
效果。但是如果同时存在，则被Cache-Control的max-age覆盖

##### 缓存对比策略
1. last-modified:  Fri, 25 Nov 2016 08:15:46 GMT。 资源被修改的最后时间
   * 浏览器会携带该值去服务器对比，对比成功在返回304，服务器提示浏览器从本地加载数据，否则返回200并响应数据。
2. eTag:  "Fpwrobxxh6n6-E2sDbMMA2znbN1i"
   * 对资源的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的，是资源的唯一标识

#### HTTP 1.x 缺点
* Head Of Line Blocking 队头阻塞
  1. HTTP/1.1实际上没实现pipelining，⼀条连接同时只能进⾏⼀个HTTP请求，若该请求的响应很慢，则后续使⽤该连接的HTTP请求都被阻塞
* ⾸部数据冗余：发往同⼀server的多个请求的Header重复发送
  1. gzip只会压缩实体数据
* 客户端请求-服务端响应模型（缺少服务端推送）  

### http/2

#### 连接复用
* 多个请求和响应复⽤同⼀连接
  1. 解决了HTTP/1.1中的队头阻塞问题
  2. 基于新的⼆进制分帧层，客户端和服务端可以将多个HTTP消息分解为互不依赖的帧，交错发送，最后重新组装
  3. 连接复⽤解决了HTTP/1.x存在的队头阻塞问题，减少连接数，更好利⽤了⽹络带宽（⻓连接避免了TCP拥塞控制的影响）

#### 首部压缩
* 压缩HTTP⾸部字段
  1. 减少⾸部的传输开销
  2. 每个HTTP传输都包含⼀系列⾸部，在HTTP/1.x中这些⾸部始终以纯⽂本形式传输，并且多个连接的⾸部都是重复的，例如User-Agent, Host，Cookie等。这些⾸部会给传输带上额外的开销，可能多达1kb
  3. HTTP/2使⽤⼀种叫HPACK的⽅法来压缩⾸部数据

#### 服务器推送
* 服务端可以对⼀个客户端请求发送多个响应
* 客户端可以限制服务端推送的数据量或停⽤服务端推

** 注意：**
1. HTTP/2 没有改动 HTTP 的应⽤语义。HTTP ⽅法、状态代码、URI 和标头字段等
核⼼概念与HTTP/1.x⼀致，HTTP/2 修改了数据格式化（分帧）以及在客户端与服
务器间传输的⽅式

2. 因为引⼊新的⼆进制分帧层，HTTP/2⽆法向后兼容HTTP/1.x

***参考我的同事java大神郎哥的非常感谢他。 ***