---
title: 前端原生函数和部分原理实现
date: 2020-03-17 20:16:02
tags:
    - 原生函数重写
---

### 实现 Array.isArray
```js
//思路  利用Object.prototype.toString.call()

//实现
Array.prototype.myIsArray = function(obj){
    return Object.prototype.toString.call(obj) === '[object Array]';
}
```

### 实现 Object.create()
```js
//思路Object.create方法是不继承原型链上的属性和方法

//纯净的o = {a : 1}对象， 无任何继承原型链(toString、hasOwnProperty、...)
var o = Object.create(null, {
    a:{
        writable:true,
        configurable:true,
        value:'1'
    }
})

//和var o = {a: 1} 类似，  但是多了一层__proto__
var o = Object.create({},{
    a:{
        writable:true,
        configurable:true,
        value:'1'
    }
})

//等于 var o = {a: 1}
var o = Object.create(Object.prototype,{
    a:{
        writable:true,
        configurable:true,
        value:'1'
    }
})


//自己实现Object.create()
if(typeof Object.create !== 'function'){
   Object.create = function(o){
        let F = function(){};  
        F.prototype = o;  //F原型链指向o
        return new F();   //返回创建的新对象
   }
}
```


### 实现 new F()
```js
//思路
1. 创建一个空对象
2. 将空对象指向和构造函数原型
3. 以空对象为this上下文且执行构造函数
4. 返回构造函数结果

//实现
function creatObject(fn){
    // 创建一个空对象，并将空对象的原型设置为构造函数的原型
   let obj = Object.create(fn.prototype);
   
   // 以obj为上下文执行构造函数
   let result = fn.call(obj);
   
   // 如果构造函数有返回结果，则返回，若无直接返回obj
   if(typeof result === 'object'){
      return result;
   }else{
      return obj;
   }
}

//使用
function Person(){
    this.name = 'cha';
    this.age = 10;
}

//new 实现
//var res = new Person();

//模拟实现
var res = creatObject(Person);

```


### 实现 call、apply
```js
//思路
1. 改变函数this的指向
2. 执行函数


//实现
Function.prototype.myCall = function(context){
    context = context || window;

    //将我们传入函数挂载到context上
    context.fn = this;

    //处理传入参数，除去第一位，转换为数组
    //console.log([...[2, 3, 4]]) ==> [2, 3, 4]
    const args = [...arguments].slice(1);

    //执行函数 context.fn = this， 参数数组转换为多个字符串
    //console.log(...[2, 3, 4])  ==> 2, 3, 4
    const result =  context.fn(...args);
    
    //删除对象上属性
    delete context.fn;
   
    //将结果返回
    return result;
}


//和call不相同的地方就是参数
Function.prototype.apply = function(context){
  context = context || window;

  context.fn = this;

  let result;

  if(arguments[1]){
     //console.log(...[2, 3, 4])  ==> 2, 3, 4
     result = context.fn(...arguments[1]);
  }else{
     result = context.fn(); 
  }

  delete context.fn;

  return result;
}

```

### 实现 bind
```js
//思路
1. 用bind改变this指向的函数
2. 如果用new操作符调用会失效


//实现
Function.prototype.myBind = function(){
  //保存函数  
  const _this = this;

  //保存目标函数
  const context = arguments[0] || window;

  //保存函数中除了目标函数的其他参数
  const rest = Array.prototype.slice.call(arguments, 1);
  
  //返回一个待执行函数
  return function F(){
    const rest2 = [...arguments];  //将argments转换为真正数组  Array.prototype.slice.call(arguments)

    if(this instanceof F){
      //判断是否通过new操作符,则直接用new 调用原函数,并用扩展运算符传递参数
      return new _this(...rest2); 
    }else{
      //用apply调用第一步保存的函数，并绑定this，传递合并的参数数组 rest.concat(rest2) 
      return _this.apply(context, [rest,...rest2]);
    }
  }
}
```


### 实现函数柯里化
```js
//思路
1.  参数复用，例如用于累加函数
2.  延迟执行,类似bind改变this指向，待执行函数


//实现
function myCurrying(fn, args){
   let _this = this;
   let len = fn.length;
   let args = args || [];

   return function (){
       let _args = Array.prototype.slice.call(arguments);
       Array.prototype.push.call(args, _args);
    
        // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数
       if(_args.length < len){
          return myCurrying.call(this, fn, _args);
       }

       return fn.apply(this, _args);
   }
}

```