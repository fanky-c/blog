---
title: 前端原生函数和部分原理实现
date: 2020-03-17 20:16:02
tags:
    - 原生函数重写
---

### 实现 Array.isArray
```js
//思路  利用Object.prototype.toString.call()

//实现
Array.prototype.myIsArray = function(obj){
    return Object.prototype.toString.call(obj) === '[object Array]';
}
```

### 实现 Object.create()
```js
//思路Object.create方法是不继承原型链上的属性和方法

//纯净的o = {a : 1}对象， 无任何继承原型链(toString、hasOwnProperty、...)
var o = Object.create(null, {
    a:{
        writable:true,
        configurable:true,
        value:'1'
    }
})

//和var o = {a: 1} 类似，  但是多了一层__proto__
var o = Object.create({},{
    a:{
        writable:true,
        configurable:true,
        value:'1'
    }
})

//等于 var o = {a: 1}
var o = Object.create(Object.prototype,{
    a:{
        writable:true,
        configurable:true,
        value:'1'
    }
})


//自己实现Object.create()
if(typeof Object.create !== 'function'){
   Object.create = function(o){
        let F = function(){};  
        F.prototype = o;  //F原型链指向o
        return new F();   //返回创建的新对象
   }
}
```


### 实现 new F()
```js
//思路
1. 创建一个空对象
2. 将空对象指向和构造函数原型
3. 以空对象为this上下文且执行构造函数
4. 返回构造函数结果

//实现
function creatObject(fn){
    // 创建一个空对象，并将空对象的原型设置为构造函数的原型
   let obj = Object.create(fn.prototype);
   
   // 以obj为上下文执行构造函数
   let result = fn.call(obj);
   
   // 如果构造函数有返回结果，则返回，若无直接返回obj
   if(typeof result === 'object'){
      return result;
   }else{
      return obj;
   }
}

//使用
function Person(){
    this.name = 'cha';
    this.age = 10;
}

//new 实现
//var res = new Person();

//模拟实现
var res = creatObject(Person);

```


### 实现 call、apply
```js
//思路
1. 改变函数this的指向
2. 执行函数


//实现
Function.prototype.myCall = function(context){
    context = context || window;

    //将我们传入函数挂载到context上
    context.fn = this;

    //处理传入参数，除去第一位，转换为数组
    const args = [...arguments].slice(1);

    //执行函数 context.fn = this， 参数数组转换为多个字符串
    const result =  context.fn(...args);
    
    //删除对象上属性
    delete context.fn;
   
    //将结果返回
    return result;

}

```