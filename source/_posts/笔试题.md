---
title: 笔试题
date: 2023-11-29 17:28:27
tags:
 - 编码
 - 笔试题
 - 面试题
---

### 1、防抖和节流函数

防抖的主要思想是，当事件被触发后，延迟一定时间再执行相关操作。如果在这个延迟期内再次触发了同样的事件，就会重新计时。

```js
const debounce = function(fn, delay) {
  let timer = null;
  return function() {
    const that = this;
    if(timer){
      clearTimeout(timer);
      timer = null;
    }
    timer = setTimeout(function(){
      // 防止this为window
      fn.apply(that, arguments);
    }, delay)
   }
}

window.addEventListener('resize', debounce(()=>{
  console.log('防抖执行');
}, 300));
```


节流的主要思想是，在一定时间内只允许函数执行一次，无论事件触发了多少次。

```js
const throttle = function(fn, delay){
  let lastTime = 0;
  return function() {
    const now = Date.now();
    if(now - lastTime > delay){
      fn.apply(this, arguments);
      lastTime = now;
    }
  }
}

window.addEventListener('scroll', throttle(()=>{
  console.log('节流执行');
}, 300));
```


### 2、实现bind方法

bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。

```js
// 1、原生bind
const obj = {
  name: 'zc',
  age: 12
}
function say(sex){
  console.log(`name: ${this.name}, age: ${this.age}, sex: ${sex}, 参数: ${[...arguments]}`);
}
const mySay = say.bind(obj, 'female');
mySay(111); // name: zc, age: 12, sex: female, 参数: female,111

// 2、实现myBind
Function.prototype.myBind = function(context) {
  const that = this;
  const args = Array.prototype.slice.call(arguments, 1);  // 获取额外参数

  return function() {
    const newArgs = Array.prototype.slice.call(arguments);  // 获取调用时出入的参数
    return that.apply(context, [...args, ...newArgs]); // 执行原始函数并传递参数
  }
}

const mySay1 = say.myBind(obj, 'female');
mySay1(222); // name: zc, age: 12, sex: female, 参数: female,222
```


### 3、统计字符串出现最多的字符

```js
let str = 'afjghdfraaaasdenas';

function findMaxDuplicateChar(str) {
  if (str.length === 1) return str;

  let charObj = {};
  for (let i=0; i<str.length; i++) {
    if (!charObj[str.charAt(i)]){
      charObj[str.charAt(i)] = 1;
    } else {
      charObj[str.charAt(i)] += 1;
    }
  }

  let maxChar = '', maxValue = 1;
  for (let key in charObj) {
    if(charObj[key] >= maxChar) {
        maxChar = key;
        maxValue = charObj[key];
    }
  }
  return {
    maxChar,
    maxValue
  }
}
```


### 4、统计字符串中第一个唯一字符

```js
let str = 'leetcode';  // 返回0
// let str = 'loveleetcode'; // 返回2

function findFirstUniqChar(str) {
  for (let i=0; i<str.length(); i++) {
    let curChar = str[i];
    if (str.lastIndexOf(curChar) === str.indexOf(curChar)) {
       return i;
    }
  }
  return -1;
}
```
