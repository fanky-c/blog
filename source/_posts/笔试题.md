---
title: 笔试题
date: 2023-11-29 17:28:27
tags:
 - 编码
 - 笔试题
 - 面试题
---

### 1、防抖和节流函数

防抖的主要思想是，当事件被触发后，延迟一定时间再执行相关操作。如果在这个延迟期内再次触发了同样的事件，就会重新计时。

```js
const debounce = function(fn, delay) {
  let timer = null;
  return function() {
    const that = this;
    if(timer){
      clearTimeout(timer);
      timer = null;
    }
    timer = setTimeout(function(){
      // 防止this为window
      fn.apply(that, arguments);
    }, delay)
   }
}

window.addEventListener('resize', debounce(()=>{
  console.log('防抖执行');
}, 300));
```


节流的主要思想是，在一定时间内只允许函数执行一次，无论事件触发了多少次。

```js
const throttle = function(fn, delay){
  let lastTime = 0;
  return function() {
    const now = Date.now();
    if(now - lastTime > delay){
      fn.apply(this, arguments);
      lastTime = now;
    }
  }
}

window.addEventListener('scroll', throttle(()=>{
  console.log('节流执行');
}, 300));
```


### 2、实现bind方法

```js
// 1、原生bind
const obj = {
  name: 'zc',
  age: 12
}
function say(sex){
  console.log(`name: ${this.name}, age: ${this.age}, sex: ${sex}, 参数: ${[...arguments]}`);
}
const mySay = say.bind(obj, 'female');
mySay(111); // name: zc, age: 12, sex: female, 参数: female,111

// 2、实现myBind
Function.prototype.myBind = function(context) {
  const that = this;
  const args = Array.prototype.slice.call(arguments, 1);  // 获取额外参数

  return function() {
    const newArgs = Array.prototype.slice.call(arguments);  // 获取调用时出入的参数
    return that.apply(context, [...args, ...newArgs]); // 执行原始函数并传递参数
  }
}

const mySay1 = say.myBind(obj, 'female');
mySay1(222); // name: zc, age: 12, sex: female, 参数: female,222
```